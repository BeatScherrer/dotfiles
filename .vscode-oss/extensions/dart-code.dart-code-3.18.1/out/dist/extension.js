module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 40);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("vscode");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeSlashes = exports.areSameFolder = exports.mkDirRecursive = exports.getRandomInt = exports.tryDeleteFile = exports.getSdkVersion = exports.findProjectFolders = exports.isFlutterRepoAsync = exports.hasCreateTriggerFileAsync = exports.hasPubspecAsync = exports.hasPubspec = exports.hasPackagesFile = exports.readDirAsync = exports.getChildFolders = exports.isEqualOrWithinPath = exports.isWithinPath = exports.forceWindowsDriveLetterToUppercase = exports.fsPath = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const constants_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(3);
const array_1 = __webpack_require__(19);
function fsPath(uri) {
    // tslint:disable-next-line:disallow-fspath
    return forceWindowsDriveLetterToUppercase(typeof uri === "string" ? uri : uri.fsPath);
}
exports.fsPath = fsPath;
function forceWindowsDriveLetterToUppercase(p) {
    if (p && constants_1.isWin && path.isAbsolute(p) && p.startsWith(p.charAt(0).toLowerCase()))
        p = p.substr(0, 1).toUpperCase() + p.substr(1);
    return p;
}
exports.forceWindowsDriveLetterToUppercase = forceWindowsDriveLetterToUppercase;
function isWithinPath(file, folder) {
    const relative = path.relative(folder, file);
    return !!relative && !relative.startsWith("..") && !path.isAbsolute(relative);
}
exports.isWithinPath = isWithinPath;
function isEqualOrWithinPath(file, folder) {
    const relative = path.relative(folder, file);
    return relative === "" || (!!relative && !relative.startsWith("..") && !path.isAbsolute(relative));
}
exports.isEqualOrWithinPath = isEqualOrWithinPath;
function getChildFolders(logger, parent, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!fs.existsSync(parent))
            return [];
        const files = yield readDirAsync(logger, parent);
        return files.filter((f) => f.isDirectory())
            .filter((f) => f.name !== "bin" || (options && options.allowBin)) // Don't look in bin folders
            .filter((f) => f.name !== "cache" || (options && options.allowCache)) // Don't look in cache folders
            .map((item) => path.join(parent, item.name));
    });
}
exports.getChildFolders = getChildFolders;
function readDirAsync(logger, folder) {
    return new Promise((resolve) => fs.readdir(folder, { withFileTypes: true }, (err, files) => {
        // We will generate errors if we don't have access to this folder
        // so just skip over it.
        if (err) {
            logger.warn(`Skipping folder ${folder} due to error: ${err}`);
            resolve([]);
        }
        else {
            resolve(files);
        }
    }));
}
exports.readDirAsync = readDirAsync;
function hasPackagesFile(folder) {
    return fs.existsSync(path.join(folder, ".packages"));
}
exports.hasPackagesFile = hasPackagesFile;
function hasPubspec(folder) {
    return fs.existsSync(path.join(folder, "pubspec.yaml"));
}
exports.hasPubspec = hasPubspec;
function hasPubspecAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield fileExists(path.join(folder, "pubspec.yaml"));
    });
}
exports.hasPubspecAsync = hasPubspecAsync;
function hasCreateTriggerFileAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield fileExists(path.join(folder, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE));
    });
}
exports.hasCreateTriggerFileAsync = hasCreateTriggerFileAsync;
function isFlutterRepoAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield fileExists(path.join(folder, "bin/flutter"))) && (yield fileExists(path.join(folder, "bin/cache/dart-sdk")));
    });
}
exports.isFlutterRepoAsync = isFlutterRepoAsync;
function fileExists(p) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.promises.access(p);
            return true;
        }
        catch (_a) {
            return false;
        }
    });
}
// Walks a few levels down and returns all folders that look like project
// folders, such as:
// - have a pubspec.yaml
// - have a project create trigger file
// - are the Flutter repo root
function findProjectFolders(logger, roots, excludedFolders, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const dartToolFolderName = `${path.sep}.dart_tool${path.sep}`;
        const level2Folders = yield utils_1.flatMapAsync(roots, (f) => getChildFolders(logger, f));
        const level3Folders = yield utils_1.flatMapAsync(level2Folders, (f) => getChildFolders(logger, f));
        const allPossibleFolders = roots.concat(level2Folders).concat(level3Folders)
            .filter((f) => !f.includes(dartToolFolderName) && excludedFolders.every((ef) => !isEqualOrWithinPath(f, ef)));
        const projectFolderPromises = allPossibleFolders.map((folder) => __awaiter(this, void 0, void 0, function* () {
            return ({
                exists: options && options.requirePubspec
                    ? yield hasPubspecAsync(folder)
                    : (yield hasPubspecAsync(folder)) || (yield hasCreateTriggerFileAsync(folder)) || (yield isFlutterRepoAsync(folder)),
                folder,
            });
        }));
        const projectFoldersChecks = yield Promise.all(projectFolderPromises);
        const projectFolders = projectFoldersChecks
            .filter((res) => res.exists)
            .map((res) => res.folder);
        return options && options.sort
            ? array_1.sortBy(projectFolders, (p) => p.toLowerCase())
            : projectFolders;
    });
}
exports.findProjectFolders = findProjectFolders;
function getSdkVersion(logger, { sdkRoot, versionFile }) {
    if (!sdkRoot && !versionFile)
        return undefined;
    if (!versionFile)
        versionFile = path.join(sdkRoot, "version");
    if (!fs.existsSync(versionFile))
        return undefined;
    try {
        return fs
            .readFileSync(versionFile, "utf8")
            .trim()
            .split("\n")
            .filter((l) => l)
            .filter((l) => l.trim().substr(0, 1) !== "#")
            .join("\n")
            .trim();
    }
    catch (e) {
        logger.error(e);
        return undefined;
    }
}
exports.getSdkVersion = getSdkVersion;
function tryDeleteFile(filePath) {
    if (fs.existsSync(filePath)) {
        try {
            fs.unlinkSync(filePath);
        }
        catch (_a) {
            console.warn(`Failed to delete file ${path}.`);
        }
    }
}
exports.tryDeleteFile = tryDeleteFile;
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min;
}
exports.getRandomInt = getRandomInt;
function mkDirRecursive(folder) {
    const parent = path.dirname(folder);
    if (!fs.existsSync(parent))
        mkDirRecursive(parent);
    if (!fs.existsSync(folder))
        fs.mkdirSync(folder);
}
exports.mkDirRecursive = mkDirRecursive;
function areSameFolder(folder1, folder2) {
    // Trim any trailing path separators of either direction.
    folder1 = folder1.replace(/[\\/]+$/, "");
    folder2 = folder2.replace(/[\\/]+$/, "");
    return folder1 === folder2;
}
exports.areSameFolder = areSameFolder;
function normalizeSlashes(p) {
    return p.replace(/[\\/]/g, path.sep);
}
exports.normalizeSlashes = normalizeSlashes;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.disposeAll = exports.escapeDartString = exports.generateTestNameFromFileName = exports.clamp = exports.asHex = exports.asHexColor = exports.notUndefined = exports.BufferedLogger = exports.errorString = exports.usingCustomScript = exports.isStableSdk = exports.pubVersionIsAtLeast = exports.versionIsAtLeast = exports.isDartSdkFromFlutter = exports.uriToFilePath = exports.findFileInAncestor = exports.PromiseCompleter = exports.escapeRegExp = exports.filenameSafe = exports.flatMapAsync = exports.flatMap = exports.uniq = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const semver = __webpack_require__(73);
const constants_1 = __webpack_require__(4);
function uniq(array) {
    return array.filter((value, index) => array.indexOf(value) === index);
}
exports.uniq = uniq;
function flatMap(input, f) {
    return input.reduce((acc, x) => acc.concat(f(x)), []);
}
exports.flatMap = flatMap;
function flatMapAsync(input, f) {
    return __awaiter(this, void 0, void 0, function* () {
        let res = [];
        for (const x of input)
            res = res.concat(yield f(x));
        return res;
    });
}
exports.flatMapAsync = flatMapAsync;
function filenameSafe(input) {
    return input.replace(/[^a-z0-9]+/gi, "_").toLowerCase();
}
exports.filenameSafe = filenameSafe;
function escapeRegExp(input) {
    return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
exports.escapeRegExp = escapeRegExp;
class PromiseCompleter {
    constructor() {
        this.promise = new Promise((res, rej) => {
            this.resolve = res;
            this.reject = rej;
        });
    }
}
exports.PromiseCompleter = PromiseCompleter;
function findFileInAncestor(files, startLocation) {
    let lastParent;
    let parent = startLocation;
    while (parent && parent.length > 1 && parent !== lastParent) {
        for (const file of files) {
            const child = path.join(parent, file);
            if (fs.existsSync(child))
                return child;
        }
        lastParent = parent;
        parent = path.dirname(parent);
    }
    return undefined;
}
exports.findFileInAncestor = findFileInAncestor;
/// Converts a file URI to file path without a dependency on vs.Uri.
function uriToFilePath(uri, returnWindowsPath = constants_1.isWin) {
    let filePath = uri;
    if (uri.startsWith("file://"))
        filePath = decodeURI(uri.substring(7));
    else if (uri.startsWith("file:"))
        filePath = decodeURI(uri.substring(5)); // TODO: Does this case ever get hit? Will it be over-decoded?
    // Windows fixup.
    if (returnWindowsPath) {
        filePath = filePath.replace(/\//g, "\\");
        if (filePath.startsWith("\\"))
            filePath = filePath.substring(1);
    }
    else {
        if (!filePath.startsWith("/"))
            filePath = `/${filePath}`;
    }
    return filePath;
}
exports.uriToFilePath = uriToFilePath;
function isDartSdkFromFlutter(dartSdkPath) {
    const possibleFlutterSdkPath = path.join(path.dirname(path.dirname(path.dirname(dartSdkPath))), "bin");
    return fs.existsSync(path.join(possibleFlutterSdkPath, constants_1.executableNames.flutter));
}
exports.isDartSdkFromFlutter = isDartSdkFromFlutter;
function versionIsAtLeast(inputVersion, requiredVersion) {
    return semver.gte(inputVersion, requiredVersion);
}
exports.versionIsAtLeast = versionIsAtLeast;
function pubVersionIsAtLeast(inputVersion, requiredVersion) {
    // Standard semver gt/lt
    if (semver.gt(inputVersion, requiredVersion))
        return true;
    else if (semver.lt(inputVersion, requiredVersion))
        return false;
    // If the versions are equal, we need to handle build metadata like pub does.
    // https://github.com/dart-lang/pub_semver/
    // If only one of them has build metadata, it's newest.
    if (inputVersion.indexOf("+") !== -1 && requiredVersion.indexOf("+") === -1)
        return true;
    if (inputVersion.indexOf("+") === -1 && requiredVersion.indexOf("+") !== -1)
        return false;
    // Otherwise, since they're both otherwise equal and both have build
    // metadata we can treat the build metadata like pre-release by converting
    // it to pre-release (with -) or appending it to existing pre-release.
    inputVersion = inputVersion.replace("+", inputVersion.indexOf("-") === -1 ? "-" : ".");
    requiredVersion = requiredVersion.replace("+", requiredVersion.indexOf("-") === -1 ? "-" : ".");
    return versionIsAtLeast(inputVersion, requiredVersion);
}
exports.pubVersionIsAtLeast = pubVersionIsAtLeast;
function isStableSdk(sdkVersion) {
    // We'll consider empty versions as dev; stable versions will likely always
    // be shipped with valid version files.
    return !!(sdkVersion && !semver.prerelease(sdkVersion));
}
exports.isStableSdk = isStableSdk;
function usingCustomScript(binPath, binArgs, customScript) {
    if (customScript) {
        binPath = customScript.script;
        binArgs = binArgs.slice(customScript.replacesArgs);
    }
    return { binPath, binArgs };
}
exports.usingCustomScript = usingCustomScript;
function errorString(error) {
    if (!error)
        return "<empty error>";
    else if (error instanceof Error)
        return error.message + (error.stack ? `\n${error.stack}` : "");
    else if (typeof error === "string")
        return error;
    else
        return error.message || "<empty error message>";
}
exports.errorString = errorString;
class BufferedLogger {
    constructor() {
        this.buffer = [];
    }
    info(message, category) {
        this.buffer.push({ type: "info", message, category });
    }
    warn(message, category) {
        this.buffer.push({ type: "warn", message, category });
    }
    error(error, category) {
        this.buffer.push({ type: "error", message: error, category });
    }
    flushTo(logger) {
        if (!this.buffer.length)
            return;
        logger.info("Flushing log messages...");
        for (const log of this.buffer) {
            switch (log.type) {
                case "info":
                    logger.info(log.message, log.category);
                    break;
                case "warn":
                    logger.warn(log.message, log.category);
                    break;
                case "error":
                    logger.error(log.message, log.category);
                    break;
            }
        }
        logger.info("Done flushing log messages...");
    }
}
exports.BufferedLogger = BufferedLogger;
function notUndefined(x) {
    return x !== undefined;
}
exports.notUndefined = notUndefined;
function asHexColor({ r, g, b, a }) {
    r = clamp(r, 0, 255);
    g = clamp(g, 0, 255);
    b = clamp(b, 0, 255);
    a = clamp(a, 0, 255);
    return `${asHex(a)}${asHex(r)}${asHex(g)}${asHex(b)}`.toLowerCase();
}
exports.asHexColor = asHexColor;
function asHex(v) {
    return Math.round(v).toString(16).padStart(2, "0");
}
exports.asHex = asHex;
function clamp(v, min, max) {
    return Math.min(Math.max(min, v), max);
}
exports.clamp = clamp;
function generateTestNameFromFileName(input) {
    return path.basename(input).replace("_test.dart", "").replace(/_/g, " ");
}
exports.generateTestNameFromFileName = generateTestNameFromFileName;
function escapeDartString(input) {
    return input.replace(/(['"\\])/g, "\\$1");
}
exports.escapeDartString = escapeDartString;
function disposeAll(disposables) {
    for (const d of disposables) {
        try {
            d.dispose();
        }
        catch (e) {
            console.warn(e);
        }
    }
}
exports.disposeAll = disposeAll;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.notTodayAction = exports.alwaysOpenAction = exports.openDevToolsAction = exports.wantToTryDevToolsPrompt = exports.issueTrackerUri = exports.issueTrackerAction = exports.stagehandInstallationInstructionsUrl = exports.pubGlobalDocsUrl = exports.debugTerminatingProgressId = exports.debugLaunchProgressId = exports.restartReasonSave = exports.restartReasonManual = exports.showLogAction = exports.stopLoggingAction = exports.IS_RUNNING_LOCALLY_CONTEXT = exports.PUB_OUTDATED_SUPPORTED_CONTEXT = exports.DART_IS_CAPTURING_LOGS_CONTEXT = exports.DART_DEP_FILE_NODE_CONTEXT = exports.DART_DEP_FOLDER_NODE_CONTEXT = exports.DART_DEP_PACKAGE_NODE_CONTEXT = exports.DART_DEP_PROJECT_NODE_CONTEXT = exports.DART_TEST_TEST_NODE_CONTEXT = exports.DART_TEST_GROUP_NODE_CONTEXT = exports.DART_TEST_SUITE_NODE_WITH_FAILURES_CONTEXT = exports.DART_TEST_SUITE_NODE_CONTEXT = exports.IS_LSP_CONTEXT = exports.FLUTTER_DOWNLOAD_URL = exports.DART_DOWNLOAD_URL = exports.androidStudioPaths = exports.flutterSnapScript = exports.analyzerSnapshotPath = exports.pubSnapshotPath = exports.flutterPath = exports.pubPath = exports.dartDocPath = exports.dartVMPath = exports.getExecutableName = exports.executableNames = exports.androidStudioExecutableNames = exports.platformEol = exports.platformDisplayName = exports.dartPlatformName = exports.isChromeOS = exports.isLinux = exports.isMac = exports.isWin = exports.isCI = exports.debugAdapterPath = exports.flutterExtensionIdentifier = exports.dartCodeExtensionIdentifier = void 0;
exports.dartRecommendedConfig = exports.devToolsPages = exports.cancelAction = exports.runFlutterCreateDotAction = exports.runFlutterCreateDotPrompt = exports.vmServiceHttpLinkPattern = exports.vmServiceListeningBannerPattern = exports.reactivateDevToolsAction = exports.openSettingsAction = exports.recommendedSettingsUrl = exports.showRecommendedSettingsAction = exports.skipAction = exports.noAction = exports.yesAction = exports.useRecommendedSettingsPromptKey = exports.installFlutterExtensionPromptKey = exports.userPromptContextPrefix = exports.debugAnywayAction = exports.showErrorsAction = exports.isInFlutterProfileModeDebugSessionContext = exports.isInFlutterDebugModeDebugSessionContext = exports.HAS_LAST_TEST_DEBUG_CONFIG = exports.HAS_LAST_DEBUG_CONFIG = exports.TRACK_WIDGET_CREATION_ENABLED = exports.REFACTOR_ANYWAY = exports.REFACTOR_FAILED_DOC_MODIFIED = exports.FLUTTER_CREATE_PROJECT_TRIGGER_FILE = exports.DART_STAGEHAND_PROJECT_TRIGGER_FILE = exports.CHROME_OS_VM_SERVICE_PORT = exports.CHROME_OS_DEVTOOLS_PORT = exports.pleaseReportBug = exports.longRepeatPromptThreshold = exports.noRepeatPromptThreshold = exports.fortyHoursInMs = exports.twentyHoursInMs = exports.twoHoursInMs = exports.twentyMinutesInMs = exports.tenMinutesInMs = exports.fiveMinutesInMs = exports.initializingFlutterMessage = exports.initializeSnapPrompt = exports.modifyingFilesOutsideWorkspaceInfoUrl = exports.skipThisSurveyAction = exports.takeSurveyAction = exports.flutterSurveyAnalyticsText = exports.flutterSurveyDataUrl = exports.moreInfoAction = exports.doNotAskAgainAction = void 0;
const fs = __webpack_require__(7);
exports.dartCodeExtensionIdentifier = "Dart-Code.dart-code";
exports.flutterExtensionIdentifier = "Dart-Code.flutter";
exports.debugAdapterPath = "out/dist/debug.js";
exports.isCI = !!process.env.CI;
exports.isWin = process.platform.startsWith("win");
exports.isMac = process.platform === "darwin";
exports.isLinux = !exports.isWin && !exports.isMac;
exports.isChromeOS = exports.isLinux && fs.existsSync("/dev/.cros_milestone");
// Used for code checks and in Dart SDK urls so Chrome OS is considered Linux.
exports.dartPlatformName = exports.isWin ? "win" : exports.isMac ? "mac" : "linux";
// Used for display (logs, analytics) so Chrome OS is its own.
exports.platformDisplayName = exports.isWin ? "win" : exports.isMac ? "mac" : exports.isChromeOS ? "chromeos" : "linux";
exports.platformEol = exports.isWin ? "\r\n" : "\n";
exports.androidStudioExecutableNames = exports.isWin ? ["studio64.exe"] : ["studio.sh", "studio"];
exports.executableNames = {
    dart: exports.isWin ? "dart.exe" : "dart",
    dartdoc: exports.isWin ? "dartdoc.bat" : "dartdoc",
    flutter: exports.isWin ? "flutter.bat" : "flutter",
    pub: exports.isWin ? "pub.bat" : "pub",
};
const getExecutableName = (cmd) => { var _a; return (_a = exports.executableNames[cmd]) !== null && _a !== void 0 ? _a : cmd; };
exports.getExecutableName = getExecutableName;
exports.dartVMPath = "bin/" + exports.executableNames.dart;
exports.dartDocPath = "bin/" + exports.executableNames.dartdoc;
exports.pubPath = "bin/" + exports.executableNames.pub;
exports.flutterPath = "bin/" + exports.executableNames.flutter;
exports.pubSnapshotPath = "bin/snapshots/pub.dart.snapshot";
exports.analyzerSnapshotPath = "bin/snapshots/analysis_server.dart.snapshot";
exports.flutterSnapScript = "/snap/flutter/current/flutter.sh";
exports.androidStudioPaths = exports.androidStudioExecutableNames.map((s) => "bin/" + s);
exports.DART_DOWNLOAD_URL = "https://dart.dev/get-dart";
exports.FLUTTER_DOWNLOAD_URL = "https://flutter.dev/setup/";
exports.IS_LSP_CONTEXT = "dart-code:isLsp";
exports.DART_TEST_SUITE_NODE_CONTEXT = "dart-code:testSuiteNode";
exports.DART_TEST_SUITE_NODE_WITH_FAILURES_CONTEXT = "dart-code:testSuiteNodeWithFailures";
exports.DART_TEST_GROUP_NODE_CONTEXT = "dart-code:testGroupNode";
exports.DART_TEST_TEST_NODE_CONTEXT = "dart-code:testTestNode";
exports.DART_DEP_PROJECT_NODE_CONTEXT = "dart-code:depProjectNode";
exports.DART_DEP_PACKAGE_NODE_CONTEXT = "dart-code:depPackageNode";
exports.DART_DEP_FOLDER_NODE_CONTEXT = "dart-code:depFolderNode";
exports.DART_DEP_FILE_NODE_CONTEXT = "dart-code:depFileNode";
exports.DART_IS_CAPTURING_LOGS_CONTEXT = "dart-code:isCapturingLogs";
exports.PUB_OUTDATED_SUPPORTED_CONTEXT = "dart-code:pubOutdatedSupported";
exports.IS_RUNNING_LOCALLY_CONTEXT = "dart-code:isRunningLocally";
exports.stopLoggingAction = "Stop Logging";
exports.showLogAction = "Show Log";
exports.restartReasonManual = "manual";
exports.restartReasonSave = "save";
exports.debugLaunchProgressId = "launch";
exports.debugTerminatingProgressId = "terminate";
exports.pubGlobalDocsUrl = "https://www.dartlang.org/tools/pub/cmd/pub-global";
exports.stagehandInstallationInstructionsUrl = "https://github.com/dart-lang/stagehand#installation";
exports.issueTrackerAction = "Issue Tracker";
exports.issueTrackerUri = "https://github.com/Dart-Code/Dart-Code/issues";
exports.wantToTryDevToolsPrompt = "Dart DevTools includes additional tools for debugging and profiling Flutter apps, including a Widget Inspector. Try it?";
exports.openDevToolsAction = "Open";
exports.alwaysOpenAction = "Always Open";
exports.notTodayAction = "Not Now";
exports.doNotAskAgainAction = "Never Ask";
exports.moreInfoAction = "More Info";
exports.flutterSurveyDataUrl = "https://flutter.dev/f/flutter-survey-metadata.json";
exports.flutterSurveyAnalyticsText = "By clicking on this link you agree to share feature usage along with the survey responses.";
exports.takeSurveyAction = "Take Survey";
exports.skipThisSurveyAction = "Skip This Survey";
exports.modifyingFilesOutsideWorkspaceInfoUrl = "https://dartcode.org/docs/modifying-files-outside-workspace/";
exports.initializeSnapPrompt = "The Flutter snap is installed but not initialized. Would you like to initialize it now?";
exports.initializingFlutterMessage = "Initializing Flutter. This may take a few minutes.";
// Minutes.
exports.fiveMinutesInMs = 1000 * 60 * 5;
exports.tenMinutesInMs = 1000 * 60 * 10;
exports.twentyMinutesInMs = 1000 * 60 * 20;
// Hours.
exports.twoHoursInMs = 1000 * 60 * 60 * 2;
exports.twentyHoursInMs = 1000 * 60 * 60 * 20;
exports.fortyHoursInMs = 1000 * 60 * 60 * 40;
// Duration for not showing a prompt that has been shown before.
exports.noRepeatPromptThreshold = exports.twentyHoursInMs;
exports.longRepeatPromptThreshold = exports.fortyHoursInMs;
exports.pleaseReportBug = "Please raise a bug against the Dart extension for VS Code.";
// Chrome OS exposed ports: 8000, 8008, 8080, 8085, 8888, 9005, 3000, 4200, 5000
exports.CHROME_OS_DEVTOOLS_PORT = 8080;
exports.CHROME_OS_VM_SERVICE_PORT = 8085;
exports.DART_STAGEHAND_PROJECT_TRIGGER_FILE = "dart.sh.create";
exports.FLUTTER_CREATE_PROJECT_TRIGGER_FILE = "flutter.create";
exports.REFACTOR_FAILED_DOC_MODIFIED = "This refactor cannot be applied because the document has changed.";
exports.REFACTOR_ANYWAY = "Refactor Anyway";
exports.TRACK_WIDGET_CREATION_ENABLED = "dart-code:trackWidgetCreationEnabled";
exports.HAS_LAST_DEBUG_CONFIG = "dart-code:hasLastDebugConfig";
exports.HAS_LAST_TEST_DEBUG_CONFIG = "dart-code:hasLastTestDebugConfig";
exports.isInFlutterDebugModeDebugSessionContext = "dart-code:isInFlutterDebugModeDebugSession";
exports.isInFlutterProfileModeDebugSessionContext = "dart-code:isInFlutterProfileModeDebugSession";
exports.showErrorsAction = "Show Errors";
exports.debugAnywayAction = "Debug Anyway";
exports.userPromptContextPrefix = "hasPrompted.";
exports.installFlutterExtensionPromptKey = "install_flutter_extension_3";
exports.useRecommendedSettingsPromptKey = "use_recommended_settings";
exports.yesAction = "Yes";
exports.noAction = "No";
exports.skipAction = "Skip";
exports.showRecommendedSettingsAction = "Show Recommended Settings";
exports.recommendedSettingsUrl = "https://dartcode.org/docs/recommended-settings/";
exports.openSettingsAction = "Open Settings File";
exports.reactivateDevToolsAction = "Reactivate DevTools";
exports.vmServiceListeningBannerPattern = new RegExp("Observatory (?:listening on|.* is available at:) (http:.+)");
exports.vmServiceHttpLinkPattern = new RegExp("(http://[\\d\\.:]+/)");
const runFlutterCreateDotPrompt = (deviceName) => `You must run 'flutter create .' to create the files required to use the ${deviceName} device for this project.`;
exports.runFlutterCreateDotPrompt = runFlutterCreateDotPrompt;
exports.runFlutterCreateDotAction = "Run 'flutter create .'";
exports.cancelAction = "Cancel";
exports.devToolsPages = [
    // First entry is the default page.
    { pageId: "inspector", commandId: "dart.openDevToolsInspector", title: "Widget Inspector" },
    { pageId: "cpu-profiler", commandId: "dart.openDevToolsCpuProfiler", legacyPageId: "performance", title: "CPU Profiler" },
    { pageId: "memory", commandId: "dart.openDevToolsMemory", title: "Memory" },
    { pageId: "performance", commandId: "dart.openDevToolsPerformance", legacyPageId: "timeline", title: "Performance" },
    { pageId: "network", commandId: "dart.openDevToolsNetwork", title: "Network" },
    { pageId: "logging", commandId: "dart.openDevToolsLogging", title: "Logging" },
];
exports.dartRecommendedConfig = {
    // Automatically format code on save and during typing of certain characters
    // (like `;` and `}`).
    "editor.formatOnSave": true,
    "editor.formatOnType": true,
    // Draw a guide line at 80 characters, where Dart's formatting will wrap code.
    "editor.rulers": [80],
    // Disables built-in highlighting of words that match your selection. Without
    // this, all instances of the selected text will be highlighted, interfering
    // with Dart's ability to highlight only exact references to the selected variable.
    "editor.selectionHighlight": false,
    // By default, VS Code prevents code completion from popping open when in
    // "snippet mode" (editing placeholders in inserted code). Setting this option
    // to `false` stops that and allows completion to open as normal, as if you
    // weren't in a snippet placeholder.
    "editor.suggest.snippetsPreventQuickSuggestions": false,
    // By default, VS Code will pre-select the most recently used item from code
    // completion. This is usually not the most relevant item.
    //
    // "first" will always select top item
    // "recentlyUsedByPrefix" will filter the recently used items based on the
    //     text immediately preceeding where completion was invoked.
    "editor.suggestSelection": "first",
    // Allows pressing <TAB> to complete snippets such as `for` even when the
    // completion list is not visible.
    "editor.tabCompletion": "onlySnippets",
    // By default, VS Code will popualte code completion with words found in the
    // current file when a language service does not provide its own completions.
    // This results in code completion suggesting words when editing comments and
    // strings. This setting will prevent that.
    "editor.wordBasedSuggestions": false,
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWatcher = exports.firstEditorColumn = exports.firstNonEditorColumn = exports.envUtils = exports.treeLabel = exports.warnIfPathCaseMismatch = exports.trimTrailingSlashes = exports.showCode = exports.toRangeOnLine = exports.lspToPosition = exports.toPosition = exports.lspToRange = exports.toRange = exports.isDartWorkspaceFolder = exports.getDartWorkspaceFolders = exports.isRunningLocally = exports.SourceSortMembersCodeActionKind = void 0;
const fs = __webpack_require__(7);
const url_1 = __webpack_require__(30);
const vs = __webpack_require__(0);
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const logging_1 = __webpack_require__(13);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
exports.SourceSortMembersCodeActionKind = vscode_1.CodeActionKind.Source.append("sortMembers");
const dartExtension = vscode_1.extensions.getExtension(constants_1.dartCodeExtensionIdentifier);
// The extension kind is declared as Workspace, but VS Code will return UI in the
// case that there is no remote extension host.
exports.isRunningLocally = !dartExtension || dartExtension.extensionKind === vscode_1.ExtensionKind.UI;
function getDartWorkspaceFolders() {
    if (!vscode_1.workspace.workspaceFolders)
        return [];
    return vscode_1.workspace.workspaceFolders.filter(isDartWorkspaceFolder);
}
exports.getDartWorkspaceFolders = getDartWorkspaceFolders;
function isDartWorkspaceFolder(folder) {
    if (!folder || folder.uri.scheme !== "file")
        return false;
    // Currently we don't have good logic to know what's a Dart folder.
    // We could require a pubspec, but it's valid to just write scripts without them.
    // For now, nothing calls this that will do bad things if the folder isn't a Dart
    // project so we can review amend this in future if required.
    return true;
}
exports.isDartWorkspaceFolder = isDartWorkspaceFolder;
function toRange(document, offset, length) {
    return new vscode_1.Range(document.positionAt(offset), document.positionAt(offset + length));
}
exports.toRange = toRange;
function lspToRange(range) {
    return new vscode_1.Range(lspToPosition(range.start), lspToPosition(range.end));
}
exports.lspToRange = lspToRange;
function toPosition(location) {
    return new vscode_1.Position(location.startLine - 1, location.startColumn - 1);
}
exports.toPosition = toPosition;
function lspToPosition(position) {
    return new vscode_1.Position(position.line, position.character);
}
exports.lspToPosition = lspToPosition;
// Translates an offset/length to a Range.
// NOTE: Does not wrap lines because it does not have access to a TextDocument to know
// where the line ends.
function toRangeOnLine(location) {
    const startPos = toPosition(location);
    return new vscode_1.Range(startPos, startPos.translate(0, location.length));
}
exports.toRangeOnLine = toRangeOnLine;
function showCode(editor, displayRange, highlightRange, selectionRange) {
    if (selectionRange)
        editor.selection = new vscode_1.Selection(selectionRange.start, selectionRange.end);
    // Ensure the code is visible on screen.
    editor.revealRange(displayRange, vscode_1.TextEditorRevealType.InCenterIfOutsideViewport);
    // TODO: Implement highlighting
    // See https://github.com/Microsoft/vscode/issues/45059
}
exports.showCode = showCode;
function trimTrailingSlashes(s) {
    return s.replace(/[\/\\]+$/, "");
}
exports.trimTrailingSlashes = trimTrailingSlashes;
function warnIfPathCaseMismatch(logger, p, pathDescription, helpText) {
    const userPath = trimTrailingSlashes(fs_1.forceWindowsDriveLetterToUppercase(p));
    const realPath = fs.existsSync(userPath) && trimTrailingSlashes(fs_1.forceWindowsDriveLetterToUppercase(fs.realpathSync.native(userPath)));
    // Since realpathSync.native will resolve symlinks, we'll only show these warnings
    // when there was no symlink (eg. the lowercase version of both paths match).
    if (userPath && realPath && userPath.toLowerCase() === realPath.toLowerCase() && userPath !== realPath) {
        const message = `The casing of ${pathDescription} does not match the casing on disk; please ${helpText}. `
            + `Expected ${realPath} but got ${userPath}`;
        logger.warn(message);
        vs.window.showWarningMessage(message);
        return true;
    }
    return false;
}
exports.warnIfPathCaseMismatch = warnIfPathCaseMismatch;
class EnvUtils {
    openInBrowser(url, logger = logging_1.nullLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`Opening external URL: ${url}`);
            return vscode_1.env.openExternal(vscode_1.Uri.parse(url));
        });
    }
    exposeUrl(uri, logger = logging_1.nullLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`Exposing URL: ${uri.toString()}`);
            const isWebSocket = uri.scheme === "ws" || uri.scheme === "wss";
            const isSecure = uri.scheme === "wss" || uri.scheme === "https";
            // TODO: Remove this scheme mapping when https://github.com/microsoft/vscode/issues/84819
            // is resolved.
            let fakeScheme = uri.scheme;
            if (isWebSocket)
                fakeScheme = isSecure ? "https" : "http";
            const url = new url_1.URL(uriToString(uri));
            let fakeAuthority = uri.authority;
            if (!url.port)
                fakeAuthority = `${url.hostname}:${isSecure ? "443" : "80"}`;
            const uriToMap = uri.with({ scheme: fakeScheme, authority: fakeAuthority });
            logger.info(`Mapping URL: ${uriToMap.toString()}`);
            const mappedUri = yield vscode_1.env.asExternalUri(uriToMap);
            logger.info(`Mapped URL: ${mappedUri.toString()}`);
            // Now we need to map the scheme back to WS if that's what was originally asked for, however
            // we need to take into account whether asExternalUri pushed is up to secure, so use
            // the http/https to decide which to go back to.
            let newScheme = mappedUri.scheme;
            if (isWebSocket)
                // Note: We use mappedUri.scheme here and not isSecure because we
                // care if the *exposed* URI is secure.
                newScheme = mappedUri.scheme === "https" ? "wss" : "ws";
            const finalUri = uriToString(mappedUri.with({ scheme: newScheme }));
            logger.info(`Final URI: ${finalUri}`);
            const finalUrl = new url_1.URL(finalUri).toString();
            logger.info(`Final URL: ${finalUrl}`);
            return finalUrl;
        });
    }
}
function uriToString(uri) {
    return uri.toString()
        .replace(/%24/g, "$")
        .replace(/%5B/g, "[");
}
function treeLabel(item) {
    if (!item.label || typeof item.label === "string")
        return item.label;
    return item.label.label;
}
exports.treeLabel = treeLabel;
exports.envUtils = new EnvUtils();
function usedEditorColumns() {
    return new Set(vs.window.visibleTextEditors.map((e) => e.viewColumn).filter(utils_1.notUndefined));
}
function firstNonEditorColumn() {
    const usedColumns = usedEditorColumns();
    for (let i = 1; i <= 9; i++) {
        if (!usedColumns.has(i))
            return i;
    }
}
exports.firstNonEditorColumn = firstNonEditorColumn;
function firstEditorColumn() {
    const usedColumns = usedEditorColumns();
    for (let i = 1; i <= 9; i++) {
        if (usedColumns.has(i))
            return i;
    }
}
exports.firstEditorColumn = firstEditorColumn;
function createWatcher(pattern, emitter) {
    const watcher = vs.workspace.createFileSystemWatcher(pattern);
    watcher.onDidChange((uri) => emitter.fire(uri));
    watcher.onDidCreate((uri) => emitter.fire(uri));
    watcher.onDidDelete((uri) => emitter.fire(uri));
    return watcher;
}
exports.createWatcher = createWatcher;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExcludedFolders = exports.openLogContents = exports.logTime = exports.promptToReloadExtension = exports.escapeShell = exports.getLatestSdkVersion = exports.isValidEntryFile = exports.isInsideFolderNamed = exports.isDartFile = exports.projectShouldUsePubForTests = exports.isTestFolder = exports.isPubRunnableTestFile = exports.isTestFile = exports.isTestFileOrFolder = exports.isWithinWorkspace = exports.isAnalyzableAndInWorkspace = exports.shouldHotReloadFor = exports.isAnalyzable = exports.createFolderForFile = exports.homeRelativePath = exports.resolvePaths = exports.isFlutterProjectFolder = exports.isInsideFlutterProject = exports.isFlutterWorkspaceFolder = void 0;
const fs = __webpack_require__(7);
const https = __webpack_require__(41);
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
const extension_1 = __webpack_require__(40);
const project_1 = __webpack_require__(51);
const utils_2 = __webpack_require__(100);
function isFlutterWorkspaceFolder(folder) {
    return !!(folder && utils_1.isDartWorkspaceFolder(folder) && isFlutterProjectFolder(fs_1.fsPath(folder.uri)));
}
exports.isFlutterWorkspaceFolder = isFlutterWorkspaceFolder;
function isInsideFlutterProject(uri) {
    if (!uri)
        return false;
    const projectRoot = project_1.locateBestProjectRoot(fs_1.fsPath(uri));
    if (projectRoot)
        return isFlutterProjectFolder(projectRoot);
    else
        return isFlutterWorkspaceFolder(vscode_1.workspace.getWorkspaceFolder(uri));
}
exports.isInsideFlutterProject = isInsideFlutterProject;
function isFlutterProjectFolder(folder) {
    return utils_2.referencesFlutterSdk(folder);
}
exports.isFlutterProjectFolder = isFlutterProjectFolder;
function resolvePaths(p) {
    if (typeof p !== "string")
        return undefined;
    if (p.startsWith("~/"))
        return path.join(os.homedir(), p.substr(2));
    if (!path.isAbsolute(p) && vscode_1.workspace.workspaceFolders && vscode_1.workspace.workspaceFolders.length)
        return path.join(fs_1.fsPath(vscode_1.workspace.workspaceFolders[0].uri), p);
    return p;
}
exports.resolvePaths = resolvePaths;
/// Shortens a path to use ~ if it's inside the home directory.
function homeRelativePath(p) {
    if (!p)
        return undefined;
    const homedir = os.homedir();
    if (fs_1.isWithinPath(p, homedir))
        return path.join("~", path.relative(homedir, p));
    return p;
}
exports.homeRelativePath = homeRelativePath;
function createFolderForFile(file) {
    try {
        if (!file || !path.isAbsolute(file))
            return undefined;
        const folder = path.dirname(file);
        if (!fs.existsSync(folder))
            fs_1.mkDirRecursive(folder);
        return file;
    }
    catch (_a) {
        console.warn(`Ignoring invalid file path ${file}`);
        return undefined;
    }
}
exports.createFolderForFile = createFolderForFile;
function isAnalyzable(file) {
    if (file.isUntitled || !fs_1.fsPath(file.uri) || file.uri.scheme !== "file")
        return false;
    const analyzableLanguages = ["dart", "html"];
    const analyzableFilenames = [".analysis_options", "analysis_options.yaml", "pubspec.yaml"];
    // We have to include dart/html extensions as this function may be called without a language ID
    // (for example when triggered by a file system watcher).
    const analyzableFileExtensions = ["dart", "htm", "html"].concat(config_1.config.additionalAnalyzerFileExtensions);
    const extName = path.extname(fs_1.fsPath(file.uri));
    const extension = extName ? extName.substr(1) : undefined;
    return (file.languageId && analyzableLanguages.indexOf(file.languageId) >= 0)
        || analyzableFilenames.indexOf(path.basename(fs_1.fsPath(file.uri))) >= 0
        || (extension !== undefined && analyzableFileExtensions.includes(extension));
}
exports.isAnalyzable = isAnalyzable;
function shouldHotReloadFor(file) {
    if (file.isUntitled || !fs_1.fsPath(file.uri) || file.uri.scheme !== "file")
        return false;
    const reloadableFileExtensions = ["dart", "htm", "html", "css"];
    const extName = path.extname(fs_1.fsPath(file.uri));
    const extension = extName ? extName.substr(1) : undefined;
    return extension !== undefined && reloadableFileExtensions.includes(extension);
}
exports.shouldHotReloadFor = shouldHotReloadFor;
function isAnalyzableAndInWorkspace(file) {
    return isAnalyzable(file) && isWithinWorkspace(fs_1.fsPath(file.uri));
}
exports.isAnalyzableAndInWorkspace = isAnalyzableAndInWorkspace;
function isWithinWorkspace(file) {
    return !!vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(file));
}
exports.isWithinWorkspace = isWithinWorkspace;
function isTestFileOrFolder(path) {
    return !!path && (isTestFile(path) || isTestFolder(path));
}
exports.isTestFileOrFolder = isTestFileOrFolder;
function isTestFile(file) {
    // To be a test, you must be _test.dart AND inside a test folder.
    // https://github.com/Dart-Code/Dart-Code/issues/1165
    // https://github.com/Dart-Code/Dart-Code/issues/2021
    // https://github.com/Dart-Code/Dart-Code/issues/2034
    return !!file && isDartFile(file)
        && (isInsideFolderNamed(file, "test") || isInsideFolderNamed(file, "test_driver") || config_1.config.allowTestsOutsideTestFolder)
        && file.toLowerCase().endsWith("_test.dart");
}
exports.isTestFile = isTestFile;
// Similar to isTestFile, but requires that the file is _test.dart because it will be used as
// an entry point for pub test running.
function isPubRunnableTestFile(file) {
    return !!file && isDartFile(file) && file.toLowerCase().endsWith("_test.dart");
}
exports.isPubRunnableTestFile = isPubRunnableTestFile;
function isTestFolder(path) {
    return !!path && isInsideFolderNamed(path, "test") && fs.existsSync(path) && fs.statSync(path).isDirectory();
}
exports.isTestFolder = isTestFolder;
function projectShouldUsePubForTests(folder, config) {
    return fs_1.hasPubspec(folder) && !config.useVmForTests;
}
exports.projectShouldUsePubForTests = projectShouldUsePubForTests;
function isDartFile(file) {
    return !!file && path.extname(file.toLowerCase()) === ".dart" && fs.existsSync(file) && fs.statSync(file).isFile();
}
exports.isDartFile = isDartFile;
function isInsideFolderNamed(file, folderName) {
    if (!file)
        return false;
    const ws = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(file));
    if (!ws)
        return false;
    const relPath = path.relative(fs_1.fsPath(ws.uri), file).toLowerCase();
    const segments = relPath.split(path.sep);
    return segments.indexOf(folderName.toLowerCase()) !== -1;
}
exports.isInsideFolderNamed = isInsideFolderNamed;
function isValidEntryFile(file) {
    return file && isDartFile(file) &&
        (isTestFile(file)
            || isInsideFolderNamed(file, "bin") || isInsideFolderNamed(file, "tool") || isInsideFolderNamed(file, "test_driver")
            || file.endsWith(`lib${path.sep}main.dart`));
}
exports.isValidEntryFile = isValidEntryFile;
function getLatestSdkVersion() {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: "storage.googleapis.com",
            method: "GET",
            path: "/dart-archive/channels/stable/release/latest/VERSION",
            port: 443,
        };
        const req = https.request(options, (resp) => {
            if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                reject({ message: `Failed to get Dart SDK Version ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                resp.on("data", (d) => {
                    resolve(JSON.parse(d.toString()).version);
                });
            }
        });
        req.end();
    });
}
exports.getLatestSdkVersion = getLatestSdkVersion;
// Escapes a set of command line arguments so that the escaped string is suitable for passing as an argument
// to another shell command.
// Implementation is taken from https://github.com/xxorax/node-shell-escape
function escapeShell(args) {
    const ret = [];
    args.forEach((arg) => {
        if (/[^A-Za-z0-9_\/:=-]/.test(arg)) {
            arg = "'" + arg.replace(/'/g, "'\\''") + "'";
            arg = arg.replace(/^(?:'')+/g, "") // unduplicate single-quote at the beginning
                .replace(/\\'''/g, "\\'"); // remove non-escaped single-quote if there are enclosed between 2 escaped
        }
        ret.push(arg);
    });
    return ret.join(" ");
}
exports.escapeShell = escapeShell;
function promptToReloadExtension(prompt, buttonText, offerLog) {
    return __awaiter(this, void 0, void 0, function* () {
        const restartAction = buttonText || "Restart";
        const actions = offerLog ? [restartAction, constants_1.showLogAction] : [restartAction];
        const ringLogContents = extension_1.ringLog.toString();
        let showPromptAgain = true;
        const tempLogPath = path.join(os.tmpdir(), `log-${fs_1.getRandomInt(0x1000, 0x10000).toString(16)}.txt`);
        while (showPromptAgain) {
            showPromptAgain = false;
            const chosenAction = prompt && (yield vscode_1.window.showInformationMessage(prompt, ...actions));
            if (chosenAction === constants_1.showLogAction) {
                showPromptAgain = true;
                openLogContents(undefined, ringLogContents, tempLogPath);
            }
            else if (!prompt || chosenAction === restartAction) {
                vscode_1.commands.executeCommand("_dart.reloadExtension");
            }
        }
    });
}
exports.promptToReloadExtension = promptToReloadExtension;
const shouldLogTimings = false;
const start = process.hrtime.bigint();
let last = start;
function pad(str, length) {
    while (str.length < length)
        str = "0" + str;
    return str;
}
const logTime = (taskFinished) => {
    if (!shouldLogTimings)
        return;
    const end = process.hrtime.bigint();
    console.log(`${pad((end - last).toString(), 15)} ${taskFinished ? "<== " + taskFinished : ""}`);
    last = end;
};
exports.logTime = logTime;
function openLogContents(logType = `txt`, logContents, tempPath) {
    if (!tempPath)
        tempPath = path.join(os.tmpdir(), `log-${fs_1.getRandomInt(0x1000, 0x10000).toString(16)}.${logType}`);
    fs.writeFileSync(tempPath, logContents);
    vscode_1.workspace.openTextDocument(tempPath).then(vscode_1.window.showTextDocument);
}
exports.openLogContents = openLogContents;
/// Gets all excluded folders (full absolute paths) for a given workspace
/// folder based on config.
function getExcludedFolders(f) {
    if (!f)
        return [];
    const excludedForWorkspace = config_1.config.for(f.uri).analysisExcludedFolders;
    if (!excludedForWorkspace || !Array.isArray(excludedForWorkspace))
        return [];
    const workspacePath = fs_1.fsPath(f.uri);
    return excludedForWorkspace.map((folder) => {
        // Handle both relative and absolute paths.
        if (!path.isAbsolute(folder))
            folder = path.join(workspacePath, folder);
        return folder;
    });
}
exports.getExcludedFolders = getExcludedFolders;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DebugOption = exports.debugOptionNames = exports.LogSeverity = exports.LogCategory = exports.VersionStatus = exports.VmService = exports.VmServiceExtension = exports.TestStatus = exports.DebuggerType = void 0;
var DebuggerType;
(function (DebuggerType) {
    DebuggerType[DebuggerType["Dart"] = 0] = "Dart";
    DebuggerType[DebuggerType["PubTest"] = 1] = "PubTest";
    DebuggerType[DebuggerType["Flutter"] = 2] = "Flutter";
    DebuggerType[DebuggerType["FlutterTest"] = 3] = "FlutterTest";
    DebuggerType[DebuggerType["Web"] = 4] = "Web";
    DebuggerType[DebuggerType["WebTest"] = 5] = "WebTest";
})(DebuggerType = exports.DebuggerType || (exports.DebuggerType = {}));
var TestStatus;
(function (TestStatus) {
    // This should be in order such that the highest number is the one to show
    // when aggregating (eg. from children).
    TestStatus[TestStatus["Waiting"] = 0] = "Waiting";
    TestStatus[TestStatus["Passed"] = 1] = "Passed";
    TestStatus[TestStatus["Skipped"] = 2] = "Skipped";
    TestStatus[TestStatus["Unknown"] = 3] = "Unknown";
    TestStatus[TestStatus["Failed"] = 4] = "Failed";
    TestStatus[TestStatus["Errored"] = 5] = "Errored";
    TestStatus[TestStatus["Running"] = 6] = "Running";
})(TestStatus = exports.TestStatus || (exports.TestStatus = {}));
/// The service extensions we know about.
var VmServiceExtension;
(function (VmServiceExtension) {
    VmServiceExtension["PlatformOverride"] = "ext.flutter.platformOverride";
    VmServiceExtension["DebugBanner"] = "ext.flutter.debugAllowBanner";
    VmServiceExtension["CheckElevations"] = "ext.flutter.debugCheckElevationsEnabled";
    VmServiceExtension["DebugPaint"] = "ext.flutter.debugPaint";
    VmServiceExtension["Driver"] = "ext.flutter.driver";
    VmServiceExtension["PaintBaselines"] = "ext.flutter.debugPaintBaselinesEnabled";
    VmServiceExtension["InspectorSelectMode"] = "ext.flutter.inspector.show";
    VmServiceExtension["InspectorSetPubRootDirectories"] = "ext.flutter.inspector.setPubRootDirectories";
    VmServiceExtension["InspectorStructuredErrors"] = "ext.flutter.inspector.structuredErrors";
    VmServiceExtension["BrightnessOverride"] = "ext.flutter.brightnessOverride";
    VmServiceExtension["RepaintRainbow"] = "ext.flutter.repaintRainbow";
    VmServiceExtension["PerformanceOverlay"] = "ext.flutter.showPerformanceOverlay";
    VmServiceExtension["SlowAnimations"] = "ext.flutter.timeDilation";
})(VmServiceExtension = exports.VmServiceExtension || (exports.VmServiceExtension = {}));
/// The service extensions we know about and allow toggling via commands.
var VmService;
(function (VmService) {
    VmService["HotReload"] = "reloadSources";
    VmService["HotRestart"] = "hotRestart";
    VmService["LaunchDevTools"] = "launchDevTools";
})(VmService = exports.VmService || (exports.VmService = {}));
var VersionStatus;
(function (VersionStatus) {
    VersionStatus[VersionStatus["NotInstalled"] = 0] = "NotInstalled";
    VersionStatus[VersionStatus["UpdateRequired"] = 1] = "UpdateRequired";
    VersionStatus[VersionStatus["UpdateAvailable"] = 2] = "UpdateAvailable";
    VersionStatus[VersionStatus["Valid"] = 3] = "Valid";
})(VersionStatus = exports.VersionStatus || (exports.VersionStatus = {}));
var LogCategory;
(function (LogCategory) {
    LogCategory[LogCategory["General"] = 0] = "General";
    LogCategory[LogCategory["CI"] = 1] = "CI";
    LogCategory[LogCategory["CommandProcesses"] = 2] = "CommandProcesses";
    LogCategory[LogCategory["DevTools"] = 3] = "DevTools";
    LogCategory[LogCategory["Analyzer"] = 4] = "Analyzer";
    LogCategory[LogCategory["PubTest"] = 5] = "PubTest";
    LogCategory[LogCategory["FlutterDaemon"] = 6] = "FlutterDaemon";
    LogCategory[LogCategory["FlutterRun"] = 7] = "FlutterRun";
    LogCategory[LogCategory["FlutterTest"] = 8] = "FlutterTest";
    LogCategory[LogCategory["VmService"] = 9] = "VmService";
    LogCategory[LogCategory["WebDaemon"] = 10] = "WebDaemon";
})(LogCategory = exports.LogCategory || (exports.LogCategory = {}));
var LogSeverity;
(function (LogSeverity) {
    LogSeverity[LogSeverity["Info"] = 0] = "Info";
    LogSeverity[LogSeverity["Warn"] = 1] = "Warn";
    LogSeverity[LogSeverity["Error"] = 2] = "Error";
})(LogSeverity = exports.LogSeverity || (exports.LogSeverity = {}));
exports.debugOptionNames = ["my code", "my code + packages", "my code + packages + SDK", "my code + SDK"];
var DebugOption;
(function (DebugOption) {
    DebugOption[DebugOption["MyCode"] = 0] = "MyCode";
    DebugOption[DebugOption["MyCodePackages"] = 1] = "MyCodePackages";
    DebugOption[DebugOption["MyCodePackagesSdk"] = 2] = "MyCodePackagesSdk";
    DebugOption[DebugOption["MyCodeSdk"] = 3] = "MyCodeSdk";
})(DebugOption = exports.DebugOption || (exports.DebugOption = {}));


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

const debug = __webpack_require__(25)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(24)
const { re, t } = __webpack_require__(16)

const parseOptions = __webpack_require__(26)
const { compareIdentifiers } = __webpack_require__(32)
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(6);
const misc_1 = __webpack_require__(62);
const processes_1 = __webpack_require__(15);
class Config {
    constructor() {
        vscode_1.workspace.onDidChangeConfiguration((e) => this.reloadConfig());
        this.config = vscode_1.workspace.getConfiguration("dart");
        processes_1.setupToolEnv(this.env);
    }
    reloadConfig() {
        this.config = vscode_1.workspace.getConfiguration("dart");
        processes_1.setupToolEnv(this.env);
    }
    getConfig(key, defaultValue) {
        const value = this.config.get(key, defaultValue);
        return misc_1.nullToUndefined(value);
    }
    getWorkspaceConfig(key) {
        const c = this.config.inspect(key);
        if (c && c.workspaceValue)
            return misc_1.nullToUndefined(c.workspaceValue);
        if (c && c.workspaceFolderValue)
            return misc_1.nullToUndefined(c.workspaceFolderValue);
        return undefined;
    }
    setConfig(key, value, target) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.config.update(key, value, target);
        });
    }
    get additionalAnalyzerFileExtensions() { return this.getConfig("additionalAnalyzerFileExtensions", []); }
    get allowAnalytics() { return this.getConfig("allowAnalytics", true); }
    get allowTestsOutsideTestFolder() { return this.getConfig("allowTestsOutsideTestFolder", false); }
    get analysisServerFolding() { return this.getConfig("analysisServerFolding", true); }
    get analyzeAngularTemplates() { return this.getConfig("analyzeAngularTemplates", true); }
    get analyzerAdditionalArgs() { return this.getConfig("analyzerAdditionalArgs", []); }
    get analyzerDiagnosticsPort() { return this.getConfig("analyzerDiagnosticsPort", null); }
    get analyzerInstrumentationLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("analyzerInstrumentationLogFile", null))); }
    get analyzerLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("analyzerLogFile", null))); }
    get analyzerPath() { return utils_1.resolvePaths(this.getConfig("analyzerPath", null)); }
    get analyzerSshHost() { return this.getConfig("analyzerSshHost", null); }
    get analyzerVmServicePort() { return this.getConfig("analyzerVmServicePort", null); }
    get autoImportCompletions() { return this.getConfig("autoImportCompletions", true); }
    get buildRunnerAdditionalArgs() { return this.getConfig("buildRunnerAdditionalArgs", []); }
    get checkForSdkUpdates() { return this.getConfig("checkForSdkUpdates", true); }
    get closingLabels() { return this.getConfig("closingLabels", true); }
    get debugExtensionBackendProtocol() { return this.getConfig("debugExtensionBackendProtocol", "ws"); }
    get debugExternalLibraries() { return this.getConfig("debugExternalLibraries", false); }
    get debugSdkLibraries() { return this.getConfig("debugSdkLibraries", false); }
    get devToolsBrowser() { return this.getConfig("devToolsBrowser", "chrome"); }
    get devToolsLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("devToolsLogFile", null))); }
    get devToolsPort() { return this.getConfig("devToolsPort", null); }
    get devToolsReuseWindows() { return this.getConfig("devToolsReuseWindows", true); }
    get devToolsTheme() { return this.getConfig("devToolsTheme", "dark"); }
    get embedDevTools() { return this.getConfig("embedDevTools", true); }
    get enableSdkFormatter() { return this.getConfig("enableSdkFormatter", true); }
    get enableSnippets() { return this.getConfig("enableSnippets", true); }
    get env() { return this.getConfig("env", {}); }
    get evaluateToStringInDebugViews() { return this.getConfig("evaluateToStringInDebugViews", true); }
    get extensionLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("extensionLogFile", null))); }
    get flutterAdbConnectOnChromeOs() { return this.getConfig("flutterAdbConnectOnChromeOs", false); }
    get flutterCreateAndroidLanguage() { return this.getConfig("flutterCreateAndroidLanguage", "kotlin"); }
    get flutterCreateIOSLanguage() { return this.getConfig("flutterCreateIOSLanguage", "swift"); }
    get flutterCreateOffline() { return this.getConfig("flutterCreateOffline", false); }
    get flutterCreateOrganization() { return this.getConfig("flutterCreateOrganization", null); }
    get flutterCustomEmulators() { return this.getConfig("flutterCustomEmulators", []); }
    get flutterDaemonLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("flutterDaemonLogFile", null))); }
    get flutterGutterIcons() { return this.getConfig("flutterGutterIcons", true); }
    get flutterHotReloadOnSave() { return this.getConfig("flutterHotReloadOnSave", true); }
    get flutterHotRestartOnSave() { return this.getConfig("flutterHotRestartOnSave", true); }
    get flutterOutline() { return this.getConfig("flutterOutline", true); }
    get flutterRunLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("flutterRunLogFile", null))); }
    get flutterScreenshotPath() { return utils_1.resolvePaths(this.getConfig("flutterScreenshotPath", null)); }
    get flutterSdkPath() { return utils_1.resolvePaths(this.getConfig("flutterSdkPath", null)); }
    get flutterSdkPaths() { return this.getConfig("flutterSdkPaths", []).map(utils_1.resolvePaths); }
    get flutterSelectDeviceWhenConnected() { return this.getConfig("flutterSelectDeviceWhenConnected", true); }
    get flutterTestLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("flutterTestLogFile", null))); }
    get flutterWebRenderer() { return this.getConfig("flutterWebRenderer", "auto"); }
    get hotReloadProgress() { return this.getConfig("hotReloadProgress", "notification"); }
    get maxLogLineLength() { return this.getConfig("maxLogLineLength", 2000); }
    get notifyAnalyzerErrors() { return this.getConfig("notifyAnalyzerErrors", true); }
    get openDevTools() { return this.getConfig("openDevTools", "never"); }
    get openTestView() { return this.getConfig("openTestView", ["testRunStart"]); }
    get previewBazelWorkspaceCustomScripts() { return this.getConfig("previewBazelWorkspaceCustomScripts", false); }
    get previewCommitCharacters() { return this.getConfig("previewCommitCharacters", false); }
    get previewFlutterUiGuides() { return this.getConfig("previewFlutterUiGuides", false); }
    get previewFlutterUiGuidesCustomTracking() { return this.getConfig("previewFlutterUiGuidesCustomTracking", false); }
    get previewHotReloadOnSaveWatcher() { return this.getConfig("previewHotReloadOnSaveWatcher", false); }
    get previewLsp() { return this.getConfig("previewLsp", false); }
    get promptToRunIfErrors() { return this.getConfig("promptToRunIfErrors", true); }
    get pubTestLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("pubTestLogFile", null))); }
    get sdkPath() { return utils_1.resolvePaths(this.getConfig("sdkPath", null)); }
    get sdkPaths() { return this.getConfig("sdkPaths", []).map(utils_1.resolvePaths); }
    get showDartPadSampleCodeLens() { return this.getConfig("showDartPadSampleCodeLens", true); }
    get showDevToolsDebugToolBarButtons() { return this.getConfig("showDevToolsDebugToolBarButtons", true); }
    get showIgnoreQuickFixes() { return this.getConfig("showIgnoreQuickFixes", true); }
    get showMainCodeLens() { return this.getConfig("showMainCodeLens", true); }
    get showTestCodeLens() { return this.getConfig("showTestCodeLens", true); }
    get showTodos() { return this.getConfig("showTodos", true); }
    get triggerSignatureHelpAutomatically() { return this.getConfig("triggerSignatureHelpAutomatically", false); }
    get updateImportsOnRename() { return this.getConfig("updateImportsOnRename", true); }
    get useKnownChromeOSPorts() { return this.getConfig("useKnownChromeOSPorts", true); }
    get vmServiceLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("vmServiceLogFile", null))); }
    get warnWhenEditingFilesInPubCache() { return this.getConfig("warnWhenEditingFilesInPubCache", true); }
    get warnWhenEditingFilesOutsideWorkspace() { return this.getConfig("warnWhenEditingFilesOutsideWorkspace", true); }
    get webDaemonLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("webDaemonLogFile", null))); }
    // Helpers
    get useDevToolsDarkTheme() { return this.devToolsTheme === "dark"; }
    get openTestViewOnFailure() { return this.openTestView.indexOf("testFailure") !== -1; }
    get openTestViewOnStart() { return this.openTestView.indexOf("testRunStart") !== -1; }
    get workspaceSdkPath() { return utils_1.resolvePaths(this.getWorkspaceConfig("sdkPath")); }
    get workspaceFlutterSdkPath() { return utils_1.resolvePaths(this.getWorkspaceConfig("flutterSdkPath")); }
    // Options that can be set programatically.
    setCheckForSdkUpdates(value) { return this.setConfig("checkForSdkUpdates", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterSdkPath(value) { return this.setConfig("flutterSdkPath", value, vscode_1.ConfigurationTarget.Workspace); }
    setGlobalDartSdkPath(value) { return this.setConfig("sdkPath", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalDebugSdkLibraries(value) { return this.setConfig("debugSdkLibraries", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalDebugExternalLibraries(value) { return this.setConfig("debugExternalLibraries", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalFlutterSdkPath(value) { return this.setConfig("flutterSdkPath", value, vscode_1.ConfigurationTarget.Global); }
    setPreviewLsp(value) { return this.setConfig("previewLsp", value, vscode_1.ConfigurationTarget.Global); }
    setOpenDevTools(value) { return this.setConfig("openDevTools", value, vscode_1.ConfigurationTarget.Global); }
    setSdkPath(value) { return this.setConfig("sdkPath", value, vscode_1.ConfigurationTarget.Workspace); }
    setWarnWhenEditingFilesOutsideWorkspace(value) { return this.setConfig("warnWhenEditingFilesOutsideWorkspace", value, vscode_1.ConfigurationTarget.Global); }
    setWarnWhenEditingFilesInPubCache(value) { return this.setConfig("warnWhenEditingFilesInPubCache", value, vscode_1.ConfigurationTarget.Global); }
    for(uri) {
        return new ResourceConfig(uri);
    }
}
class ResourceConfig {
    constructor(uri) {
        this.uri = uri;
        this.config = vscode_1.workspace.getConfiguration("dart", this.uri);
    }
    getConfig(key, defaultValue) {
        return misc_1.nullToUndefined(this.config.get(key, defaultValue));
    }
    get analysisExcludedFolders() { return this.getConfig("analysisExcludedFolders", []); }
    get analyzerInstrumentationLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("analyzerInstrumentationLogFile", null))); }
    get analyzerLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("analyzerLogFile", null))); }
    get analyzerPath() { return utils_1.resolvePaths(this.getConfig("analyzerPath", null)); }
    get devToolsLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("devToolsLogFile", null))); }
    get doNotFormat() { return this.getConfig("doNotFormat", []); }
    get enableCompletionCommitCharacters() { return this.getConfig("enableCompletionCommitCharacters", false); }
    get evaluateGettersInDebugViews() { return this.getConfig("evaluateGettersInDebugViews", true); }
    get extensionLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("extensionLogFile", null))); }
    get flutterAdditionalArgs() { return this.getConfig("flutterAdditionalArgs", []); }
    get flutterAttachAdditionalArgs() { return this.getConfig("flutterAttachAdditionalArgs", []); }
    get flutterRunAdditionalArgs() { return this.getConfig("flutterRunAdditionalArgs", []); }
    get flutterTestAdditionalArgs() { return this.getConfig("flutterTestAdditionalArgs", []); }
    get flutterDaemonLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("flutterDaemonLogFile", null))); }
    get flutterRunLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("flutterRunLogFile", null))); }
    get flutterScreenshotPath() { return utils_1.resolvePaths(this.getConfig("flutterScreenshotPath", null)); }
    get flutterSdkPath() { return utils_1.resolvePaths(this.getConfig("flutterSdkPath", null)); }
    get flutterSdkPaths() { return this.getConfig("flutterSdkPaths", []).map(utils_1.resolvePaths); }
    get flutterStructuredErrors() { return this.getConfig("flutterStructuredErrors", true); }
    get flutterTestLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("flutterTestLogFile", null))); }
    get flutterTrackWidgetCreation() { return this.getConfig("flutterTrackWidgetCreation", true); }
    get insertArgumentPlaceholders() { return this.getConfig("insertArgumentPlaceholders", true); }
    get lineLength() { return this.getConfig("lineLength", 80); }
    get promptToGetPackages() { return this.getConfig("promptToGetPackages", true); }
    get pubAdditionalArgs() { return this.getConfig("pubAdditionalArgs", []); }
    get pubTestLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("pubTestLogFile", null))); }
    get runPubGetOnPubspecChanges() { return this.getConfig("runPubGetOnPubspecChanges", true); }
    get sdkPath() { return utils_1.resolvePaths(this.getConfig("sdkPath", null)); }
    get sdkPaths() { return this.getConfig("sdkPaths", []).map(utils_1.resolvePaths); }
    get showDartDeveloperLogs() { return this.getConfig("showDartDeveloperLogs", true); }
    get vmAdditionalArgs() { return this.getConfig("vmAdditionalArgs", []); }
    get vmServiceLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("vmServiceLogFile", null))); }
    get webDaemonLogFile() { return utils_1.createFolderForFile(utils_1.resolvePaths(this.getConfig("webDaemonLogFile", null))); }
}
exports.config = new Config();


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0)
        this.set = [first]
      else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached)
      return cached

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const l = rangeList.length
    const rangeMap = new Map()
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp]
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has(''))
      rangeMap.delete('')

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(87)
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(26)
const Comparator = __webpack_require__(28)
const debug = __webpack_require__(25)
const SemVer = __webpack_require__(9)
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(16)

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RingLog = exports.captureLogs = exports.logToConsole = exports.logProcess = exports.nullLogger = exports.CategoryLogger = exports.EmittingLogger = void 0;
const events_1 = __webpack_require__(39);
const fs = __webpack_require__(7);
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const utils_1 = __webpack_require__(3);
class LogEmitter extends events_1.EventEmitter {
    fire(msg) {
        this.emit("log", msg);
    }
    onLog(listener) {
        this.on("log", listener);
        return {
            dispose: () => { this.removeListener("log", listener); },
        };
    }
}
class EmittingLogger {
    constructor() {
        this.onLogEmitter = new LogEmitter();
        this.onLog = (listener) => this.onLogEmitter.onLog(listener);
    }
    log(message, severity, category = enums_1.LogCategory.General) {
        this.onLogEmitter.fire(new LogMessageImpl(message, severity, category));
    }
    info(message, category) {
        this.log(message, enums_1.LogSeverity.Info, category);
    }
    warn(errorOrMessage, category) {
        this.log(utils_1.errorString(errorOrMessage), enums_1.LogSeverity.Warn, category);
    }
    error(errorOrMessage, category) {
        this.log(utils_1.errorString(errorOrMessage), enums_1.LogSeverity.Error, category);
    }
    dispose() {
        this.onLogEmitter.removeAllListeners();
    }
}
exports.EmittingLogger = EmittingLogger;
class LogMessageImpl {
    constructor(message, severity, category) {
        this.message = message;
        this.severity = severity;
        this.category = category;
    }
    toLine(maxLength) {
        const logMessage = (maxLength && this.message && this.message.length > maxLength
            ? this.message.substring(0, maxLength) + "…"
            : (this.message || "<empty message>")).trimRight();
        const time = `[${(new Date()).toLocaleTimeString()}]`;
        const prefix = `[${enums_1.LogCategory[this.category]}] [${enums_1.LogSeverity[this.severity]}]`;
        return `${time} ${prefix} ${logMessage}`;
    }
}
class CategoryLogger {
    constructor(base, defaultCategory) {
        this.base = base;
        this.defaultCategory = defaultCategory;
    }
    info(message, category = this.defaultCategory) {
        this.base.info(message, category);
    }
    warn(errorOrMessage, category = this.defaultCategory) {
        this.base.warn(errorOrMessage, category);
    }
    error(errorOrMessage, category = this.defaultCategory) {
        this.base.error(errorOrMessage, category);
    }
}
exports.CategoryLogger = CategoryLogger;
class NullLogger {
    // tslint:disable-next-line: no-empty
    info(message, category) { }
    // tslint:disable-next-line: no-empty
    warn(message, category) { }
    // tslint:disable-next-line: no-empty
    error(error, category) { }
}
exports.nullLogger = new NullLogger();
function logProcess(logger, category, process) {
    const prefix = `(PROC ${process.pid})`;
    logger.info(`${prefix} Logging data for process...`, category);
    process.stdout.on("data", (data) => logger.info(`${prefix} ${data}`, category));
    process.stderr.on("data", (data) => logger.info(`${prefix} ${data}`, category));
    process.on("close", (code, signal) => logger.info(`${prefix} closed (${code}, ${signal})`, category));
    process.on("exit", (code, signal) => logger.info(`${prefix} exited (${code}, ${signal})`, category));
}
exports.logProcess = logProcess;
function logToConsole(logger) {
    return logger.onLog((m) => {
        if (m.severity === enums_1.LogSeverity.Error)
            console.error(m.toLine(1000));
        else if (m.severity === enums_1.LogSeverity.Warn)
            console.warn(m.toLine(1000));
    });
}
exports.logToConsole = logToConsole;
function captureLogs(logger, file, header, maxLogLineLength, logCategories, excludeLogCategories = false) {
    if (!file || !path.isAbsolute(file))
        throw new Error("Path passed to logTo must be an absolute path");
    const time = (detailed = false) => detailed ? `[${(new Date()).toTimeString()}] ` : `[${(new Date()).toLocaleTimeString()}] `;
    let logStream = fs.createWriteStream(file);
    if (header)
        logStream.write(header);
    const categoryNames = logCategories.map((c) => enums_1.LogCategory[c]);
    logStream.write(`Logging Categories:${constants_1.platformEol}    ${categoryNames.join(", ")}${constants_1.platformEol}${constants_1.platformEol}`);
    logStream.write(`${(new Date()).toDateString()} ${time(true)}Log file started${constants_1.platformEol}`);
    let fileLogger = logger.onLog((e) => {
        if (!logStream)
            return;
        // We should log this event if:
        // - We don't have a category filter; or
        // - The category filter includes this category; or
        // - The log is WARN/ERROR (they get logged everywhere).
        const shouldLog = (excludeLogCategories
            ? logCategories.indexOf(e.category) === -1
            : logCategories.indexOf(e.category) !== -1)
            || e.severity === enums_1.LogSeverity.Warn
            || e.severity === enums_1.LogSeverity.Error;
        if (!shouldLog)
            return;
        logStream.write(`${e.toLine(maxLogLineLength)}${os.EOL}`);
    });
    return {
        dispose() {
            if (fileLogger) {
                fileLogger.dispose();
                fileLogger = undefined;
            }
            return new Promise((resolve) => {
                if (logStream) {
                    logStream.write(`${(new Date()).toDateString()} ${time(true)}Log file ended${os.EOL}`);
                    logStream.end(resolve);
                    logStream = undefined;
                }
            });
        },
    };
}
exports.captureLogs = captureLogs;
class RingLog {
    constructor(size) {
        this.size = size;
        this.pointer = 0;
        this.lines = new Array(this.size);
    }
    get rawLines() { return this.lines; }
    log(message) {
        this.lines[this.pointer] = message;
        this.pointer = (this.pointer + 1) % this.size;
    }
    toString() {
        return this.lines.slice(this.pointer, this.size).concat(this.lines.slice(0, this.pointer)).filter((l) => l).join("\n");
    }
}
exports.RingLog = RingLog;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.CancellationToken = vscode_jsonrpc_1.CancellationToken;
exports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
exports.Disposable = vscode_jsonrpc_1.Disposable;
exports.Event = vscode_jsonrpc_1.Event;
exports.Emitter = vscode_jsonrpc_1.Emitter;
exports.Trace = vscode_jsonrpc_1.Trace;
exports.TraceFormat = vscode_jsonrpc_1.TraceFormat;
exports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
exports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
exports.RequestType = vscode_jsonrpc_1.RequestType;
exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
exports.NotificationType = vscode_jsonrpc_1.NotificationType;
exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
exports.MessageReader = vscode_jsonrpc_1.MessageReader;
exports.MessageWriter = vscode_jsonrpc_1.MessageWriter;
exports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
exports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
exports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
exports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
exports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
exports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
exports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
exports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
exports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
exports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
exports.ProgressType = vscode_jsonrpc_1.ProgressType;
__export(__webpack_require__(166));
__export(__webpack_require__(167));
const callHierarchy = __webpack_require__(178);
const st = __webpack_require__(179);
var Proposed;
(function (Proposed) {
    let CallHierarchyPrepareRequest;
    (function (CallHierarchyPrepareRequest) {
        CallHierarchyPrepareRequest.method = callHierarchy.CallHierarchyPrepareRequest.method;
        CallHierarchyPrepareRequest.type = callHierarchy.CallHierarchyPrepareRequest.type;
    })(CallHierarchyPrepareRequest = Proposed.CallHierarchyPrepareRequest || (Proposed.CallHierarchyPrepareRequest = {}));
    let CallHierarchyIncomingCallsRequest;
    (function (CallHierarchyIncomingCallsRequest) {
        CallHierarchyIncomingCallsRequest.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;
        CallHierarchyIncomingCallsRequest.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;
    })(CallHierarchyIncomingCallsRequest = Proposed.CallHierarchyIncomingCallsRequest || (Proposed.CallHierarchyIncomingCallsRequest = {}));
    let CallHierarchyOutgoingCallsRequest;
    (function (CallHierarchyOutgoingCallsRequest) {
        CallHierarchyOutgoingCallsRequest.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;
        CallHierarchyOutgoingCallsRequest.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;
    })(CallHierarchyOutgoingCallsRequest = Proposed.CallHierarchyOutgoingCallsRequest || (Proposed.CallHierarchyOutgoingCallsRequest = {}));
    Proposed.SemanticTokenTypes = st.SemanticTokenTypes;
    Proposed.SemanticTokenModifiers = st.SemanticTokenModifiers;
    Proposed.SemanticTokens = st.SemanticTokens;
    let SemanticTokensRequest;
    (function (SemanticTokensRequest) {
        SemanticTokensRequest.method = st.SemanticTokensRequest.method;
        SemanticTokensRequest.type = st.SemanticTokensRequest.type;
    })(SemanticTokensRequest = Proposed.SemanticTokensRequest || (Proposed.SemanticTokensRequest = {}));
    let SemanticTokensEditsRequest;
    (function (SemanticTokensEditsRequest) {
        SemanticTokensEditsRequest.method = st.SemanticTokensEditsRequest.method;
        SemanticTokensEditsRequest.type = st.SemanticTokensEditsRequest.type;
    })(SemanticTokensEditsRequest = Proposed.SemanticTokensEditsRequest || (Proposed.SemanticTokensEditsRequest = {}));
    let SemanticTokensRangeRequest;
    (function (SemanticTokensRangeRequest) {
        SemanticTokensRangeRequest.method = st.SemanticTokensRangeRequest.method;
        SemanticTokensRangeRequest.type = st.SemanticTokensRangeRequest.type;
    })(SemanticTokensRangeRequest = Proposed.SemanticTokensRangeRequest || (Proposed.SemanticTokensRangeRequest = {}));
})(Proposed = exports.Proposed || (exports.Proposed = {}));
function createProtocolConnection(reader, writer, logger, strategy) {
    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RunProcessResult = exports.runProcess = exports.safeToolSpawn = exports.setupToolEnv = exports.getGlobalFlutterArgs = exports.getToolEnv = void 0;
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const processes_1 = __webpack_require__(43);
const misc_1 = __webpack_require__(62);
// Environment used when spawning Dart and Flutter processes.
let toolEnv = /* { [key: string]: string | undefined } */ {};
let globalFlutterArgs = [];
function getToolEnv() {
    return toolEnv;
}
exports.getToolEnv = getToolEnv;
function getGlobalFlutterArgs() {
    return globalFlutterArgs;
}
exports.getGlobalFlutterArgs = getGlobalFlutterArgs;
function setupToolEnv(envOverrides) {
    toolEnv = {};
    globalFlutterArgs = [];
    toolEnv.FLUTTER_HOST = "VSCode";
    toolEnv.PUB_ENVIRONMENT = (toolEnv.PUB_ENVIRONMENT ? `${toolEnv.PUB_ENVIRONMENT}:` : "") + "vscode.dart-code";
    if (process.env.DART_CODE_IS_TEST_RUN) {
        toolEnv.PUB_ENVIRONMENT += ".test.bot";
        globalFlutterArgs.push("--suppress-analytics");
    }
    // Add on any overrides.
    if (envOverrides)
        toolEnv = Object.assign(toolEnv, envOverrides);
}
exports.setupToolEnv = setupToolEnv;
// TODO: Should we move this to extension activate?
setupToolEnv();
function safeToolSpawn(workingDirectory, binPath, args, envOverrides) {
    return processes_1.safeSpawn(workingDirectory, binPath, args, { envOverrides, toolEnv });
}
exports.safeToolSpawn = safeToolSpawn;
/// Runs a process and returns the exit code, stdout, stderr. Always resolves even for non-zero exit codes.
function runProcess(logger, workingDirectory, binPath, args, envOverrides) {
    return new Promise((resolve) => {
        logger.info(`Spawning ${binPath} with args ${JSON.stringify(args)} in ${workingDirectory} with env ${JSON.stringify(envOverrides)}`);
        const proc = safeToolSpawn(workingDirectory, binPath, args, envOverrides);
        logging_1.logProcess(logger, enums_1.LogCategory.CommandProcesses, proc);
        const out = [];
        const err = [];
        proc.stdout.on("data", (data) => out.push(data.toString()));
        proc.stderr.on("data", (data) => err.push(data.toString()));
        proc.on("exit", (code) => {
            resolve(new RunProcessResult(misc_1.nullToUndefined(code), out.join(""), err.join("")));
        });
    });
}
exports.runProcess = runProcess;
class RunProcessResult {
    constructor(exitCode, stdout, stderr) {
        this.exitCode = exitCode;
        this.stdout = stdout;
        this.stderr = stderr;
    }
}
exports.RunProcessResult = RunProcessResult;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(24)
const debug = __webpack_require__(25)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

const {MAX_LENGTH} = __webpack_require__(24)
const { re, t } = __webpack_require__(16)
const SemVer = __webpack_require__(9)

const parseOptions = __webpack_require__(26)
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayStartsWith = exports.arraysEqual = exports.unique = exports.not = exports.sortBy = void 0;
function sortBy(items, f) {
    return items.sort((item1, item2) => {
        const r1 = f(item1);
        const r2 = f(item2);
        if (r1 < r2)
            return -1;
        if (r1 > r2)
            return 1;
        return 0;
    });
}
exports.sortBy = sortBy;
function not(f) {
    return (x) => !f(x);
}
exports.not = not;
function unique(items) {
    return Array.from(new Set(items));
}
exports.unique = unique;
function arraysEqual(items1, items2) {
    return items1.length === items2.length && items1.every((val, i) => val === items2[i]);
}
exports.arraysEqual = arraysEqual;
function arrayStartsWith(items1, items2) {
    return items1.length >= items2.length && items1.slice(0, items2.length).every((val, i) => val === items2[i]);
}
exports.arrayStartsWith = arrayStartsWith;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanDartdoc = exports.checkHasFlutterExtension = exports.readJson = exports.docsIconPathFormat = exports.hasFlutterExtension = exports.isDevExtension = exports.vsCodeVersionConstraint = exports.extensionVersion = exports.extensionPath = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const dartdoc = __webpack_require__(116);
exports.extensionPath = vscode_1.extensions.getExtension(constants_1.dartCodeExtensionIdentifier).extensionPath;
exports.extensionVersion = getExtensionVersion();
exports.vsCodeVersionConstraint = getVsCodeVersionConstraint();
exports.isDevExtension = checkIsDevExtension();
exports.hasFlutterExtension = checkHasFlutterExtension();
exports.docsIconPathFormat = vscode_1.Uri.file(path.join(exports.extensionPath, "media/doc-icons/")).toString() + "$1%402x.png";
function readJson(file) {
    return JSON.parse(fs.readFileSync(file).toString());
}
exports.readJson = readJson;
function getExtensionVersion() {
    const packageJson = readJson(path.join(exports.extensionPath, "package.json"));
    return packageJson.version;
}
function getVsCodeVersionConstraint() {
    const packageJson = readJson(path.join(exports.extensionPath, "package.json"));
    return packageJson.engines.vscode;
}
function checkIsDevExtension() {
    return exports.extensionVersion.endsWith("-dev");
}
function checkHasFlutterExtension() {
    return vscode_1.extensions.getExtension(constants_1.flutterExtensionIdentifier) !== undefined;
}
exports.checkHasFlutterExtension = checkHasFlutterExtension;
function cleanDartdoc(doc) {
    return dartdoc.cleanDartdoc(doc, exports.docsIconPathFormat);
}
exports.cleanDartdoc = cleanDartdoc;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const c2p = __webpack_require__(180);
const p2c = __webpack_require__(181);
const Is = __webpack_require__(56);
const async_1 = __webpack_require__(182);
const UUID = __webpack_require__(124);
const progressPart_1 = __webpack_require__(125);
__export(__webpack_require__(14));
class ConsoleLogger {
    error(message) {
        console.error(message);
    }
    warn(message) {
        console.warn(message);
    }
    info(message) {
        console.info(message);
    }
    log(message) {
        console.log(message);
    }
}
function createConnection(input, output, errorHandler, closeHandler) {
    let logger = new ConsoleLogger();
    let connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger);
    connection.onError((data) => { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    let result = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),
        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),
        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
                sendNotification: false,
                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === void 0) {
                connection.trace(value, tracer, defaultTraceOptions);
            }
            else if (Is.boolean(sendNotificationOrTraceOptions)) {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
            else {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
        },
        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined),
        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
        dispose: () => connection.dispose()
    };
    return result;
}
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
class DefaultErrorHandler {
    constructor(name) {
        this.name = name;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return ErrorAction.Continue;
        }
        return ErrorAction.Shutdown;
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < 5) {
            return CloseAction.Restart;
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                vscode_1.window.showErrorMessage(`The ${this.name} server crashed 5 times in the last 3 minutes. The server will not be restarted.`);
                return CloseAction.DoNotRestart;
            }
            else {
                this.restarts.shift();
                return CloseAction.Restart;
            }
        }
    }
}
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var State;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Starting"] = 3] = "Starting";
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState || (ClientState = {}));
const SupportedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.register) && Is.func(candidate.unregister) && Is.func(candidate.dispose) && candidate.messages !== void 0;
    }
    DynamicFeature.is = is;
})(DynamicFeature || (DynamicFeature = {}));
class DocumentNotifiactions {
    constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
    }
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument)) {
                return true;
            }
        }
        return false;
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(data) {
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
            if (this._middleware) {
                this._middleware(data, (data) => this._client.sendNotification(this._type, this._createParams(data)));
            }
            else {
                this._client.sendNotification(this._type, this._createParams(data));
            }
            this.notificationSent(data);
        }
    }
    notificationSent(_data) {
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const selector of this._selectors.values()) {
            if (vscode_1.languages.match(selector, document)) {
                return {
                    send: (data) => {
                        this.callback(data);
                    }
                };
            }
        }
        throw new Error(`No provider available for the given text document`);
    }
}
class DidOpenTextDocumentFeature extends DocumentNotifiactions {
    constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register(this.messages, { id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    register(message, data) {
        super.register(message, data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
            let uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
                return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didOpen = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                if (middleware.didOpen) {
                    middleware.didOpen(textDocument, didOpen);
                }
                else {
                    didOpen(textDocument);
                }
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    }
}
class DidCloseTextDocumentFeature extends DocumentNotifiactions {
    constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register(this.messages, { id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.delete(textDocument.uri.toString());
    }
    unregister(id) {
        let selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) && !this._selectorFilter(selectors, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didClose = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                if (middleware.didClose) {
                    middleware.didClose(textDocument, didClose);
                }
                else {
                    didClose(textDocument);
                }
            }
        });
    }
}
class DidChangeTextDocumentFeature {
    constructor(_client) {
        this._client = _client;
        this._changeData = new Map();
        this._forcingDelivery = false;
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            documentSelector: data.registerOptions.documentSelector,
            syncKind: data.registerOptions.syncKind
        });
    }
    callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / undirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document)) {
                let middleware = this._client.clientOptions.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    let params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event);
                    if (middleware.didChange) {
                        middleware.didChange(event, () => this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params));
                    }
                    else {
                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    }
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    let didChange = (event) => {
                        if (this._changeDelayer) {
                            if (this._changeDelayer.uri !== event.document.uri.toString()) {
                                // Use this force delivery to track boolean state. Otherwise we might call two times.
                                this.forceDelivery();
                                this._changeDelayer.uri = event.document.uri.toString();
                            }
                            this._changeDelayer.delayer.trigger(() => {
                                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            });
                        }
                        else {
                            this._changeDelayer = {
                                uri: event.document.uri.toString(),
                                delayer: new async_1.Delayer(200)
                            };
                            this._changeDelayer.delayer.trigger(() => {
                                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            }, -1);
                        }
                    };
                    if (middleware.didChange) {
                        middleware.didChange(event, didChange);
                    }
                    else {
                        didChange(event);
                    }
                }
            }
        }
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._changeDelayer = undefined;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
            return;
        }
        try {
            this._forcingDelivery = true;
            this._changeDelayer.delayer.forceDelivery();
        }
        finally {
            this._forcingDelivery = false;
        }
    }
    getProvider(document) {
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, document)) {
                return {
                    send: (event) => {
                        this.callback(event);
                    }
                };
            }
        }
        throw new Error(`No provider available for the given text document`);
    }
}
class WillSaveFeature extends DocumentNotifiactions {
    constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get messages() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
}
class WillSaveWaitUntilFeature {
    constructor(_client) {
        this._client = _client;
        this._selectors = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(event) {
        if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {
            let middleware = this._client.clientOptions.middleware;
            let willSaveWaitUntil = (event) => {
                return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then((edits) => {
                    let vEdits = this._client.protocol2CodeConverter.asTextEdits(edits);
                    return vEdits === void 0 ? [] : vEdits;
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
class DidSaveTextDocumentFeature extends DocumentNotifiactions {
    constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifiactions.textDocumentFilter);
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { includeText: !!textDocumentSyncOptions.save.includeText })
            });
        }
    }
    register(method, data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(method, data);
    }
}
class FileSystemWatcherFeature {
    constructor(_client, _notifyFileEvent) {
        this._client = _client;
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
    }
    initialize(_capabilities, _documentSelector) {
    }
    register(_method, data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        let disposeables = [];
        for (let watcher of data.registerOptions.watchers) {
            if (!Is.string(watcher.globPattern)) {
                continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== void 0 && watcher.kind !== null) {
                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
            }
            let fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete);
            disposeables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposeables);
    }
    registerRaw(id, fileSystemWatchers) {
        let disposeables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposeables);
        }
        this._watchers.set(id, disposeables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposeables = this._watchers.get(id);
        if (disposeables) {
            for (let disposable of disposeables) {
                disposable.dispose();
            }
        }
    }
    dispose() {
        this._watchers.forEach((disposeables) => {
            for (let disposable of disposeables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
class TextDocumentFeature {
    constructor(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._registrations = new Map();
    }
    get messages() {
        return this._message;
    }
    register(message, data) {
        if (message.method !== this.messages.method) {
            throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);
        }
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((value) => {
            value.disposable.dispose();
        });
        this._registrations.clear();
    }
    getRegistration(documentSelector, capability) {
        if (!capability) {
            return [undefined, undefined];
        }
        else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector || documentSelector;
            if (selector) {
                return [id, Object.assign({}, capability, { documentSelector: selector })];
            }
        }
        else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
                return [undefined, undefined];
            }
            let options = (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
            return [UUID.generateUuid(), options];
        }
        return [undefined, undefined];
    }
    getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
            return undefined;
        }
        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
    }
    getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && vscode_1.languages.match(selector, textDocument)) {
                return registration.provider;
            }
        }
        throw new Error(`The feature has no registration for the provided text document ${textDocument.uri.toString()}`);
    }
}
exports.TextDocumentFeature = TextDocumentFeature;
class WorkspaceFeature {
    constructor(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._registrations = new Map();
    }
    get messages() {
        return this._message;
    }
    register(message, data) {
        if (message.method !== this.messages.method) {
            throw new Error(`Register called on wron feature. Requested ${message.method} but reached feature ${this.messages.method}`);
        }
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((registration) => {
            registration.disposable.dispose();
        });
        this._registrations.clear();
    }
    getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
            result.push(registration.provider);
        }
        return result;
    }
}
class CompletionItemFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let completion = ensure(ensure(capabilites, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const triggerCharacters = options.triggerCharacters || [];
        const provider = {
            provideCompletionItems: (document, position, token, context) => {
                const client = this._client;
                const middleware = this._client.clientOptions.middleware;
                const provideCompletionItems = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then(client.protocol2CodeConverter.asCompletionResult, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.clientOptions.middleware;
                    const resolveCompletionItem = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item), token).then(client.protocol2CodeConverter.asCompletionItem, (error) => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, error);
                            return Promise.resolve(item);
                        });
                    };
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCompletionItemProvider(options.documentSelector, provider, ...triggerCharacters), provider];
    }
}
class HoverFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const hoverCapability = (ensure(ensure(capabilites, 'textDocument'), 'hover'));
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideHover: (document, position, token) => {
                const client = this._client;
                const provideHover = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asHover, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        };
        return [vscode_1.languages.registerHoverProvider(options.documentSelector, provider), provider];
    }
}
class SignatureHelpFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let config = ensure(ensure(capabilites, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.contextSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSignatureHelp: (document, position, token, context) => {
                const client = this._client;
                const providerSignatureHelp = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document, position, context), token).then(client.protocol2CodeConverter.asSignatureHelp, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideSignatureHelp
                    ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp)
                    : providerSignatureHelp(document, position, context, token);
            }
        };
        let disposable;
        if (options.retriggerCharacters === undefined) {
            const triggerCharacters = options.triggerCharacters || [];
            disposable = vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, provider, ...triggerCharacters);
        }
        else {
            const metaData = {
                triggerCharacters: options.triggerCharacters || [],
                retriggerCharacters: options.retriggerCharacters || []
            };
            disposable = vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, provider, metaData);
        }
        return [disposable, provider];
    }
}
class DefinitionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let definitionSupport = ensure(ensure(capabilites, 'textDocument'), 'definition');
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDefinition: (document, position, token) => {
                const client = this._client;
                const provideDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        };
        return [vscode_1.languages.registerDefinitionProvider(options.documentSelector, provider), provider];
    }
}
class ReferencesFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'references').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideReferences: (document, position, options, token) => {
                const client = this._client;
                const _providerReferences = (document, position, options, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then(client.protocol2CodeConverter.asReferences, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, _providerReferences)
                    : _providerReferences(document, position, options, token);
            }
        };
        return [vscode_1.languages.registerReferenceProvider(options.documentSelector, provider), provider];
    }
}
class DocumentHighlightFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentHighlights: (document, position, token) => {
                const client = this._client;
                const _provideDocumentHighlights = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDocumentHighlights, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights)
                    : _provideDocumentHighlights(document, position, token);
            }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(options.documentSelector, provider), provider];
    }
}
class DocumentSymbolFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let symbolCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentSymbols: (document, token) => {
                const client = this._client;
                const _provideDocumentSymbols = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token).then((data) => {
                        if (data === null) {
                            return undefined;
                        }
                        if (data.length === 0) {
                            return [];
                        }
                        else {
                            let element = data[0];
                            if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {
                                return client.protocol2CodeConverter.asDocumentSymbols(data);
                            }
                            else {
                                return client.protocol2CodeConverter.asSymbolInformations(data);
                            }
                        }
                    }, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols)
                    : _provideDocumentSymbols(document, token);
            }
        };
        return [vscode_1.languages.registerDocumentSymbolProvider(options.documentSelector, provider), provider];
    }
}
class WorkspaceSymbolFeature extends WorkspaceFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let symbolCapabilities = ensure(ensure(capabilites, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
    }
    initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
    }
    registerLanguageProvider(_options) {
        const provider = {
            provideWorkspaceSymbols: (query, token) => {
                const client = this._client;
                const provideWorkspaceSymbols = (query, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then(client.protocol2CodeConverter.asSymbolInformations, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            }
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
    }
}
class CodeActionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const cap = ensure(ensure(capabilites, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    vscode_languageserver_protocol_1.CodeActionKind.Empty,
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideCodeActions: (document, range, context, token) => {
                const client = this._client;
                const _provideCodeActions = (document, range, context, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        context: client.code2ProtocolConverter.asCodeActionContext(context)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {
                        if (values === null) {
                            return undefined;
                        }
                        const result = [];
                        for (let item of values) {
                            if (vscode_languageserver_protocol_1.Command.is(item)) {
                                result.push(client.protocol2CodeConverter.asCommand(item));
                            }
                            else {
                                result.push(client.protocol2CodeConverter.asCodeAction(item));
                            }
                        }
                        return result;
                    }, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)
                    : _provideCodeActions(document, range, context, token);
            }
        };
        return [vscode_1.languages.registerCodeActionsProvider(options.documentSelector, provider, (options.codeActionKinds
                ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) }
                : undefined)), provider];
    }
}
class CodeLensFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'codeLens').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideCodeLenses: (document, token) => {
                const client = this._client;
                const provideCodeLenses = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then(client.protocol2CodeConverter.asCodeLenses, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    const client = this._client;
                    const resolveCodeLens = (codeLens, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then(client.protocol2CodeConverter.asCodeLens, (error) => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, error);
                            return codeLens;
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeLensProvider(options.documentSelector, provider), provider];
    }
}
class DocumentFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'formatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentFormattingEdits: (document, options, token) => {
                const client = this._client;
                const provideDocumentFormattingEdits = (document, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        options: client.code2ProtocolConverter.asFormattingOptions(options)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(options.documentSelector, provider), provider];
    }
}
class DocumentRangeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentRangeFormattingEdits: (document, range, options, token) => {
                const client = this._client;
                const provideDocumentRangeFormattingEdits = (document, range, options, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        options: client.code2ProtocolConverter.asFormattingOptions(options)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                let middleware = client.clientOptions.middleware;
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, provider), provider];
    }
}
class DocumentOnTypeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {
                const client = this._client;
                const provideOnTypeFormattingEdits = (document, position, ch, options, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        ch: ch,
                        options: client.code2ProtocolConverter.asFormattingOptions(options)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideOnTypeFormattingEdits
                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                    : provideOnTypeFormattingEdits(document, position, ch, options, token);
            }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(options.documentSelector, provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
    }
}
class RenameFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let rename = ensure(ensure(capabilites, 'textDocument'), 'rename');
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
            return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideRenameEdits: (document, position, newName, token) => {
                const client = this._client;
                const provideRenameEdits = (document, position, newName, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        newName: newName
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then(client.protocol2CodeConverter.asWorkspaceEdit, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, error);
                        return Promise.reject(new Error(error.message));
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            },
            prepareRename: options.prepareProvider
                ? (document, position, token) => {
                    const client = this._client;
                    const prepareRename = (document, position, token) => {
                        let params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            position: client.code2ProtocolConverter.asPosition(position),
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {
                            if (vscode_languageserver_protocol_1.Range.is(result)) {
                                return client.protocol2CodeConverter.asRange(result);
                            }
                            else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                                return {
                                    range: client.protocol2CodeConverter.asRange(result.range),
                                    placeholder: result.placeholder
                                };
                            }
                            // To cancel the rename vscode API expects a rejected promise.
                            return Promise.reject(new Error(`The element can't be renamed.`));
                        }, (error) => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, error);
                            return Promise.reject(new Error(error.message));
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.prepareRename
                        ? middleware.prepareRename(document, position, token, prepareRename)
                        : prepareRename(document, position, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerRenameProvider(options.documentSelector, provider), provider];
    }
}
class DocumentLinkFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const documentLinkCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentLink');
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
            return;
        }
        this.register(this.messages, { id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentLinks: (document, token) => {
                const client = this._client;
                const provideDocumentLinks = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then(client.protocol2CodeConverter.asDocumentLinks, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, error);
                        return Promise.resolve([]);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? (link, token) => {
                    const client = this._client;
                    let resolveDocumentLink = (link, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then(client.protocol2CodeConverter.asDocumentLink, (error) => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, error);
                            return Promise.resolve(link);
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerDocumentLinkProvider(options.documentSelector, provider), provider];
    }
}
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        let section = this._client.clientOptions.synchronize.configurationSection;
        if (section !== void 0) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    }
    register(_message, data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== void 0) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== void 0 && event !== void 0) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
                return;
            }
        }
        let didChangeConfiguration = (sections) => {
            if (sections === void 0) {
                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
                return;
            }
            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections) });
        };
        let middleware = this.getMiddleware();
        middleware
            ? middleware(sections, didChangeConfiguration)
            : didChangeConfiguration(sections);
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let resource = this._client.clientOptions.workspaceFolder
            ? this._client.clientOptions.workspaceFolder.uri
            : undefined;
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(key, resource);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = config;
            }
        }
        return result;
    }
    getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
            return middleware.workspace.didChangeConfiguration;
        }
        else {
            return undefined;
        }
    }
}
class ExecuteCommandFeature {
    constructor(_client) {
        this._client = _client;
        this._commands = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(_message, data) {
        const client = this._client;
        const middleware = client.clientOptions.middleware;
        const executeCommand = (command, args) => {
            let params = {
                command,
                arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, error);
            });
        };
        if (data.registerOptions.commands) {
            const disposeables = [];
            for (const command of data.registerOptions.commands) {
                disposeables.push(vscode_1.commands.registerCommand(command, (...args) => {
                    return middleware.executeCommand
                        ? middleware.executeCommand(command, args, executeCommand)
                        : executeCommand(command, args);
                }));
            }
            this._commands.set(data.id, disposeables);
        }
    }
    unregister(id) {
        let disposeables = this._commands.get(id);
        if (disposeables) {
            disposeables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach((value) => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class OnReady {
    constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
    }
    get isUsed() {
        return this._used;
    }
    resolve() {
        this._used = true;
        this._resolve();
    }
    reject(error) {
        this._used = true;
        this._reject(error);
    }
}
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._features = [];
        this._method2Message = new Map();
        this._dynamicFeatures = new Map();
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        this._clientOptions = {
            documentSelector: clientOptions.documentSelector || [],
            synchronize: clientOptions.synchronize || {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName || this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding || 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._name),
            middleware: clientOptions.middleware || {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this.state = ClientState.Initial;
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        this._initializeResult = undefined;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
        }
        else {
            this._outputChannel = undefined;
            this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._listeners = undefined;
        this._providers = undefined;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise((resolve, reject) => {
            this._onReadyCallbacks = new OnReady(resolve, reject);
        });
        this._onStop = undefined;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            },
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined);
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    get state() {
        return this._state;
    }
    set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        if (this.state === ClientState.Running) {
            return State.Running;
        }
        else if (this.state === ClientState.Starting) {
            return State.Starting;
        }
        else {
            return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            return this._resolvedConnection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onRequest(type, handler);
        }
        catch (error) {
            this.error(`Registering request handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    sendNotification(type, params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onNotification(type, handler);
        }
        catch (error) {
            this.error(`Registering notification handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onProgress(type, token, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            return this._resolvedConnection.onProgress(type, token, handler);
        }
        catch (error) {
            this.error(`Registering progress handler for token ${token} failed.`, error);
            throw error;
        }
    }
    sendProgress(type, token, value) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendProgress(type, token, value);
        }
        catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
        }
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get protocol2CodeConverter() {
        return this._p2c;
    }
    get code2ProtocolConverter() {
        return this._c2p;
    }
    get onTelemetry() {
        return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get traceOutputChannel() {
        if (this._traceOutputChannel) {
            return this._traceOutputChannel;
        }
        return this.outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    createDefaultErrorHandler() {
        return new DefaultErrorHandler(this._name);
    }
    set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
            this.resolveConnection().then((connection) => {
                connection.trace(this._trace, this._tracer, {
                    sendNotification: false,
                    traceFormat: this._traceFormat
                });
            });
        }, () => {
        });
    }
    data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    }
    info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage();
        }
    }
    warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage();
        }
    }
    error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
            this.showNotificationMessage();
        }
    }
    showNotificationMessage() {
        vscode_1.window.showInformationMessage('A request has failed. See the output for more information.', 'Go to output').then(() => {
            this.outputChannel.show(true);
        });
    }
    logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.traceOutputChannel.appendLine(this.data2String(data));
        }
    }
    logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
            this.traceOutputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);
        }
        else {
            this.traceOutputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);
        }
        if (data) {
            this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
    }
    needsStart() {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
    }
    needsStop() {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
    }
    onReady() {
        return this._onReady;
    }
    isConnectionActive() {
        return this.state === ClientState.Running && !!this._resolvedConnection;
    }
    start() {
        if (this._onReadyCallbacks.isUsed) {
            this._onReady = new Promise((resolve, reject) => {
                this._onReadyCallbacks = new OnReady(resolve, reject);
            });
        }
        this._listeners = [];
        this._providers = [];
        // If we restart then the diagnostics collection is reused.
        if (!this._diagnostics) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        this.state = ClientState.Starting;
        this.resolveConnection().then((connection) => {
            connection.onLogMessage((message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        this.error(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        this.warn(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        this.info(message.message, undefined, false);
                        break;
                    default:
                        this.outputChannel.appendLine(message.message);
                }
            });
            connection.onShowMessage((message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        vscode_1.window.showErrorMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        vscode_1.window.showWarningMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
                let messageFunc;
                switch (params.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                let actions = params.actions || [];
                return messageFunc(params.message, ...actions);
            });
            connection.onTelemetry((data) => {
                this._telemetryEmitter.fire(data);
            });
            connection.listen();
            // Error is handled in the initialize call.
            return this.initialize(connection);
        }).then(undefined, (error) => {
            this.state = ClientState.StartFailed;
            this._onReadyCallbacks.reject(error);
            this.error('Starting client failed', error);
            vscode_1.window.showErrorMessage(`Couldn't start client ${this._name}`);
        });
        return new vscode_1.Disposable(() => {
            if (this.needsStop()) {
                this.stop();
            }
        });
    }
    resolveConnection() {
        if (!this._connectionPromise) {
            this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
    }
    initialize(connection) {
        this.refreshTrace(connection, false);
        let initOption = this._clientOptions.initializationOptions;
        let rootPath = this._clientOptions.workspaceFolder
            ? this._clientOptions.workspaceFolder.uri.fsPath
            : this._clientGetRootPath();
        let initParams = {
            processId: process.pid,
            clientInfo: {
                name: 'vscode',
                version: vscode_1.version
            },
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: null
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
            const token = UUID.generateUuid();
            const part = new progressPart_1.ProgressPart(connection, token);
            initParams.workDoneToken = token;
            return this.doInitialize(connection, initParams).then((result) => {
                part.done();
                return result;
            }, (error) => {
                part.cancel();
                throw error;
            });
        }
        else {
            return this.doInitialize(connection, initParams);
        }
    }
    doInitialize(connection, initParams) {
        return connection.initialize(initParams).then((result) => {
            this._resolvedConnection = connection;
            this._initializeResult = result;
            this.state = ClientState.Running;
            let textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onDiagnostics(params => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            this._onReadyCallbacks.resolve();
            return result;
        }).then(undefined, (error) => {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    this.initialize(connection);
                }
                else {
                    this.stop();
                    this._onReadyCallbacks.reject(error);
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
                vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: 'retry' }).then(item => {
                    if (item && item.id === 'retry') {
                        this.initialize(connection);
                    }
                    else {
                        this.stop();
                        this._onReadyCallbacks.reject(error);
                    }
                });
            }
            else {
                if (error && error.message) {
                    vscode_1.window.showErrorMessage(error.message);
                }
                this.error('Server initialization failed.', error);
                this.stop();
                this._onReadyCallbacks.reject(error);
            }
            throw error;
        });
    }
    _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    stop() {
        this._initializeResult = undefined;
        if (!this._connectionPromise) {
            this.state = ClientState.Stopped;
            return Promise.resolve();
        }
        if (this.state === ClientState.Stopping && this._onStop) {
            return this._onStop;
        }
        this.state = ClientState.Stopping;
        this.cleanUp(false);
        // unhook listeners
        return this._onStop = this.resolveConnection().then(connection => {
            return connection.shutdown().then(() => {
                connection.exit();
                connection.dispose();
                this.state = ClientState.Stopped;
                this.cleanUpChannel();
                this._onStop = undefined;
                this._connectionPromise = undefined;
                this._resolvedConnection = undefined;
            });
        });
    }
    cleanUp(channel = true, diagnostics = true) {
        if (this._listeners) {
            this._listeners.forEach(listener => listener.dispose());
            this._listeners = undefined;
        }
        if (this._providers) {
            this._providers.forEach(provider => provider.dispose());
            this._providers = undefined;
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        for (let handler of this._dynamicFeatures.values()) {
            handler.dispose();
        }
        if (channel) {
            this.cleanUpChannel();
        }
        if (diagnostics && this._diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
    }
    cleanUpChannel() {
        if (this._outputChannel && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
    }
    notifyFileEvent(event) {
        var _a, _b;
        const client = this;
        function didChangeWatchedFile(event) {
            client._fileEvents.push(event);
            client._fileEventDelayer.trigger(() => {
                client.onReady().then(() => {
                    client.resolveConnection().then(connection => {
                        if (client.isConnectionActive()) {
                            client.forceDocumentSync();
                            connection.didChangeWatchedFiles({ changes: client._fileEvents });
                        }
                        client._fileEvents = [];
                    });
                }, (error) => {
                    client.error(`Notify file events failed.`, error);
                });
            });
        }
        const workSpaceMiddleware = (_a = this.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        ((_b = workSpaceMiddleware) === null || _b === void 0 ? void 0 : _b.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);
    }
    forceDocumentSync() {
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method).forceDelivery();
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        let uri = this._p2c.asUri(params.uri);
        let diagnostics = this._p2c.asDiagnostics(params.diagnostics);
        let middleware = this.clientOptions.middleware;
        if (middleware.handleDiagnostics) {
            middleware.handleDiagnostics(uri, diagnostics, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
        }
        else {
            this.setDiagnostics(uri, diagnostics);
        }
    }
    setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(uri, diagnostics);
    }
    createConnection() {
        let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
            this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8').then((transports) => {
            return createConnection(transports.reader, transports.writer, errorHandler, closeHandler);
        });
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._resolvedConnection) {
                this._resolvedConnection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let action = CloseAction.DoNotRestart;
        try {
            action = this._clientOptions.errorHandler.closed();
        }
        catch (error) {
            // Ignore errors coming from the error handler.
        }
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        if (action === CloseAction.DoNotRestart) {
            this.error('Connection to server got closed. Server will not be restarted.');
            this.state = ClientState.Stopped;
            this.cleanUp(false, true);
        }
        else if (action === CloseAction.Restart) {
            this.info('Connection to server got closed. Server will restart.');
            this.cleanUp(false, false);
            this.state = ClientState.Initial;
            this.start();
        }
    }
    handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction.Shutdown) {
            this.error('Connection to server is erroring. Shutting down server.');
            this.stop();
        }
    }
    hookConfigurationChanged(connection) {
        vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
        });
    }
    refreshTrace(connection, sendNotification = false) {
        let config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        });
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature);
        }
    }
    registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
            let messages = feature.messages;
            if (Array.isArray(messages)) {
                for (let message of messages) {
                    this._method2Message.set(message.method, message);
                    this._dynamicFeatures.set(message.method, feature);
                }
            }
            else {
                this._method2Message.set(messages.method, messages);
                this._dynamicFeatures.set(messages.method, feature);
            }
        }
    }
    getFeature(request) {
        return this._dynamicFeatures.get(request);
    }
    registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new CompletionItemFeature(this));
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        let result = {};
        ensure(result, 'workspace').applyEdit = true;
        let workspaceEdit = ensure(ensure(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        let diagnostics = ensure(ensure(result, 'textDocument'), 'publishDiagnostics');
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    handleRegistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (let registration of params.registrations) {
                const feature = this._dynamicFeatures.get(registration.method);
                if (!feature) {
                    reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
                    return;
                }
                const options = registration.registerOptions || {};
                options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
                const data = {
                    id: registration.id,
                    registerOptions: options
                };
                feature.register(this._method2Message.get(registration.method), data);
            }
            resolve();
        });
    }
    handleUnregistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (let unregistration of params.unregisterations) {
                const feature = this._dynamicFeatures.get(unregistration.method);
                if (!feature) {
                    reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
                    return;
                }
                feature.unregister(unregistration.id);
            }
            resolve();
        });
    }
    handleApplyWorkspaceEdit(params) {
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    let textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then((value) => { return { applied: value }; }));
    }
    logFailedRequest(type, error) {
        // If we get a request cancel or a content modified don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError && (error.code === vscode_languageserver_protocol_1.ErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.ErrorCodes.ContentModified)) {
            return;
        }
        this.error(`Request ${type.method} failed.`, error);
    }
}
exports.BaseLanguageClient = BaseLanguageClient;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../typings/thenable.d.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const Is = __webpack_require__(53);
const messages_1 = __webpack_require__(161);
exports.RequestType = messages_1.RequestType;
exports.RequestType0 = messages_1.RequestType0;
exports.RequestType1 = messages_1.RequestType1;
exports.RequestType2 = messages_1.RequestType2;
exports.RequestType3 = messages_1.RequestType3;
exports.RequestType4 = messages_1.RequestType4;
exports.RequestType5 = messages_1.RequestType5;
exports.RequestType6 = messages_1.RequestType6;
exports.RequestType7 = messages_1.RequestType7;
exports.RequestType8 = messages_1.RequestType8;
exports.RequestType9 = messages_1.RequestType9;
exports.ResponseError = messages_1.ResponseError;
exports.ErrorCodes = messages_1.ErrorCodes;
exports.NotificationType = messages_1.NotificationType;
exports.NotificationType0 = messages_1.NotificationType0;
exports.NotificationType1 = messages_1.NotificationType1;
exports.NotificationType2 = messages_1.NotificationType2;
exports.NotificationType3 = messages_1.NotificationType3;
exports.NotificationType4 = messages_1.NotificationType4;
exports.NotificationType5 = messages_1.NotificationType5;
exports.NotificationType6 = messages_1.NotificationType6;
exports.NotificationType7 = messages_1.NotificationType7;
exports.NotificationType8 = messages_1.NotificationType8;
exports.NotificationType9 = messages_1.NotificationType9;
const messageReader_1 = __webpack_require__(102);
exports.MessageReader = messageReader_1.MessageReader;
exports.StreamMessageReader = messageReader_1.StreamMessageReader;
exports.IPCMessageReader = messageReader_1.IPCMessageReader;
exports.SocketMessageReader = messageReader_1.SocketMessageReader;
const messageWriter_1 = __webpack_require__(103);
exports.MessageWriter = messageWriter_1.MessageWriter;
exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
exports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
const events_1 = __webpack_require__(64);
exports.Disposable = events_1.Disposable;
exports.Event = events_1.Event;
exports.Emitter = events_1.Emitter;
const cancellation_1 = __webpack_require__(162);
exports.CancellationTokenSource = cancellation_1.CancellationTokenSource;
exports.CancellationToken = cancellation_1.CancellationToken;
const linkedMap_1 = __webpack_require__(163);
__export(__webpack_require__(164));
__export(__webpack_require__(165));
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    let notificationHandlers = Object.create(null);
    let progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let unhandledProgressEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        let message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    let callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                let key = createRequestQueueKey(message.params.id);
                let toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== void 0 || response.result !== void 0)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === void 0) {
                result = null;
            }
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            let cancellationSource = new cancellation_1.CancellationTokenSource();
            let tokenKey = String(requestMessage.id);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    handlerResult = requestHandler
                        ? requestHandler(cancellationSource.token)
                        : starRequestHandler(requestMessage.method, cancellationSource.token);
                }
                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
                    handlerResult = requestHandler
                        ? requestHandler(...requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
                }
                else {
                    handlerResult = requestHandler
                        ? requestHandler(requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                let promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            let key = String(responseMessage.id);
            let responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        let error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== void 0) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                let id = params.id;
                let source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            let element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
                }
                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
                }
                else {
                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        let responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            let key = String(responseMessage.id);
            let responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === void 0) {
            return null;
        }
        else {
            return param;
        }
    }
    function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = null;
                break;
            case 1:
                result = undefinedToNull(params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    let connection = {
        sendNotification: (type, ...params) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        messageParams = params[0];
                        break;
                    default:
                        messageParams = params;
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            let notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    notificationHandlers[type.method] = { type, handler };
                }
            }
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...params) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        // The cancellation token is optional so it can also be undefined.
                        if (cancellation_1.CancellationToken.is(params[0])) {
                            messageParams = null;
                            token = params[0];
                        }
                        else {
                            messageParams = undefinedToNull(params[0]);
                        }
                        break;
                    default:
                        const last = params.length - 1;
                        if (cancellation_1.CancellationToken.is(params[last])) {
                            token = params[last];
                            if (params.length === 2) {
                                messageParams = undefinedToNull(params[0]);
                            }
                            else {
                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));
                            }
                        }
                        else {
                            messageParams = params.map(value => undefinedToNull(value));
                        }
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
                let numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            let id = sequenceNumber++;
            let result = new Promise((resolve, reject) => {
                let requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            if (token) {
                token.onCancellationRequested(() => {
                    connection.sendNotification(CancelNotification.type, { id });
                });
            }
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starRequestHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    requestHandlers[type] = { type: undefined, handler };
                }
                else {
                    requestHandlers[type.method] = { type, handler };
                }
            }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            let error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
}
function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
}
function createMessageConnection(input, output, logger, strategy) {
    if (!logger) {
        logger = exports.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger, strategy);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),
/* 25 */
/***/ (function(module, exports) {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),
/* 26 */
/***/ (function(module, exports) {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((options, k) => {
    options[k] = true
    return options
  }, {})
module.exports = parseOptions


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(11)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(26)
const {re, t} = __webpack_require__(16)
const cmp = __webpack_require__(48)
const debug = __webpack_require__(25)
const SemVer = __webpack_require__(9)
const Range = __webpack_require__(12)


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(12)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitFor = exports.resolvedPromise = void 0;
exports.resolvedPromise = Promise.resolve(true);
function waitFor(action, checkEveryMilliseconds = 100, tryForMilliseconds = 10000, token) {
    return __awaiter(this, void 0, void 0, function* () {
        let timeRemaining = tryForMilliseconds;
        while (timeRemaining > 0 && !(token && token.isCancellationRequested)) {
            const res = yield action();
            if (res)
                return res;
            yield new Promise((resolve) => setTimeout(resolve, checkEveryMilliseconds));
            timeRemaining -= checkEveryMilliseconds;
        }
    });
}
exports.waitFor = waitFor;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(11)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(11)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(11)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(11)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const Comparator = __webpack_require__(28)
const {ANY} = Comparator
const Range = __webpack_require__(12)
const satisfies = __webpack_require__(29)
const gt = __webpack_require__(27)
const lt = __webpack_require__(35)
const lte = __webpack_require__(37)
const gte = __webpack_require__(36)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deactivate = exports.activate = exports.ringLog = exports.SERVICE_CONTEXT_PREFIX = exports.SERVICE_EXTENSION_CONTEXT_PREFIX = exports.FLUTTER_SUPPORTS_ATTACH = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const dart_1 = __webpack_require__(72);
const flutter_1 = __webpack_require__(59);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const fetch_1 = __webpack_require__(146);
const logging_1 = __webpack_require__(13);
const api_1 = __webpack_require__(147);
const symbols_1 = __webpack_require__(148);
const coordindator_1 = __webpack_require__(149);
const test_model_1 = __webpack_require__(61);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const device_manager_1 = __webpack_require__(150);
const extension_utils_1 = __webpack_require__(20);
const uri_handler_1 = __webpack_require__(151);
const utils_2 = __webpack_require__(5);
const workspace_1 = __webpack_require__(153);
const analyzer_das_1 = __webpack_require__(50);
const analyzer_lsp_1 = __webpack_require__(159);
const analyzer_status_reporter_1 = __webpack_require__(196);
const file_change_handler_1 = __webpack_require__(197);
const file_change_warnings_1 = __webpack_require__(198);
const analytics_1 = __webpack_require__(199);
const api_2 = __webpack_require__(201);
const flutter_dartpad_samples_1 = __webpack_require__(202);
const flutter_dartpad_samples_lsp_1 = __webpack_require__(203);
const main_code_lens_provider_1 = __webpack_require__(204);
const main_code_lens_provider_lsp_1 = __webpack_require__(205);
const test_code_lens_provider_1 = __webpack_require__(206);
const test_code_lens_provider_lsp_1 = __webpack_require__(207);
const analyzer_1 = __webpack_require__(208);
const debug_1 = __webpack_require__(106);
const edit_1 = __webpack_require__(214);
const edit_das_1 = __webpack_require__(107);
const edit_lsp_1 = __webpack_require__(215);
const flutter_outline_1 = __webpack_require__(128);
const go_to_super_1 = __webpack_require__(216);
const logging_2 = __webpack_require__(130);
const open_in_other_editors_1 = __webpack_require__(217);
const refactor_1 = __webpack_require__(218);
const sdk_1 = __webpack_require__(132);
const test_1 = __webpack_require__(224);
const type_hierarchy_1 = __webpack_require__(225);
const config_1 = __webpack_require__(10);
const dart_task_provider_1 = __webpack_require__(134);
const closing_labels_decorations_1 = __webpack_require__(135);
const flutter_color_decorations_1 = __webpack_require__(226);
const flutter_icon_decorations_das_1 = __webpack_require__(229);
const flutter_icon_decorations_lsp_1 = __webpack_require__(231);
const flutter_ui_guides_decorations_das_1 = __webpack_require__(232);
const flutter_ui_guides_decorations_lsp_1 = __webpack_require__(234);
const experiments_1 = __webpack_require__(235);
const daemon_message_handler_1 = __webpack_require__(236);
const flutter_daemon_1 = __webpack_require__(237);
const flutter_outline_view_1 = __webpack_require__(238);
const flutter_task_provider_1 = __webpack_require__(240);
const hot_reload_save_handler_1 = __webpack_require__(241);
const analyzer_status_reporter_2 = __webpack_require__(242);
const closing_labels_decorations_2 = __webpack_require__(243);
const go_to_super_2 = __webpack_require__(244);
const test_discoverer_1 = __webpack_require__(245);
const assist_code_action_provider_1 = __webpack_require__(246);
const dart_completion_item_provider_1 = __webpack_require__(247);
const dart_diagnostic_provider_1 = __webpack_require__(110);
const dart_document_symbol_provider_1 = __webpack_require__(248);
const dart_folding_provider_1 = __webpack_require__(249);
const dart_formatting_edit_provider_1 = __webpack_require__(250);
const dart_highlighting_provider_1 = __webpack_require__(255);
const dart_hover_provider_1 = __webpack_require__(256);
const dart_implementation_provider_1 = __webpack_require__(257);
const dart_language_configuration_1 = __webpack_require__(258);
const dart_reference_provider_1 = __webpack_require__(259);
const dart_rename_provider_1 = __webpack_require__(260);
const dart_signature_help_provider_1 = __webpack_require__(261);
const dart_workspace_symbol_provider_1 = __webpack_require__(262);
const debug_adapter_descriptor_factory_1 = __webpack_require__(263);
const debug_config_provider_1 = __webpack_require__(265);
const fix_code_action_provider_1 = __webpack_require__(267);
const ignore_lint_code_action_provider_1 = __webpack_require__(268);
const legacy_dart_workspace_symbol_provider_1 = __webpack_require__(269);
const ranking_code_action_provider_1 = __webpack_require__(109);
const refactor_code_action_provider_1 = __webpack_require__(270);
const snippet_completion_item_provider_1 = __webpack_require__(271);
const source_code_action_provider_1 = __webpack_require__(272);
const global_1 = __webpack_require__(273);
const status_bar_version_tracker_1 = __webpack_require__(274);
const update_check_1 = __webpack_require__(275);
const utils_3 = __webpack_require__(100);
const link_provider_1 = __webpack_require__(276);
const user_prompts_1 = __webpack_require__(277);
const util = __webpack_require__(6);
const log_1 = __webpack_require__(131);
const processes_1 = __webpack_require__(15);
const packages_view_1 = __webpack_require__(278);
const test_view_1 = __webpack_require__(279);
const DART_MODE = { language: "dart", scheme: "file" };
const HTML_MODE = { language: "html", scheme: "file" };
const DART_PROJECT_LOADED = "dart-code:dartProjectLoaded";
// TODO: Define what this means better. Some commands a general Flutter (eg. Hot
// Reload) and some are more specific (eg. Attach).
const FLUTTER_PROJECT_LOADED = "dart-code:anyFlutterProjectLoaded";
const FLUTTER_MOBILE_PROJECT_LOADED = "dart-code:flutterMobileProjectLoaded";
const WEB_PROJECT_LOADED = "dart-code:WebProjectLoaded";
exports.FLUTTER_SUPPORTS_ATTACH = "dart-code:flutterSupportsAttach";
const DART_PLATFORM_NAME = "dart-code:dartPlatformName";
exports.SERVICE_EXTENSION_CONTEXT_PREFIX = "dart-code:serviceExtension.";
exports.SERVICE_CONTEXT_PREFIX = "dart-code:service.";
let analyzer;
let flutterDaemon;
let deviceManager;
const dartCapabilities = dart_1.DartCapabilities.empty;
const flutterCapabilities = flutter_1.FlutterCapabilities.empty;
let analysisRoots = [];
let analytics;
let showTodos;
let previousSettings;
let experiments;
const loggers = [];
let ringLogger;
const logger = new logging_1.EmittingLogger();
// Keep a running in-memory buffer of last 200 log events we can give to the
// user when something crashed even if they don't have disk-logging enabled.
exports.ringLog = new logging_1.RingLog(200);
function activate(context, isRestart = false) {
    return __awaiter(this, void 0, void 0, function* () {
        // Ring logger is only set up once and presist over silent restarts.
        if (!ringLogger)
            ringLogger = logger.onLog((message) => exports.ringLog.log(message.toLine(500)));
        if (extension_utils_1.isDevExtension)
            context.subscriptions.push(logging_1.logToConsole(logger));
        vs.commands.executeCommand("setContext", constants_1.IS_RUNNING_LOCALLY_CONTEXT, utils_2.isRunningLocally);
        buildLogHeaders();
        setupLog(log_1.getExtensionLogPath(), enums_1.LogCategory.General);
        const extContext = workspace_1.Context.for(context);
        const webClient = new fetch_1.WebClient(extension_utils_1.extensionVersion);
        util.logTime("Code called activate");
        // Wire up a reload command that will re-initialise everything.
        context.subscriptions.push(vs.commands.registerCommand("_dart.reloadExtension", () => __awaiter(this, void 0, void 0, function* () {
            logger.info("Performing silent extension reload...");
            yield deactivate(true);
            const toDispose = context.subscriptions.slice();
            context.subscriptions.length = 0;
            for (const sub of toDispose) {
                try {
                    sub.dispose();
                }
                catch (e) {
                    logger.error(e);
                }
            }
            yield activate(context, true);
            logger.info("Done!");
        })));
        showTodos = config_1.config.showTodos;
        previousSettings = getSettingsThatRequireRestart();
        const extensionStartTime = new Date();
        util.logTime();
        const sdkUtils = new utils_3.SdkUtils(logger);
        const isUsingLsp = !!(config_1.config.previewLsp || process.env.DART_CODE_FORCE_LSP);
        const workspaceContextUnverified = yield sdkUtils.scanWorkspace(isUsingLsp);
        util.logTime("initWorkspace");
        // Create log headers and set up all other log files.
        buildLogHeaders(logger, workspaceContextUnverified);
        setupLog(config_1.config.analyzerLogFile, enums_1.LogCategory.Analyzer);
        setupLog(config_1.config.flutterDaemonLogFile, enums_1.LogCategory.FlutterDaemon);
        setupLog(config_1.config.devToolsLogFile, enums_1.LogCategory.DevTools);
        analytics = new analytics_1.Analytics(logger, workspaceContextUnverified);
        if (!workspaceContextUnverified.sdks.dart || (workspaceContextUnverified.hasAnyFlutterProjects && !workspaceContextUnverified.sdks.flutter)) {
            // Don't set anything else up; we can't work like this!
            return sdkUtils.handleMissingSdks(context, analytics, workspaceContextUnverified);
        }
        const workspaceContext = workspaceContextUnverified;
        const sdks = workspaceContext.sdks;
        if (sdks.flutterVersion) {
            flutterCapabilities.version = sdks.flutterVersion;
            analytics.flutterSdkVersion = sdks.flutterVersion;
        }
        try {
            if (!experiments)
                experiments = experiments_1.getExperiments(logger, workspaceContext, extContext);
        }
        catch (e) {
            logger.error(e);
        }
        vs.commands.executeCommand("setContext", constants_1.IS_LSP_CONTEXT, workspaceContext.config.useLsp);
        // Show the SDK version in the status bar.
        if (sdks.dartVersion) {
            dartCapabilities.version = sdks.dartVersion;
            analytics.sdkVersion = sdks.dartVersion;
            // tslint:disable-next-line: no-floating-promises
            update_check_1.checkForStandardDartSdkUpdates(logger, workspaceContext);
            context.subscriptions.push(new status_bar_version_tracker_1.StatusBarVersionTracker(workspaceContext, isUsingLsp));
        }
        vs.commands.executeCommand("setContext", constants_1.PUB_OUTDATED_SUPPORTED_CONTEXT, dartCapabilities.supportsPubOutdated);
        const pubApi = new api_1.PubApi(webClient);
        const pubGlobal = new global_1.PubGlobal(logger, extContext, sdks, pubApi);
        const sdkCommands = new sdk_1.SdkCommands(logger, context, workspaceContext, sdkUtils, pubGlobal, dartCapabilities, flutterCapabilities, deviceManager);
        const debugCommands = new debug_1.DebugCommands(logger, extContext, workspaceContext, analytics, pubGlobal);
        // Handle new projects before creating the analyer to avoid a few issues with
        // showing errors while packages are fetched, plus issues like
        // https://github.com/Dart-Code/Dart-Code/issues/2793 which occur if the analyzer
        // is created too early.
        if (!isRestart)
            yield user_prompts_1.handleNewProjects(logger, extContext);
        // Fire up the analyzer process.
        const analyzerStartTime = new Date();
        analyzer = isUsingLsp ? new analyzer_lsp_1.LspAnalyzer(logger, sdks, dartCapabilities, workspaceContext) : new analyzer_das_1.DasAnalyzer(logger, analytics, sdks, dartCapabilities, workspaceContext);
        const lspAnalyzer = isUsingLsp ? analyzer : undefined;
        const dasAnalyzer = isUsingLsp ? undefined : analyzer;
        const dasClient = dasAnalyzer ? dasAnalyzer.client : undefined;
        const lspClient = dasClient ? undefined : analyzer.client;
        context.subscriptions.push(analyzer);
        // tslint:disable-next-line: no-floating-promises
        analyzer.onReady.then(() => {
            const analyzerEndTime = new Date();
            analytics.logAnalyzerStartupTime(analyzerEndTime.getTime() - analyzerStartTime.getTime());
        });
        // Log analysis server first analysis completion time when it completes.
        let analysisStartTime;
        const analysisCompleteEvents = analyzer.onAnalysisStatusChange.listen((status) => {
            // Analysis started for the first time.
            if (status.isAnalyzing && !analysisStartTime)
                analysisStartTime = new Date();
            // Analysis ends for the first time.
            if (!status.isAnalyzing && analysisStartTime) {
                const analysisEndTime = new Date();
                analytics.logAnalyzerFirstAnalysisTime(analysisEndTime.getTime() - analysisStartTime.getTime());
                analysisCompleteEvents.dispose();
            }
        });
        // Set up providers.
        // TODO: Do we need to push all these to subscriptions?!
        if (lspClient)
            context.subscriptions.push(new closing_labels_decorations_2.LspClosingLabelsDecorations(lspClient));
        const completionItemProvider = isUsingLsp || !dasClient ? undefined : new dart_completion_item_provider_1.DartCompletionItemProvider(logger, dasClient);
        const referenceProvider = isUsingLsp || !dasClient ? undefined : new dart_reference_provider_1.DartReferenceProvider(dasClient);
        const activeFileFilters = [DART_MODE];
        // Analyze Angular2 templates, requires the angular_analyzer_plugin.
        if (config_1.config.analyzeAngularTemplates) {
            activeFileFilters.push(HTML_MODE);
        }
        // Analyze files supported by plugins.
        for (const ext of utils_1.uniq(config_1.config.additionalAnalyzerFileExtensions)) {
            // We can't check that these don't overlap with the existing language filters
            // because vs.languages.match() won't take an extension, only a TextDocument.
            // So we'll just manually exclude file names we know for sure overlap with them.
            if (ext === "dart" || (config_1.config.analyzeAngularTemplates && (ext === "htm" || ext === "html")))
                continue;
            activeFileFilters.push({ scheme: "file", pattern: `**/*.${ext}` });
        }
        // This is registered with VS Code further down, so it's metadata can be collected from all
        // registered providers.
        const rankingCodeActionProvider = new ranking_code_action_provider_1.RankingCodeActionProvider();
        const triggerCharacters = ".(${'\"/\\".split("");
        if (!isUsingLsp && dasClient) {
            context.subscriptions.push(vs.languages.registerHoverProvider(activeFileFilters, new dart_hover_provider_1.DartHoverProvider(logger, dasClient)));
            const formattingEditProvider = new dart_formatting_edit_provider_1.DartFormattingEditProvider(logger, dasClient, extContext);
            context.subscriptions.push(formattingEditProvider);
            formattingEditProvider.registerDocumentFormatter(activeFileFilters);
            // Only for Dart.
            formattingEditProvider.registerTypingFormatter(DART_MODE, "}", ";");
        }
        if (completionItemProvider)
            context.subscriptions.push(vs.languages.registerCompletionItemProvider(activeFileFilters, completionItemProvider, ...triggerCharacters));
        if (referenceProvider) {
            context.subscriptions.push(vs.languages.registerDefinitionProvider(activeFileFilters, referenceProvider));
            context.subscriptions.push(vs.languages.registerReferenceProvider(activeFileFilters, referenceProvider));
        }
        let renameProvider;
        if (!isUsingLsp && dasClient && dasAnalyzer) {
            context.subscriptions.push(vs.languages.registerDocumentHighlightProvider(activeFileFilters, new dart_highlighting_provider_1.DartDocumentHighlightProvider(dasAnalyzer.fileTracker)));
            rankingCodeActionProvider.registerProvider(new assist_code_action_provider_1.AssistCodeActionProvider(logger, activeFileFilters, dasClient));
            rankingCodeActionProvider.registerProvider(new fix_code_action_provider_1.FixCodeActionProvider(logger, activeFileFilters, dasClient));
            rankingCodeActionProvider.registerProvider(new refactor_code_action_provider_1.RefactorCodeActionProvider(activeFileFilters, dasClient));
            renameProvider = new dart_rename_provider_1.DartRenameProvider(dasClient);
            context.subscriptions.push(vs.languages.registerRenameProvider(activeFileFilters, renameProvider));
            // Dart only.
            context.subscriptions.push(vs.languages.registerCodeActionsProvider(DART_MODE, new source_code_action_provider_1.SourceCodeActionProvider(), source_code_action_provider_1.SourceCodeActionProvider.metadata));
            context.subscriptions.push(vs.languages.registerImplementationProvider(DART_MODE, new dart_implementation_provider_1.DartImplementationProvider(dasAnalyzer)));
            if (config_1.config.showMainCodeLens) {
                const codeLensProvider = new main_code_lens_provider_1.MainCodeLensProvider(logger, dasAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(DART_MODE, codeLensProvider));
            }
            if (config_1.config.showTestCodeLens) {
                const codeLensProvider = new test_code_lens_provider_1.TestCodeLensProvider(logger, dasAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(DART_MODE, codeLensProvider));
            }
            if (config_1.config.showDartPadSampleCodeLens && sdks.flutter) {
                const codeLensProvider = new flutter_dartpad_samples_1.FlutterDartPadSamplesCodeLensProvider(logger, dasAnalyzer, sdks);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(DART_MODE, codeLensProvider));
            }
        }
        if (isUsingLsp && lspClient && lspAnalyzer) {
            if (config_1.config.showMainCodeLens) {
                const codeLensProvider = new main_code_lens_provider_lsp_1.LspMainCodeLensProvider(logger, lspAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(DART_MODE, codeLensProvider));
            }
            if (config_1.config.showTestCodeLens) {
                const codeLensProvider = new test_code_lens_provider_lsp_1.LspTestCodeLensProvider(logger, lspAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(DART_MODE, codeLensProvider));
            }
            if (config_1.config.showDartPadSampleCodeLens && sdks.flutter) {
                const codeLensProvider = new flutter_dartpad_samples_lsp_1.LspFlutterDartPadSamplesCodeLensProvider(logger, lspAnalyzer, sdks);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(DART_MODE, codeLensProvider));
            }
        }
        rankingCodeActionProvider.registerProvider(new ignore_lint_code_action_provider_1.IgnoreLintCodeActionProvider(activeFileFilters));
        // Register the ranking provider from VS Code now that it has all of its delegates.
        context.subscriptions.push(vs.languages.registerCodeActionsProvider(activeFileFilters, rankingCodeActionProvider, rankingCodeActionProvider.metadata));
        // Task handlers.
        context.subscriptions.push(vs.tasks.registerTaskProvider(dart_task_provider_1.DartTaskProvider.type, new dart_task_provider_1.DartTaskProvider(logger, context, sdks, dartCapabilities)));
        context.subscriptions.push(vs.tasks.registerTaskProvider(flutter_task_provider_1.FlutterTaskProvider.type, new flutter_task_provider_1.FlutterTaskProvider(logger, context, sdks, flutterCapabilities)));
        // Snippets are language-specific
        context.subscriptions.push(vs.languages.registerCompletionItemProvider(DART_MODE, new snippet_completion_item_provider_1.SnippetCompletionItemProvider("snippets/dart.json", () => true)));
        context.subscriptions.push(vs.languages.registerCompletionItemProvider(DART_MODE, new snippet_completion_item_provider_1.SnippetCompletionItemProvider("snippets/flutter.json", (uri) => util.isInsideFlutterProject(uri))));
        context.subscriptions.push(vs.languages.setLanguageConfiguration(DART_MODE.language, new dart_language_configuration_1.DartLanguageConfiguration()));
        // TODO: Push the differences into the Analyzer classes so we can have one reporter.
        if (lspClient)
            // tslint:disable-next-line: no-unused-expression
            new analyzer_status_reporter_2.LspAnalyzerStatusReporter(analyzer);
        if (dasClient)
            // tslint:disable-next-line: no-unused-expression
            new analyzer_status_reporter_1.AnalyzerStatusReporter(logger, dasClient, workspaceContext, analytics);
        context.subscriptions.push(new file_change_warnings_1.FileChangeWarnings());
        // Set up diagnostics.
        if (!isUsingLsp && dasClient) {
            const diagnostics = vs.languages.createDiagnosticCollection("dart");
            context.subscriptions.push(diagnostics);
            const diagnosticsProvider = new dart_diagnostic_provider_1.DartDiagnosticProvider(dasClient, diagnostics);
            // TODO: Currently calculating analysis roots requires the version to check if
            // we need the package workaround. In future if we stop supporting server < 1.20.1 we
            // can unwrap this call so that it'll start sooner.
            const serverConnected = dasClient.registerForServerConnected((sc) => {
                serverConnected.dispose();
                if (vs.workspace.workspaceFolders)
                    recalculateAnalysisRoots();
                // Set up a handler to warn the user if they open a Dart file and we
                // never set up the analyzer
                let hasWarnedAboutLooseDartFiles = false;
                const handleOpenFile = (d) => {
                    if (!hasWarnedAboutLooseDartFiles && d.languageId === "dart" && d.uri.scheme === "file" && analysisRoots.length === 0) {
                        hasWarnedAboutLooseDartFiles = true;
                        vs.window.showWarningMessage("For full Dart language support, please open a folder containing your Dart files instead of individual loose files");
                    }
                };
                context.subscriptions.push(vs.workspace.onDidOpenTextDocument((d) => handleOpenFile(d)));
                // Fire for editors already visible at the time this code runs.
                vs.window.visibleTextEditors.forEach((e) => handleOpenFile(e.document));
            });
            // Hook editor changes to send updated contents to analyzer.
            context.subscriptions.push(new file_change_handler_1.FileChangeHandler(dasClient));
        }
        // Fire up Flutter daemon if required.
        if (workspaceContext.hasAnyFlutterMobileProjects && sdks.flutter) {
            flutterDaemon = new flutter_daemon_1.FlutterDaemon(logger, workspaceContext, flutterCapabilities);
            deviceManager = new device_manager_1.FlutterDeviceManager(logger, flutterDaemon, config_1.config);
            context.subscriptions.push(deviceManager);
            context.subscriptions.push(flutterDaemon);
            daemon_message_handler_1.setUpDaemonMessageHandler(logger, context, flutterDaemon);
            context.subscriptions.push(vs.commands.registerCommand("flutter.selectDevice", deviceManager.showDevicePicker, deviceManager));
            context.subscriptions.push(vs.commands.registerCommand("flutter.launchEmulator", deviceManager.promptForAndLaunchEmulator, deviceManager));
        }
        util.logTime("All other stuff before debugger..");
        const testTreeModel = new test_model_1.TestTreeModel();
        const testCoordinator = new coordindator_1.TestSessionCoordindator(logger, testTreeModel);
        const analyzerCommands = new analyzer_1.AnalyzerCommands(context, logger, analyzer, analytics);
        // Set up debug stuff.
        const debugProvider = new debug_config_provider_1.DebugConfigProvider(logger, workspaceContext, analytics, pubGlobal, testTreeModel, flutterDaemon, deviceManager, dartCapabilities, flutterCapabilities);
        context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", debugProvider));
        context.subscriptions.push(vs.debug.registerDebugAdapterDescriptorFactory("dart", new debug_adapter_descriptor_factory_1.DartDebugAdapterDescriptorFactory(logger, context)));
        // Also the providers for the initial configs.
        if (vs.DebugConfigurationProviderTriggerKind) { // Temporary workaround for GitPod/Theia not having this enum.
            context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", new debug_config_provider_1.InitialLaunchJsonDebugConfigProvider(logger), vs.DebugConfigurationProviderTriggerKind.Initial));
            context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", new debug_config_provider_1.DynamicDebugConfigProvider(logger), vs.DebugConfigurationProviderTriggerKind.Dynamic));
        }
        if (config_1.config.flutterGutterIcons)
            context.subscriptions.push(new flutter_color_decorations_1.FlutterColorDecorations(logger, path.join(context.globalStoragePath, "flutterColors")));
        if (!isUsingLsp && dasClient && dasAnalyzer) {
            if (config_1.config.previewFlutterUiGuides)
                context.subscriptions.push(new flutter_ui_guides_decorations_das_1.FlutterUiGuideDecorationsDas(dasAnalyzer));
            if (config_1.config.flutterGutterIcons)
                context.subscriptions.push(new flutter_icon_decorations_das_1.FlutterIconDecorationsDas(logger, dasAnalyzer));
            // Setup that requires server version/capabilities.
            const connectedSetup = dasClient.registerForServerConnected((sc) => __awaiter(this, void 0, void 0, function* () {
                connectedSetup.dispose();
                context.subscriptions.push(new refactor_1.RefactorCommands(logger, context, dasClient));
                if (dasClient.capabilities.supportsClosingLabels && config_1.config.closingLabels) {
                    context.subscriptions.push(new closing_labels_decorations_1.ClosingLabelsDecorations(dasClient));
                }
                if (dasClient.capabilities.supportsGetDeclerations) {
                    context.subscriptions.push(vs.languages.registerWorkspaceSymbolProvider(new dart_workspace_symbol_provider_1.DartWorkspaceSymbolProvider(logger, dasClient)));
                }
                else {
                    context.subscriptions.push(vs.languages.registerWorkspaceSymbolProvider(new legacy_dart_workspace_symbol_provider_1.LegacyDartWorkspaceSymbolProvider(logger, dasClient)));
                }
                if (dasClient.capabilities.supportsCustomFolding && config_1.config.analysisServerFolding)
                    context.subscriptions.push(vs.languages.registerFoldingRangeProvider(activeFileFilters, new dart_folding_provider_1.DartFoldingProvider(dasAnalyzer)));
                if (dasClient.capabilities.supportsGetSignature)
                    context.subscriptions.push(vs.languages.registerSignatureHelpProvider(DART_MODE, new dart_signature_help_provider_1.DartSignatureHelpProvider(dasClient), ...(config_1.config.triggerSignatureHelpAutomatically ? ["(", ","] : [])));
                const documentSymbolProvider = new dart_document_symbol_provider_1.DartDocumentSymbolProvider(logger, dasAnalyzer.fileTracker);
                activeFileFilters.forEach((filter) => {
                    context.subscriptions.push(vs.languages.registerDocumentSymbolProvider(filter, documentSymbolProvider));
                });
                // Set up completions for unimported items.
                if (dasClient.capabilities.supportsAvailableSuggestions && config_1.config.autoImportCompletions) {
                    yield dasClient.completionSetSubscriptions({
                        subscriptions: ["AVAILABLE_SUGGESTION_SETS"],
                    });
                }
            }));
        }
        else if (isUsingLsp && lspClient && lspAnalyzer) {
            if (config_1.config.previewFlutterUiGuides)
                context.subscriptions.push(new flutter_ui_guides_decorations_lsp_1.FlutterUiGuideDecorationsLsp(lspAnalyzer));
            if (config_1.config.flutterGutterIcons)
                context.subscriptions.push(new flutter_icon_decorations_lsp_1.FlutterIconDecorationsLsp(logger, lspAnalyzer));
        }
        // Handle config changes so we can reanalyze if necessary.
        context.subscriptions.push(vs.workspace.onDidChangeConfiguration(() => handleConfigurationChange(sdks)));
        // Wire up handling of Hot Reload on Save.
        context.subscriptions.push(new hot_reload_save_handler_1.HotReloadOnSaveHandler(debugCommands, flutterCapabilities));
        // Register URI handler.
        context.subscriptions.push(vs.window.registerUriHandler(new uri_handler_1.DartUriHandler(flutterCapabilities)));
        context.subscriptions.push(new logging_2.LoggingCommands(logger, context.logPath));
        context.subscriptions.push(new open_in_other_editors_1.OpenInOtherEditorCommands(logger, sdks));
        if (dasAnalyzer)
            context.subscriptions.push(new test_1.DasTestCommands(logger, workspaceContext, dasAnalyzer.fileTracker));
        if (lspAnalyzer)
            context.subscriptions.push(new test_1.LspTestCommands(logger, workspaceContext, lspAnalyzer.fileTracker));
        if (lspClient && lspAnalyzer) {
            // TODO: LSP equivs of the others...
            // Refactors
            // TypeHierarchyCommand
            context.subscriptions.push(new go_to_super_2.LspGoToSuperCommand(lspAnalyzer));
        }
        // Set up commands for Dart editors.
        context.subscriptions.push(new edit_1.EditCommands());
        if (dasClient && dasAnalyzer) {
            context.subscriptions.push(new edit_das_1.DasEditCommands(logger, context, dasClient));
            context.subscriptions.push(new type_hierarchy_1.TypeHierarchyCommand(logger, dasClient));
            context.subscriptions.push(new go_to_super_1.GoToSuperCommand(dasAnalyzer));
        }
        else if (lspClient && lspAnalyzer) {
            context.subscriptions.push(new edit_lsp_1.LspEditCommands(lspAnalyzer));
        }
        if (vs.window.registerTerminalLinkProvider) // Temporary workaround for GitPod/Theia not having this.
            context.subscriptions.push(vs.window.registerTerminalLinkProvider(new link_provider_1.DartTerminalLinkProvider(logger, workspaceContext)));
        // Register our view providers.
        const dartPackagesProvider = new packages_view_1.DartPackagesProvider(logger, workspaceContext);
        const packagesTreeView = vs.window.createTreeView("dartPackages", { treeDataProvider: dartPackagesProvider });
        context.subscriptions.push(packagesTreeView);
        if (lspAnalyzer)
            context.subscriptions.push(new test_discoverer_1.TestDiscoverer(logger, lspAnalyzer.fileTracker, testTreeModel));
        const testTreeProvider = new test_view_1.TestResultsProvider(testTreeModel, testCoordinator);
        const testTreeView = vs.window.createTreeView("dartTestTree", { treeDataProvider: testTreeProvider });
        const tryReveal = (node) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield testTreeView.reveal(node);
            }
            catch (_a) {
                // Reveal can fail if something else triggers an update to the tree
                // while it's asynchronously locating the node. These errors can just be discarded.
            }
        });
        context.subscriptions.push(testTreeProvider, testTreeView, testCoordinator.onDidStartTests.listen((node) => __awaiter(this, void 0, void 0, function* () {
            if (config_1.config.openTestViewOnStart)
                tryReveal(node);
        })), testCoordinator.onFirstFailure.listen((node) => __awaiter(this, void 0, void 0, function* () {
            if (config_1.config.openTestViewOnFailure)
                // HACK: Because the tree update is async, this code may fire before
                // the tree has been re-sorted, so wait a short period before revealing
                // to let the tree update complete.
                setTimeout(() => tryReveal(node), 100);
        })));
        let flutterOutlineTreeProvider;
        if (config_1.config.flutterOutline) {
            // TODO: Extract this out - it's become messy since TreeView was added in.
            flutterOutlineTreeProvider = dasAnalyzer ? new flutter_outline_view_1.DasFlutterOutlineProvider(dasAnalyzer) : new flutter_outline_view_1.LspFlutterOutlineProvider(lspAnalyzer);
            const tree = vs.window.createTreeView("dartFlutterOutline", { treeDataProvider: flutterOutlineTreeProvider, showCollapseAll: true });
            tree.onDidChangeSelection((e) => __awaiter(this, void 0, void 0, function* () {
                // TODO: This should be in a tree, not the data provider.
                yield flutterOutlineTreeProvider.setContexts(e.selection);
            }));
            context.subscriptions.push(vs.window.onDidChangeTextEditorSelection((e) => {
                if (e.selections && e.selections.length) {
                    const node = flutterOutlineTreeProvider.getNodeAt(e.textEditor.document.uri, e.selections[0].start);
                    if (node && tree.visible)
                        tree.reveal(node, { select: true, focus: false, expand: true });
                }
            }));
            context.subscriptions.push(tree);
            context.subscriptions.push(flutterOutlineTreeProvider);
            // TODO: This doesn't work for LSP!!!
            const flutterOutlineCommands = new flutter_outline_1.FlutterOutlineCommands(tree, context);
        }
        context.subscriptions.push(vs.commands.registerCommand("dart.package.openFile", (filePath) => {
            if (!filePath)
                return;
            vs.workspace.openTextDocument(filePath).then((document) => {
                vs.window.showTextDocument(document, { preview: true });
            }, (error) => logger.error(error));
        }));
        // Warn the user if they've opened a folder with mismatched casing.
        if (vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length) {
            for (const wf of vs.workspace.workspaceFolders) {
                if (utils_2.warnIfPathCaseMismatch(logger, fs_1.fsPath(wf.uri), "the open workspace folder", "re-open the folder using the File Open dialog"))
                    break;
            }
        }
        // Prompt user for any special config we might want to set.
        if (!isRestart)
            // tslint:disable-next-line: no-floating-promises
            user_prompts_1.showUserPrompts(logger, extContext, webClient, workspaceContext);
        // Turn on all the commands.
        setCommandVisiblity(true, workspaceContext);
        vs.commands.executeCommand("setContext", DART_PLATFORM_NAME, constants_1.dartPlatformName);
        // Prompt for pub get if required
        function checkForPackages() {
            // Don't prompt for package updates in the Fuchsia tree/Dart SDK repo.
            if (workspaceContext.config.disableAutomaticPackageGet)
                return;
            // tslint:disable-next-line: no-floating-promises
            sdkCommands.fetchPackagesOrPrompt(undefined, { alwaysPrompt: true });
        }
        if (!isRestart)
            checkForPackages();
        // Begin activating dependant packages.
        if (workspaceContext.shouldLoadFlutterExtension) {
            const flutterExtension = vs.extensions.getExtension(constants_1.flutterExtensionIdentifier);
            if (flutterExtension) {
                logger.info(`Activating Flutter extension for ${workspaceContext.workspaceTypeDescription} project...`);
                // Do NOT await this.. the Flutter extension needs to wait for the Dart extension to finish activating
                // so that it can call its exported API, therefore we'll deadlock if we wait for the Flutter extension
                // to finish activating.
                flutterExtension.activate()
                    // Then rebuild log because it includes whether we activated Flutter.
                    .then(() => buildLogHeaders(logger, workspaceContextUnverified));
            }
        }
        // Log how long all this startup took.
        const extensionEndTime = new Date();
        if (isRestart) {
            analytics.logExtensionRestart(extensionEndTime.getTime() - extensionStartTime.getTime());
        }
        else {
            analytics.logExtensionStartup(extensionEndTime.getTime() - extensionStartTime.getTime());
        }
        // Handle changes to the workspace.
        // Set the roots, handling project changes that might affect SDKs.
        context.subscriptions.push(vs.workspace.onDidChangeWorkspaceFolders((f) => __awaiter(this, void 0, void 0, function* () {
            // First check if something changed that will affect our SDK, in which case
            // we'll perform a silent restart so that we do new SDK searches.
            const newWorkspaceContext = yield sdkUtils.scanWorkspace(isUsingLsp);
            if (newWorkspaceContext.hasAnyFlutterProjects !== workspaceContext.hasAnyFlutterProjects
                || newWorkspaceContext.hasProjectsInFuchsiaTree !== workspaceContext.hasProjectsInFuchsiaTree) {
                // tslint:disable-next-line: no-floating-promises
                util.promptToReloadExtension();
                return;
            }
            workspaceContext.events.onPackageMapChange.fire();
            recalculateAnalysisRoots();
            checkForPackages();
        })));
        context.subscriptions.push(utils_2.createWatcher("**/.packages", workspaceContext.events.onPackageMapChange));
        context.subscriptions.push(utils_2.createWatcher("**/.dart_tool/package_config.json", workspaceContext.events.onPackageMapChange));
        workspaceContext.events.onPackageMapChange.fire();
        return Object.assign(Object.assign({}, new api_2.DartExtensionApi()), { [symbols_1.internalApiSymbol]: {
                analyzer,
                analyzerCapabilities: dasClient && dasClient.capabilities,
                cancelAllAnalysisRequests: () => dasClient && dasClient.cancelAllRequests(),
                completionItemProvider,
                context: extContext,
                currentAnalysis: () => analyzer.onCurrentAnalysisComplete,
                daemonCapabilities: flutterDaemon ? flutterDaemon.capabilities : flutter_1.DaemonCapabilities.empty,
                dartCapabilities,
                debugCommands,
                debugProvider,
                debugSessions: debug_1.debugSessions,
                envUtils: utils_2.envUtils,
                fileTracker: dasAnalyzer ? dasAnalyzer.fileTracker : (lspAnalyzer ? lspAnalyzer.fileTracker : undefined),
                flutterCapabilities,
                flutterOutlineTreeProvider,
                get cursorIsInTest() { return test_1.cursorIsInTest; },
                get isInImplementationFileThatCanHaveTest() { return test_1.isInImplementationFileThatCanHaveTest; },
                get isInTestFileThatHasImplementation() { return test_1.isInTestFileThatHasImplementation; },
                getLogHeader: log_1.getLogHeader,
                initialAnalysis: analyzer.onInitialAnalysis,
                isLsp: isUsingLsp,
                logger,
                nextAnalysis: () => analyzer.onNextAnalysisComplete,
                packagesTreeProvider: dartPackagesProvider,
                pubGlobal,
                renameProvider,
                safeToolSpawn: processes_1.safeToolSpawn,
                testCoordinator,
                testTreeModel,
                testTreeProvider,
                webClient,
                workspaceContext,
            } });
    });
}
exports.activate = activate;
function setupLog(logFile, category) {
    if (logFile)
        loggers.push(logging_1.captureLogs(logger, logFile, log_1.getLogHeader(), config_1.config.maxLogLineLength, [category]));
}
function buildLogHeaders(logger, workspaceContext) {
    log_1.clearLogHeader();
    log_1.addToLogHeader(() => `!! PLEASE REVIEW THIS LOG FOR SENSITIVE INFORMATION BEFORE SHARING !!`);
    log_1.addToLogHeader(() => ``);
    log_1.addToLogHeader(() => `Dart Code extension: ${extension_utils_1.extensionVersion}`);
    log_1.addToLogHeader(() => {
        const ext = vs.extensions.getExtension(constants_1.flutterExtensionIdentifier);
        return `Flutter extension: ${ext.packageJSON.version} (${ext.isActive ? "" : "not "}activated)`;
    });
    log_1.addToLogHeader(() => ``);
    log_1.addToLogHeader(() => `App: ${vs.env.appName}`);
    if (vs.env.remoteName)
        log_1.addToLogHeader(() => `Remote: ${vs.env.remoteName}`);
    log_1.addToLogHeader(() => `Version: ${vs.version}`);
    log_1.addToLogHeader(() => `Platform: ${constants_1.platformDisplayName}`);
    if (workspaceContext) {
        log_1.addToLogHeader(() => ``);
        log_1.addToLogHeader(() => `Workspace type: ${workspaceContext.workspaceTypeDescription}`);
        log_1.addToLogHeader(() => `Analyzer type: ${workspaceContext.config.useLsp ? "LSP" : "DAS"}`);
        log_1.addToLogHeader(() => `Multi-root?: ${vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length > 1}`);
        const sdks = workspaceContext.sdks;
        log_1.addToLogHeader(() => ``);
        log_1.addToLogHeader(() => `Dart SDK:\n    Loc: ${sdks.dart}\n    Ver: ${sdks.dartVersion}`);
        log_1.addToLogHeader(() => `Flutter SDK:\n    Loc: ${sdks.flutter}\n    Ver: ${sdks.flutterVersion}`);
    }
    log_1.addToLogHeader(() => ``);
    log_1.addToLogHeader(() => `HTTP_PROXY: ${process.env.HTTP_PROXY}`);
    log_1.addToLogHeader(() => `NO_PROXY: ${process.env.NO_PROXY}`);
    // Any time the log headers are rebuilt, we should re-log them.
    logger === null || logger === void 0 ? void 0 : logger.info(log_1.getLogHeader());
}
function recalculateAnalysisRoots() {
    const workspaceFolders = utils_2.getDartWorkspaceFolders();
    analysisRoots = workspaceFolders.map((w) => fs_1.fsPath(w.uri));
    // Sometimes people open their home directories as the workspace root and
    // have all sorts of performance issues because of PubCache and AppData folders
    // so we will exclude them if the user has opened a parent folder (opening a
    // child of these directly will still work).
    const excludeFolders = [];
    if (constants_1.isWin) {
        const addExcludeIfRequired = (folder) => {
            if (!folder || !path.isAbsolute(folder))
                return;
            const containingRoot = analysisRoots.find((root) => fs_1.isWithinPath(folder, root));
            if (containingRoot) {
                logger.info(`Excluding folder ${folder} from analysis roots as it is a child of analysis root ${containingRoot} and may cause performance issues.`);
                excludeFolders.push(folder);
            }
        };
        addExcludeIfRequired(process.env.PUB_CACHE);
        addExcludeIfRequired(process.env.APPDATA);
        addExcludeIfRequired(process.env.LOCALAPPDATA);
    }
    // For each workspace, handle excluded folders.
    workspaceFolders.forEach((f) => {
        for (const folder of util.getExcludedFolders(f))
            excludeFolders.push(folder);
    });
    // tslint:disable-next-line: no-floating-promises
    analyzer.client.analysisSetAnalysisRoots({
        excluded: excludeFolders,
        included: analysisRoots,
    });
}
function handleConfigurationChange(sdks) {
    // TODOs
    const newShowTodoSetting = config_1.config.showTodos;
    const todoSettingChanged = showTodos !== newShowTodoSetting;
    showTodos = newShowTodoSetting;
    // SDK
    const newSettings = getSettingsThatRequireRestart();
    const settingsChanged = previousSettings !== newSettings;
    previousSettings = newSettings;
    if (todoSettingChanged && analyzer instanceof analyzer_das_1.DasAnalyzer) {
        // tslint:disable-next-line: no-floating-promises
        analyzer.client.analysisReanalyze();
    }
    if (settingsChanged) {
        // tslint:disable-next-line: no-floating-promises
        util.promptToReloadExtension();
    }
}
function getSettingsThatRequireRestart() {
    var _a, _b;
    // The return value here is used to detect when any config option changes that requires a project reload.
    // It doesn't matter how these are combined; it just gets called on every config change and compared.
    // Usually these are options that affect the analyzer and need a reload, but config options used at
    // activation time will also need to be included.
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    return "CONF-"
        + config_1.config.sdkPath
        + ((_a = config_1.config.sdkPaths) === null || _a === void 0 ? void 0 : _a.length)
        + config_1.config.analyzerPath
        + config_1.config.analyzerDiagnosticsPort
        + config_1.config.analyzerVmServicePort
        + config_1.config.analyzerInstrumentationLogFile
        + config_1.config.extensionLogFile
        + config_1.config.analyzerAdditionalArgs
        + config_1.config.flutterSdkPath
        + ((_b = config_1.config.flutterSdkPaths) === null || _b === void 0 ? void 0 : _b.length)
        + config_1.config.flutterSelectDeviceWhenConnected
        + config_1.config.closingLabels
        + config_1.config.analyzeAngularTemplates
        + config_1.config.analysisServerFolding
        + config_1.config.showMainCodeLens
        + config_1.config.showTestCodeLens
        + config_1.config.updateImportsOnRename
        + config_1.config.previewBazelWorkspaceCustomScripts
        + config_1.config.flutterOutline
        + config_1.config.triggerSignatureHelpAutomatically
        + config_1.config.flutterAdbConnectOnChromeOs;
}
function deactivate(isRestart = false) {
    return __awaiter(this, void 0, void 0, function* () {
        setCommandVisiblity(false);
        yield (analyzer === null || analyzer === void 0 ? void 0 : analyzer.dispose());
        if (loggers) {
            yield Promise.all(loggers.map((logger) => logger.dispose()));
            loggers.length = 0;
        }
        vs.commands.executeCommand("setContext", exports.FLUTTER_SUPPORTS_ATTACH, false);
        if (!isRestart) {
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_DEBUG_CONFIG, false);
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_TEST_DEBUG_CONFIG, false);
            yield analytics.logExtensionShutdown();
            ringLogger === null || ringLogger === void 0 ? void 0 : ringLogger.dispose();
            logger.dispose();
        }
    });
}
exports.deactivate = deactivate;
function setCommandVisiblity(enable, workspaceContext) {
    vs.commands.executeCommand("setContext", DART_PROJECT_LOADED, enable);
    // TODO: Make this more specific. Maybe the one above?
    vs.commands.executeCommand("setContext", FLUTTER_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyFlutterProjects);
    vs.commands.executeCommand("setContext", FLUTTER_MOBILE_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyFlutterMobileProjects);
    vs.commands.executeCommand("setContext", WEB_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyWebProjects);
}


/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EventEmitter = void 0;
const evt = __webpack_require__(39);
class EventEmitter {
    constructor() {
        this.emitter = new evt.EventEmitter();
    }
    fire(x) {
        this.emitter.emit("thing", x);
    }
    listen(listener) {
        this.emitter.on("thing", listener);
        return {
            dispose: () => { this.emitter.removeListener("thing", listener); },
        };
    }
    get event() { return this; }
    dispose() {
        this.emitter.removeAllListeners();
    }
}
exports.EventEmitter = EventEmitter;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.safeSpawn = void 0;
const child_process = __webpack_require__(49);
function safeSpawn(workingDirectory, binPath, args, env) {
    // Spawning processes on Windows with funny symbols in the path requires quoting. However if you quote an
    // executable with a space in its path and an argument also has a space, you have to then quote all of the
    // arguments too!\
    // https://github.com/nodejs/node/issues/7367
    const customEnv = Object.assign({}, process.env, env.toolEnv, env.envOverrides);
    const quotedArgs = args.map((a) => `"${a.replace(/"/g, `\\"`)}"`);
    return child_process.spawn(`"${binPath}"`, quotedArgs, { cwd: workingDirectory, env: customEnv, shell: true });
}
exports.safeSpawn = safeSpawn;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StdIOService = void 0;
const fs = __webpack_require__(7);
const processes_1 = __webpack_require__(43);
// Reminder: This class is used in the debug adapter as well as the main Code process!
class StdIOService {
    constructor(logger, maxLogLineLength, messagesWrappedInBrackets = false, treatHandlingErrorsAsUnhandledMessages = false, treatCarriageReturnsAsNewlines = false, logFile) {
        this.logger = logger;
        this.maxLogLineLength = maxLogLineLength;
        this.messagesWrappedInBrackets = messagesWrappedInBrackets;
        this.treatHandlingErrorsAsUnhandledMessages = treatHandlingErrorsAsUnhandledMessages;
        this.treatCarriageReturnsAsNewlines = treatCarriageReturnsAsNewlines;
        this.logFile = logFile;
        this.disposables = [];
        this.additionalPidsToTerminate = [];
        this.nextRequestID = 1;
        this.activeRequests = {};
        this.messageBuffers = [];
        this.requestErrorSubscriptions = [];
        this.processExited = false;
    }
    createProcess(workingDirectory, binPath, args, env) {
        this.logTraffic(`Spawning ${binPath} with args ${JSON.stringify(args)}`);
        if (workingDirectory)
            this.logTraffic(`..  in ${workingDirectory}`);
        if (env.envOverrides || env.toolEnv)
            this.logTraffic(`..  with ${JSON.stringify(env)}`);
        this.process = processes_1.safeSpawn(workingDirectory, binPath, args, env);
        this.logTraffic(`    PID: ${process.pid}`);
        this.process.stdout.on("data", (data) => this.handleStdOut(data));
        this.process.stderr.on("data", (data) => this.handleStdErr(data));
        this.process.on("exit", (code, signal) => this.handleExit(code, signal));
        this.process.on("error", (error) => this.handleError(error));
    }
    /// Flutter may send only \r as a line terminator for improved terminal output
    /// but we should always treat this as a standard newline (eg. terminating a message)
    /// so all \r's can be replaced with \n immediately. Blank lines (from \n\n)
    /// are already handled gracefully.
    ///
    /// https://github.com/flutter/flutter/pull/57590
    normalizeNewlines(data) {
        const normalised = this.treatCarriageReturnsAsNewlines
            ? Buffer.from(data.toString().replace(/\r/g, "\n"))
            : data;
        return Buffer.from(normalised);
    }
    handleStdOut(data) {
        data = this.normalizeNewlines(data);
        // Add this message to the buffer for processing.
        this.messageBuffers.push(data);
        // Kick off processing if we have a full message.
        if (data.indexOf("\n") >= 0)
            this.processMessageBuffer();
    }
    handleStdErr(data) {
        this.logTraffic(`${data.toString()}`, true);
    }
    handleExit(code, signal) {
        this.logTraffic(`Process terminated! ${code}, ${signal}`);
        this.processExited = true;
    }
    handleError(error) {
        this.logTraffic(`Process errored! ${error}`);
    }
    buildRequest(id, method, params) {
        return {
            id: id.toString(),
            method,
            params,
        };
    }
    sendRequest(method, params) {
        // Generate an ID for this request so we can match up the response.
        const id = this.nextRequestID++;
        return new Promise((resolve, reject) => {
            // Stash the callbacks so we can call them later.
            this.activeRequests[id.toString()] = [resolve, reject, method];
            const req = this.buildRequest(id, method, params);
            const json = this.messagesWrappedInBrackets
                ? "[" + JSON.stringify(req) + "]\r\n"
                : JSON.stringify(req) + "\r\n";
            this.sendMessage(json);
        });
    }
    cancelAllRequests() {
        Object.keys(this.activeRequests).forEach((key) => this.activeRequests[key] = "CANCELLED");
    }
    sendMessage(json) {
        this.logTraffic(`==> ${json}`);
        if (this.process)
            this.process.stdin.write(json);
        else
            this.logTraffic(`  (not sent: no process)`);
    }
    processMessageBuffer() {
        let fullBuffer = Buffer.concat(this.messageBuffers);
        this.messageBuffers = [];
        // If the message doesn't end with \n then put the last part back into the buffer.
        const lastNewline = fullBuffer.lastIndexOf("\n");
        if (lastNewline !== fullBuffer.length - 1) {
            const incompleteMessage = fullBuffer.slice(lastNewline + 1);
            fullBuffer = fullBuffer.slice(0, lastNewline);
            this.messageBuffers.push(incompleteMessage);
        }
        // Process the complete messages in the buffer.
        fullBuffer.toString().split("\n").filter((m) => m.trim() !== "").forEach((m) => this.handleMessage(`${m}\n`));
    }
    // tslint:disable-next-line:no-empty
    processUnhandledMessage(message) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logTraffic(`<== ${message.trimRight()}\r\n`);
            if (!this.shouldHandleMessage(message.trim())) {
                return this.processUnhandledMessage(message);
            }
            let msg;
            try {
                msg = JSON.parse(message);
                if (this.messagesWrappedInBrackets && msg && msg.length === 1)
                    msg = msg[0];
            }
            catch (e) {
                if (this.treatHandlingErrorsAsUnhandledMessages) {
                    this.logger.error(`Unexpected non-JSON message, assuming normal stdout (${e})\n\n${e.stack}\n\n${message}`);
                    return this.processUnhandledMessage(message);
                }
                else {
                    throw e;
                }
            }
            try {
                if (msg && this.isNotification(msg))
                    // tslint:disable-next-line: no-floating-promises
                    this.handleNotification(msg).catch((e) => this.logger.error(e));
                else if (msg && this.isRequest(msg))
                    this.processServerRequest(msg).catch((e) => this.logger.error(e));
                else if (msg && this.isResponse(msg))
                    this.handleResponse(msg).catch((e) => this.logger.error(e));
                else {
                    this.logger.error(`Unexpected JSON message, assuming normal stdout : ${message}`);
                    this.processUnhandledMessage(message).catch((e) => this.logger.error(e));
                }
            }
            catch (e) {
                if (this.treatHandlingErrorsAsUnhandledMessages) {
                    this.logger.error(`Failed to handle JSON message, assuming normal stdout (${e})\n\n${e.stack}\n\n${message}`);
                    this.processUnhandledMessage(message).catch((e) => this.logger.error(e));
                }
                else {
                    throw e;
                }
            }
        });
    }
    // tslint:disable-next-line: no-empty
    handleRequest(method, args) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    isNotification(msg) { return !!msg.event; }
    isRequest(msg) { return !!msg.method && !!msg.id; }
    isResponse(msg) { return !!msg.id; }
    processServerRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            let error;
            try {
                result = yield this.handleRequest(request.method, request.params);
            }
            catch (e) {
                error = e;
            }
            const resp = { id: request.id, result, error };
            const json = this.messagesWrappedInBrackets
                ? "[" + JSON.stringify(resp) + "]\r\n"
                : JSON.stringify(resp) + "\r\n";
            this.sendMessage(json);
        });
    }
    handleResponse(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this.activeRequests[evt.id];
            delete this.activeRequests[evt.id];
            if (handler === "CANCELLED") {
                this.logger.info(`Ignoring response to ${evt.id} because it was cancelled:\n\n${JSON.stringify(evt, undefined, 4)}`);
                return;
            }
            else if (!handler) {
                this.logger.error(`Unable to handle response with ID ${evt.id} because its handler is not available`);
                return;
            }
            const method = handler[2];
            const error = evt.error;
            if (error && error.code === "SERVER_ERROR") {
                error.method = method;
                this.notify(this.requestErrorSubscriptions, error).catch((e) => this.logger.error(e));
            }
            if (error) {
                yield handler[1](error);
            }
            else {
                yield handler[0](evt.result);
            }
        });
    }
    notify(subscriptions, notification) {
        return Promise.all(subscriptions.slice().map((sub) => sub(notification))).catch((e) => console.error(e));
    }
    subscribe(subscriptions, subscriber) {
        subscriptions.push(subscriber);
        const disposable = {
            dispose: () => {
                // Remove from the subscription list.
                let index = subscriptions.indexOf(subscriber);
                if (index >= 0) {
                    subscriptions.splice(index, 1);
                }
                // Also remove from our disposables (else we'll leak it).
                index = this.disposables.indexOf(disposable);
                if (index >= 0) {
                    this.disposables.splice(index, 1);
                }
            },
        };
        this.disposables.push(disposable);
        return disposable;
    }
    registerForRequestError(subscriber) {
        return this.subscribe(this.requestErrorSubscriptions, subscriber);
    }
    logTraffic(message, isError = false) {
        if (isError)
            this.logger.error(message);
        else
            this.logger.info(message);
        if (this.openLogFile !== this.logFile && this.logStream) {
            this.logStream.end();
            this.logStream = undefined;
            this.openLogFile = undefined;
        }
        if (!this.logFile)
            return;
        if (!this.logStream) {
            this.logStream = fs.createWriteStream(this.logFile);
            this.openLogFile = this.logFile;
        }
        this.logStream.write(`[${(new Date()).toLocaleTimeString()}]: `);
        if (this.maxLogLineLength && message.length > this.maxLogLineLength)
            this.logStream.write(message.substring(0, this.maxLogLineLength) + "…\r\n");
        else
            this.logStream.write(message.trim() + "\r\n");
    }
    dispose() {
        for (const pid of this.additionalPidsToTerminate) {
            try {
                process.kill(pid);
            }
            catch (e) {
                // TODO: Logger knows the category!
                this.logger.error({ message: e.toString() });
            }
        }
        this.additionalPidsToTerminate.length = 0;
        try {
            if (!this.processExited && this.process && !this.process.killed)
                this.process.kill();
        }
        catch (e) {
            // This tends to throw a lot because the shell process quit when we terminated the related
            // process above, so just swallow the error.
        }
        this.process = undefined;
        this.disposables.forEach((d) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield d.dispose();
            }
            catch (e) {
                this.logger.error({ message: e.toString() });
            }
        }));
        this.disposables.length = 0;
        // Clear log file so if any more log events come through later, we don't
        // create a new log file and overwrite what we had.
        this.logFile = undefined;
        if (this.logStream) {
            this.logStream.end();
            this.logStream = undefined;
            this.openLogFile = undefined;
        }
    }
}
exports.StdIOService = StdIOService;


/***/ }),
/* 45 */,
/* 46 */,
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(11)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

const eq = __webpack_require__(33)
const neq = __webpack_require__(47)
const gt = __webpack_require__(27)
const gte = __webpack_require__(36)
const lt = __webpack_require__(35)
const lte = __webpack_require__(37)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSymbolKindForElementKind = exports.DasAnalyzerClient = exports.DasAnalyzer = exports.AnalyzerCapabilities = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const analyzer_1 = __webpack_require__(119);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const utils_1 = __webpack_require__(3);
const config_1 = __webpack_require__(10);
const utils_2 = __webpack_require__(6);
const misc_1 = __webpack_require__(62);
const processes_1 = __webpack_require__(15);
const analyzer_2 = __webpack_require__(120);
const analyzer_gen_1 = __webpack_require__(157);
const file_tracker_das_1 = __webpack_require__(158);
class AnalyzerCapabilities {
    constructor(analyzerVersion) {
        this.version = analyzerVersion;
    }
    static get empty() { return new AnalyzerCapabilities("0.0.0"); }
    get hasCompleteStatementFix() { return utils_1.versionIsAtLeast(this.version, "1.20.2"); }
    get supportsPriorityFilesOutsideAnalysisRoots() { return utils_1.versionIsAtLeast(this.version, "1.18.2"); }
    get supportsDiagnostics() { return utils_1.versionIsAtLeast(this.version, "1.18.1"); }
    get supportsClosingLabels() { return utils_1.versionIsAtLeast(this.version, "1.18.4"); }
    get supportsCustomFolding() { return utils_1.versionIsAtLeast(this.version, "1.20.3"); }
    // 1.26.0 is stable Flutter at time of writing. Unclear what version had Outline, but
    // we don't need to support older.
    get supportsFlutterOutline() { return utils_1.versionIsAtLeast(this.version, "1.26.0"); }
    get supportsGetDeclerations() { return utils_1.versionIsAtLeast(this.version, "1.18.7"); }
    get supportsGetDeclerationsForFile() { return utils_1.versionIsAtLeast(this.version, "1.19.0"); }
    get supportsGetSignature() { return utils_1.versionIsAtLeast(this.version, "1.20.5"); }
    get supportsMoveFile() { return utils_1.versionIsAtLeast(this.version, "1.27.0"); }
    get supportsAvailableSuggestions() { return utils_1.versionIsAtLeast(this.version, "1.26.0"); }
    get supportsIncludedImports() { return utils_1.versionIsAtLeast(this.version, "1.27.1"); }
}
exports.AnalyzerCapabilities = AnalyzerCapabilities;
class DasAnalyzer extends analyzer_1.Analyzer {
    constructor(logger, analytics, sdks, dartCapabilities, wsContext) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.Analyzer));
        this.client = new DasAnalyzerClient(this.logger, sdks, dartCapabilities);
        this.fileTracker = new file_tracker_das_1.DasFileTracker(logger, this.client, wsContext);
        this.disposables.push(this.client);
        this.disposables.push(this.fileTracker);
        const connectedEvent = this.client.registerForServerConnected((sc) => {
            // TODO: Lsp equiv.
            analytics.analysisServerVersion = sc.version;
            this.onReadyCompleter.resolve();
            connectedEvent.dispose();
        });
        this.client.registerForServerStatus((params) => {
            if (params.analysis)
                this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: params.analysis.isAnalyzing });
        });
    }
    getDiagnosticServerPort() {
        return this.client.diagnosticGetServerPort();
    }
    forceReanalyze() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.analysisReanalyze();
        });
    }
}
exports.DasAnalyzer = DasAnalyzer;
class DasAnalyzerClient extends analyzer_gen_1.AnalyzerGen {
    constructor(logger, sdks, dartCapabilities) {
        var _a;
        super(logger, config_1.config.maxLogLineLength);
        this.isAnalyzing = false;
        this.capabilities = AnalyzerCapabilities.empty;
        this.resolvedPromise = Promise.resolve();
        this.serverTerminatedSubscriptions = [];
        this.launchArgs = analyzer_2.getAnalyzerArgs(logger, sdks, dartCapabilities, false);
        // Hook error subscriptions so we can try and get diagnostic info if this happens.
        this.registerForServerError((e) => this.requestDiagnosticsUpdate());
        this.registerForRequestError((e) => this.requestDiagnosticsUpdate());
        // Register for version.
        this.registerForServerConnected((e) => { this.version = e.version; this.capabilities.version = this.version; });
        const fullDartVmPath = path.join(sdks.dart, constants_1.dartVMPath);
        let binaryPath = fullDartVmPath;
        let processArgs = this.launchArgs.slice();
        // Since we communicate with the analysis server over STDOUT/STDIN, it is trivial for us
        // to support launching it on a remote machine over SSH. This can be useful if the codebase
        // is being modified remotely over SSHFS, and running the analysis server locally would
        // result in excessive file reading over SSHFS.
        if (config_1.config.analyzerSshHost) {
            binaryPath = "ssh";
            processArgs.unshift(fullDartVmPath);
            processArgs = [
                // SSH quiet mode, which prevents SSH from interfering with the STDOUT/STDIN communication
                // with the analysis server.
                "-q",
                config_1.config.analyzerSshHost,
                utils_2.escapeShell(processArgs),
            ];
        }
        this.createProcess(undefined, binaryPath, processArgs, { toolEnv: processes_1.getToolEnv() });
        (_a = this.process) === null || _a === void 0 ? void 0 : _a.on("exit", (code, signal) => {
            this.handleAnalyzerTerminated(!!code);
        });
        this.registerForServerStatus((n) => {
            if (n.analysis) {
                if (n.analysis.isAnalyzing) {
                    this.isAnalyzing = true;
                }
                else {
                    this.isAnalyzing = false;
                    if (this.currentAnalysisCompleter) {
                        this.currentAnalysisCompleter.resolve();
                        this.currentAnalysisCompleter = undefined;
                    }
                }
            }
        });
        // tslint:disable-next-line: no-floating-promises
        this.serverSetSubscriptions({
            subscriptions: ["STATUS"],
        });
    }
    get currentAnalysis() {
        if (!this.isAnalyzing)
            return this.resolvedPromise;
        if (!this.currentAnalysisCompleter)
            this.currentAnalysisCompleter = new utils_1.PromiseCompleter();
        return this.currentAnalysisCompleter.promise;
    }
    sendMessage(json) {
        try {
            super.sendMessage(json);
        }
        catch (e) {
            this.handleAnalyzerTerminated(true);
            throw e;
        }
    }
    handleAnalyzerTerminated(withError) {
        const serverHasStarted = !!this.version;
        if (withError)
            misc_1.reportAnalyzerTerminatedWithError(!serverHasStarted);
        this.notify(this.serverTerminatedSubscriptions, undefined);
    }
    shouldHandleMessage(message) {
        // This will include things like Observatory output and some analyzer logging code.
        return !message.startsWith("--- ")
            && !message.startsWith("+++ ")
            && !message.startsWith("Observatory listening on")
            && !message.startsWith("Observatory server");
    }
    requestDiagnosticsUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            this.lastDiagnostics = undefined;
            if (!this.capabilities.supportsDiagnostics)
                return;
            this.lastDiagnostics = (yield this.diagnosticGetDiagnostics()).contexts;
        });
    }
    getLastDiagnostics() {
        return this.lastDiagnostics;
    }
    getAnalyzerLaunchArgs() {
        return this.launchArgs;
    }
    forceNotificationsFor(file) {
        // Send a dummy edit (https://github.com/dart-lang/sdk/issues/30238)
        const files = {};
        files[file] = {
            edits: [{ offset: 0, length: 0, replacement: "", id: "" }],
            type: "change",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analysisUpdateContent({ files });
    }
    // Wraps completionGetSuggestions to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    completionGetSuggestionsResults(request) {
        return this.requestWithStreamedResults(() => this.completionGetSuggestions(request), this.registerForCompletionResults);
    }
    // Wraps searchFindElementReferences to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindElementReferencesResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindElementReferences(request), this.registerForSearchResults);
    }
    // Wraps searchFindTopLevelDeclarations to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindTopLevelDeclarationsResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindTopLevelDeclarations(request), this.registerForSearchResults);
    }
    // Wraps searchFindMemberDeclarations to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindMemberDeclarationsResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindMemberDeclarations(request), this.registerForSearchResults);
    }
    // We need to subscribe before we send the request to avoid races in registering
    // for results (see https://github.com/Dart-Code/Dart-Code/issues/471).
    // Since we don't have the ID yet, we'll have to buffer them for the duration
    // and check inside the buffer when we get the ID back.
    requestWithStreamedResults(sendRequest, registerForResults) {
        return new Promise((resolve, reject) => {
            const buffer = []; // Buffer to store results that come in before we're ready.
            let searchResultsID; // ID that'll be set once we get it back.
            const disposable = registerForResults.bind(this)((notification) => {
                // If we know our ID and this is it, and it's the last result, then resolve.
                if (searchResultsID && notification.id === searchResultsID && notification.isLast) {
                    disposable.dispose();
                    resolve(notification);
                }
                else if (!searchResultsID && notification.isLast) // Otherwise if we didn't know our ID and this might be what we want, stash it.
                    buffer.push(notification);
            });
            // Now we have the above handler set up, send the actual request.
            sendRequest.bind(this)().then((resp) => {
                if (!resp.id) {
                    disposable.dispose();
                    reject();
                }
                // When the ID comes back, stash it...
                searchResultsID = resp.id;
                // And also check the buffer.
                const result = buffer.find((b) => b.id === searchResultsID);
                if (result) {
                    disposable.dispose();
                    resolve(result);
                }
            }, () => reject());
        });
    }
    registerForServerTerminated(subscriber) {
        return this.subscribe(this.serverTerminatedSubscriptions, subscriber);
    }
}
exports.DasAnalyzerClient = DasAnalyzerClient;
function getSymbolKindForElementKind(logger, kind) {
    switch (kind) {
        case "CLASS":
        case "CLASS_TYPE_ALIAS":
        case "MIXIN":
            return vs.SymbolKind.Class;
        case "COMPILATION_UNIT":
        case "EXTENSION":
            return vs.SymbolKind.Module;
        case "CONSTRUCTOR":
        case "CONSTRUCTOR_INVOCATION":
            return vs.SymbolKind.Constructor;
        case "ENUM":
            return vs.SymbolKind.Enum;
        case "ENUM_CONSTANT":
            return vs.SymbolKind.EnumMember;
        case "FIELD":
            return vs.SymbolKind.Field;
        case "FILE":
            return vs.SymbolKind.File;
        case "FUNCTION":
        case "FUNCTION_INVOCATION":
        case "FUNCTION_TYPE_ALIAS":
            return vs.SymbolKind.Function;
        case "GETTER":
            return vs.SymbolKind.Property;
        case "LABEL":
            return vs.SymbolKind.Module;
        case "LIBRARY":
            return vs.SymbolKind.Namespace;
        case "LOCAL_VARIABLE":
            return vs.SymbolKind.Variable;
        case "METHOD":
            return vs.SymbolKind.Method;
        case "PARAMETER":
        case "PREFIX":
            return vs.SymbolKind.Variable;
        case "SETTER":
            return vs.SymbolKind.Property;
        case "TOP_LEVEL_VARIABLE":
        case "TYPE_PARAMETER":
            return vs.SymbolKind.Variable;
        case "UNIT_TEST_GROUP":
            return vs.SymbolKind.Module;
        case "UNIT_TEST_TEST":
            return vs.SymbolKind.Method;
        case "UNKNOWN":
            return vs.SymbolKind.Object;
        default:
            logger.error(`Unknown kind: ${kind}`, enums_1.LogCategory.Analyzer);
            return vs.SymbolKind.Object;
    }
}
exports.getSymbolKindForElementKind = getSymbolKindForElementKind;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.locateBestProjectRoot = exports.UPGRADE_TO_WORKSPACE_FOLDERS = void 0;
const path = __webpack_require__(2);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(6);
exports.UPGRADE_TO_WORKSPACE_FOLDERS = "Mark Projects as Workspace Folders";
function locateBestProjectRoot(folder) {
    if (!folder || !utils_1.isWithinWorkspace(folder))
        return undefined;
    let dir = folder;
    while (dir !== path.dirname(dir)) {
        if (fs_1.hasPubspec(dir) || fs_1.hasPackagesFile(dir))
            return dir;
        dir = path.dirname(dir);
    }
    return undefined;
}
exports.locateBestProjectRoot = locateBestProjectRoot;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageMap = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const url = __webpack_require__(30);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
class PackageMap {
    static findPackagesFile(entryPoint) {
        if (typeof entryPoint !== "string")
            return undefined;
        const file = utils_1.findFileInAncestor([path.join(".dart_tool/package_config.json"), ".packages"], entryPoint);
        return file;
    }
    static loadForProject(logger, projectFolder) {
        const paths = [
            ".dart_tool/package_config.json",
            ".packages",
        ];
        for (const p of paths) {
            const fullP = path.join(projectFolder, p);
            if (fs.existsSync(fullP))
                return this.load(logger, fullP);
        }
        return new MissingPackageMap();
    }
    static load(logger, file) {
        if (!file)
            return new MissingPackageMap();
        try {
            if (path.basename(file).toLowerCase() === ".packages")
                return new DotPackagesPackageMap(file);
            else
                return new PackageConfigJsonPackageMap(logger, file);
        }
        catch (e) {
            logger.error(e);
            return new MissingPackageMap();
        }
    }
    getPackagePath(name) {
        return this.packages[name];
    }
    resolvePackageUri(uri) {
        if (!uri)
            return undefined;
        let name = uri;
        if (name.startsWith("package:"))
            name = name.substring(8);
        const index = name.indexOf("/");
        if (index === -1)
            return undefined;
        const rest = name.substring(index + 1);
        name = name.substring(0, index);
        const location = this.getPackagePath(name);
        if (location)
            return path.join(location, rest);
        else
            return undefined;
    }
}
exports.PackageMap = PackageMap;
class MissingPackageMap extends PackageMap {
    get packages() {
        return {};
    }
    getPackagePath(name) {
        return undefined;
    }
    resolvePackageUri(uri) {
        return undefined;
    }
}
class DotPackagesPackageMap extends PackageMap {
    constructor(file) {
        super();
        this.map = {};
        if (!file)
            return;
        this.localPackageRoot = path.dirname(file);
        const lines = fs.readFileSync(file, { encoding: "utf8" }).split("\n");
        for (let line of lines) {
            line = line.trim();
            if (line.length === 0 || line.startsWith("#"))
                continue;
            const index = line.indexOf(":");
            if (index !== -1) {
                const name = line.substr(0, index);
                const rest = line.substring(index + 1);
                if (rest.startsWith("file:"))
                    this.map[name] = utils_1.uriToFilePath(rest);
                else
                    this.map[name] = path.join(this.localPackageRoot, rest);
            }
        }
    }
    get packages() { return Object.assign({}, this.map); }
}
class PackageConfigJsonPackageMap extends PackageMap {
    constructor(logger, packageConfigPath) {
        super();
        this.logger = logger;
        this.packageConfigPath = packageConfigPath;
        this.map = {};
        const json = fs.readFileSync(this.packageConfigPath, "utf8");
        this.config = JSON.parse(json);
        for (const pkg of this.config.packages) {
            try {
                const packageConfigFolderPath = path.dirname(this.packageConfigPath);
                const packageRootPath = this.getPathForUri(pkg.rootUri);
                const packageLibPath = this.getPathForUri(pkg.packageUri);
                this.map[pkg.name] = path.resolve(packageConfigFolderPath, packageRootPath !== null && packageRootPath !== void 0 ? packageRootPath : "", packageLibPath !== null && packageLibPath !== void 0 ? packageLibPath : "");
            }
            catch (e) {
                logger.error(`Failed to resolve path for package ${pkg.name}: ${e}`);
            }
        }
    }
    getPathForUri(uri) {
        if (!uri)
            return undefined;
        const parsedPath = fs_1.normalizeSlashes(uri.startsWith("file:")
            ? url.fileURLToPath(uri)
            : unescape(uri));
        return parsedPath.endsWith(path.sep) ? parsedPath : `${parsedPath}${path.sep}`;
    }
    get packages() { return Object.assign({}, this.map); }
    getPackagePath(name) {
        return this.map[name];
    }
}


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
function asPromise(value) {
    if (value instanceof Promise) {
        return value;
    }
    else if (thenable(value)) {
        return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
        });
    }
    else {
        return Promise.resolve(value);
    }
}
exports.asPromise = asPromise;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isSimpleTestName = exports.extractTestNameFromOutline = exports.defaultDartTestFileContents = exports.defaultFlutterTestFileContents = exports.defaultTestFileContents = exports.createTestFileAction = exports.makeRegexForTests = exports.getLaunchConfig = void 0;
const path = __webpack_require__(2);
const utils_1 = __webpack_require__(3);
function getLaunchConfig(noDebug, path, testNames, isGroup, template) {
    const templateArgs = (template === null || template === void 0 ? void 0 : template.args) || [];
    const testNameArgs = testNames
        ? ["--name", makeRegexForTests(testNames, isGroup)]
        : [];
    return Object.assign({
        // Trailing space is a workaround for https://github.com/microsoft/vscode/issues/100115
        name: "Tests ",
        noDebug,
        request: "launch",
        type: "dart",
    }, template, {
        args: templateArgs.concat(testNameArgs),
        expectSingleTest: !isGroup && (testNames === null || testNames === void 0 ? void 0 : testNames.length) === 1 && !testNames[0].includes("$"),
        program: path,
    });
}
exports.getLaunchConfig = getLaunchConfig;
const regexEscapedInterpolationExpressionPattern = /\\\$(?:(?:\w+)|(?:\\\{.*\\\}))/g;
function makeRegexForTests(names, isGroup) {
    const regexSegments = [];
    for (const name of names) {
        const prefix = "^";
        // We can't anchor to the end for groups, as we want them to run all children.
        const suffix = isGroup ? "" : "$";
        const escapedName = utils_1.escapeRegExp(name);
        // If a test name contains interpolated expressions, passing the exact
        // name won't match. So we just replace them out with wildcards. We'll need
        // to do this after escaping for regex, to ensure the original expression
        // is escaped but our wildcard is not.
        const substitutedName = escapedName.replace(regexEscapedInterpolationExpressionPattern, ".*");
        regexSegments.push(`${prefix}${substitutedName}${suffix}`);
    }
    return regexSegments.join("|");
}
exports.makeRegexForTests = makeRegexForTests;
const createTestFileAction = (file) => `Create ${path.basename(file)}`;
exports.createTestFileAction = createTestFileAction;
const defaultTestFileContents = (isFlutterProject, dartEscapedTestName) => isFlutterProject ? defaultFlutterTestFileContents(dartEscapedTestName) : defaultDartTestFileContents(dartEscapedTestName);
exports.defaultTestFileContents = defaultTestFileContents;
const defaultTestFileSelectionPlaceholder = "// TODO: Implement test";
function defaultFlutterTestFileContents(dartEscapedTestName) {
    const contents = `
import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('${dartEscapedTestName} ...', (tester) async {
    ${defaultTestFileSelectionPlaceholder}
  });
}
`.trim();
    return {
        contents,
        selectionLength: defaultTestFileSelectionPlaceholder.length,
        selectionOffset: contents.indexOf(defaultTestFileSelectionPlaceholder),
    };
}
exports.defaultFlutterTestFileContents = defaultFlutterTestFileContents;
function defaultDartTestFileContents(dartEscapedTestName) {
    const contents = `
import 'package:test/test.dart';

void main() {
  test('${dartEscapedTestName} ...', () async {
    ${defaultTestFileSelectionPlaceholder}
  });
}
`.trim();
    return {
        contents,
        selectionLength: defaultTestFileSelectionPlaceholder.length,
        selectionOffset: contents.indexOf(defaultTestFileSelectionPlaceholder),
    };
}
exports.defaultDartTestFileContents = defaultDartTestFileContents;
function extractTestNameFromOutline(elementName) {
    if (!elementName)
        return;
    // Strip off the function name/parent like test( or testWidget(
    const openParen = elementName.indexOf("(");
    const closeParen = elementName.lastIndexOf(")");
    if (openParen === -1 || closeParen === -1 || openParen >= closeParen)
        return;
    elementName = elementName.substring(openParen + 2, closeParen - 1);
    // For tests with variables, we often end up with additional quotes wrapped
    // around them...
    if ((elementName.startsWith("'") || elementName.startsWith('"')) && (elementName.endsWith("'") || elementName.endsWith('"')))
        elementName = elementName.substring(1, elementName.length - 1);
    return elementName;
}
exports.extractTestNameFromOutline = extractTestNameFromOutline;
/// Checks whether a test name is a simple string (and does not include interpolation).
function isSimpleTestName(name) {
    return !!name && !name.includes("$");
}
exports.isSimpleTestName = isSimpleTestName;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getActiveDartEditor = exports.isDartDocument = void 0;
const vs = __webpack_require__(0);
function isDartDocument(document) {
    return document && document.languageId === "dart";
}
exports.isDartDocument = isDartDocument;
function getActiveDartEditor() {
    const editor = vs.window.activeTextEditor;
    if (!editor || editor.document.languageId !== "dart")
        return undefined;
    return editor;
}
exports.getActiveDartEditor = getActiveDartEditor;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DaemonCapabilities = exports.FlutterCapabilities = void 0;
const utils_1 = __webpack_require__(3);
class FlutterCapabilities {
    constructor(flutterVersion) {
        this.version = flutterVersion;
    }
    static get empty() { return new FlutterCapabilities("0.0.0"); }
    get supportsCreatingSamples() { return utils_1.versionIsAtLeast(this.version, "1.0.0"); }
    get hasLatestStructuredErrorsWork() { return utils_1.versionIsAtLeast(this.version, "1.21.0-5.0"); }
    get supportsFlutterCreateListSamples() { return utils_1.versionIsAtLeast(this.version, "1.3.10"); }
    get supportsWsVmService() { return utils_1.versionIsAtLeast(this.version, "1.18.0-5"); }
    get supportsWsDebugBackend() { return utils_1.versionIsAtLeast(this.version, "1.21.0-0"); }
    get supportsExposeUrl() { return utils_1.versionIsAtLeast(this.version, "1.18.0-5"); }
    get supportsDartDefine() { return utils_1.versionIsAtLeast(this.version, "1.17.0"); }
    get supportsRestartDebounce() { return utils_1.versionIsAtLeast(this.version, "1.21.0-0"); }
    get supportsShowWebServerDevice() { return utils_1.versionIsAtLeast(this.version, "1.26.0-0"); }
    get supportsWebRendererOption() { return utils_1.versionIsAtLeast(this.version, "1.25.0-0"); }
    // TODO: Update these (along with Dart) when supported.
    get webSupportsEvaluation() { return false; }
    get webSupportsDebugging() { return true; }
    get webSupportsHotReload() { return false; }
}
exports.FlutterCapabilities = FlutterCapabilities;
class DaemonCapabilities {
    constructor(daemonProtocolVersion) {
        this.version = daemonProtocolVersion;
    }
    static get empty() { return new DaemonCapabilities("0.0.0"); }
    get canCreateEmulators() { return utils_1.versionIsAtLeast(this.version, "0.4.0"); }
    get canFlutterAttach() { return utils_1.versionIsAtLeast(this.version, "0.4.1"); }
    get providesPlatformTypes() { return utils_1.versionIsAtLeast(this.version, "0.5.2"); }
}
exports.DaemonCapabilities = DaemonCapabilities;


/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiteData = exports.TestTreeModel = exports.TestNode = exports.GroupNode = exports.SuiteNode = exports.TreeNode = void 0;
const path = __webpack_require__(2);
const enums_1 = __webpack_require__(8);
const events_1 = __webpack_require__(42);
const utils_1 = __webpack_require__(3);
const array_1 = __webpack_require__(19);
const fs_1 = __webpack_require__(1);
var TestSortOrder;
(function (TestSortOrder) {
    TestSortOrder[TestSortOrder["Top"] = 0] = "Top";
    TestSortOrder[TestSortOrder["Middle"] = 1] = "Middle";
    TestSortOrder[TestSortOrder["Bottom"] = 2] = "Bottom";
})(TestSortOrder || (TestSortOrder = {}));
function getTestSortOrder(status) {
    if (status === enums_1.TestStatus.Failed || status === enums_1.TestStatus.Errored)
        return TestSortOrder.Top;
    // https://github.com/Dart-Code/Dart-Code/issues/1125
    // if (status === TestStatus.Skipped)
    // 	return TestSortOrder.Bottom;
    return TestSortOrder.Middle;
}
class TreeNode {
    constructor(suiteData) {
        this.suiteData = suiteData;
        this.isStale = false;
        this._status = enums_1.TestStatus.Unknown; // tslint:disable-line:variable-name
        // To avoid the sort changing on every status change (stale, running, etc.) this
        // field will be the last status the user would care about (pass/fail/skip).
        // Default to Passed just so things default to the most likely (hopefully) place. This should
        // never be used for rendering; only sorting.
        this._sort = TestSortOrder.Middle; // tslint:disable-line:variable-name
        this.suiteRunNumber = 1;
        this.isPotentiallyDeleted = false;
    }
    get status() {
        return this._status;
    }
    set status(status) {
        this._status = status;
        this.description = undefined; // Clear old run duration.
        if (status === enums_1.TestStatus.Errored || status === enums_1.TestStatus.Failed
            || status === enums_1.TestStatus.Passed
            || status === enums_1.TestStatus.Skipped) {
            this.isStale = false;
            this.isPotentiallyDeleted = false;
            this._sort = getTestSortOrder(status);
        }
    }
    get hasFailures() {
        return this._status === enums_1.TestStatus.Errored || this._status === enums_1.TestStatus.Failed;
    }
    get sort() {
        return this._sort;
    }
}
exports.TreeNode = TreeNode;
class SuiteNode extends TreeNode {
    constructor(suiteData) {
        super(suiteData);
        this.groups = [];
        this.tests = [];
    }
    get label() { return undefined; }
    get testCount() {
        return this.children.map((t) => t.testCount)
            .reduce((total, value) => total + value, 0);
    }
    get testPassCount() {
        return this.children.map((t) => t.testPassCount)
            .reduce((total, value) => total + value, 0);
    }
    get duration() {
        return this.children
            .map((t) => t.duration)
            .filter(utils_1.notUndefined)
            .reduce((total, value) => total + value, 0);
    }
    get children() {
        // Children should be:
        // 1. All children of any of our phantom groups
        // 2. Our children excluding our phantom groups
        return [
            ...utils_1.flatMap(this.groups.filter((g) => g.isPhantomGroup), (g) => g.children),
            ...this.groups.filter((g) => !g.isPhantomGroup && !g.hidden),
            ...this.tests.filter((t) => !t.hidden),
        ];
    }
}
exports.SuiteNode = SuiteNode;
class GroupNode extends TreeNode {
    constructor(suiteData, parent, id, name, path, line, column) {
        super(suiteData);
        this.suiteData = suiteData;
        this.parent = parent;
        this.id = id;
        this.name = name;
        this.path = path;
        this.line = line;
        this.column = column;
        this.groups = [];
        this.tests = [];
    }
    get label() {
        return this.parent && this.parent instanceof GroupNode && this.parent.name && this.name && this.name.startsWith(`${this.parent.name} `)
            ? this.name.substr(this.parent.name.length + 1) // +1 because of the space (included above).
            : this.name || "<unnamed>";
    }
    get testCount() {
        return this.children.map((t) => t.testCount)
            .reduce((total, value) => total + value, 0);
    }
    get testPassCount() {
        return this.children.map((t) => t.testPassCount)
            .reduce((total, value) => total + value, 0);
    }
    get duration() {
        return this.children
            .map((t) => t.duration)
            .filter(utils_1.notUndefined)
            .reduce((total, value) => total + value, 0);
    }
    // TODO: Remove phatom groups from this model, and handle only in the test notification handler.
    get isPhantomGroup() {
        return !this.name && this.parent instanceof SuiteNode;
    }
    get hidden() {
        // If every child is hidden, we are hidden.
        return this.children.every((c) => (c instanceof GroupNode && c.hidden)
            || (c instanceof TestNode && c.hidden));
    }
    get children() {
        return []
            .concat(this.groups.filter((t) => !t.hidden))
            .concat(this.tests.filter((t) => !t.hidden));
    }
}
exports.GroupNode = GroupNode;
class TestNode extends TreeNode {
    // TODO: Flatten test into this class so we're not tied to the test protocol.
    constructor(suiteData, parent, id, name, path, line, column) {
        super(suiteData);
        this.suiteData = suiteData;
        this.parent = parent;
        this.id = id;
        this.name = name;
        this.path = path;
        this.line = line;
        this.column = column;
        this.outputEvents = [];
        this.hidden = false;
    }
    get label() {
        return this.parent && this.parent instanceof GroupNode && this.parent.name && this.name && this.name.startsWith(`${this.parent.name} `)
            ? this.name.substr(this.parent.name.length + 1) // +1 because of the space (included above).
            : (this.name || "<unnamed>");
    }
    get testCount() {
        return 1;
    }
    get testPassCount() {
        return this.status === enums_1.TestStatus.Passed ? 1 : 0;
    }
}
exports.TestNode = TestNode;
class TestTreeModel {
    constructor() {
        // Set this flag we know when a new run starts so we can show the tree; however
        // we can't show it until we render a node (we can only call reveal on a node) so
        // we need to delay this until the suite starts.
        this.isNewTestRun = true;
        this.nextFailureIsFirst = true;
        this.onDidChangeDataEmitter = new events_1.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeDataEmitter.event;
        // TODO: Make private?
        this.suites = {};
    }
    flagSuiteStart(suitePath, isRunningWholeSuite) {
        this.isNewTestRun = true;
        this.nextFailureIsFirst = true;
        if (suitePath && path.isAbsolute(suitePath)) {
            const suite = this.suites[fs_1.fsPath(suitePath)];
            if (suite) {
                // Mark all test for this suite as "stale" which will make them faded, so that results from
                // the "new" run are more obvious in the tree.
                suite.getAllGroups().forEach((g) => g.isStale = true);
                suite.getAllTests().forEach((t) => t.isStale = true);
                // When running the whole suite, we flag all tests as being potentially deleted
                // and then any tests that aren't run are removed from the tree. This is to ensure
                // if a test is renamed, we don't keep the old version of it in the test tree forever
                // since we don't have the necessary information to know the test was renamed.
                if (isRunningWholeSuite) {
                    if (suite) {
                        suite.getAllGroups().forEach((g) => g.isPotentiallyDeleted = true);
                        suite.getAllTests().forEach((t) => t.isPotentiallyDeleted = true);
                    }
                }
            }
        }
        // Also increase the currentRunNumber to ensure we know all results are from
        // the newest run.
        Object.values(this.suites).forEach((suite) => suite.node.suiteRunNumber++);
    }
    getOrCreateSuite(suitePath) {
        let suite = this.suites[suitePath];
        if (!suite) {
            suite = new SuiteData(suitePath);
            this.suites[suitePath] = suite;
            return [suite, true];
        }
        return [suite, false];
    }
    updateNode(node) {
        this.onDidChangeDataEmitter.fire(node);
    }
    updateSuiteStatuses(suite) {
        // Walk the tree to get the status.
        this.updateStatusFromChildren(suite.node);
        // Update top level list, as we could've changed order.
        this.updateNode();
    }
    updateStatusFromChildren(node) {
        const childStatuses = node.children.length
            ? node.children.filter((c) => (c instanceof GroupNode && !c.isPhantomGroup)
                || (c instanceof TestNode && !c.hidden)).map((c) => {
                if (c instanceof GroupNode)
                    return this.updateStatusFromChildren(c);
                if (c instanceof TestNode)
                    return c.status;
                return enums_1.TestStatus.Unknown;
            })
            : [enums_1.TestStatus.Unknown];
        const newStatus = Math.max(...childStatuses);
        if (newStatus !== node.status) {
            node.status = newStatus;
            this.updateNode(node);
        }
        node.description = `${node.testPassCount}/${node.testCount} passed, ${node.duration}ms`;
        return node.status;
    }
}
exports.TestTreeModel = TestTreeModel;
class SuiteData {
    constructor(suitePath) {
        this.groups = {};
        this.tests = {};
        this.path = suitePath;
        this.node = new SuiteNode(this);
    }
    get currentRunNumber() { return this.node.suiteRunNumber; }
    getAllGroups(includeHidden = false) {
        // Have to unique these, as we keep dupes in the lookup with the "old" IDs
        // so that stale nodes can still look up their parents.
        return utils_1.uniq(Object.keys(this.groups)
            .map((gKey) => this.groups[gKey])
            .filter((g) => includeHidden || (!g.hidden && !g.isPhantomGroup)));
    }
    getAllTests(includeHidden = false) {
        // Have to unique these, as we keep dupes in the lookup with the "old" IDs
        // so that stale nodes can still look up their parents.
        return utils_1.uniq(Object.keys(this.tests)
            .map((tKey) => this.tests[tKey])
            .filter((t) => includeHidden || !t.hidden));
    }
    getCurrentGroup(id) {
        return this.groups[`${this.currentRunNumber}_${id}`];
    }
    getCurrentTest(id) {
        return this.tests[`${this.currentRunNumber}_${id}`];
    }
    getMyGroup(suiteRunNumber, id) {
        return this.groups[`${suiteRunNumber}_${id}`];
    }
    getMyTest(suiteRunNumber, id) {
        return this.tests[`${suiteRunNumber}_${id}`];
    }
    storeGroup(node) {
        return this.groups[`${this.currentRunNumber}_${node.id}`] = node;
    }
    storeTest(node) {
        return this.tests[`${this.currentRunNumber}_${node.id}`] = node;
    }
    reuseMatchingGroup(currentSuiteRunNumber, group) {
        // To reuse a node, the name must match and it must have not been used for the current run.
        const matches = this.getAllGroups(true).filter((g) => g.name === group.name
            && g.suiteRunNumber !== currentSuiteRunNumber);
        // Reuse the one nearest to the source position.
        const sortedMatches = matches.sort((g1, g2) => Math.abs((g1.line || 0) - (group.line || 0)) - Math.abs((g2.line || 0) - (group.line || 0)));
        const match = sortedMatches.length ? sortedMatches[0] : undefined;
        if (match) {
            match.id = group.id;
            match.suiteRunNumber = this.currentRunNumber;
            this.storeGroup(match);
        }
        return match;
    }
    reuseMatchingTest(currentSuiteRunNumber, test) {
        // To reuse a node, the name must match and it must have not been used for the current run.
        const matches = this.getAllTests().filter((t) => t.name === test.name
            && t.suiteRunNumber !== currentSuiteRunNumber);
        // Reuse the one nearest to the source position.
        const sortedMatches = array_1.sortBy(matches, (t) => Math.abs((t.line || 0) - (test.line || 0)));
        const match = sortedMatches.length ? sortedMatches[0] : undefined;
        if (match) {
            match.id = test.id;
            match.suiteRunNumber = this.currentRunNumber;
            this.storeTest(match);
        }
        return match;
    }
}
exports.SuiteData = SuiteData;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.reportAnalyzerTerminatedWithError = exports.nullToUndefined = void 0;
const utils_1 = __webpack_require__(6);
function nullToUndefined(value) {
    return (value === null ? undefined : value);
}
exports.nullToUndefined = nullToUndefined;
let isShowingAnalyzerError = false;
function reportAnalyzerTerminatedWithError(duringStartup = false) {
    if (isShowingAnalyzerError)
        return;
    isShowingAnalyzerError = true;
    const message = duringStartup
        ? "The Dart Analyzer could not be started."
        : "The Dart Analyzer has terminated.";
    // tslint:disable-next-line: no-floating-promises
    utils_1.promptToReloadExtension(message, undefined, true).then(() => isShowingAnalyzerError = false);
}
exports.reportAnalyzerTerminatedWithError = reportAnalyzerTerminatedWithError;


/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                let result;
                result = {
                    dispose: () => {
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LspClassOutlineVisitor = exports.LspTestOutlineVisitor = exports.LspOutlineVisitor = void 0;
const test_1 = __webpack_require__(57);
class LspOutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.element && outline.element.kind) {
            case "CLASS":
                this.visitClass(outline);
                break;
            case "CLASS_TYPE_ALIAS":
                this.visitClassTypeAlias(outline);
                break;
            case "COMPILATION_UNIT":
                this.visitCompilationUnit(outline);
                break;
            case "CONSTRUCTOR":
                this.visitConstructor(outline);
                break;
            case "CONSTRUCTOR_INVOCATION":
                this.visitContructorInvocation(outline);
                break;
            case "ENUM":
                this.visitEnum(outline);
                break;
            case "ENUM_CONSTANT":
                this.visitEnumConstant(outline);
                break;
            case "FIELD":
                this.visitField(outline);
                break;
            case "FILE":
                this.visitFile(outline);
                break;
            case "FUNCTION":
                this.visitFunction(outline);
                break;
            case "FUNCTION_INVOCATION":
                this.visitFunctionInvocation(outline);
                break;
            case "FUNCTION_TYPE_ALIAS":
                this.visitFunctionTypeAlias(outline);
                break;
            case "GETTER":
                this.visitGetter(outline);
                break;
            case "LABEL":
                this.visitLabel(outline);
                break;
            case "LIBRARY":
                this.visitLibrary(outline);
                break;
            case "LOCAL_VARIABLE":
                this.visitLocalVariable(outline);
                break;
            case "METHOD":
                this.visitMethod(outline);
                break;
            case "MIXIN":
                this.visitMixin(outline);
                break;
            case "PARAMETER":
                this.visitParameter(outline);
                break;
            case "PREFIX":
                this.visitPrefix(outline);
                break;
            case "SETTER":
                this.visitSetter(outline);
                break;
            case "TOP_LEVEL_VARIABLE":
                this.visitTopLevelVariable(outline);
                break;
            case "TYPE_PARAMETER":
                this.visitTypeParameter(outline);
                break;
            case "UNIT_TEST_GROUP":
                this.visitUnitTestGroup(outline);
                break;
            case "UNIT_TEST_TEST":
                this.visitUnitTestTest(outline);
                break;
            case "UNKNOWN":
                this.visitUnknown(outline);
                break;
            default:
                this.logger.error(`Unknown Outline item! ${outline && outline.element && outline.element.kind}`);
        }
    }
    visitClass(outline) { this.visitChildren(outline); }
    visitClassTypeAlias(outline) { this.visitChildren(outline); }
    visitCompilationUnit(outline) { this.visitChildren(outline); }
    visitConstructor(outline) { this.visitChildren(outline); }
    visitContructorInvocation(outline) { this.visitChildren(outline); }
    visitEnum(outline) { this.visitChildren(outline); }
    visitEnumConstant(outline) { this.visitChildren(outline); }
    visitField(outline) { this.visitChildren(outline); }
    visitFile(outline) { this.visitChildren(outline); }
    visitFunction(outline) { this.visitChildren(outline); }
    visitFunctionInvocation(outline) { this.visitChildren(outline); }
    visitFunctionTypeAlias(outline) { this.visitChildren(outline); }
    visitGetter(outline) { this.visitChildren(outline); }
    visitLabel(outline) { this.visitChildren(outline); }
    visitLibrary(outline) { this.visitChildren(outline); }
    visitLocalVariable(outline) { this.visitChildren(outline); }
    visitMethod(outline) { this.visitChildren(outline); }
    visitMixin(outline) { this.visitChildren(outline); }
    visitParameter(outline) { this.visitChildren(outline); }
    visitPrefix(outline) { this.visitChildren(outline); }
    visitSetter(outline) { this.visitChildren(outline); }
    visitTopLevelVariable(outline) { this.visitChildren(outline); }
    visitTypeParameter(outline) { this.visitChildren(outline); }
    visitUnitTestGroup(outline) { this.visitChildren(outline); }
    visitUnitTestTest(outline) { this.visitChildren(outline); }
    visitUnknown(outline) { this.visitChildren(outline); }
}
exports.LspOutlineVisitor = LspOutlineVisitor;
class LspTestOutlineVisitor extends LspOutlineVisitor {
    constructor(logger, file) {
        super(logger);
        this.file = file;
        this.tests = [];
        this.names = [];
    }
    visitUnitTestTest(outline) {
        this.addTest(outline, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.addTest(outline, super.visitUnitTestGroup);
    }
    addTest(outline, base) {
        const name = test_1.extractTestNameFromOutline(outline.element.name);
        if (!name || !outline.element.range)
            return;
        this.names.push(name);
        const fullName = this.names.join(" ");
        const isGroup = outline.element.kind === "UNIT_TEST_GROUP";
        this.tests.push({
            file: this.file,
            fullName,
            isGroup,
            range: outline.codeRange || outline.range || (outline.element ? outline.element.range : undefined),
        });
        try {
            base.bind(this)(outline);
        }
        finally {
            this.names.pop();
        }
    }
}
exports.LspTestOutlineVisitor = LspTestOutlineVisitor;
class LspClassOutlineVisitor extends LspOutlineVisitor {
    constructor() {
        super(...arguments);
        this.classes = [];
    }
    visitClass(outline) {
        this.addClass(outline);
        super.visitClass(outline);
    }
    visitMixin(outline) {
        this.addClass(outline);
        super.visitMixin(outline);
    }
    addClass(outline) {
        if (!outline.element || !outline.element.range || !outline.element.name)
            return;
        this.classes.push({
            className: outline.element.name,
            codeRange: outline.codeRange,
            range: outline.range,
        });
    }
}
exports.LspClassOutlineVisitor = LspClassOutlineVisitor;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isTemplateOfType = exports.getTemplatedLaunchConfigs = void 0;
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const debugTypeTokenRegex = new RegExp(utils_1.escapeRegExp("${debugType}"), "gi");
function getTemplatedLaunchConfigs(document, fileType) {
    var _a, _b;
    const runConfigs = vscode_1.workspace.getConfiguration("launch", document.uri).get("configurations") || [];
    const wantedTemplateTypes = [`run-${fileType}`, `debug-${fileType}`];
    const filePath = fs_1.fsPath(document.uri);
    const workspaceUri = (_a = vscode_1.workspace.getWorkspaceFolder(document.uri)) === null || _a === void 0 ? void 0 : _a.uri;
    const workspacePath = workspaceUri ? fs_1.fsPath(workspaceUri) : undefined;
    // Loop through each launch config and add the relevant templates. Configs may be
    // added multiple times if they have multiple template types.
    const runFileTemplates = [];
    for (const templateType of wantedTemplateTypes) {
        const relevantLaunchConfigs = runConfigs
            .filter((c) => c.type === "dart" && isTemplateOfType(c, templateType))
            .filter((c) => { var _a, _b, _c; return ((_a = c.codeLens) === null || _a === void 0 ? void 0 : _a.path) && workspacePath ? fs_1.isWithinPath(filePath, path.join(workspacePath, (_b = c.codeLens) === null || _b === void 0 ? void 0 : _b.path)) : !((_c = c.codeLens) === null || _c === void 0 ? void 0 : _c.path); });
        for (const launchConfig of relevantLaunchConfigs) {
            runFileTemplates.push(Object.assign(Object.assign({}, launchConfig), { name: (((_b = launchConfig.codeLens) === null || _b === void 0 ? void 0 : _b.title) || launchConfig.name || "${debugType}").replace(debugTypeTokenRegex, templateType.startsWith("run-") ? "Run" : "Debug"), template: templateType }));
        }
    }
    return runFileTemplates;
}
exports.getTemplatedLaunchConfigs = getTemplatedLaunchConfigs;
function isTemplateOfType(config, templateType) {
    var _a;
    const template = ((_a = config.codeLens) === null || _a === void 0 ? void 0 : _a.for) || config.template;
    return !!template && ((typeof template === "string" && template === templateType)
        || (Array.isArray(template) && template.indexOf(templateType) !== -1));
}
exports.isTemplateOfType = isTemplateOfType;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.applyColor = exports.brightWhiteBackground = exports.brightCyanBackground = exports.brightMagentaBackground = exports.brightBlueBackground = exports.brightYellowBackground = exports.brightGreenBackground = exports.brightRedBackground = exports.brightBlackBackground = exports.whiteBackground = exports.cyanBackground = exports.magentaBackground = exports.blueBackground = exports.yellowBackground = exports.greenBackground = exports.redBackground = exports.blackBackground = exports.brightWhite = exports.brightCyan = exports.brightMagenta = exports.brightBlue = exports.brightYellow = exports.brightGreen = exports.brightRed = exports.brightBlack = exports.grey2 = exports.grey = exports.white = exports.cyan = exports.magenta = exports.blue = exports.yellow = exports.green = exports.red = exports.black = void 0;
const codeReset = "39;49";
const brightOffset = 8;
const codeFg = "38;5";
const codeBg = "48;5";
const codeBlack = 0;
const codeRed = 1;
const codeGreen = 2;
const codeYellow = 3;
const codeBlue = 4;
const codeMagenta = 5;
const codeCyan = 6;
const codeWhite = 7;
const codeGrey = 244;
const codeGrey2 = 248;
const esc = (...code) => `\u001B[${code.join(";")}m`;
const black = (msg) => `${esc(codeFg, codeBlack)}${msg}${esc(codeReset)}`;
exports.black = black;
const red = (msg) => `${esc(codeFg, codeRed)}${msg}${esc(codeReset)}`;
exports.red = red;
const green = (msg) => `${esc(codeFg, codeGreen)}${msg}${esc(codeReset)}`;
exports.green = green;
const yellow = (msg) => `${esc(codeFg, codeYellow)}${msg}${esc(codeReset)}`;
exports.yellow = yellow;
const blue = (msg) => `${esc(codeFg, codeBlue)}${msg}${esc(codeReset)}`;
exports.blue = blue;
const magenta = (msg) => `${esc(codeFg, codeMagenta)}${msg}${esc(codeReset)}`;
exports.magenta = magenta;
const cyan = (msg) => `${esc(codeFg, codeCyan)}${msg}${esc(codeReset)}`;
exports.cyan = cyan;
const white = (msg) => `${esc(codeFg, codeWhite)}${msg}${esc(codeReset)}`;
exports.white = white;
const grey = (msg) => `${esc(codeFg, codeGrey)}${msg}${esc(codeReset)}`;
exports.grey = grey;
const grey2 = (msg) => `${esc(codeFg, codeGrey2)}${msg}${esc(codeReset)}`;
exports.grey2 = grey2;
const brightBlack = (msg) => `${esc(codeFg, codeBlack + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightBlack = brightBlack;
const brightRed = (msg) => `${esc(codeFg, codeRed + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightRed = brightRed;
const brightGreen = (msg) => `${esc(codeFg, codeGreen + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightGreen = brightGreen;
const brightYellow = (msg) => `${esc(codeFg, codeYellow + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightYellow = brightYellow;
const brightBlue = (msg) => `${esc(codeFg, codeBlue + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightBlue = brightBlue;
const brightMagenta = (msg) => `${esc(codeFg, codeMagenta + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightMagenta = brightMagenta;
const brightCyan = (msg) => `${esc(codeFg, codeCyan + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightCyan = brightCyan;
const brightWhite = (msg) => `${esc(codeFg, codeWhite + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightWhite = brightWhite;
const blackBackground = (msg) => `${esc(codeBg, codeBlack + brightOffset)}${msg}${esc(codeReset)}`;
exports.blackBackground = blackBackground;
const redBackground = (msg) => `${esc(codeBg, codeRed)}${msg}${esc(codeReset)}`;
exports.redBackground = redBackground;
const greenBackground = (msg) => `${esc(codeBg, codeGreen)}${msg}${esc(codeReset)}`;
exports.greenBackground = greenBackground;
const yellowBackground = (msg) => `${esc(codeBg, codeYellow)}${msg}${esc(codeReset)}`;
exports.yellowBackground = yellowBackground;
const blueBackground = (msg) => `${esc(codeBg, codeBlue)}${msg}${esc(codeReset)}`;
exports.blueBackground = blueBackground;
const magentaBackground = (msg) => `${esc(codeBg, codeMagenta)}${msg}${esc(codeReset)}`;
exports.magentaBackground = magentaBackground;
const cyanBackground = (msg) => `${esc(codeBg, codeCyan)}${msg}${esc(codeReset)}`;
exports.cyanBackground = cyanBackground;
const whiteBackground = (msg) => `${esc(codeBg, codeWhite)}${msg}${esc(codeReset)}`;
exports.whiteBackground = whiteBackground;
const brightBlackBackground = (msg) => `${esc(codeBg, codeBlack + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightBlackBackground = brightBlackBackground;
const brightRedBackground = (msg) => `${esc(codeBg, codeRed + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightRedBackground = brightRedBackground;
const brightGreenBackground = (msg) => `${esc(codeBg, codeGreen + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightGreenBackground = brightGreenBackground;
const brightYellowBackground = (msg) => `${esc(codeBg, codeYellow + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightYellowBackground = brightYellowBackground;
const brightBlueBackground = (msg) => `${esc(codeBg, codeBlue + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightBlueBackground = brightBlueBackground;
const brightMagentaBackground = (msg) => `${esc(codeBg, codeMagenta + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightMagentaBackground = brightMagentaBackground;
const brightCyanBackground = (msg) => `${esc(codeBg, codeCyan + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightCyanBackground = brightCyanBackground;
const brightWhiteBackground = (msg) => `${esc(codeBg, codeWhite + brightOffset)}${msg}${esc(codeReset)}`;
exports.brightWhiteBackground = brightWhiteBackground;
const whitespacePattern = new RegExp(`^(\\s*)(\\S.*\\S)(\\s*)$`);
/// Applies a color function to a string, but leaves leading/trailing whitespace outside
/// of the color codes. This is mainly used because if trailing newlines fall inside the message
/// when sending OutputEvents() to VS Code, it won't allow source locations to be attached (since
/// they can only be attached to single-line messages).
function applyColor(text, color) {
    const match = text && whitespacePattern.exec(text);
    if (!match)
        return color(text);
    return `${match[1]}${color(match[2])}${match[3]}`;
}
exports.applyColor = applyColor;


/***/ }),
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DartCapabilities = void 0;
const utils_1 = __webpack_require__(3);
class DartCapabilities {
    constructor(dartVersion) {
        this.version = dartVersion;
    }
    static get empty() { return new DartCapabilities("0.0.0"); }
    // This is also missing in v2.10, but assume it will be back in v2.11.
    // https://github.com/dart-lang/sdk/issues/43207
    get includesSourceForSdkLibs() { return utils_1.versionIsAtLeast(this.version, "2.2.1") && !this.version.startsWith("2.10."); }
    get supportsWriteServiceInfo() { return utils_1.versionIsAtLeast(this.version, "2.7.1"); }
    get supportsDebugInternalLibraries() { return utils_1.versionIsAtLeast(this.version, "2.9.0-a"); }
    get supportsPubOutdated() { return utils_1.versionIsAtLeast(this.version, "2.8.0-a"); }
    get supportsDartPub() { return utils_1.versionIsAtLeast(this.version, "2.12.0-0"); }
    get supportsDartRunTest() { return utils_1.versionIsAtLeast(this.version, "2.12.0-0"); }
    // TODO: Update these (along with Flutter) when supported.
    get webSupportsEvaluation() { return false; }
    get webSupportsDebugging() { return true; }
    get webSupportsHotReload() { return false; }
}
exports.DartCapabilities = DartCapabilities;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(16)
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(24).SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(9),
  compareIdentifiers: __webpack_require__(32).compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(32).rcompareIdentifiers,
  parse: __webpack_require__(17),
  valid: __webpack_require__(74),
  clean: __webpack_require__(75),
  inc: __webpack_require__(76),
  diff: __webpack_require__(77),
  major: __webpack_require__(78),
  minor: __webpack_require__(79),
  patch: __webpack_require__(80),
  prerelease: __webpack_require__(81),
  compare: __webpack_require__(11),
  rcompare: __webpack_require__(82),
  compareLoose: __webpack_require__(83),
  compareBuild: __webpack_require__(34),
  sort: __webpack_require__(84),
  rsort: __webpack_require__(85),
  gt: __webpack_require__(27),
  lt: __webpack_require__(35),
  eq: __webpack_require__(33),
  neq: __webpack_require__(47),
  gte: __webpack_require__(36),
  lte: __webpack_require__(37),
  cmp: __webpack_require__(48),
  coerce: __webpack_require__(86),
  Comparator: __webpack_require__(28),
  Range: __webpack_require__(12),
  satisfies: __webpack_require__(29),
  toComparators: __webpack_require__(90),
  maxSatisfying: __webpack_require__(91),
  minSatisfying: __webpack_require__(92),
  minVersion: __webpack_require__(93),
  validRange: __webpack_require__(94),
  outside: __webpack_require__(38),
  gtr: __webpack_require__(95),
  ltr: __webpack_require__(96),
  intersects: __webpack_require__(97),
  simplifyRange: __webpack_require__(98),
  subset: __webpack_require__(99),
}


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(17)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(17)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(17)
const eq = __webpack_require__(33)

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(17)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(11)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

const compare = __webpack_require__(11)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

const compareBuild = __webpack_require__(34)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

const compareBuild = __webpack_require__(34)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const parse = __webpack_require__(17)
const {re, t} = __webpack_require__(16)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(88)

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(89)(Yallist)
} catch (er) {}


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(12)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const Range = __webpack_require__(12)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const Range = __webpack_require__(12)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer = __webpack_require__(9)
const Range = __webpack_require__(12)
const gt = __webpack_require__(27)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin)))
      minver = setMin
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(12)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(38)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

const outside = __webpack_require__(38)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(12)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(29)
const compare = __webpack_require__(11)
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

const Range = __webpack_require__(12)
const { ANY } = __webpack_require__(28)
const satisfies = __webpack_require__(29)
const compare = __webpack_require__(11)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else return false
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
// - If any C is a = range, and GT or LT are set, return false
// - Else return true

const subset = (sub, dom, options) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY)
    return dom.length === 1 && dom[0].semver === ANY

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasDartAnalysisServer = exports.referencesBuildRunner = exports.referencesFlutterSdk = exports.SdkUtils = void 0;
const fs = __webpack_require__(7);
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const logging_1 = __webpack_require__(13);
const package_map_1 = __webpack_require__(52);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const promises_1 = __webpack_require__(31);
const workspace_1 = __webpack_require__(154);
const utils_2 = __webpack_require__(5);
const workspace_2 = __webpack_require__(155);
const config_1 = __webpack_require__(10);
const extension_1 = __webpack_require__(40);
const utils_3 = __webpack_require__(6);
const flutter_1 = __webpack_require__(156);
// TODO: Tidy this class up (it exists mainly to share logger).
class SdkUtils {
    constructor(logger) {
        this.logger = logger;
        this.hasShownActivationFailure = false;
    }
    handleMissingSdks(context, analytics, workspaceContext) {
        // Note: This code only runs if we fail to find the Dart SDK, or fail to find the Flutter SDK
        // and are in a Flutter project. In the case where we fail to find the Flutter SDK but are not
        // in a Flutter project (eg. we ran Flutter Doctor without the extension activated) then
        // this code will not be run as the extension will activate normally, and then the command-handling
        // code for each command will detect the missing Flutter SDK and respond appropriately.
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.createProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.createProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("dart.createProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, false, "dart.createProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("_dart.flutter.createSampleProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "_dart.flutter.createSampleProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.doctor", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.doctor");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.upgrade", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.upgrade");
        }));
        // Wait a while before showing the error to allow the code above to have run if it will.
        setTimeout(() => {
            // Only show the "startup" message if we didn't already show another message as
            // a result of one of the above commands beinv invoked.
            if (!this.hasShownActivationFailure) {
                if (workspaceContext.hasAnyFlutterProjects) {
                    this.showRelevantActivationFailureMessage(analytics, workspaceContext, true);
                }
                else if (workspaceContext.hasAnyStandardDartProjects) {
                    this.showRelevantActivationFailureMessage(analytics, workspaceContext, false);
                }
                else {
                    this.logger.error("No Dart or Flutter SDK was found. Suppressing prompt because it doesn't appear that a Dart/Flutter project is open.");
                }
            }
        }, 500);
        return;
    }
    showRelevantActivationFailureMessage(analytics, workspaceContext, isFlutter, commandToReRun) {
        if (isFlutter && workspaceContext.sdks.flutter && !workspaceContext.sdks.dart) {
            this.showFluttersDartSdkActivationFailure();
        }
        else if (isFlutter) {
            this.showFlutterActivationFailure(commandToReRun);
        }
        else {
            this.showDartActivationFailure(commandToReRun);
        }
        if (!this.hasShownActivationFailure) {
            analytics.logSdkDetectionFailure();
            this.hasShownActivationFailure = true;
        }
    }
    showFluttersDartSdkActivationFailure() {
        // tslint:disable-next-line: no-floating-promises
        utils_3.promptToReloadExtension("Could not find Dart in your Flutter SDK. " +
            "Please run 'flutter doctor' in the terminal then reload the project once all issues are resolved.", "Reload", // eslint-disable-line @typescript-eslint/indent
        true);
    }
    showFlutterActivationFailure(commandToReRun) {
        // tslint:disable-next-line: no-floating-promises
        this.showSdkActivationFailure("Flutter", (p) => this.findFlutterSdk(p), constants_1.FLUTTER_DOWNLOAD_URL, (p) => config_1.config.setGlobalFlutterSdkPath(p), commandToReRun);
    }
    showDartActivationFailure(commandToReRun) {
        // tslint:disable-next-line: no-floating-promises
        this.showSdkActivationFailure("Dart", (p) => this.findDartSdk(p), constants_1.DART_DOWNLOAD_URL, (p) => config_1.config.setGlobalDartSdkPath(p), commandToReRun);
    }
    showSdkActivationFailure(sdkType, search, downloadUrl, saveSdkPath, commandToReRun) {
        return __awaiter(this, void 0, void 0, function* () {
            const locateAction = "Locate SDK";
            const downloadAction = "Download SDK";
            let displayMessage = `Could not find a ${sdkType} SDK. ` +
                `Please ensure ${sdkType.toLowerCase()} is installed and in your PATH (you may need to restart).`;
            while (true) {
                const ringLogContents = extension_1.ringLog.toString();
                const selectedItem = yield vscode_1.window.showErrorMessage(displayMessage, locateAction, downloadAction, constants_1.showLogAction);
                // TODO: Refactor/reformat/comment this code - it's messy and hard to understand!
                if (selectedItem === locateAction) {
                    const selectedFolders = yield vscode_1.window.showOpenDialog({ canSelectFolders: true, openLabel: `Set ${sdkType} SDK folder` });
                    if (selectedFolders && selectedFolders.length > 0) {
                        const matchingSdkFolder = search(selectedFolders.map(fs_1.fsPath));
                        if (matchingSdkFolder) {
                            yield saveSdkPath(matchingSdkFolder);
                            yield utils_3.promptToReloadExtension();
                            if (commandToReRun) {
                                vscode_1.commands.executeCommand(commandToReRun);
                            }
                            break;
                        }
                        else {
                            displayMessage = `That folder does not appear to be a ${sdkType} SDK.`;
                        }
                    }
                }
                else if (selectedItem === downloadAction) {
                    yield utils_2.envUtils.openInBrowser(downloadUrl);
                    break;
                }
                else if (selectedItem === constants_1.showLogAction) {
                    utils_3.openLogContents(undefined, ringLogContents);
                    break;
                }
                else {
                    break;
                }
            }
        });
    }
    scanWorkspace(useLsp) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info("Searching for SDKs...");
            const pathOverride = process.env.DART_PATH_OVERRIDE || "";
            const normalPath = process.env.PATH || "";
            const paths = (pathOverride + path.delimiter + normalPath).split(path.delimiter).filter((p) => p);
            this.logger.info("Environment PATH:");
            for (const p of paths)
                this.logger.info(`    ${p}`);
            // If we are running the analyzer remotely over SSH, we only support an analyzer, since none
            // of the other SDKs will work remotely. Also, there is no need to validate the sdk path,
            // since that file will exist on a remote machine.
            if (config_1.config.analyzerSshHost) {
                return new workspace_2.WorkspaceContext({
                    dart: config_1.config.sdkPath,
                    dartSdkIsFromFlutter: false,
                    flutter: undefined,
                }, {}, false, false, false, false);
            }
            // TODO: This has gotten very messy and needs tidying up...
            let firstFlutterMobileProject;
            let hasAnyFlutterProject = false;
            let hasAnyFlutterMobileProject = false;
            let hasAnyWebProject = false;
            let hasAnyStandardDartProject = false;
            const workspaceFolders = utils_2.getDartWorkspaceFolders();
            const topLevelFolders = workspaceFolders.map((w) => fs_1.fsPath(w.uri));
            const allExcludedFolders = utils_1.flatMap(workspaceFolders, utils_3.getExcludedFolders);
            const possibleProjects = yield fs_1.findProjectFolders(this.logger, topLevelFolders, allExcludedFolders);
            // Scan through them all to figure out what type of projects we have.
            for (const folder of possibleProjects) {
                const hasPubspecFile = fs_1.hasPubspec(folder);
                const refsFlutter = hasPubspecFile && referencesFlutterSdk(folder);
                const refsWeb = false; // hasPubspecFile && referencesWeb(folder);
                const hasFlutterCreateProjectTriggerFile = fs.existsSync(path.join(folder, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE));
                // Special case to detect the Flutter repo root, so we always consider it a Flutter project and will use the local SDK
                const isFlutterRepo = fs.existsSync(path.join(folder, "bin/flutter")) && fs.existsSync(path.join(folder, "bin/cache/dart-sdk"));
                // Since we just blocked on a lot of sync FS, yield.
                yield promises_1.resolvedPromise;
                const isSomethingFlutter = refsFlutter || hasFlutterCreateProjectTriggerFile || isFlutterRepo;
                if (isSomethingFlutter) {
                    this.logger.info(`Found Flutter project at ${folder}:
			Mobile? ${refsFlutter}
			Web? ${refsWeb}
			Create Trigger? ${hasFlutterCreateProjectTriggerFile}
			Flutter Repo? ${isFlutterRepo}`);
                }
                // Track the first Flutter Project so we can try finding the Flutter SDK from its packages file.
                firstFlutterMobileProject = firstFlutterMobileProject || (isSomethingFlutter ? folder : undefined);
                // Set some flags we'll use to construct the workspace, so we know what things we need to light up.
                hasAnyFlutterProject = hasAnyFlutterProject || isSomethingFlutter;
                hasAnyFlutterMobileProject = hasAnyFlutterMobileProject || refsFlutter || hasFlutterCreateProjectTriggerFile;
                hasAnyWebProject = hasAnyWebProject || refsWeb;
                hasAnyStandardDartProject = hasAnyStandardDartProject || (!isSomethingFlutter && hasPubspecFile);
            }
            // Certain types of workspaces will have special config, so read them here.
            const workspaceConfig = { useLsp };
            // Helper that searches for a specific folder/file up the tree and
            // runs some specific processing.
            const processWorkspaceType = (search, process) => __awaiter(this, void 0, void 0, function* () {
                for (const folder of topLevelFolders) {
                    const root = yield search(this.logger, folder);
                    if (root) {
                        process(this.logger, workspaceConfig, root);
                        return root;
                    }
                }
                return undefined;
            });
            yield processWorkspaceType(findGitRoot, workspace_1.processKnownGitRepositories);
            // TODO: Remove this lambda when the preview flag is removed.
            yield processWorkspaceType(findBazelWorkspaceRoot, (l, c, b) => workspace_1.processBazelWorkspace(l, c, b, config_1.config.previewBazelWorkspaceCustomScripts));
            const fuchsiaRoot = yield processWorkspaceType(findFuchsiaRoot, workspace_1.processFuchsiaWorkspace);
            yield processWorkspaceType(findFlutterSnapSdkRoot, workspace_1.processFlutterSnap);
            if (fuchsiaRoot) {
                this.logger.info(`Found Fuchsia root at ${fuchsiaRoot}`);
                if (hasAnyStandardDartProject)
                    this.logger.info(`Found Fuchsia project that is not vanilla Flutter`);
            }
            const flutterSdkSearchPaths = [
                workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterSdkHome,
                config_1.config.flutterSdkPath,
                // TODO: These could move into processFuchsiaWorkspace and be set on the config?
                fuchsiaRoot && path.join(fuchsiaRoot, "lib/flutter"),
                fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart-pkg/git/flutter"),
                firstFlutterMobileProject,
                firstFlutterMobileProject && extractFlutterSdkPathFromPackagesFile(firstFlutterMobileProject),
                firstFlutterMobileProject && path.join(firstFlutterMobileProject, ".flutter"),
                firstFlutterMobileProject && path.join(firstFlutterMobileProject, "vendor/flutter"),
                process.env.FLUTTER_ROOT,
                constants_1.isLinux ? "~/snap/flutter/common/flutter" : undefined,
            ].concat(paths).filter(utils_1.notUndefined);
            const flutterSdkPath = this.findFlutterSdk(flutterSdkSearchPaths);
            // Since we just blocked on a lot of sync FS, yield.
            yield promises_1.resolvedPromise;
            const dartSdkSearchPaths = [
                constants_1.isMac ? workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.dartSdkHomeMac : workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.dartSdkHomeLinux,
                // TODO: These could move into processFuchsiaWorkspace and be set on the config?
                fuchsiaRoot && path.join(fuchsiaRoot, "topaz/tools/prebuilt-dart-sdk", `${constants_1.dartPlatformName}-x64`),
                fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart/tools/sdks/dart-sdk"),
                fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart/tools/sdks", constants_1.dartPlatformName, "dart-sdk"),
                fuchsiaRoot && path.join(fuchsiaRoot, "dart/tools/sdks", constants_1.dartPlatformName, "dart-sdk"),
                firstFlutterMobileProject && flutterSdkPath && path.join(flutterSdkPath, "bin/cache/dart-sdk"),
                config_1.config.sdkPath,
            ].concat(paths)
                // The above array only has the Flutter SDK	in the search path if we KNOW it's a flutter
                // project, however this doesn't cover the activating-to-run-flutter.createProject so
                // we need to always look in the flutter SDK, but only AFTER the users PATH so that
                // we don't prioritise it over any real Dart versions.
                .concat([flutterSdkPath && path.join(flutterSdkPath, "bin/cache/dart-sdk")])
                .filter(utils_1.notUndefined);
            const dartSdkPath = this.findDartSdk(dartSdkSearchPaths);
            // Since we just blocked on a lot of sync FS, yield.
            yield promises_1.resolvedPromise;
            // If we're a Flutter workspace but we couldn't get the version, try running Flutter to initialise it first.
            if (hasAnyFlutterProject && flutterSdkPath) {
                const flutterNeedsInitializing = !fs_1.getSdkVersion(this.logger, { sdkRoot: flutterSdkPath, versionFile: workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterVersionFile })
                    || !fs.existsSync(path.join(flutterSdkPath, "bin/cache/dart-sdk"));
                if (flutterNeedsInitializing)
                    yield flutter_1.initializeFlutterSdk(this.logger, path.join(flutterSdkPath, constants_1.flutterPath));
            }
            return new workspace_2.WorkspaceContext({
                dart: dartSdkPath,
                dartSdkIsFromFlutter: !!dartSdkPath && utils_1.isDartSdkFromFlutter(dartSdkPath),
                dartVersion: fs_1.getSdkVersion(this.logger, { sdkRoot: dartSdkPath }),
                flutter: flutterSdkPath,
                flutterVersion: fs_1.getSdkVersion(this.logger, { sdkRoot: flutterSdkPath, versionFile: workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterVersionFile }),
            }, workspaceConfig, hasAnyFlutterMobileProject, hasAnyWebProject, hasAnyStandardDartProject, !!fuchsiaRoot && hasAnyStandardDartProject);
        });
    }
    findDartSdk(folders) {
        return this.searchPaths(folders, constants_1.executableNames.dart, (p) => this.hasExecutable(p, constants_1.dartVMPath) && exports.hasDartAnalysisServer(p));
    }
    findFlutterSdk(folders) {
        return this.searchPaths(folders, constants_1.executableNames.flutter, (p) => this.hasExecutable(p, constants_1.flutterPath));
    }
    hasExecutable(folder, executablePath) {
        const fullPath = path.join(folder, executablePath);
        return fs.existsSync(fullPath) && fs.statSync(fullPath).isFile();
    }
    searchPaths(paths, executableFilename, postFilter) {
        this.logger.info(`Searching for ${executableFilename}`);
        let sdkPaths = paths
            .filter((p) => p)
            .map(utils_3.resolvePaths)
            .filter(utils_1.notUndefined);
        // Any that don't end with bin, add it on (as an extra path) since some of our
        // paths may come from places that don't already include it (for ex. the
        // user config.sdkPath).
        const isBinFolder = (f) => ["bin", "sbin"].indexOf(path.basename(f)) !== -1;
        sdkPaths = utils_1.flatMap(sdkPaths, (p) => isBinFolder(p) ? [p] : [p, path.join(p, "bin")]);
        // Add on the executable name, as we need to do filtering based on the resolve path.
        // TODO: Make the list unique, but preserve the order of the first occurrences. We currently
        // have uniq() and unique(), so also consolidate them.
        this.logger.info(`    Looking for ${executableFilename} in:`);
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        // Restrict only to the paths that have the executable.
        sdkPaths = sdkPaths.filter((p) => fs.existsSync(path.join(p, executableFilename)));
        this.logger.info(`    Found at:`);
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        // Convert all the paths to their resolved locations.
        sdkPaths = sdkPaths.map((p) => {
            const fullPath = path.join(p, executableFilename);
            // In order to handle symlinks on the binary (not folder), we need to add the executableName before calling realpath.
            const realExecutableLocation = p && fs.realpathSync(fullPath);
            if (realExecutableLocation.toLowerCase() !== fullPath.toLowerCase())
                this.logger.info(`Following symlink: ${fullPath} ==> ${realExecutableLocation}`);
            // Then we need to take the executable name and /bin back off
            return path.dirname(path.dirname(realExecutableLocation));
        });
        // Now apply any post-filters.
        this.logger.info("    Candidate paths to be post-filtered:");
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        const sdkPath = sdkPaths.find(postFilter || (() => true));
        if (sdkPath)
            this.logger.info(`    Found at ${sdkPath}`);
        this.logger.info(`    Returning SDK path ${sdkPath} for ${executableFilename}`);
        return sdkPath;
    }
}
exports.SdkUtils = SdkUtils;
function referencesFlutterSdk(folder) {
    if (folder && fs_1.hasPubspec(folder)) {
        const regex = new RegExp("sdk\\s*:\\s*flutter", "i");
        return regex.test(fs.readFileSync(path.join(folder, "pubspec.yaml")).toString());
    }
    return false;
}
exports.referencesFlutterSdk = referencesFlutterSdk;
function referencesBuildRunner(folder) {
    if (folder && fs_1.hasPubspec(folder)) {
        const regex = new RegExp("build_runner\\s*:", "i");
        return regex.test(fs.readFileSync(path.join(folder, "pubspec.yaml")).toString());
    }
    return false;
}
exports.referencesBuildRunner = referencesBuildRunner;
function extractFlutterSdkPathFromPackagesFile(projectFolder) {
    if (!fs.existsSync(projectFolder))
        return undefined;
    let packagePath = package_map_1.PackageMap.loadForProject(logging_1.nullLogger, projectFolder).getPackagePath("flutter");
    if (!packagePath)
        return undefined;
    // Set windows slashes to / while manipulating.
    if (constants_1.isWin) {
        packagePath = packagePath.replace(/\\/g, "/");
    }
    // Make sure ends with a slash.
    if (!packagePath.endsWith("/"))
        packagePath = packagePath + "/";
    // Trim suffix we don't need.
    const pathSuffix = "/packages/flutter/lib/";
    if (packagePath.endsWith(pathSuffix)) {
        packagePath = packagePath.substr(0, packagePath.length - pathSuffix.length);
    }
    // Make sure ends with a slash.
    if (!packagePath.endsWith("/"))
        packagePath = packagePath + "/";
    // Append bin if required.
    if (!packagePath.endsWith("/bin/")) {
        packagePath = packagePath + "bin/";
    }
    // Set windows paths back.
    if (constants_1.isWin) {
        packagePath = packagePath.replace(/\//g, "\\");
        if (packagePath.startsWith("\\"))
            packagePath = packagePath.substring(1);
    }
    return packagePath;
}
function findFuchsiaRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, ".jiri_root");
    });
}
function findBazelWorkspaceRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, "WORKSPACE", true);
    });
}
function findGitRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, ".git");
    });
}
function findFlutterSnapSdkRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        if (constants_1.isLinux && fs.existsSync(constants_1.flutterSnapScript)) {
            logger.info(`Found Flutter snap script`);
            const snapSdkRoot = path.join(os.homedir(), "/snap/flutter/common/flutter");
            if (!fs.existsSync(snapSdkRoot + "/.git")) {
                logger.info(`Flutter snap is not initialized, showing prompt`);
                yield flutter_1.initializeFlutterSdk(logger, constants_1.flutterSnapScript, constants_1.initializeSnapPrompt);
            }
            if (fs.existsSync(snapSdkRoot + "/.git")) {
                logger.info(`Returning ${snapSdkRoot} as Flutter snap SDK root`);
                return snapSdkRoot;
            }
        }
        return undefined;
    });
}
function findRootContaining(folder, childName, expectFile = false) {
    if (folder) {
        // Walk up the directories from the workspace root, and see if there
        // exists a directory which has `childName` file/directory as a child.
        let child = folder;
        while (child) {
            try {
                const stat = fs.statSync(path.join(child, childName));
                if (expectFile ? stat.isFile() : stat.isDirectory()) {
                    return child;
                }
            }
            catch (_a) { }
            const parentDir = path.dirname(child);
            if (child === parentDir)
                break;
            child = parentDir;
        }
    }
    return undefined;
}
const hasDartAnalysisServer = (folder) => fs.existsSync(path.join(folder, constants_1.analyzerSnapshotPath));
exports.hasDartAnalysisServer = hasDartAnalysisServer;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const cp = __webpack_require__(49);
const fs = __webpack_require__(7);
const SemVer = __webpack_require__(160);
const client_1 = __webpack_require__(22);
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const colorProvider_1 = __webpack_require__(183);
const configuration_1 = __webpack_require__(184);
const implementation_1 = __webpack_require__(185);
const typeDefinition_1 = __webpack_require__(186);
const workspaceFolders_1 = __webpack_require__(187);
const foldingRange_1 = __webpack_require__(188);
const declaration_1 = __webpack_require__(189);
const selectionRange_1 = __webpack_require__(190);
const progress_1 = __webpack_require__(191);
const callHierarchy_proposed_1 = __webpack_require__(192);
const semanticTokens_proposed_1 = __webpack_require__(193);
const Is = __webpack_require__(56);
const processes_1 = __webpack_require__(194);
__export(__webpack_require__(22));
const REQUIRED_VSCODE_VERSION = '^1.41.0'; // do not change format, updated by `updateVSCode` script
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === 'boolean';
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends client_1.BaseLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === void 0) {
            forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        try {
            this.checkVersion();
        }
        catch (error) {
            if (Is.string(error.message)) {
                this.outputChannel.appendLine(error.message);
            }
            throw error;
        }
    }
    checkVersion() {
        let codeVersion = SemVer.parse(vscode_1.version);
        if (!codeVersion) {
            throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        // Remove the insider pre-release since we stay API compatible.
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
            codeVersion.prerelease = [];
        }
        if (!SemVer.satisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
            throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
    }
    stop() {
        return super.stop().then(() => {
            if (this._serverProcess) {
                let toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === void 0 || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        });
    }
    checkProcessDied(childProcess) {
        if (!childProcess) {
            return;
        }
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
                // All is fine.
            }
        }, 2000);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        super.handleConnectionClosed();
    }
    createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
            if (!env && !fork) {
                return undefined;
            }
            let result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            if (fork) {
                result['ELECTRON_RUN_AS_NODE'] = '1';
                result['ELECTRON_NO_ASAR'] = '1';
            }
            if (env) {
                Object.keys(env).forEach(key => result[key] = env[key]);
            }
            return result;
        }
        const debugStartWith = ['--debug=', '--debug-brk=', '--inspect=', '--inspect-brk='];
        const debugEquals = ['--debug', '--debug-brk', '--inspect', '--inspect-brk'];
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some((arg) => {
                    return debugStartWith.some(value => arg.startsWith(value)) ||
                        debugEquals.some(value => arg === value);
                });
            }
            return false;
        }
        function assertStdio(process) {
            if (process.stdin === null || process.stdout === null || process.stderr === null) {
                throw new Error('Process created without stdio streams');
            }
        }
        let server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then((result) => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return { reader: new vscode_languageserver_protocol_1.StreamMessageReader(result.reader), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(result.writer) };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    return { reader: new vscode_languageserver_protocol_1.StreamMessageReader(cp.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(cp.stdin) };
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            if (this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                if (node.runtime) {
                    let args = [];
                    let options = node.options || Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(element => args.push(element));
                    }
                    args.push(node.module);
                    if (node.args) {
                        node.args.forEach(element => args.push(element));
                    }
                    let execOptions = Object.create(null);
                    execOptions.cwd = serverWorkingDir;
                    execOptions.env = getEnvironment(options.env, false);
                    let pipeName = undefined;
                    if (transport === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions.stdio = [null, null, null, 'ipc'];
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();
                        args.push(`--pipe=${pipeName}`);
                    }
                    else if (Transport.isSocket(transport)) {
                        args.push(`--socket=${transport.port}`);
                    }
                    args.push(`--clientProcessId=${process.pid.toString()}`);
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        let serverProcess = cp.spawn(node.runtime, args, execOptions);
                        if (!serverProcess || !serverProcess.pid) {
                            return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        if (transport === TransportKind.ipc) {
                            serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return Promise.resolve({ reader: new vscode_languageserver_protocol_1.IPCMessageReader(serverProcess), writer: new vscode_languageserver_protocol_1.IPCMessageWriter(serverProcess) });
                        }
                        else {
                            return Promise.resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });
                        }
                    }
                    else if (transport === TransportKind.pipe) {
                        return vscode_languageserver_protocol_1.createClientPipeTransport(pipeName).then((transport) => {
                            let process = cp.spawn(node.runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                    else if (Transport.isSocket(transport)) {
                        return vscode_languageserver_protocol_1.createClientSocketTransport(transport.port).then((transport) => {
                            let process = cp.spawn(node.runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                }
                else {
                    let pipeName = undefined;
                    return new Promise((resolve, _reject) => {
                        let args = node.args && node.args.slice() || [];
                        if (transport === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (transport === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        else if (transport === TransportKind.pipe) {
                            pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();
                            args.push(`--pipe=${pipeName}`);
                        }
                        else if (Transport.isSocket(transport)) {
                            args.push(`--socket=${transport.port}`);
                        }
                        args.push(`--clientProcessId=${process.pid.toString()}`);
                        let options = node.options || Object.create(null);
                        options.env = getEnvironment(options.env, true);
                        options.execArgv = options.execArgv || [];
                        options.cwd = serverWorkingDir;
                        options.silent = true;
                        if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                            let sp = cp.fork(node.module, args || [], options);
                            assertStdio(sp);
                            this._serverProcess = sp;
                            sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            if (transport === TransportKind.ipc) {
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                resolve({ reader: new vscode_languageserver_protocol_1.IPCMessageReader(this._serverProcess), writer: new vscode_languageserver_protocol_1.IPCMessageWriter(this._serverProcess) });
                            }
                            else {
                                resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(sp.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(sp.stdin) });
                            }
                        }
                        else if (transport === TransportKind.pipe) {
                            vscode_languageserver_protocol_1.createClientPipeTransport(pipeName).then((transport) => {
                                let sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                });
                            });
                        }
                        else if (Transport.isSocket(transport)) {
                            vscode_languageserver_protocol_1.createClientSocketTransport(transport.port).then((transport) => {
                                let sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                });
                            });
                        }
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                let command = json;
                let args = command.args || [];
                let options = Object.assign({}, command.options);
                options.cwd = options.cwd || serverWorkingDir;
                let serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                    return Promise.reject(`Launching server using command ${command.command} failed.`);
                }
                serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                return Promise.resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });
            }
            return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        });
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
    }
    _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
            cwd = this.clientOptions.workspaceFolder
                ? this.clientOptions.workspaceFolder.uri.fsPath
                : this._mainGetRootPath();
        }
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(s => {
                fs.lstat(cwd, (err, stats) => {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
            if (this._client.needsStop()) {
                this._client.stop();
            }
        });
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            this._client.stop();
        }
    }
}
exports.SettingMonitor = SettingMonitor;
// Exporting proposed protocol.
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(client) {
        let result = [
            new callHierarchy_proposed_1.CallHierarchyFeature(client),
            new semanticTokens_proposed_1.SemanticTokensFeature(client)
        ];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(64);
const Is = __webpack_require__(53);
let DefaultSize = 8192;
let CR = Buffer.from('\r', 'ascii')[0];
let LF = Buffer.from('\n', 'ascii')[0];
let CRLF = '\r\n';
class MessageBuffer {
    constructor(encoding = 'utf8') {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
    }
    append(chunk) {
        var toAppend = chunk;
        if (typeof (chunk) === 'string') {
            var str = chunk;
            var bufferLen = Buffer.byteLength(str, this.encoding);
            toAppend = Buffer.allocUnsafe(bufferLen);
            toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
            toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        }
        else {
            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
            if (this.index === 0) {
                this.buffer = Buffer.allocUnsafe(newSize);
                toAppend.copy(this.buffer, 0, 0, toAppend.length);
            }
            else {
                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
            }
        }
        this.index += toAppend.length;
    }
    tryReadHeaders() {
        let result = undefined;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
            current++;
        }
        // No header / body separator found (e.g CRLFCRLF)
        if (current + 3 >= this.index) {
            return result;
        }
        result = Object.create(null);
        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);
        headers.forEach((header) => {
            let index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            let key = header.substr(0, index);
            let value = header.substr(index + 1).trim();
            result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    tryReadContent(length) {
        if (this.index < length) {
            return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    get numberOfBytes() {
        return this.index;
    }
}
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
class StreamMessageReader extends AbstractMessageReader {
    constructor(readable, encoding = 'utf8') {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 10000;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        this.readable.on('data', (data) => {
            this.onData(data);
        });
        this.readable.on('error', (error) => this.fireError(error));
        this.readable.on('close', () => this.fireClose());
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                let headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                let contentLength = headers['Content-Length'];
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                let length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
                // Take the encoding form the header. For compatibility
                // treat both utf-8 and utf8 as node utf8
            }
            var msg = this.buffer.tryReadContent(this.nextMessageLength);
            if (msg === null) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.messageToken++;
            var json = JSON.parse(msg);
            this.callback(json);
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class IPCMessageReader extends AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
    }
}
exports.IPCMessageReader = IPCMessageReader;
class SocketMessageReader extends StreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(socket, encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(64);
const Is = __webpack_require__(53);
let ContentLength = 'Content-Length: ';
let CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
class StreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, encoding = 'utf8') {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on('error', (error) => this.fireError(error));
        this.writable.on('close', () => this.fireClose());
    }
    write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.writable.write(headers.join(''), 'ascii');
            // Now write the content. This can be written in any encoding
            this.writable.write(json, this.encoding);
            this.errorCount = 0;
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
class IPCMessageWriter extends AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        try {
            if (this.process.send) {
                this.sending = true;
                this.process.send(msg, undefined, undefined, (error) => {
                    this.sending = false;
                    if (error) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    else {
                        this.errorCount = 0;
                    }
                    if (this.queue.length > 0) {
                        this.doWriteMessage(this.queue.shift());
                    }
                });
            }
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageWriter extends AbstractMessageWriter {
    constructor(socket, encoding = 'utf8') {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on('error', (error) => this.fireError(error));
        this.socket.on('close', () => this.fireClose());
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.sending = true;
            this.socket.write(headers.join(''), 'ascii', (error) => {
                if (error) {
                    this.handleError(error, msg);
                }
                try {
                    // Now write the content. This can be written in any encoding
                    this.socket.write(json, this.encoding, (error) => {
                        this.sending = false;
                        if (error) {
                            this.handleError(error, msg);
                        }
                        else {
                            this.errorCount = 0;
                        }
                        if (this.queue.length > 0) {
                            this.doWriteMessage(this.queue.shift());
                        }
                    });
                }
                catch (error) {
                    this.handleError(error, msg);
                }
            });
        }
        catch (error) {
            this.handleError(error, msg);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
}
exports.SocketMessageWriter = SocketMessageWriter;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CompleteStatementRequest = exports.ReanalyzeRequest = exports.DiagnosticServerRequest = exports.SuperRequest = exports.PublishFlutterOutlineNotification = exports.PublishOutlineNotification = exports.PublishClosingLabelsNotification = exports.AnalyzerStatusNotification = void 0;
const vscode_languageclient_1 = __webpack_require__(101);
class AnalyzerStatusNotification {
}
exports.AnalyzerStatusNotification = AnalyzerStatusNotification;
AnalyzerStatusNotification.type = new vscode_languageclient_1.NotificationType("$/analyzerStatus");
class PublishClosingLabelsNotification {
}
exports.PublishClosingLabelsNotification = PublishClosingLabelsNotification;
PublishClosingLabelsNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishClosingLabels");
class PublishOutlineNotification {
}
exports.PublishOutlineNotification = PublishOutlineNotification;
PublishOutlineNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishOutline");
class PublishFlutterOutlineNotification {
}
exports.PublishFlutterOutlineNotification = PublishFlutterOutlineNotification;
PublishFlutterOutlineNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishFlutterOutline");
class SuperRequest {
}
exports.SuperRequest = SuperRequest;
SuperRequest.type = new vscode_languageclient_1.RequestType("dart/textDocument/super");
class DiagnosticServerRequest {
}
exports.DiagnosticServerRequest = DiagnosticServerRequest;
DiagnosticServerRequest.type = new vscode_languageclient_1.RequestType("dart/diagnosticServer");
class ReanalyzeRequest {
}
exports.ReanalyzeRequest = ReanalyzeRequest;
ReanalyzeRequest.type = new vscode_languageclient_1.RequestType("dart/reanalyze");
class CompleteStatementRequest {
}
exports.CompleteStatementRequest = CompleteStatementRequest;
CompleteStatementRequest.type = new vscode_languageclient_1.RequestType("dart/completeStatement");


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassOutlineVisitor = exports.TestOutlineVisitor = exports.OutlineVisitor = void 0;
const test_1 = __webpack_require__(57);
class OutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        var _a, _b, _c;
        switch ((_a = outline === null || outline === void 0 ? void 0 : outline.element) === null || _a === void 0 ? void 0 : _a.kind) {
            case "CLASS":
                this.visitClass(outline);
                break;
            case "CLASS_TYPE_ALIAS":
                this.visitClassTypeAlias(outline);
                break;
            case "COMPILATION_UNIT":
                this.visitCompilationUnit(outline);
                break;
            case "CONSTRUCTOR":
                this.visitConstructor(outline);
                break;
            case "CONSTRUCTOR_INVOCATION":
                this.visitContructorInvocation(outline);
                break;
            case "ENUM":
                this.visitEnum(outline);
                break;
            case "ENUM_CONSTANT":
                this.visitEnumConstant(outline);
                break;
            case "FIELD":
                this.visitField(outline);
                break;
            case "FILE":
                this.visitFile(outline);
                break;
            case "FUNCTION":
                this.visitFunction(outline);
                break;
            case "FUNCTION_INVOCATION":
                this.visitFunctionInvocation(outline);
                break;
            case "FUNCTION_TYPE_ALIAS":
                this.visitFunctionTypeAlias(outline);
                break;
            case "GETTER":
                this.visitGetter(outline);
                break;
            case "LABEL":
                this.visitLabel(outline);
                break;
            case "LIBRARY":
                this.visitLibrary(outline);
                break;
            case "LOCAL_VARIABLE":
                this.visitLocalVariable(outline);
                break;
            case "METHOD":
                this.visitMethod(outline);
                break;
            case "MIXIN":
                this.visitMixin(outline);
                break;
            case "PARAMETER":
                this.visitParameter(outline);
                break;
            case "PREFIX":
                this.visitPrefix(outline);
                break;
            case "SETTER":
                this.visitSetter(outline);
                break;
            case "TOP_LEVEL_VARIABLE":
                this.visitTopLevelVariable(outline);
                break;
            case "TYPE_PARAMETER":
                this.visitTypeParameter(outline);
                break;
            case "UNIT_TEST_GROUP":
                this.visitUnitTestGroup(outline);
                break;
            case "UNIT_TEST_TEST":
                this.visitUnitTestTest(outline);
                break;
            case "UNKNOWN":
                this.visitUnknown(outline);
                break;
            default:
                this.logger.error(`Unknown Outline item! ${(_b = outline === null || outline === void 0 ? void 0 : outline.element) === null || _b === void 0 ? void 0 : _b.kind} (${(_c = outline === null || outline === void 0 ? void 0 : outline.element) === null || _c === void 0 ? void 0 : _c.name})`);
        }
    }
    visitClass(outline) { this.visitChildren(outline); }
    visitClassTypeAlias(outline) { this.visitChildren(outline); }
    visitCompilationUnit(outline) { this.visitChildren(outline); }
    visitConstructor(outline) { this.visitChildren(outline); }
    visitContructorInvocation(outline) { this.visitChildren(outline); }
    visitEnum(outline) { this.visitChildren(outline); }
    visitEnumConstant(outline) { this.visitChildren(outline); }
    visitField(outline) { this.visitChildren(outline); }
    visitFile(outline) { this.visitChildren(outline); }
    visitFunction(outline) { this.visitChildren(outline); }
    visitFunctionInvocation(outline) { this.visitChildren(outline); }
    visitFunctionTypeAlias(outline) { this.visitChildren(outline); }
    visitGetter(outline) { this.visitChildren(outline); }
    visitLabel(outline) { this.visitChildren(outline); }
    visitLibrary(outline) { this.visitChildren(outline); }
    visitLocalVariable(outline) { this.visitChildren(outline); }
    visitMixin(outline) { this.visitChildren(outline); }
    visitMethod(outline) { this.visitChildren(outline); }
    visitParameter(outline) { this.visitChildren(outline); }
    visitPrefix(outline) { this.visitChildren(outline); }
    visitSetter(outline) { this.visitChildren(outline); }
    visitTopLevelVariable(outline) { this.visitChildren(outline); }
    visitTypeParameter(outline) { this.visitChildren(outline); }
    visitUnitTestGroup(outline) { this.visitChildren(outline); }
    visitUnitTestTest(outline) { this.visitChildren(outline); }
    visitUnknown(outline) { this.visitChildren(outline); }
}
exports.OutlineVisitor = OutlineVisitor;
class TestOutlineVisitor extends OutlineVisitor {
    constructor() {
        super(...arguments);
        this.tests = [];
        this.names = [];
    }
    visitUnitTestTest(outline) {
        this.addTest(outline, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.addTest(outline, super.visitUnitTestGroup);
    }
    addTest(outline, base) {
        const name = test_1.extractTestNameFromOutline(outline.element.name);
        if (!name || !outline.element.location)
            return;
        this.names.push(name);
        const fullName = this.names.join(" ");
        const isGroup = outline.element.kind === "UNIT_TEST_GROUP";
        this.tests.push({
            file: outline.element.location.file,
            fullName,
            isGroup,
            length: outline.codeLength || outline.element.location.length,
            offset: outline.codeOffset || outline.element.location.offset,
        });
        try {
            base.bind(this)(outline);
        }
        finally {
            this.names.pop();
        }
    }
}
exports.TestOutlineVisitor = TestOutlineVisitor;
class ClassOutlineVisitor extends OutlineVisitor {
    constructor() {
        super(...arguments);
        this.classes = [];
    }
    visitClass(outline) {
        this.addClass(outline);
        super.visitClass(outline);
    }
    visitMixin(outline) {
        this.addClass(outline);
        super.visitMixin(outline);
    }
    addClass(outline) {
        if (!outline.element || !outline.element.location || !outline.element.name)
            return;
        this.classes.push({
            className: outline.element.name,
            codeLength: outline.codeLength,
            codeOffset: outline.codeOffset,
            length: outline.length,
            offset: outline.offset,
        });
    }
}
exports.ClassOutlineVisitor = ClassOutlineVisitor;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebugCommands = exports.LastTestDebugSession = exports.LastDebugSession = exports.debugSessions = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const user_prompts_1 = __webpack_require__(126);
const utils_2 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
const vm_service_extensions_1 = __webpack_require__(209);
const manager_1 = __webpack_require__(210);
const utils_3 = __webpack_require__(6);
const debug_1 = __webpack_require__(213);
exports.debugSessions = [];
const CURRENT_FILE_RUNNABLE = "dart-code:currentFileIsRunnable";
// Workaround for https://github.com/microsoft/vscode/issues/100115
const dynamicDebugSessionName = "Dart ";
// As a workaround for https://github.com/Microsoft/vscode/issues/71651 we
// will keep any events that arrive before their session "started" and then
// replace them when the start event comes through.
let pendingCustomEvents = [];
let hasPromptedAboutDebugSettings = false;
class LastDebugSession {
}
exports.LastDebugSession = LastDebugSession;
class LastTestDebugSession {
}
exports.LastTestDebugSession = LastTestDebugSession;
class DebugCommands {
    constructor(logger, context, workspaceContext, analytics, pubGlobal) {
        this.logger = logger;
        this.context = context;
        this.analytics = analytics;
        this.debugOptions = vs.window.createStatusBarItem(vs.StatusBarAlignment.Left, 0);
        this.currentDebugOption = enums_1.DebugOption.MyCode;
        this.debugMetrics = vs.window.createStatusBarItem(vs.StatusBarAlignment.Right, 0);
        this.onWillHotReloadEmitter = new vs.EventEmitter();
        this.onWillHotReload = this.onWillHotReloadEmitter.event;
        this.onWillHotRestartEmitter = new vs.EventEmitter();
        this.onWillHotRestart = this.onWillHotRestartEmitter.event;
        this.onFirstFrameEmitter = new vs.EventEmitter();
        this.onFirstFrame = this.onFirstFrameEmitter.event;
        this.onDebugSessionVmServiceAvailableEmitter = new vs.EventEmitter();
        this.onDebugSessionVmServiceAvailable = this.onDebugSessionVmServiceAvailableEmitter.event;
        this.vmServices = new vm_service_extensions_1.VmServiceExtensions(logger, this.sendServiceSetting);
        this.devTools = new manager_1.DevToolsManager(logger, workspaceContext, this, analytics, pubGlobal);
        context.subscriptions.push(this.devTools);
        context.subscriptions.push(this.debugOptions);
        context.subscriptions.push(this.debugMetrics);
        context.subscriptions.push(vs.debug.onDidChangeBreakpoints((e) => this.handleBreakpointChange(e)));
        context.subscriptions.push(vs.debug.onDidStartDebugSession((s) => this.handleDebugSessionStart(s)));
        context.subscriptions.push(vs.debug.onDidReceiveDebugSessionCustomEvent((e) => this.handleDebugSessionCustomEvent(e)));
        context.subscriptions.push(vs.debug.onDidTerminateDebugSession((s) => this.handleDebugSessionEnd(s)));
        context.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.updateEditorContexts(e)));
        // Run for current open editor.
        this.updateEditorContexts(vs.window.activeTextEditor);
        context.subscriptions.push(vs.commands.registerCommand("flutter.togglePlatform", () => this.vmServices.toggle(enums_1.VmServiceExtension.PlatformOverride, "iOS", "android")));
        context.subscriptions.push(vs.commands.registerCommand("flutter.toggleDebugPainting", () => this.vmServices.toggle(enums_1.VmServiceExtension.DebugPaint)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.togglePerformanceOverlay", () => this.vmServices.toggle(enums_1.VmServiceExtension.PerformanceOverlay)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.toggleBrightness", () => this.vmServices.toggle(enums_1.VmServiceExtension.BrightnessOverride, "Brightness.dark", "Brightness.light")));
        context.subscriptions.push(vs.commands.registerCommand("flutter.toggleRepaintRainbow", () => this.vmServices.toggle(enums_1.VmServiceExtension.RepaintRainbow)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.toggleDebugModeBanner", () => this.vmServices.toggle(enums_1.VmServiceExtension.DebugBanner)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.toggleCheckElevations", () => this.vmServices.toggle(enums_1.VmServiceExtension.CheckElevations)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.togglePaintBaselines", () => this.vmServices.toggle(enums_1.VmServiceExtension.PaintBaselines)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.toggleSlowAnimations", () => this.vmServices.toggle(enums_1.VmServiceExtension.SlowAnimations, vm_service_extensions_1.timeDilationNormal, vm_service_extensions_1.timeDilationSlow)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.inspectWidget", () => this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, true, true)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.cancelInspectWidget", () => this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, false, false)));
        context.subscriptions.push(vs.commands.registerCommand("dart.openObservatory", () => __awaiter(this, void 0, void 0, function* () {
            const session = yield this.getDebugSession();
            if (session && !session.session.configuration.noDebug && session.observatoryUri) {
                yield utils_2.envUtils.openInBrowser(session.observatoryUri);
                analytics.logDebuggerOpenObservatory();
            }
            else if (session) {
                logger.warn("Cannot start Observatory for session without debug/observatoryUri");
            }
        })));
        context.subscriptions.push(vs.commands.registerCommand("flutter.openTimeline", () => __awaiter(this, void 0, void 0, function* () {
            const session = yield this.getDebugSession();
            if (session && !session.session.configuration.noDebug && session.observatoryUri) {
                yield utils_2.envUtils.openInBrowser(session.observatoryUri + "/#/timeline-dashboard");
                analytics.logDebuggerOpenTimeline();
            }
            else if (session) {
                logger.warn("Cannot start Observatory for session without debug/observatoryUri");
            }
        })));
        context.subscriptions.push(vs.commands.registerCommand("_dart.openDevTools.touchBar", () => vs.commands.executeCommand("dart.openDevTools")));
        constants_1.devToolsPages.forEach((page) => {
            context.subscriptions.push(vs.commands.registerCommand(page.commandId, (options) => __awaiter(this, void 0, void 0, function* () {
                options = Object.assign({}, options, { page });
                return vs.commands.executeCommand("dart.openDevTools", options);
            })));
        });
        context.subscriptions.push(vs.commands.registerCommand("dart.openDevTools", (options) => __awaiter(this, void 0, void 0, function* () {
            if (!exports.debugSessions.length) {
                this.logger.warn("No active debug sessions found, so unable to launch DevTools");
                vs.window.showInformationMessage("You must have an active debug session to start DevTools.");
                return;
            }
            const session = options && options.debugSessionId
                ? exports.debugSessions.find((s) => s.session.id === options.debugSessionId)
                : yield this.getDebugSession();
            if (!session)
                return; // User cancelled or specified session was gone
            // Only show a notification if we were not triggered automatically.
            const notify = !options || options.triggeredAutomatically !== true;
            const reuseWindows = config_1.config.devToolsReuseWindows;
            const page = options === null || options === void 0 ? void 0 : options.page;
            if (session.vmServiceUri) {
                return this.devTools.spawnForSession(session, { embed: config_1.config.embedDevTools, reuseWindows, notify, page });
            }
            else if (session.session.configuration.noDebug) {
                vs.window.showInformationMessage("You must start your app with debugging in order to use DevTools.");
            }
            else {
                vs.window.showInformationMessage("This debug session is not ready yet.");
            }
        })));
        // Misc custom debug commands.
        context.subscriptions.push(vs.commands.registerCommand("_flutter.hotReload.touchBar", (args) => vs.commands.executeCommand("flutter.hotReload", args)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.hotReload", (args) => {
            if (!exports.debugSessions.length)
                return;
            this.onWillHotReloadEmitter.fire();
            exports.debugSessions.forEach((s) => s.session.customRequest("hotReload", args));
            analytics.logDebuggerHotReload();
        }));
        context.subscriptions.push(vs.commands.registerCommand("flutter.hotRestart", (args) => {
            if (!exports.debugSessions.length)
                return;
            this.onWillHotRestartEmitter.fire();
            exports.debugSessions.forEach((s) => s.session.customRequest("hotRestart", args));
            analytics.logDebuggerRestart();
        }));
        context.subscriptions.push(vs.commands.registerCommand("dart.startDebugging", (resource, launchTemplate) => {
            const launchConfig = Object.assign({
                name: dynamicDebugSessionName,
                noDebug: false,
                request: "launch",
                type: "dart",
            }, launchTemplate, {
                program: fs_1.fsPath(resource),
            });
            vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(resource), launchConfig);
        }));
        context.subscriptions.push(vs.commands.registerCommand("dart.startWithoutDebugging", (resource, launchTemplate) => {
            const launchConfig = Object.assign({
                name: dynamicDebugSessionName,
                noDebug: true,
                request: "launch",
                type: "dart",
            }, launchTemplate, {
                program: fs_1.fsPath(resource),
            });
            vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(resource), launchConfig);
        }));
        context.subscriptions.push(vs.commands.registerCommand("dart.runAllTestsWithoutDebugging", () => __awaiter(this, void 0, void 0, function* () {
            const workspaceFolders = utils_2.getDartWorkspaceFolders();
            const topLevelFolders = workspaceFolders.map((w) => fs_1.fsPath(w.uri));
            const allExcludedFolders = utils_1.flatMap(workspaceFolders, utils_3.getExcludedFolders);
            const testFolders = (yield fs_1.findProjectFolders(this.logger, topLevelFolders, allExcludedFolders, { requirePubspec: true }))
                .map((project) => path.join(project, "test"))
                .filter((testFolder) => fs.existsSync(testFolder));
            if (testFolders.length === 0) {
                vs.window.showErrorMessage("Unable to find any test folders");
                return;
            }
            for (const folder of testFolders) {
                const ws = vs.workspace.getWorkspaceFolder(vs.Uri.file(folder));
                const name = path.basename(path.dirname(folder));
                vs.debug.startDebugging(ws, {
                    name: `${name} tests`,
                    noDebug: true,
                    // To run all tests, we set `program` to a test folder.
                    program: folder,
                    request: "launch",
                    type: "dart",
                });
            }
        })));
        context.subscriptions.push(vs.commands.registerCommand("dart.rerunLastDebugSession", () => {
            if (LastDebugSession.debugConfig) {
                vs.debug.startDebugging(LastDebugSession.workspaceFolder, LastDebugSession.debugConfig);
            }
            else {
                vs.window.showErrorMessage("There is no previous debug session to run.");
            }
        }));
        context.subscriptions.push(vs.commands.registerCommand("dart.rerunLastTestDebugSession", () => {
            if (LastTestDebugSession.debugConfig) {
                vs.debug.startDebugging(LastTestDebugSession.workspaceFolder, LastTestDebugSession.debugConfig);
            }
            else {
                vs.window.showErrorMessage("There is no previous test session to run.");
            }
        }));
        // Attach commands.
        context.subscriptions.push(vs.commands.registerCommand("dart.attach", () => {
            vs.debug.startDebugging(undefined, {
                name: "Dart: Attach to Process",
                request: "attach",
                type: "dart",
            });
        }));
        context.subscriptions.push(vs.commands.registerCommand("flutter.attachProcess", () => {
            vs.debug.startDebugging(undefined, {
                name: "Flutter: Attach to Process",
                request: "attach",
                type: "dart",
                vmServiceUri: "${command:dart.promptForVmService}",
            });
        }));
        context.subscriptions.push(vs.commands.registerCommand("flutter.attach", () => {
            vs.debug.startDebugging(undefined, {
                name: "Flutter: Attach to Device",
                request: "attach",
                type: "dart",
            });
        }));
        context.subscriptions.push(vs.commands.registerCommand("dart.promptForVmService", (defaultValueOrConfig) => __awaiter(this, void 0, void 0, function* () {
            const defaultValue = typeof defaultValueOrConfig === "string" ? defaultValueOrConfig : undefined;
            return vs.window.showInputBox({
                ignoreFocusOut: true,
                placeHolder: "Paste an VM Service URI",
                prompt: "Enter VM Service URI",
                validateInput: (input) => {
                    if (!input)
                        return;
                    input = input.trim();
                    // eslint-disable-next-line id-blacklist
                    if (Number.isInteger(parseFloat(input)))
                        return;
                    // Uri.parse doesn't seem to work as expected, so do our own basic validation
                    // https://github.com/Microsoft/vscode/issues/49818
                    if (!input.startsWith("http://") && !input.startsWith("https://")
                        && !input.startsWith("ws://") && !input.startsWith("wss://"))
                        return "Please enter a valid VM Service URI";
                },
                value: defaultValue,
            });
        })));
        // Debug options.
        if (config_1.config.debugSdkLibraries && config_1.config.debugExternalLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodePackagesSdk;
        else if (config_1.config.debugSdkLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodeSdk;
        else if (config_1.config.debugExternalLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodePackages;
        context.subscriptions.push(vs.commands.registerCommand("_dart.toggleDebugOptions", this.toggleDebugOptions, this));
        this.debugOptions.text = `Debug ${enums_1.debugOptionNames[this.currentDebugOption]}`;
        this.debugOptions.tooltip = `Controls whether to step into or stop at breakpoints in only files in this workspace or also those in SDK and/or external Pub packages`;
        this.debugOptions.command = "_dart.toggleDebugOptions";
    }
    getDebugSession() {
        return __awaiter(this, void 0, void 0, function* () {
            if (exports.debugSessions.length === 0) {
                this.logger.info("No debug session to use!");
                return undefined;
            }
            else if (exports.debugSessions.length === 1) {
                this.logger.info("Using only available debug session");
                return exports.debugSessions[0];
            }
            else {
                this.logger.info("Multiple debug sessions available, prompting user");
                const selectedItem = yield vs.window.showQuickPick(exports.debugSessions.map((s) => ({
                    description: s.session.workspaceFolder ? s.session.workspaceFolder.name : undefined,
                    detail: s.session.configuration.deviceName || `Started ${s.sessionStart.toLocaleTimeString()}`,
                    label: s.session.name,
                    session: s,
                })), {
                    placeHolder: "Which debug session?",
                });
                return selectedItem && selectedItem.session;
            }
        });
    }
    handleBreakpointChange(e) {
        if (hasPromptedAboutDebugSettings)
            return;
        for (const bp of e.added)
            this.promptAboutDebuggerSettingsIfBreakpointOutsideWorkspace(bp);
    }
    promptAboutDebuggerSettingsIfBreakpointOutsideWorkspace(e) {
        // If the user has enabled any of these, assume they understand the setting.
        if (config_1.config.debugSdkLibraries || config_1.config.debugExternalLibraries)
            return;
        if (hasPromptedAboutDebugSettings || this.context.breakpointOutsideWorkspaceDoNotShow || !(e instanceof vs.SourceBreakpoint) || !e.enabled)
            return;
        // Don't consider non-Dart files.
        if (!fs_1.fsPath(e.location.uri).toLocaleLowerCase().endsWith(".dart"))
            return;
        // If it's inside the workspace we don't want to prompt.
        if (vs.workspace.getWorkspaceFolder(e.location.uri))
            return;
        hasPromptedAboutDebugSettings = true;
        const message = `You have a breakpoint outside of your workspace but debug settings are set to 'my code'. Would you like to change settings? You can also change this from the status bar while debugging.`;
        const debugJustMyCodeAction = "Debug just my code";
        const debugEverything = "Debug my code + packages + SDK";
        vs.window.showWarningMessage(message, debugJustMyCodeAction, debugEverything, constants_1.doNotAskAgainAction).then((choice) => {
            if (choice === constants_1.doNotAskAgainAction)
                this.context.breakpointOutsideWorkspaceDoNotShow = true;
            if (choice !== debugEverything)
                return;
            this.currentDebugOption = enums_1.DebugOption.MyCodePackagesSdk;
            this.applyNewDebugOption();
        });
    }
    handleDebugSessionStart(s) {
        if (s.type !== "dart")
            return;
        const debuggerType = s.configuration ? enums_1.DebuggerType[s.configuration.debuggerType] : "<unknown>";
        const session = new debug_1.DartDebugSessionInformation(s, debuggerType);
        // If we're the first fresh debug session, reset all settings to default.
        // Subsequent launches will inherit the "current" values.
        if (exports.debugSessions.length === 0)
            this.vmServices.resetToDefaults();
        exports.debugSessions.push(session);
        if (s.configuration.debuggerType === enums_1.DebuggerType.Flutter || s.configuration.debuggerType === enums_1.DebuggerType.Web) {
            const mode = s.configuration.flutterMode;
            if (mode === "debug")
                vs.commands.executeCommand("setContext", constants_1.isInFlutterDebugModeDebugSessionContext, true);
            if (mode === "profile")
                vs.commands.executeCommand("setContext", constants_1.isInFlutterProfileModeDebugSessionContext, true);
        }
        // Process any queued events that came in before the session start
        // event.
        const eventsToProcess = pendingCustomEvents.filter((e) => e.session.id === s.id);
        pendingCustomEvents = pendingCustomEvents.filter((e) => e.session.id !== s.id);
        eventsToProcess.forEach((e) => {
            this.logger.info(`Processing delayed event ${e.event} for session ${e.session.id}`);
            // tslint:disable-next-line: no-floating-promises
            this.handleCustomEventWithSession(session, e);
        });
        this.debugOptions.show();
    }
    handleDebugSessionCustomEvent(e) {
        if (this.handleCustomEvent(e))
            return;
        const session = exports.debugSessions.find((ds) => ds.session.id === e.session.id);
        if (!session) {
            this.logger.warn(`Did not find session ${e.session.id} to handle ${e.event}. There were ${exports.debugSessions.length} sessions:\n${exports.debugSessions.map((ds) => `  ${ds.session.id}`).join("\n")}`);
            this.logger.warn(`Event will be queued and processed when the session start event fires`);
            pendingCustomEvents.push(e);
            return;
        }
        // tslint:disable-next-line: no-floating-promises
        this.handleCustomEventWithSession(session, e);
    }
    handleDebugSessionEnd(s) {
        var _a;
        const sessionIndex = exports.debugSessions.findIndex((ds) => ds.session.id === s.id);
        if (sessionIndex === -1)
            return;
        // Grab the session and remove it from the list so we don't try to interact with it anymore.
        const session = exports.debugSessions[sessionIndex];
        session.hasEnded = true;
        exports.debugSessions.splice(sessionIndex, 1);
        // Close any in-progress progress notifications.
        for (const progressID of Object.keys(session.progress))
            (_a = session.progress[progressID]) === null || _a === void 0 ? void 0 : _a.complete();
        const debugSessionEnd = new Date();
        this.analytics.logDebugSessionDuration(session.debuggerType, debugSessionEnd.getTime() - session.sessionStart.getTime());
        // If this was the last session terminating, then remove all the flags for which service extensions are supported.
        // Really we should track these per-session, but the changes of them being different given we only support one
        // SDK at a time are practically zero.
        if (exports.debugSessions.length === 0) {
            this.vmServices.markAllServicesUnloaded();
            this.debugOptions.hide();
            this.debugMetrics.hide();
            for (const debugContext of [
                constants_1.isInFlutterDebugModeDebugSessionContext,
                constants_1.isInFlutterProfileModeDebugSessionContext,
            ])
                vs.commands.executeCommand("setContext", debugContext, false);
        }
    }
    handleCustomEvent(e) {
        if (e.event === "dart.log") {
            const message = e.body;
            const logMessage = `[${e.session.name}] ${message.message}`;
            // TODO: Can we get rid of this switch?
            switch (message.severity) {
                case enums_1.LogSeverity.Info:
                    this.logger.info(logMessage, message.category);
                    break;
                case enums_1.LogSeverity.Warn:
                    this.logger.warn(logMessage, message.category);
                    break;
                case enums_1.LogSeverity.Error:
                    this.logger.error(logMessage, message.category);
                    break;
                default:
                    this.logger.warn(`Failed to handle log event [${e.session.name}] ${JSON.stringify(message)}`);
            }
        }
        else if (e.event === "dart.hotRestartRequest") {
            // This event comes back when the user restarts with the Restart button
            // (eg. it wasn't intiated from our extension, so we don't get to log it
            // in the command).
            this.analytics.logDebuggerRestart();
            this.onWillHotRestartEmitter.fire();
        }
        else if (e.event === "dart.hotReloadRequest") {
            // This event comes back when the user restarts with the Restart button
            // (eg. it wasn't intiated from our extension, so we don't get to log it
            // in the command).
            this.analytics.logDebuggerHotReload();
            this.onWillHotReloadEmitter.fire();
        }
        else if (e.event === "dart.flutter.firstFrame") {
            this.onFirstFrameEmitter.fire();
        }
        else if (e.event === "dart.debugMetrics") {
            const memory = e.body.memory;
            const message = `${Math.ceil(memory.current / 1024 / 1024)}MB of ${Math.ceil(memory.total / 1024 / 1024)}MB`;
            this.debugMetrics.text = message;
            this.debugMetrics.tooltip = "This is the amount of memory being consumed by your applications heaps (out of what has been allocated).\n\nNote: memory usage shown in debug builds may not be indicative of usage in release builds. Use profile builds for more accurate figures when testing memory usage.";
            this.debugMetrics.show();
        }
        else if (e.event === "dart.navigate") {
            if (e.body.file && e.body.line && e.body.column)
                vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.parse(e.body.file), e.body.line, e.body.column, e.body.inOtherEditorColumn);
        }
        else {
            // Not handled, will fall through in the caller.
            return false;
        }
        return true;
    }
    handleCustomEventWithSession(session, e) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.vmServices.handleDebugEvent(session, e)
                .catch((e) => this.logger.error(e));
            if (e.event === "dart.webLaunchUrl") {
                const launched = !!e.body.launched;
                if (!launched) {
                    try {
                        const uri = vs.Uri.parse(e.body.url, true);
                        yield utils_2.envUtils.openInBrowser(uri.toString());
                    }
                    catch (e) {
                        this.logger.error(`Failed to parse URL from Flutter app.webLaunchUrl event: ${e.body.url}`);
                    }
                }
            }
            else if (e.event === "dart.exposeUrl") {
                const originalUrl = e.body.url;
                try {
                    const exposedUrl = yield utils_2.envUtils.exposeUrl(vs.Uri.parse(originalUrl, true), this.logger);
                    // HACK: Convert %24 back to $
                    session.session.customRequest("exposeUrlResponse", { originalUrl, exposedUrl });
                }
                catch (e) {
                    this.logger.error(`Failed to expose URL ${originalUrl}: ${e}`);
                    session.session.customRequest("exposeUrlResponse", { originalUrl, exposedUrl: originalUrl });
                }
            }
            else if (e.event === "dart.debuggerUris") {
                session.observatoryUri = e.body.observatoryUri;
                session.vmServiceUri = e.body.vmServiceUri;
                this.onDebugSessionVmServiceAvailableEmitter.fire(session);
                // Open or prompt for DevTools when appropriate.
                const debuggerType = session.session.configuration.debuggerType;
                if (debuggerType === enums_1.DebuggerType.Dart || debuggerType === enums_1.DebuggerType.Flutter || debuggerType === enums_1.DebuggerType.Web) {
                    if (config_1.config.openDevTools !== "never") {
                        const shouldLaunch = debuggerType !== enums_1.DebuggerType.Dart || config_1.config.openDevTools === "always";
                        if (shouldLaunch)
                            vs.commands.executeCommand("dart.openDevTools", { debugSessionId: session.session.id, triggeredAutomatically: true });
                    }
                    else if (debuggerType === enums_1.DebuggerType.Flutter) {
                        // tslint:disable-next-line: no-floating-promises
                        user_prompts_1.showDevToolsNotificationIfAppropriate(this.context).then((res) => {
                            if (res.shouldAlwaysOpen)
                                config_1.config.setOpenDevTools("flutter");
                        });
                    }
                }
            }
            else if (e.event === "dart.progressStart") {
                const progressLocation = config_1.config.hotReloadProgress === "notification" && (e.body.progressID.endsWith("-hot.reload") || e.body.progressID.endsWith("-hot.restart")) ? vs.ProgressLocation.Notification : vs.ProgressLocation.Window;
                vs.window.withProgress(
                // TODO: This was previously Window to match what we'd get using DAP progress
                // notifications but users prefer larger notifications as they're easier to
                // see (especially when it comes to things like waiting for debug extension).
                // https://github.com/Dart-Code/Dart-Code/issues/2597
                // If this is changed back, ensure the waiting-for-debug-extension notification
                // is still displayed with additional description.
                { location: progressLocation }, (progress) => {
                    var _a, _b;
                    // Complete any existing one with this ID.
                    (_a = session.progress[e.body.progressID]) === null || _a === void 0 ? void 0 : _a.complete();
                    // Build a new progress and store it in the session.
                    const completer = new utils_1.PromiseCompleter();
                    session.progress[e.body.progressID] = new debug_1.ProgressMessage(progress, completer);
                    (_b = session.progress[e.body.progressID]) === null || _b === void 0 ? void 0 : _b.report(e.body.message);
                    return completer.promise;
                });
            }
            else if (e.event === "dart.progressUpdate") {
                (_a = session.progress[e.body.progressID]) === null || _a === void 0 ? void 0 : _a.report(e.body.message);
            }
            else if (e.event === "dart.progressEnd") {
                if (e.body.message) {
                    (_b = session.progress[e.body.progressID]) === null || _b === void 0 ? void 0 : _b.report(e.body.message);
                    yield new Promise((resolve) => setTimeout(resolve, 400));
                }
                (_c = session.progress[e.body.progressID]) === null || _c === void 0 ? void 0 : _c.complete();
            }
        });
    }
    toggleDebugOptions() {
        // -1 is because we skip the last combination when toggling since it seems uncommon.
        this.currentDebugOption = (this.currentDebugOption + 1) % (enums_1.debugOptionNames.length - 1);
        this.applyNewDebugOption();
    }
    applyNewDebugOption() {
        this.debugOptions.text = `Debug ${enums_1.debugOptionNames[this.currentDebugOption]}`;
        const debugExternalLibraries = this.currentDebugOption === enums_1.DebugOption.MyCodePackages || this.currentDebugOption === enums_1.DebugOption.MyCodePackagesSdk;
        const debugSdkLibraries = this.currentDebugOption === enums_1.DebugOption.MyCodeSdk || this.currentDebugOption === enums_1.DebugOption.MyCodePackagesSdk;
        config_1.config.setGlobalDebugExternalLibraries(debugExternalLibraries);
        config_1.config.setGlobalDebugSdkLibraries(debugSdkLibraries);
        exports.debugSessions.forEach((session) => {
            session.session.customRequest("updateDebugOptions", {
                debugExternalLibraries,
                debugSdkLibraries,
            });
        });
    }
    sendServiceSetting(args) {
        exports.debugSessions.forEach((session) => {
            session.session.customRequest("serviceExtension", args);
        });
    }
    updateEditorContexts(e) {
        const isRunnable = !!(e && e.document && e.document.uri.scheme === "file" && utils_3.isValidEntryFile(fs_1.fsPath(e.document.uri)));
        vs.commands.executeCommand("setContext", CURRENT_FILE_RUNNABLE, isRunnable);
    }
}
exports.DebugCommands = DebugCommands;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasOverlappingEdits = exports.DasEditCommands = void 0;
const fs = __webpack_require__(7);
const vs = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const editors = __webpack_require__(58);
class DasEditCommands {
    constructor(logger, context, analyzer) {
        this.logger = logger;
        this.context = context;
        this.analyzer = analyzer;
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("_dart.organizeImports", this.organizeImports, this), vs.commands.registerCommand("dart.sortMembers", this.sortMembers, this), vs.commands.registerCommand("_dart.applySourceChange", this.applyEdits, this), vs.commands.registerCommand("dart.completeStatement", this.completeStatement, this));
    }
    getActiveDoc() {
        return vs.window.activeTextEditor && vs.window.activeTextEditor.document;
    }
    organizeImports(document) {
        document = document || this.getActiveDoc();
        return this.sendEdit(this.analyzer.editOrganizeDirectives, "Organize Imports", document);
    }
    sortMembers(document) {
        document = document || this.getActiveDoc();
        return this.sendEdit(this.analyzer.editSortMembers, "Sort Members", document);
    }
    completeStatement() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vs.window.activeTextEditor;
            if (!editor || !editor.selection || !this.analyzer.capabilities.hasCompleteStatementFix)
                return;
            const document = editor.document;
            const file = fs_1.fsPath(document.uri);
            const offset = document.offsetAt(editor.selection.end);
            const res = yield this.analyzer.editGetStatementCompletion({ file, offset });
            if (res && res.change)
                yield this.applyEdits(document, res.change);
        });
    }
    sendEdit(f, commandName, document) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!document || !editors.isDartDocument(document)) {
                vs.window.showWarningMessage("Not a Dart file.");
                return;
            }
            const originalDocumentVersion = document.version;
            f = f.bind(this.analyzer); // Yay JavaScript!
            try {
                const response = yield f({ file: fs_1.fsPath(document.uri) });
                const edit = response.edit;
                if (edit.edits.length === 0)
                    return;
                if (document.isClosed) {
                    vs.window.showErrorMessage(`Error running ${commandName}: Document has been closed.`);
                    return;
                }
                if (document.version !== originalDocumentVersion) {
                    vs.window.showErrorMessage(`Error running ${commandName}: Document has been modified.`);
                    return;
                }
                const editBuilder = new vs.WorkspaceEdit();
                edit.edits.forEach((edit) => {
                    const range = new vs.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length));
                    editBuilder.replace(document.uri, range, edit.replacement);
                });
                yield vs.workspace.applyEdit(editBuilder);
            }
            catch (error) {
                vs.window.showErrorMessage(`Error running ${commandName}: ${error.message}.`);
            }
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
    applyEdits(initiatingDocument, change) {
        return __awaiter(this, void 0, void 0, function* () {
            // We can only apply with snippets if there's a single change.
            if (change.edits.length === 1 && change.linkedEditGroups && change.linkedEditGroups.length !== 0)
                return this.applyEditsWithSnippets(initiatingDocument, change);
            // VS Code expects offsets to be based on the original document, but the analysis server provides
            // them assuming all previous edits have already been made. This means if the server provides us a
            // set of edits where any edits offset is *equal to or greater than* a previous edit, it will do the wrong thing.
            // If this happens; we will fall back to sequential edits and write a warning.
            const hasProblematicEdits = hasOverlappingEdits(change);
            if (hasProblematicEdits) {
                this.logger.warn("Falling back to sequential edits due to overlapping edits in server.");
            }
            const applyEditsSequentially = hasProblematicEdits;
            // Otherwise, just make all the edits without the snippets.
            let changes = applyEditsSequentially ? undefined : new vs.WorkspaceEdit();
            for (const edit of change.edits) {
                const uri = vs.Uri.file(edit.file);
                // We can only create files with edits that are at 0/0 because we can't open the document if it doesn't exist.
                // If we create the file ourselves, it won't go into the single undo buffer.
                if (!fs.existsSync(edit.file) && edit.edits.find((e) => e.offset !== 0 || e.length !== 0)) {
                    this.logger.error(`Unable to edit file ${edit.file} because it does not exist and had an edit that was not the start of the file`);
                    vs.window.showErrorMessage(`Unable to edit file ${edit.file} because it does not exist and had an edit that was not the start of the file`);
                    continue;
                }
                const document = fs.existsSync(edit.file) ? yield vs.workspace.openTextDocument(uri) : undefined;
                if (changes)
                    changes.createFile(uri, { ignoreIfExists: true });
                for (const e of edit.edits) {
                    if (!changes) {
                        changes = new vs.WorkspaceEdit();
                        changes.createFile(uri, { ignoreIfExists: true });
                    }
                    const range = document
                        ? new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length))
                        : new vs.Range(new vs.Position(0, 0), new vs.Position(0, 0));
                    changes.replace(uri, range, e.replacement);
                    if (applyEditsSequentially) {
                        yield vs.workspace.applyEdit(changes);
                        changes = undefined;
                    }
                }
            }
            // If we weren't applying sequentially
            if (changes)
                yield vs.workspace.applyEdit(changes);
            // Set the cursor position.
            if (change.selection) {
                const uri = vs.Uri.file(change.selection.file);
                const document = yield vs.workspace.openTextDocument(uri);
                const editor = yield vs.window.showTextDocument(document);
                const pos = document.positionAt(change.selection.offset);
                const selection = new vs.Selection(pos, pos);
                editor.selection = selection;
            }
        });
    }
    applyEditsWithSnippets(initiatingDocument, change) {
        return __awaiter(this, void 0, void 0, function* () {
            const edit = change.edits[0];
            const document = yield vs.workspace.openTextDocument(edit.file);
            const editor = yield vs.window.showTextDocument(document);
            // Apply of all of the edits.
            yield editor.edit((eb) => {
                edit.edits.forEach((e) => {
                    eb.replace(new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length)), e.replacement);
                });
            });
            const documentText = editor.document.getText();
            // Create a list of all the placeholders.
            const placeholders = [];
            let placeholderNumber = 1;
            change.linkedEditGroups.forEach((leg) => {
                leg.positions.forEach((pos) => {
                    const defaultValue = documentText.substr(pos.offset, leg.length);
                    let choices = leg.suggestions ? leg.suggestions.map((s) => s.value) : undefined;
                    if (defaultValue && choices && choices.indexOf(defaultValue) === -1) {
                        choices = [defaultValue, ...choices];
                    }
                    placeholders.push({ offset: pos.offset, length: leg.length, defaultValue, choices, placeholderNumber });
                });
                placeholderNumber++;
            });
            // Ensure they're in offset order so the next maths works!
            placeholders.sort((p1, p2) => p1.offset - p2.offset);
            const snippet = new vs.SnippetString();
            const firstPlaceholder = placeholders[0];
            const lastPlaceholder = placeholders[placeholders.length - 1];
            const startPos = firstPlaceholder.offset;
            const endPos = lastPlaceholder.offset + lastPlaceholder.length;
            let currentPos = startPos;
            placeholders.forEach((p) => {
                // Add the text from where we last were up to current placeholder.
                if (currentPos !== p.offset)
                    snippet.appendText(documentText.substring(currentPos, p.offset));
                // Add the choices / placeholder.
                if (p.choices && p.choices.length > 1)
                    // TODO: Change this back to appendChoice when it handles commas correctly
                    // https://github.com/microsoft/vscode/issues/107220
                    // snippet.appendChoice(p.choices, p.placeholderNumber);
                    snippet.value += "${" + p.placeholderNumber.toString() + "|" + p.choices.map((c) => this.snippetStringEscape(c)).join(",") + "|}";
                else
                    snippet.appendPlaceholder(p.defaultValue, p.placeholderNumber);
                currentPos = p.offset + p.length;
            });
            // Replace the document.
            yield editor.insertSnippet(snippet, new vs.Range(document.positionAt(startPos), document.positionAt(endPos)));
            // Ensure original document is the active one.
            yield vs.window.showTextDocument(initiatingDocument);
        });
    }
    snippetStringEscape(value) {
        return value.replace(/\$|}|\\|,/g, "\\$&");
    }
}
exports.DasEditCommands = DasEditCommands;
function hasOverlappingEdits(change) {
    const priorEdits = {};
    for (const edit of change.edits) {
        if (!priorEdits[edit.file])
            priorEdits[edit.file] = [];
        for (const e of edit.edits) {
            if (priorEdits[edit.file].find((pe) => pe.offset <= e.offset))
                return true;
            priorEdits[edit.file].push(e);
        }
    }
    return false;
}
exports.hasOverlappingEdits = hasOverlappingEdits;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.runProcessInChannel = exports.getChannel = exports.createChannel = void 0;
const vs = __webpack_require__(0);
const channels = {};
function createChannel(name) {
    // Remove any pre-existing output channel with this name.
    if (channels[name]) {
        channels[name].hide();
        channels[name].dispose();
    }
    channels[name] = vs.window.createOutputChannel(name);
    return channels[name];
}
exports.createChannel = createChannel;
function getChannel(name) {
    if (!channels[name])
        return createChannel(name);
    return channels[name];
}
exports.getChannel = getChannel;
function runProcessInChannel(process, channel) {
    process.stdout.on("data", (data) => channel.append(data.toString()));
    process.stderr.on("data", (data) => channel.append(data.toString()));
    process.on("close", (code) => channel.appendLine(`exit code ${code}`));
}
exports.runProcessInChannel = runProcessInChannel;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKindFor = exports.RankingCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const array_1 = __webpack_require__(19);
class RankingCodeActionProvider {
    constructor() {
        this.codeActionProviders = [];
    }
    registerProvider(provider) {
        this.codeActionProviders.push(provider);
        array_1.sortBy(this.codeActionProviders, (p) => p.rank);
    }
    get metadata() {
        const allKinds = utils_1.flatMap(this.codeActionProviders, (p) => p.metadata.providedCodeActionKinds || []);
        return { providedCodeActionKinds: utils_1.uniq(allKinds) };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Sort the providers, because then their results will be sorted (flatMap doesn't change the order, and
            // Promise.all preserves order).
            const applicableProviders = this.codeActionProviders.filter((p) => vscode_1.languages.match(p.selector, document));
            const promises = applicableProviders.map((p) => p.provideCodeActions(document, range, context, token));
            const allResults = yield Promise.all(promises);
            const flatResults = utils_1.flatMap(allResults, (x) => x || []);
            return flatResults;
        });
    }
}
exports.RankingCodeActionProvider = RankingCodeActionProvider;
function getKindFor(id, base) {
    if (!id)
        return base;
    const newID = id
        .replace("dart.assist.", "")
        .replace("dart.fix.", "")
        .replace("analysisOptions.assist.", "")
        .replace("analysisOptions.fix.", "");
    return base.append(newID);
}
exports.getKindFor = getKindFor;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DartDiagnostic = exports.DartDiagnosticProvider = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
// TODO: This is not a provider?
class DartDiagnosticProvider {
    constructor(analyzer, diagnostics) {
        this.analyzer = analyzer;
        this.diagnostics = diagnostics;
        this.analyzer.registerForAnalysisErrors((es) => this.handleErrors(es));
        // Fired when files are deleted
        this.analyzer.registerForAnalysisFlushResults((es) => this.flushResults(es));
    }
    handleErrors(notification) {
        const notificationJson = JSON.stringify(notification);
        // As a workaround for https://github.com/Dart-Code/Dart-Code/issues/1678, if
        // the errors we got are exactly the same as the previous set, do not give
        // them to VS Code. This avoids a potential loop of refreshing the error view
        // which triggers a request for Code Actions, which could result in analysis
        // of the file (which triggers errors to be sent, which triggers a refresh
        // of the error view... etc.!).
        if (this.lastErrorJson === notificationJson) {
            // TODO: Come up with a better fix than this!
            // log("Skipping error notification as it was the same as the previous one");
            return;
        }
        let errors = notification.errors;
        if (!config_1.config.showTodos)
            errors = errors.filter((error) => error.type !== "TODO");
        this.diagnostics.set(vscode_1.Uri.file(notification.file), errors.map((e) => DartDiagnosticProvider.createDiagnostic(e)));
        this.lastErrorJson = notificationJson;
    }
    static createDiagnostic(error) {
        const diag = new DartDiagnostic(utils_1.toRangeOnLine(error.location), error.message, DartDiagnosticProvider.getSeverity(error.severity, error.type), error.type);
        diag.code = error.url ? { value: error.code, target: vscode_1.Uri.parse(error.url) } : error.code;
        diag.source = "dart";
        diag.tags = DartDiagnosticProvider.getTags(error);
        if (error.correction)
            diag.message += `\n${error.correction}`;
        if (error.contextMessages && error.contextMessages.length)
            diag.relatedInformation = error.contextMessages.map(DartDiagnosticProvider.createRelatedInformation);
        return diag;
    }
    static createRelatedInformation(related) {
        return new vscode_1.DiagnosticRelatedInformation(new vscode_1.Location(vscode_1.Uri.file(related.location.file), utils_1.toRangeOnLine(related.location)), related.message);
    }
    static getSeverity(severity, type) {
        switch (severity) {
            case "ERROR":
                return vscode_1.DiagnosticSeverity.Error;
            case "WARNING":
                return vscode_1.DiagnosticSeverity.Warning;
            case "INFO":
                switch (type) {
                    case "TODO":
                        return vscode_1.DiagnosticSeverity.Information; // https://github.com/Microsoft/vscode/issues/48376
                    default:
                        return vscode_1.DiagnosticSeverity.Information;
                }
            default:
                throw new Error(`Unknown severity type: ${severity}`);
        }
    }
    static getTags(error) {
        const tags = [];
        if (error.code === "dead_code" || error.code === "unused_local_variable" || error.code === "unused_import")
            tags.push(vscode_1.DiagnosticTag.Unnecessary);
        if (error.code === "deprecated_member_use" || error.code === "deprecated_member_use_from_same_package")
            tags.push(vscode_1.DiagnosticTag.Deprecated);
        return tags;
    }
    flushResults(notification) {
        this.lastErrorJson = undefined;
        const entries = notification.files.map((file) => [vscode_1.Uri.file(file), undefined]);
        this.diagnostics.set(entries);
    }
}
exports.DartDiagnosticProvider = DartDiagnosticProvider;
class DartDiagnostic extends vscode_1.Diagnostic {
    constructor(range, message, severity, type) {
        super(range, message, severity);
        this.type = type;
    }
}
exports.DartDiagnostic = DartDiagnostic;


/***/ }),
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.stripMarkdown = exports.cleanDartdoc = void 0;
const utils_1 = __webpack_require__(3);
const materialIconRegex = new RegExp(`(?:${utils_1.escapeRegExp("<p>")})?`
    + utils_1.escapeRegExp('<i class="material-icons md-36">')
    + "([\\w\\s_]+)"
    + utils_1.escapeRegExp('</i> &#x2014; material icon named "')
    + "([\\w\\s_]+)"
    + utils_1.escapeRegExp('".')
    + `(?:${utils_1.escapeRegExp("</p>")})?`, "gi");
const dartDocDirectives = new RegExp(`(\\n\\s*{@.*?}$)|(^{@.*?}\\s*\\n)|(^{@.*?}$)`, "gim");
const dartDocCodeBlockSections = new RegExp(`(\`\`\`\\w+) +\\w+`, "gi");
function cleanDartdoc(doc, iconPathFormat) {
    if (!doc)
        return "";
    // Clean up some dart.core dartdoc.
    const index = doc.indexOf("## Other resources");
    if (index !== -1)
        doc = doc.substring(0, index);
    // Remove colons from old-style references like [:foo:].
    doc = doc.replace(/\[:\S+:\]/g, (match) => `[${match.substring(2, match.length - 2)}]`);
    const materialIconPathFormat = iconPathFormat.replace("$1", "material/$1");
    doc = doc.replace(materialIconRegex, `![$1](${materialIconPathFormat}|width=32,height=32)`);
    // Remove any directives like {@template xxx}
    doc = doc.replace(dartDocDirectives, "");
    // Remove any code block section names like ```dart preamble
    doc = doc.replace(dartDocCodeBlockSections, "$1");
    return doc;
}
exports.cleanDartdoc = cleanDartdoc;
/// Strips markdown to make nicer plain text.
function stripMarkdown(doc) {
    if (!doc)
        return "";
    // Remove links like [foo](bar).
    doc = doc.replace(/\[(.+?)\]\(.+?\)/g, "$1");
    // Remove references like [foo].
    doc = doc.replace(/\[(.+?)\]/g, "$1");
    return doc;
}
exports.stripMarkdown = stripMarkdown;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.createFlutterSampleInTempFolder = void 0;
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const fs_1 = __webpack_require__(1);
const projects_1 = __webpack_require__(118);
function createFlutterSampleInTempFolder(flutterCapabilities, sampleID, flutterSdkOverride) {
    // Ensure we're on at least Flutter v1 so we know creating samples works.
    if (!flutterCapabilities.supportsCreatingSamples) {
        vs.window.showErrorMessage("Opening sample projects requires Flutter v1.0 or later");
        return;
    }
    // Create a temp folder for the sample.
    const tempSamplePath = path.join(os.tmpdir(), constants_1.dartCodeExtensionIdentifier, "flutter", "sample", sampleID, fs_1.getRandomInt(0x1000, 0x10000).toString(16));
    // Create the empty folder so we can open it.
    fs_1.mkDirRecursive(tempSamplePath);
    const triggerData = { sample: sampleID };
    projects_1.writeFlutterTriggerFile(tempSamplePath, triggerData);
    // If we're using a custom SDK, we need to apply it to the new project too.
    if (flutterSdkOverride)
        projects_1.writeFlutterSdkSettingIntoProject(flutterSdkOverride, tempSamplePath);
    const hasFoldersOpen = !!(vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length);
    const openInNewWindow = hasFoldersOpen;
    const folderUri = vs.Uri.file(tempSamplePath);
    vs.commands.executeCommand("vscode.openFolder", folderUri, openInNewWindow);
    return folderUri;
}
exports.createFlutterSampleInTempFolder = createFlutterSampleInTempFolder;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.writeSettingIntoProject = exports.writeFlutterSdkSettingIntoProject = exports.writeFlutterTriggerFile = exports.writeDartSdkSettingIntoProject = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const constants_1 = __webpack_require__(4);
function writeDartSdkSettingIntoProject(dartSdkPath, projectFolder) {
    writeSettingIntoProject(projectFolder, { "dart.sdkPath": dartSdkPath });
}
exports.writeDartSdkSettingIntoProject = writeDartSdkSettingIntoProject;
function writeFlutterTriggerFile(folderPath, triggerData) {
    const jsonString = triggerData ? JSON.stringify(triggerData) : "";
    fs.writeFileSync(path.join(folderPath, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE), jsonString);
}
exports.writeFlutterTriggerFile = writeFlutterTriggerFile;
function writeFlutterSdkSettingIntoProject(flutterSdkPath, projectFolder) {
    writeSettingIntoProject(projectFolder, { "dart.flutterSdkPath": flutterSdkPath });
}
exports.writeFlutterSdkSettingIntoProject = writeFlutterSdkSettingIntoProject;
function writeSettingIntoProject(projectFolder, settings) {
    const vsCodeFolder = path.join(projectFolder, ".vscode");
    const settingsFile = path.join(vsCodeFolder, "settings.json");
    if (!fs.existsSync(vsCodeFolder))
        fs.mkdirSync(vsCodeFolder);
    // The file should never exist, because the user has to select a new folder
    // to create projects. If it exists, something is wrong. We can't just load
    // the file, because VS Code settings file are not standard JSON (they can
    // have comments) so we don't want to try and deal with parsing them.
    if (fs.existsSync(settingsFile))
        return;
    fs.writeFileSync(settingsFile, JSON.stringify(settings, undefined, 4));
}
exports.writeSettingIntoProject = writeSettingIntoProject;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Analyzer = void 0;
const events_1 = __webpack_require__(42);
const utils_1 = __webpack_require__(3);
const promises_1 = __webpack_require__(31);
class Analyzer {
    constructor(logger) {
        this.logger = logger;
        this.disposables = [];
        this.onReadyCompleter = new utils_1.PromiseCompleter();
        this.onReady = this.onReadyCompleter.promise;
        this.onAnalysisCompleteCompleter = new utils_1.PromiseCompleter();
        // InitialAnalysis uses the very first promise from onAnalysisCompleteCompleter.
        this.onInitialAnalysis = this.onAnalysisCompleteCompleter.promise;
        this.onAnalysisStatusChangeEmitter = new events_1.EventEmitter();
        this.onAnalysisStatusChange = this.onAnalysisStatusChangeEmitter.event;
        this.isAnalyzing = false;
        this.disposables.push(this.onAnalysisStatusChangeEmitter);
        // tslint:disable-next-line: no-floating-promises
        this.setup();
    }
    get onCurrentAnalysisComplete() { return this.isAnalyzing ? this.onAnalysisCompleteCompleter.promise : promises_1.resolvedPromise; }
    get onNextAnalysisComplete() { return this.onAnalysisCompleteCompleter.promise; }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.onReady;
            this.onAnalysisStatusChange.listen((status) => {
                this.isAnalyzing = status.isAnalyzing;
                if (!status.isAnalyzing) {
                    this.onAnalysisCompleteCompleter.resolve();
                    this.onAnalysisCompleteCompleter = new utils_1.PromiseCompleter();
                }
            });
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.Analyzer = Analyzer;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getAnalyzerArgs = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const extension_utils_1 = __webpack_require__(20);
const utils_1 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
function getAnalyzerArgs(logger, sdks, dartCapabilities, isLsp) {
    const analyzerPath = config_1.config.analyzerPath || path.join(sdks.dart, constants_1.analyzerSnapshotPath);
    // If the ssh host is set, then we are running the analyzer on a remote machine, that same analyzer
    // might not exist on the local machine.
    if (!config_1.config.analyzerSshHost && !fs.existsSync(analyzerPath)) {
        const msg = "Could not find a Dart Analysis Server at " + analyzerPath;
        vs.window.showErrorMessage(msg);
        logger.error(msg);
        throw new Error(msg);
    }
    return buildAnalyzerArgs(analyzerPath, dartCapabilities, isLsp);
}
exports.getAnalyzerArgs = getAnalyzerArgs;
function buildAnalyzerArgs(analyzerPath, dartCapabilities, isLsp) {
    let analyzerArgs = [];
    // Optionally start the VM service for the analyzer.
    if (config_1.config.analyzerVmServicePort) {
        analyzerArgs.push(`--enable-vm-service=${config_1.config.analyzerVmServicePort}`);
        // When using LSP, printing the VM Service URI will break the protocol and
        // stop the client from working, so it needs to be hidden.
        analyzerArgs.push(`-DSILENT_OBSERVATORY=true`);
        analyzerArgs.push(`--disable-service-auth-codes`);
        vs.window.showInformationMessage("The Dart Analysis server is running with the debugger accessible. Please disable (unset the `dart.analyzerVmServicePort` setting) when no longer required.");
    }
    analyzerArgs.push(analyzerPath);
    if (isLsp)
        analyzerArgs.push("--lsp");
    // Optionally start the analyzer's diagnostic web server on the given port.
    if (config_1.config.analyzerDiagnosticsPort)
        analyzerArgs.push(`--port=${config_1.config.analyzerDiagnosticsPort}`);
    // Add info about the extension that will be collected for crash reports etc.
    const clientID = utils_1.isRunningLocally ? "VS-Code" : "VS-Code-Remote";
    analyzerArgs.push(`--client-id=${clientID}`);
    analyzerArgs.push(`--client-version=${extension_utils_1.extensionVersion}`);
    // The analysis server supports a verbose instrumentation log file.
    if (config_1.config.analyzerInstrumentationLogFile)
        analyzerArgs.push(`--instrumentation-log-file=${config_1.config.analyzerInstrumentationLogFile}`);
    // Allow arbitrary args to be passed to the analysis server.
    if (config_1.config.analyzerAdditionalArgs)
        analyzerArgs = analyzerArgs.concat(config_1.config.analyzerAdditionalArgs);
    return analyzerArgs;
}


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const code = __webpack_require__(0);
class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
        super(label);
    }
}
exports.default = ProtocolCompletionItem;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const code = __webpack_require__(0);
class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
        super(range);
    }
}
exports.default = ProtocolCodeLens;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const code = __webpack_require__(0);
class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
        super(range, target);
    }
}
exports.default = ProtocolDocumentLink;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", { value: true });
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const Is = __webpack_require__(56);
class ProgressPart {
    constructor(_client, _token) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._disposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
            switch (value.kind) {
                case 'begin':
                    this.begin(value);
                    break;
                case 'report':
                    this.report(value);
                    break;
                case 'end':
                    this.done();
                    break;
            }
        });
    }
    begin(params) {
        let location = params.cancellable ? vscode_1.ProgressLocation.Notification : vscode_1.ProgressLocation.Window;
        vscode_1.window.withProgress({ location, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
            this._progress = progress;
            this._infinite = params.percentage === undefined;
            this._cancellationToken = cancellationToken;
            this._cancellationToken.onCancellationRequested(() => {
                this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
            });
            this.report(params);
            return new Promise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
        });
    }
    report(params) {
        if (this._infinite && Is.string(params.message)) {
            this._progress.report({ message: params.message });
        }
        else if (Is.number(params.percentage)) {
            let percentage = Math.max(0, Math.min(params.percentage, 100));
            let delta = Math.max(0, percentage - this._reported);
            this._progress.report({ message: params.message, increment: delta });
            this._reported += delta;
        }
    }
    cancel() {
        if (this._disposable) {
            this._disposable.dispose();
            this._disposable = undefined;
        }
        if (this._reject) {
            this._reject();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    done() {
        if (this._disposable) {
            this._disposable.dispose();
            this._disposable = undefined;
        }
        if (this._resolve) {
            this._resolve();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
}
exports.ProgressPart = ProgressPart;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.showDevToolsNotificationIfAppropriate = exports.showFlutterSurveyNotificationIfAppropriate = void 0;
const fs = __webpack_require__(7);
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
/// Shows Survey notification if appropriate. Returns whether a notification was shown
/// (not whether it was clicked/opened).
function showFlutterSurveyNotificationIfAppropriate(context, webClient, openInBrowser, now, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        let surveyData;
        try {
            const rawSurveyJson = yield webClient.fetch(constants_1.flutterSurveyDataUrl);
            const rawSurveyData = JSON.parse(rawSurveyJson);
            surveyData = Object.assign(Object.assign({}, rawSurveyData), { endDate: new Date(rawSurveyData.endDate).getTime(), startDate: new Date(rawSurveyData.startDate).getTime() });
            if (!surveyData.uniqueId || !surveyData.title || !surveyData.url)
                throw new Error(`Survey data did not include ID, Title or URL:\n${rawSurveyJson}`);
        }
        catch (e) {
            logger.error(e);
            return false;
        }
        if (now <= surveyData.startDate || now >= surveyData.endDate)
            return false;
        const lastShown = context.getFlutterSurveyNotificationLastShown(surveyData.uniqueId);
        const doNotShow = context.getFlutterSurveyNotificationDoNotShow(surveyData.uniqueId);
        // Don't show this notification if user previously said not to.
        if (doNotShow)
            return false;
        // Don't show this notification if we've shown it in the last 40 hours.
        if (lastShown && now - lastShown < constants_1.longRepeatPromptThreshold)
            return false;
        // Work out the URL and prompt to show.
        let clientID;
        try {
            const flutterSettingsFolder = constants_1.isWin ?
                process.env.APPDATA || os.homedir()
                : os.homedir();
            const flutterSettingsPath = path.join(flutterSettingsFolder, ".flutter");
            if (fs.existsSync(flutterSettingsPath)) {
                const json = fs.readFileSync(flutterSettingsPath).toString();
                const settings = JSON.parse(json);
                if (settings.enabled !== false) {
                    clientID = settings.clientId;
                }
            }
        }
        catch (_a) {
            logger.warn("Unable to read Flutter settings for preparing survey link");
        }
        const prompt = clientID ? `${surveyData.title} ${constants_1.flutterSurveyAnalyticsText}` : surveyData.title;
        const firstQsSep = surveyData.url.indexOf("?") !== -1 ? "&" : "?";
        const surveyUrl = `${surveyData.url}${firstQsSep}Source=VSCode${clientID ? `&ClientID=${encodeURIComponent(clientID)}` : ""}`;
        // Mark the last time we've shown it (now) so we can avoid showing again for
        // 40 hours.
        context.setFlutterSurveyNotificationLastShown(surveyData.uniqueId, Date.now());
        // Prompt to show and handle response.
        vs.window.showInformationMessage(prompt, constants_1.takeSurveyAction, constants_1.skipThisSurveyAction).then((choice) => __awaiter(this, void 0, void 0, function* () {
            if (choice === constants_1.skipThisSurveyAction) {
                context.setFlutterSurveyNotificationDoNotShow(surveyData.uniqueId, true);
            }
            else if (choice === constants_1.takeSurveyAction) {
                // Mark as do-not-show-again if they answer it, since it seems silly
                // to show them again if they already completed it.
                context.setFlutterSurveyNotificationDoNotShow(surveyData.uniqueId, true);
                yield openInBrowser(surveyUrl);
            }
        }));
        // Return true because we showed the notification and don't want to cause more
        // than one notification per activation.
        return true;
    });
}
exports.showFlutterSurveyNotificationIfAppropriate = showFlutterSurveyNotificationIfAppropriate;
function showDevToolsNotificationIfAppropriate(context) {
    return __awaiter(this, void 0, void 0, function* () {
        const lastShown = context.devToolsNotificationLastShown;
        const doNotShow = context.devToolsNotificationDoNotShow;
        // Don't show this notification more than 10 times or if user said not to.
        if (doNotShow)
            return { didOpen: false };
        // Don't show this notification if we've shown it in the last 20 hours.
        if (lastShown && Date.now() - lastShown < constants_1.noRepeatPromptThreshold)
            return { didOpen: false };
        context.devToolsNotificationLastShown = Date.now();
        const choice = yield vs.window.showInformationMessage(constants_1.wantToTryDevToolsPrompt, constants_1.openDevToolsAction, constants_1.alwaysOpenAction, constants_1.notTodayAction, constants_1.doNotAskAgainAction);
        if (choice === constants_1.doNotAskAgainAction) {
            context.devToolsNotificationDoNotShow = true;
            return { didOpen: false };
        }
        else if (choice === constants_1.alwaysOpenAction) {
            vs.commands.executeCommand("dart.openDevTools");
            return { didOpen: true, shouldAlwaysOpen: true };
        }
        else if (choice === constants_1.openDevToolsAction) {
            vs.commands.executeCommand("dart.openDevTools");
            return { didOpen: true };
        }
        else {
            // No thanks.
            return { didOpen: false };
        }
    });
}
exports.showDevToolsNotificationIfAppropriate = showDevToolsNotificationIfAppropriate;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.writeToPseudoTerminal = void 0;
const vs = __webpack_require__(0);
function writeToPseudoTerminal(messages) {
    const emitter = new vs.EventEmitter();
    const pseudoterminal = {
        close: () => { },
        onDidWrite: emitter.event,
        open: () => {
            for (const output of messages) {
                if (output)
                    emitter.fire(output.replace(/\n/g, "\r\n"));
            }
        },
    };
    const currentTestTerminal = [
        vs.window.createTerminal({ name: "Test Output", pty: pseudoterminal }),
        emitter,
    ];
    currentTestTerminal[0].show();
    return currentTestTerminal;
}
exports.writeToPseudoTerminal = writeToPseudoTerminal;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterOutlineCommands = exports.flutterOutlineCommands = void 0;
const vs = __webpack_require__(0);
exports.flutterOutlineCommands = [
    "refactor.flutter.wrap.center",
    "refactor.flutter.wrap.padding",
    "refactor.flutter.wrap.column",
    "refactor.flutter.move.up",
    "refactor.flutter.move.down",
    "refactor.flutter.removeWidget",
];
class FlutterOutlineCommands {
    constructor(tree, context) {
        this.tree = tree;
        for (const id of exports.flutterOutlineCommands) {
            context.subscriptions.push(vs.commands.registerCommand("_flutter.outline." + id, () => this.applyRefactoring(id)));
        }
    }
    applyRefactoring(refactorType) {
        if (!this.tree.selection || this.tree.selection.length !== 1) {
            console.error(`Invalid selection when running Flutter Outline refactor: ${refactorType}`);
            return;
        }
        const widget = this.tree.selection[0];
        const fix = widget.fixes.filter((f) => f.command).find((f) => f.kind && f.kind.value.endsWith(refactorType));
        if (fix) {
            if (fix.command && fix.command.arguments)
                vs.commands.executeCommand(fix.command.command, ...fix.command.arguments);
            else
                console.error(`Flutter Outline fix was missing command/arguments`);
        }
        else {
            console.error(`Unable to find command for Flutter Outline: ${refactorType}`);
        }
    }
}
exports.FlutterOutlineCommands = FlutterOutlineCommands;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.findNearestOutlineNode = void 0;
function findNearestOutlineNode(fileTracker, document, position, useReducedRange = false, kinds = ["CLASS", "METHOD", "GETTER", "SETTER"]) {
    const outline = fileTracker.getOutlineFor(document.uri);
    return outline && findNode([outline], document.offsetAt(position), useReducedRange, kinds);
}
exports.findNearestOutlineNode = findNearestOutlineNode;
function findNode(outlines, offset, useReducedRange, kinds) {
    if (!outlines)
        return undefined;
    for (const outline of outlines) {
        const outlineStart = outline.offset;
        const outlineEnd = outline.offset + outline.length;
        // Bail if this node is not spanning us.
        if (outlineStart > offset || outlineEnd < offset)
            continue;
        // Although we use the full code range above so that we can walk into children, when performing a match we want to stop
        // at the end of the element, so we use a reduce range to avoid returning a method for the whole of its body.
        const isInReducedRange = !useReducedRange || !outline.element || !outline.element.location
            || (offset >= outlineStart && offset <= outline.element.location.offset + outline.element.location.length);
        return findNode(outline.children, offset, useReducedRange, kinds)
            || (kinds.indexOf(outline.element.kind) !== -1 && isInReducedRange ? outline : undefined);
    }
}


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggingCommands = exports.isLogging = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const config_1 = __webpack_require__(10);
const utils_2 = __webpack_require__(6);
const log_1 = __webpack_require__(131);
exports.isLogging = false;
class LoggingCommands {
    constructor(logger, extensionLogPath) {
        this.logger = logger;
        this.extensionLogPath = extensionLogPath;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.startLogging", this.startLoggingViaPicker, this), vs.commands.registerCommand("dart.startLoggingDebugging", this.startLoggingDebugging, this), vs.commands.registerCommand("dart.startLoggingAnalysisServer", this.startLoggingAnalysisServer, this), vs.commands.registerCommand("dart.startLoggingExtensionOnly", this.startLoggingExtensionOnly, this), vs.commands.registerCommand("dart.openExtensionLog", this.openExtensionLog, this), vs.commands.registerCommand("dart.stopLogging", this.stopLogging, this));
    }
    startLoggingViaPicker() {
        return __awaiter(this, void 0, void 0, function* () {
            const selectedLogCategories = yield vs.window.showQuickPick(Object.keys(log_1.userSelectableLogCategories).map((k) => ({
                label: k,
                logCategory: log_1.userSelectableLogCategories[k],
                picked: true,
            })), {
                canPickMany: true,
                placeHolder: "Select which categories to include in the log",
            });
            if (!selectedLogCategories || !selectedLogCategories.length)
                return;
            return this.startLogging(selectedLogCategories.map((s) => s.logCategory));
        });
    }
    startLoggingDebugging() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.debuggingLogCategories);
        });
    }
    startLoggingAnalysisServer() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.analysisServerLogCategories);
        });
    }
    startLoggingExtensionOnly() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.extensionsLogCategories);
        });
    }
    startLogging(categoriesToLog) {
        return __awaiter(this, void 0, void 0, function* () {
            const logFilename = path.join(fs_1.forceWindowsDriveLetterToUppercase(this.extensionLogPath), this.generateFilename());
            const logUri = vs.Uri.file(logFilename);
            utils_2.createFolderForFile(logFilename);
            const allLoggedCategories = [enums_1.LogCategory.General].concat(categoriesToLog);
            const logger = logging_1.captureLogs(this.logger, fs_1.fsPath(logUri), log_1.getLogHeader(), config_1.config.maxLogLineLength, allLoggedCategories);
            exports.isLogging = true;
            this.disposables.push(logger);
            vs.commands.executeCommand("setContext", constants_1.DART_IS_CAPTURING_LOGS_CONTEXT, true);
            const completer = new utils_1.PromiseCompleter();
            this.currentLogCompleter = completer;
            yield vs.window.withProgress({
                cancellable: true,
                location: vs.ProgressLocation.Notification,
                title: `Dart and Flutter logs are being captured. Reproduce your issue then click Cancel.`,
            }, (_, token) => {
                token.onCancellationRequested(() => completer.resolve());
                return completer.promise;
            });
            exports.isLogging = false;
            yield logger.dispose();
            const doc = yield vs.workspace.openTextDocument(logUri);
            yield vs.window.showTextDocument(doc);
            return logFilename;
        });
    }
    openExtensionLog() {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield vs.workspace.openTextDocument(vs.Uri.file(log_1.getExtensionLogPath()));
            yield vs.window.showTextDocument(doc);
        });
    }
    stopLogging() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentLogCompleter)
                this.currentLogCompleter.resolve();
        });
    }
    generateFilename() {
        const pad = (s) => `0${s.toString()}`.slice(-2);
        const now = new Date();
        const formattedDate = `${now.getFullYear()}-${pad(now.getMonth())}-${pad(now.getDay())} ${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
        return `Dart-Code-Log-${formattedDate}.txt`;
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
exports.LoggingCommands = LoggingCommands;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.addToLogHeader = exports.getLogHeader = exports.clearLogHeader = exports.debuggingLogCategories = exports.extensionsLogCategories = exports.analysisServerLogCategories = exports.userSelectableLogCategories = exports.getExtensionLogPath = void 0;
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const fs_1 = __webpack_require__(1);
const config_1 = __webpack_require__(10);
let extensionLogPath;
function getExtensionLogPath() {
    extensionLogPath = extensionLogPath || config_1.config.extensionLogFile || path.join(process.env.DC_TEST_LOGS || os.tmpdir(), `dart-code-startup-log-${fs_1.getRandomInt(0x1000, 0x10000).toString(16)}.txt`);
    return extensionLogPath;
}
exports.getExtensionLogPath = getExtensionLogPath;
exports.userSelectableLogCategories = {
    "Analysis Server": enums_1.LogCategory.Analyzer,
    "Command Processes": enums_1.LogCategory.CommandProcesses,
    "Debugger and VM Service": enums_1.LogCategory.VmService,
    "DevTools": enums_1.LogCategory.DevTools,
    "Flutter Device Daemon": enums_1.LogCategory.FlutterDaemon,
    "Flutter Run": enums_1.LogCategory.FlutterRun,
    "Flutter Test": enums_1.LogCategory.FlutterTest,
    "Pub Run Test": enums_1.LogCategory.PubTest,
    "Web Daemon": enums_1.LogCategory.WebDaemon,
};
exports.analysisServerLogCategories = [
    enums_1.LogCategory.Analyzer,
    enums_1.LogCategory.CommandProcesses,
];
exports.extensionsLogCategories = [
    enums_1.LogCategory.CommandProcesses,
    enums_1.LogCategory.DevTools,
    enums_1.LogCategory.FlutterDaemon,
];
exports.debuggingLogCategories = Object.values(exports.userSelectableLogCategories)
    .filter((c) => c !== enums_1.LogCategory.Analyzer);
const logHeader = [];
function clearLogHeader() {
    logHeader.length = 0;
}
exports.clearLogHeader = clearLogHeader;
function getLogHeader() {
    if (!logHeader.length)
        return "";
    return logHeader.join(constants_1.platformEol) + constants_1.platformEol + constants_1.platformEol;
}
exports.getLogHeader = getLogHeader;
function addToLogHeader(f) {
    try {
        logHeader.push(f().replace(/\r/g, "").replace(/\n/g, "\r\n"));
    }
    catch (_a) {
        // Don't log here; we may be trying to access things that aren't available yet.
    }
}
exports.addToLogHeader = addToLogHeader;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.markProjectCreationEnded = exports.markProjectCreationStarted = exports.SdkCommands = void 0;
const fs = __webpack_require__(7);
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const utils_1 = __webpack_require__(3);
const array_1 = __webpack_require__(19);
const dartdocs_1 = __webpack_require__(116);
const fs_1 = __webpack_require__(1);
const projects_1 = __webpack_require__(118);
const flutter_samples_1 = __webpack_require__(117);
const utils_2 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
const pub_1 = __webpack_require__(219);
const stagehand_1 = __webpack_require__(220);
const flutter_docs_snippets_1 = __webpack_require__(222);
const sdk_manager_1 = __webpack_require__(223);
const util = __webpack_require__(6);
const processes_1 = __webpack_require__(15);
const projects_2 = __webpack_require__(133);
const channels = __webpack_require__(108);
const packageNameRegex = new RegExp("^[a-z][a-z0-9_]*$");
let isFetchingPackages = false;
let runPubGetDelayTimer;
let lastPubspecSaveReason;
let numProjectCreationsInProgress = 0;
class SdkCommands {
    constructor(logger, context, workspace, sdkUtils, pubGlobal, dartCapabilities, flutterCapabilities, deviceManager) {
        this.logger = logger;
        this.context = context;
        this.workspace = workspace;
        this.sdkUtils = sdkUtils;
        this.pubGlobal = pubGlobal;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.deviceManager = deviceManager;
        // A map of any in-progress commands so we can terminate them if we want to run another.
        this.runningCommands = {};
        this.sdks = workspace.sdks;
        const dartSdkManager = new sdk_manager_1.DartSdkManager(this.logger, this.workspace.sdks);
        context.subscriptions.push(vs.commands.registerCommand("dart.changeSdk", () => dartSdkManager.changeSdk()));
        if (workspace.hasAnyFlutterProjects) {
            const flutterSdkManager = new sdk_manager_1.FlutterSdkManager(this.logger, workspace.sdks);
            context.subscriptions.push(vs.commands.registerCommand("dart.changeFlutterSdk", () => flutterSdkManager.changeSdk()));
        }
        context.subscriptions.push(vs.commands.registerCommand("dart.getPackages", this.getPackages, this));
        context.subscriptions.push(vs.commands.registerCommand("dart.listOutdatedPackages", this.listOutdatedPackages, this));
        context.subscriptions.push(vs.commands.registerCommand("dart.upgradePackages", this.upgradePackages, this));
        // Pub commands.
        context.subscriptions.push(vs.commands.registerCommand("pub.get", (selection) => vs.commands.executeCommand("dart.getPackages", selection)));
        context.subscriptions.push(vs.commands.registerCommand("pub.upgrade", (selection) => vs.commands.executeCommand("dart.upgradePackages", selection)));
        context.subscriptions.push(vs.commands.registerCommand("pub.outdated", (selection) => vs.commands.executeCommand("dart.listOutdatedPackages", selection)));
        // Flutter commands.
        context.subscriptions.push(vs.commands.registerCommand("flutter.packages.get", this.flutterGetPackages, this));
        context.subscriptions.push(vs.commands.registerCommand("flutter.clean", this.flutterClean, this));
        context.subscriptions.push(vs.commands.registerCommand("_flutter.screenshot.touchBar", (args) => vs.commands.executeCommand("flutter.screenshot", args)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.screenshot", this.flutterScreenshot, this));
        context.subscriptions.push(vs.commands.registerCommand("flutter.packages.upgrade", (selection) => vs.commands.executeCommand("dart.upgradePackages", selection)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.packages.outdated", (selection) => vs.commands.executeCommand("dart.listOutdatedPackages", selection)));
        context.subscriptions.push(vs.commands.registerCommand("flutter.doctor", this.flutterDoctor, this));
        context.subscriptions.push(vs.commands.registerCommand("flutter.upgrade", this.flutterUpgrade, this));
        context.subscriptions.push(vs.commands.registerCommand("flutter.createProject", this.createFlutterProject, this));
        context.subscriptions.push(vs.commands.registerCommand("flutter.createProject.module", () => this.createFlutterProject("module"), this));
        context.subscriptions.push(vs.commands.registerCommand("flutter.createProject.package", () => this.createFlutterProject("package"), this));
        context.subscriptions.push(vs.commands.registerCommand("flutter.createProject.plugin", () => this.createFlutterProject("plugin"), this));
        context.subscriptions.push(vs.commands.registerCommand("_dart.flutter.createSampleProject", this.createFlutterSampleProject, this));
        context.subscriptions.push(vs.commands.registerCommand("dart.createProject", this.createDartProject, this));
        context.subscriptions.push(vs.commands.registerCommand("_dart.create", this.dartCreate, this));
        context.subscriptions.push(vs.commands.registerCommand("_flutter.create", this.flutterCreate, this));
        context.subscriptions.push(vs.commands.registerCommand("_flutter.clean", this.flutterClean, this));
        // Hook saving pubspec to run pub.get.
        this.setupPubspecWatcher(context);
    }
    getPackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vscode_1.Uri)) {
                uri = yield projects_2.getFolderToRunCommandIn(this.logger, "Select which folder to get packages for");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "get"], uri);
            else
                return this.runPub(["get"], uri);
        });
    }
    listOutdatedPackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vscode_1.Uri)) {
                uri = yield projects_2.getFolderToRunCommandIn(this.logger, "Select which folder to check for outdated packages");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "outdated"], uri, true);
            else
                return this.runPub(["outdated"], uri, true);
        });
    }
    upgradePackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vscode_1.Uri)) {
                uri = yield projects_2.getFolderToRunCommandIn(this.logger, "Select which folder to upgrade packages in");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "upgrade"], uri);
            else
                return this.runPub(["upgrade"], uri);
        });
    }
    flutterGetPackages(selection) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: This should just bounce to dart.getPackages, and ensure that handles all of the cases here.
            if (!selection) {
                const path = yield projects_2.getFolderToRunCommandIn(this.logger, `Select the folder to run "flutter packages get" in`, selection);
                if (!path)
                    return;
                selection = vs.Uri.file(path);
            }
            // If we're working on the flutter repository, map this on to update-packages.
            if (selection && fs_1.fsPath(selection) === this.workspace.sdks.flutter) {
                return this.runFlutter(["update-packages"], selection);
            }
            return this.runFlutter(["pub", "get"], selection);
        });
    }
    flutterClean(selection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!selection) {
                const path = yield projects_2.getFolderToRunCommandIn(this.logger, `Select the folder to run "flutter clean" in`, selection, true);
                if (!path)
                    return;
                selection = vs.Uri.file(path);
            }
            return this.runFlutter(["clean"], selection);
        });
    }
    flutterScreenshot() {
        return __awaiter(this, void 0, void 0, function* () {
            let shouldNotify = false;
            // If there is no path for this session, or it differs from config, use the one from config.
            if (!this.flutterScreenshotPath ||
                (config_1.config.flutterScreenshotPath && this.flutterScreenshotPath !== config_1.config.flutterScreenshotPath)) {
                this.flutterScreenshotPath = config_1.config.flutterScreenshotPath;
                shouldNotify = true;
            }
            // If path is still empty, bring up the folder selector.
            if (!this.flutterScreenshotPath) {
                const selectedFolder = yield vscode_1.window.showOpenDialog({ canSelectFolders: true, openLabel: "Set screenshots folder" });
                if (selectedFolder && selectedFolder.length > 0) {
                    // Set variable to selected path. This allows prompting the user only once.
                    this.flutterScreenshotPath = selectedFolder[0].path;
                    shouldNotify = true;
                }
                else {
                    // Do nothing if the user cancelled the folder selection.
                    return;
                }
            }
            // Ensure folder exists.
            fs_1.mkDirRecursive(this.flutterScreenshotPath);
            const deviceId = this.deviceManager && this.deviceManager.currentDevice ? this.deviceManager.currentDevice.id : undefined;
            const args = deviceId ? ["screenshot", "-d", deviceId] : ["screenshot"];
            yield this.runFlutterInFolder(this.flutterScreenshotPath, args, "screenshot", true);
            if (shouldNotify) {
                const res = yield vs.window.showInformationMessage(`Screenshots will be saved to ${this.flutterScreenshotPath}`, "Show Folder");
                if (res)
                    yield vs.commands.executeCommand("revealFileInOS", vscode_1.Uri.file(this.flutterScreenshotPath));
            }
        });
    }
    dartCreate(projectPath, templateName) {
        const args = ["global", "run", "stagehand", templateName];
        return this.runPubInFolder(projectPath, args, templateName);
    }
    flutterDoctor() {
        var _a, _b;
        if (!this.workspace.sdks.flutter) {
            this.sdkUtils.showFlutterActivationFailure("flutter.doctor");
            return;
        }
        const tempDir = path.join(os.tmpdir(), "dart-code-cmd-run");
        if (!fs.existsSync(tempDir))
            fs.mkdirSync(tempDir);
        return this.runFlutterInFolder(tempDir, ["doctor", "-v"], "flutter", true, ((_a = this.workspace.config) === null || _a === void 0 ? void 0 : _a.flutterDoctorScript) || ((_b = this.workspace.config) === null || _b === void 0 ? void 0 : _b.flutterScript));
    }
    flutterUpgrade() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.workspace.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("flutter.upgrade");
                return;
            }
            const tempDir = path.join(os.tmpdir(), "dart-code-cmd-run");
            if (!fs.existsSync(tempDir))
                fs.mkdirSync(tempDir);
            yield this.runFlutterInFolder(tempDir, ["upgrade"], "flutter", true);
            yield util.promptToReloadExtension();
        });
    }
    flutterCreate(projectPath, projectName, triggerData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!projectPath) {
                projectPath = yield projects_2.getFolderToRunCommandIn(this.logger, `Select the folder to run "flutter create" in`, undefined, true);
                if (!projectPath)
                    return;
            }
            const args = ["create"];
            if (config_1.config.flutterCreateOffline) {
                args.push("--offline");
            }
            if (projectName) {
                args.push("--project-name");
                args.push(projectName);
            }
            if (config_1.config.flutterCreateOrganization) {
                args.push("--org");
                args.push(config_1.config.flutterCreateOrganization);
            }
            if (config_1.config.flutterCreateIOSLanguage) {
                args.push("--ios-language");
                args.push(config_1.config.flutterCreateIOSLanguage);
            }
            if (config_1.config.flutterCreateAndroidLanguage) {
                args.push("--android-language");
                args.push(config_1.config.flutterCreateAndroidLanguage);
            }
            if (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample) {
                args.push("--sample");
                args.push(triggerData.sample);
                args.push("--overwrite");
            }
            if (triggerData === null || triggerData === void 0 ? void 0 : triggerData.template) {
                args.push("--template");
                args.push(triggerData.template);
                args.push("--overwrite");
            }
            args.push(".");
            return this.runFlutterInFolder(projectPath, args, projectName);
        });
    }
    setupPubspecWatcher(context) {
        context.subscriptions.push(vs.workspace.onWillSaveTextDocument((e) => {
            if (path.basename(fs_1.fsPath(e.document.uri)).toLowerCase() === "pubspec.yaml")
                lastPubspecSaveReason = e.reason;
        }));
        const watcher = vs.workspace.createFileSystemWatcher("**/pubspec.yaml");
        context.subscriptions.push(watcher);
        watcher.onDidChange(this.handlePubspecChange, this);
        watcher.onDidCreate(this.handlePubspecChange, this);
    }
    handlePubspecChange(uri) {
        const filePath = fs_1.fsPath(uri);
        // Never do anything for files inside hidden or build folders.
        if (filePath.includes(`${path.sep}.`) || filePath.includes(`${path.sep}build${path.sep}`)) {
            this.logger.info(`Skipping pubspec change for ignored folder ${filePath}`);
            return;
        }
        this.logger.info(`Pubspec ${filePath} was modified`);
        const conf = config_1.config.for(uri);
        // Don't do anything if we're disabled.
        if (!conf.runPubGetOnPubspecChanges) {
            this.logger.info(`Automatically running "pub get" is disabled`);
            return;
        }
        // Or if the workspace config says we shouldn't run.
        if (this.workspace.config.disableAutomaticPackageGet) {
            this.logger.info(`Workspace suppresses automatic "pub get"`);
            return;
        }
        // Don't do anything if we're in the middle of creating projects, as packages
        // may  be fetched automatically.
        if (numProjectCreationsInProgress > 0) {
            this.logger.info("Skipping package fetch because project creation is in progress");
            return;
        }
        // Cancel any existing delayed timer.
        if (runPubGetDelayTimer) {
            clearTimeout(runPubGetDelayTimer);
        }
        // If the save was triggered by one of the auto-save options, then debounce longer.
        const debounceDuration = lastPubspecSaveReason === vs.TextDocumentSaveReason.FocusOut
            || lastPubspecSaveReason === vs.TextDocumentSaveReason.AfterDelay
            ? 10000
            : 1000;
        runPubGetDelayTimer = setTimeout(() => {
            runPubGetDelayTimer = undefined;
            lastPubspecSaveReason = undefined;
            // tslint:disable-next-line: no-floating-promises
            this.fetchPackagesOrPrompt(uri);
        }, debounceDuration); // TODO: Does this need to be configurable?
    }
    fetchPackagesOrPrompt(uri, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isFetchingPackages) {
                this.logger.info(`Already running pub get, skipping!`);
                return;
            }
            isFetchingPackages = true;
            // TODO: Extract this into a Pub class with the things in pub.ts.
            try {
                const forcePrompt = options && options.alwaysPrompt;
                // We debounced so we might get here and have multiple projects to fetch for
                // for ex. when we change Git branch we might change many files at once. So
                // check how many there are, and if there are:
                //   0 - then just use Uri
                //   1 - then just do that one
                //   more than 1 - prompt to do all
                const workspaceFolders = utils_2.getDartWorkspaceFolders();
                const topLevelFolders = workspaceFolders.map((w) => fs_1.fsPath(w.uri));
                const allExcludedFolders = utils_1.flatMap(workspaceFolders, util.getExcludedFolders);
                const folders = yield fs_1.findProjectFolders(this.logger, topLevelFolders, allExcludedFolders, { requirePubspec: true });
                const foldersRequiringPackageGet = utils_1.uniq(folders)
                    .map(vs.Uri.file)
                    .filter((uri) => config_1.config.for(uri).promptToGetPackages)
                    .filter(pub_1.isPubGetProbablyRequired);
                this.logger.info(`Found ${foldersRequiringPackageGet.length} folders requiring "pub get":${foldersRequiringPackageGet.map((uri) => `\n    ${fs_1.fsPath(uri)}`).join("")}`);
                if (!forcePrompt && foldersRequiringPackageGet.length === 0)
                    yield vs.commands.executeCommand("dart.getPackages", uri);
                else if (!forcePrompt && foldersRequiringPackageGet.length === 1)
                    yield vs.commands.executeCommand("dart.getPackages", foldersRequiringPackageGet[0]);
                else if (foldersRequiringPackageGet.length)
                    pub_1.promptToRunPubGet(foldersRequiringPackageGet);
            }
            finally {
                isFetchingPackages = false;
            }
        });
    }
    runCommandForWorkspace(handler, placeHolder, args, selection, alwaysShowOutput = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const folderToRunCommandIn = yield projects_2.getFolderToRunCommandIn(this.logger, placeHolder, selection);
            if (!folderToRunCommandIn)
                return;
            const containingWorkspace = vs.workspace.getWorkspaceFolder(vs.Uri.file(folderToRunCommandIn));
            if (!containingWorkspace) {
                this.logger.error(`Failed to get workspace folder for ${folderToRunCommandIn}`);
                throw new Error(`Failed to get workspace folder for ${folderToRunCommandIn}`);
            }
            const containingWorkspacePath = fs_1.fsPath(containingWorkspace.uri);
            // Display the relative path from the workspace root to the folder we're running, or if they're
            // the same then the folder name we're running in.
            const shortPath = path.relative(containingWorkspacePath, folderToRunCommandIn)
                || path.basename(folderToRunCommandIn);
            return handler(folderToRunCommandIn, args, shortPath, alwaysShowOutput);
        });
    }
    runFlutter(args, selection, alwaysShowOutput = false) {
        return this.runCommandForWorkspace(this.runFlutterInFolder.bind(this), `Select the folder to run "flutter ${args.join(" ")}" in`, args, selection, alwaysShowOutput);
    }
    runFlutterInFolder(folder, args, shortPath, alwaysShowOutput = false, customScript) {
        if (!this.sdks.flutter)
            throw new Error("Flutter SDK not available");
        const { binPath, binArgs } = utils_1.usingCustomScript(path.join(this.sdks.flutter, constants_1.flutterPath), args, customScript);
        const allArgs = processes_1.getGlobalFlutterArgs()
            .concat(config_1.config.for(vs.Uri.file(folder)).flutterAdditionalArgs)
            .concat(binArgs);
        return this.runCommandInFolder(shortPath, folder, binPath, allArgs, alwaysShowOutput);
    }
    runPub(args, selection, alwaysShowOutput = false) {
        return this.runCommandForWorkspace(this.runPubInFolder.bind(this), `Select the folder to run "pub ${args.join(" ")}" in`, args, selection, alwaysShowOutput);
    }
    runPubInFolder(folder, args, shortPath, alwaysShowOutput = false) {
        if (!this.sdks.dart)
            throw new Error("Dart SDK not available");
        let binPath;
        if (this.dartCapabilities.supportsDartPub) {
            binPath = path.join(this.sdks.dart, constants_1.dartVMPath);
            args = ["pub"].concat(args);
        }
        else {
            binPath = path.join(this.sdks.dart, constants_1.pubPath);
        }
        args = args.concat(...config_1.config.for(vs.Uri.file(folder)).pubAdditionalArgs);
        return this.runCommandInFolder(shortPath, folder, binPath, args, alwaysShowOutput);
    }
    runCommandInFolder(shortPath, folder, binPath, args, alwaysShowOutput) {
        shortPath = shortPath || path.basename(folder);
        const commandName = path.basename(binPath).split(".")[0]; // Trim file extension.
        const channel = channels.createChannel(`${commandName} (${shortPath})`);
        if (alwaysShowOutput)
            channel.show();
        // Figure out if there's already one of this command running, in which case we'll chain off the
        // end of it.
        const commandId = `${folder}|${commandName}|${args}`;
        const existingProcess = this.runningCommands[commandId];
        if (existingProcess && !existingProcess.hasStarted) {
            // We already have a queued version of this command so there's no value in queueing another
            // just bail.
            return Promise.resolve(undefined);
        }
        return vs.window.withProgress({
            cancellable: true,
            location: vscode_1.ProgressLocation.Notification,
            title: `${commandName} ${args.join(" ")}`,
        }, (progress, token) => {
            if (existingProcess) {
                progress.report({ message: "terminating previous command..." });
                existingProcess.cancel();
            }
            else {
                channel.clear();
            }
            const process = new ChainedProcess(() => {
                channel.appendLine(`[${shortPath}] ${commandName} ${args.join(" ")}`);
                progress.report({ message: "running..." });
                const proc = processes_1.safeToolSpawn(folder, binPath, args);
                channels.runProcessInChannel(proc, channel);
                this.logger.info(`(PROC ${proc.pid}) Spawned ${binPath} ${args.join(" ")} in ${folder}`, enums_1.LogCategory.CommandProcesses);
                logging_1.logProcess(this.logger, enums_1.LogCategory.CommandProcesses, proc);
                // If we complete with a non-zero code, or don't complete within 10s, we should show
                // the output pane.
                const completedWithErrorPromise = new Promise((resolve) => proc.on("close", resolve));
                const timedOutPromise = new Promise((resolve) => setTimeout(() => resolve(true), 10000));
                // tslint:disable-next-line: no-floating-promises
                Promise.race([completedWithErrorPromise, timedOutPromise]).then((showOutput) => {
                    if (showOutput)
                        channel.show(true);
                });
                return proc;
            }, existingProcess);
            this.runningCommands[commandId] = process;
            token.onCancellationRequested(() => process.cancel());
            return process.completed;
        });
    }
    createDartProject() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.createStagehandProject("dart.createProject", constants_1.DART_STAGEHAND_PROJECT_TRIGGER_FILE, false);
        });
    }
    createStagehandProject(command, triggerFilename, autoPickIfSingleItem, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.dart) {
                this.sdkUtils.showDartActivationFailure(command);
                return;
            }
            // Get the JSON for the available templates by calling stagehand.
            const stagehand = new stagehand_1.Stagehand(this.logger, this.sdks, this.pubGlobal);
            const isAvailable = yield stagehand.promptToInstallIfRequired();
            if (!isAvailable) {
                return;
            }
            let templates;
            try {
                templates = yield stagehand.getTemplates();
            }
            catch (e) {
                vs.window.showErrorMessage(`Unable to execute Stagehand. ${e}`);
                return;
            }
            const filteredTemplate = filter ? templates.filter(filter) : templates;
            const sortedTemplates = array_1.sortBy(filteredTemplate, (s) => s.label);
            const pickItems = sortedTemplates.map((t) => ({
                description: t.name,
                detail: t.description,
                label: t.label,
                template: t,
            }));
            // Get the user to pick a template (but pick for them if there's only one
            // and autoPickIfSingleItem).
            const selectedTemplate = autoPickIfSingleItem && pickItems.length === 1
                ? pickItems[0]
                : yield vs.window.showQuickPick(pickItems, {
                    matchOnDescription: true,
                    placeHolder: "Which Dart template?",
                });
            if (!selectedTemplate)
                return;
            // If already in a workspace, set the default folder to something nearby.
            const folders = yield vs.window.showOpenDialog({ canSelectFolders: true, openLabel: "Select a folder to create the project in" });
            if (!folders || folders.length !== 1)
                return;
            const folderPath = fs_1.fsPath(folders[0]);
            const defaultName = yield this.nextAvailableName(folderPath, "dart_application_");
            const name = yield vs.window.showInputBox({ prompt: "Enter a name for your new project", placeHolder: defaultName, value: defaultName, validateInput: (s) => this.validateDartProjectName(s, folderPath) });
            if (!name)
                return;
            const projectFolderUri = vscode_1.Uri.file(path.join(folderPath, name));
            const projectFolderPath = fs_1.fsPath(projectFolderUri);
            if (fs.existsSync(projectFolderPath)) {
                vs.window.showErrorMessage(`A folder named ${name} already exists in ${folderPath}`);
                return;
            }
            // Create the empty folder so we can open it.
            fs.mkdirSync(projectFolderPath);
            // Create a temp dart file to force extension to load when we open this folder.
            fs.writeFileSync(path.join(projectFolderPath, triggerFilename), JSON.stringify(selectedTemplate.template));
            // If we're using a custom SDK, we need to apply it to the new project too.
            if (config_1.config.workspaceSdkPath)
                projects_1.writeDartSdkSettingIntoProject(config_1.config.workspaceSdkPath, projectFolderPath);
            const hasFoldersOpen = !!(vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length);
            const openInNewWindow = hasFoldersOpen;
            vs.commands.executeCommand("vscode.openFolder", projectFolderUri, openInNewWindow);
        });
    }
    createFlutterProject(template) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("flutter.createProject");
                return;
            }
            // If already in a workspace, set the default folder to something nearby.
            const folders = yield vs.window.showOpenDialog({ canSelectFolders: true, openLabel: "Select a folder to create the project in" });
            if (!folders || folders.length !== 1)
                return;
            const folderPath = fs_1.fsPath(folders[0]);
            const defaultName = yield this.nextAvailableName(folderPath, "flutter_application_");
            const name = yield vs.window.showInputBox({ prompt: "Enter a name for your new project", placeHolder: defaultName, value: defaultName, validateInput: (s) => this.validateFlutterProjectName(s, folderPath) });
            if (!name)
                return;
            const projectFolderUri = vscode_1.Uri.file(path.join(folderPath, name));
            const projectFolderPath = fs_1.fsPath(projectFolderUri);
            if (fs.existsSync(projectFolderPath)) {
                vs.window.showErrorMessage(`A folder named ${name} already exists in ${folderPath}`);
                return;
            }
            // Create the empty folder so we can open it.
            fs.mkdirSync(projectFolderPath);
            const triggerData = template ? { template } : undefined;
            projects_1.writeFlutterTriggerFile(projectFolderPath, triggerData);
            // If we're using a custom SDK, we need to apply it to the new project too.
            if (config_1.config.workspaceFlutterSdkPath)
                projects_1.writeFlutterSdkSettingIntoProject(config_1.config.workspaceFlutterSdkPath, projectFolderPath);
            const hasFoldersOpen = !!(vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length);
            const openInNewWindow = hasFoldersOpen;
            vs.commands.executeCommand("vscode.openFolder", projectFolderUri, openInNewWindow);
            return projectFolderUri;
        });
    }
    /**
     * Gets a unique path or filename for the specified {folderUri} location, appending a numerical value
     * onto the end of {prefix}, as required.
     *
     * A directory or file location will be generated from {prefix} with a trailing number (eg. `mydir1`) and
     * its existence will be checked; if it already exists, the number will be incremented and checked again.
     *
     * This will continue until a non-existent directory and file is available, or until the maxiumum search
     * limit (of 128) is reached.
     *
     * @param folder directory to check for existing directories or files.
     * @param prefix base name of the directory or file; an integer will be placed
     * at the end of {prefix}, starting from 1. Example: `mydir1` would become `mydir2` if `mydir1` exists.
     */
    nextAvailableName(folder, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            // Set an upper bound on how many attempts we should make in getting a non-existent name.
            const maxSearchLimit = 128;
            for (let index = 1; index <= maxSearchLimit; index++) {
                const name = `${prefix}${index}`;
                const fullPath = path.join(folder, name);
                if (!fs.existsSync(fullPath)) {
                    // Name doesn't appear to exist on-disk and thus can be used - return it.
                    return name;
                }
            }
            // We hit the search limit, so return {prefix}{index} (eg. mydir1) and allow the extension to
            // handle the already-exists condition if user doesn't change it manually.
            return `${prefix}1`;
        });
    }
    createFlutterSampleProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("_dart.flutter.createSampleProject");
                return;
            }
            // Fetch the JSON for the available samples.
            let snippets;
            try {
                snippets = yield flutter_docs_snippets_1.getFlutterSnippets(this.logger, this.sdks, this.flutterCapabilities);
            }
            catch (_a) {
                vs.window.showErrorMessage("Unable to retrieve Flutter documentation snippets");
                return;
            }
            const sortedSnippets = array_1.sortBy(snippets, (s) => s.element);
            const selectedSnippet = yield vs.window.showQuickPick(sortedSnippets.map((s) => ({
                description: `${s.package}/${s.library}`,
                detail: dartdocs_1.stripMarkdown(s.description),
                label: s.element,
                snippet: s,
            })), {
                matchOnDescription: true,
                placeHolder: "Which Flutter sample?",
            });
            if (!selectedSnippet)
                return;
            return flutter_samples_1.createFlutterSampleInTempFolder(this.flutterCapabilities, selectedSnippet.snippet.id, config_1.config.workspaceFlutterSdkPath);
        });
    }
    validateDartProjectName(input, folderDir) {
        if (!packageNameRegex.test(input))
            return "Dart project names should be all lowercase, with underscores to separate words";
        const bannedNames = ["dart", "test"];
        if (bannedNames.includes(input))
            return `You may not use ${input} as the name for a dart project`;
        if (fs.existsSync(path.join(folderDir, input)))
            return `A project with this name already exists within the selected directory`;
    }
    validateFlutterProjectName(input, folderDir) {
        if (!packageNameRegex.test(input))
            return "Flutter project names should be all lowercase, with underscores to separate words";
        const bannedNames = ["flutter", "flutter_test", "test"];
        if (bannedNames.includes(input))
            return `You may not use ${input} as the name for a flutter project`;
        if (fs.existsSync(path.join(folderDir, input)))
            return `A project with this name already exists within the selected directory`;
    }
}
exports.SdkCommands = SdkCommands;
function markProjectCreationStarted() {
    numProjectCreationsInProgress++;
}
exports.markProjectCreationStarted = markProjectCreationStarted;
function markProjectCreationEnded() {
    numProjectCreationsInProgress--;
}
exports.markProjectCreationEnded = markProjectCreationEnded;
class ChainedProcess {
    constructor(spawn, parent) {
        this.spawn = spawn;
        this.processNumber = ChainedProcess.processNumber++;
        this.completer = new utils_1.PromiseCompleter();
        this.completed = this.completer.promise;
        this.isCancelled = false;
        // We'll either start immediately, or if given a parent process only when it completes.
        if (parent) {
            // tslint:disable-next-line: no-floating-promises
            parent.completed.then(() => this.start());
        }
        else {
            this.start();
        }
    }
    get hasStarted() {
        return this.process !== undefined;
    }
    start() {
        if (this.process)
            throw new Error(`${this.processNumber} Can't start an already started process!`);
        if (this.isCancelled) {
            this.completer.resolve(undefined);
            return;
        }
        this.process = this.spawn();
        this.process.on("close", (code) => this.completer.resolve(code));
    }
    cancel() {
        this.isCancelled = true;
    }
}
ChainedProcess.processNumber = 1;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFolderToRunCommandIn = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const utils_2 = __webpack_require__(5);
const project_1 = __webpack_require__(51);
const utils_3 = __webpack_require__(6);
function getFolderToRunCommandIn(logger, placeHolder, selection, flutterOnly = false) {
    return __awaiter(this, void 0, void 0, function* () {
        // Attempt to find a project based on the supplied folder of active file.
        let file = selection && fs_1.fsPath(selection);
        file = file || (vs.window.activeTextEditor && fs_1.fsPath(vs.window.activeTextEditor.document.uri));
        const folder = file && project_1.locateBestProjectRoot(file);
        if (folder)
            return folder;
        // Otherwise look for what projects we have.
        const workspaceFolders = utils_2.getDartWorkspaceFolders();
        const topLevelFolders = workspaceFolders.map((w) => fs_1.fsPath(w.uri));
        const allExcludedFolders = utils_1.flatMap(workspaceFolders, utils_3.getExcludedFolders);
        const selectableFolders = (yield fs_1.findProjectFolders(logger, topLevelFolders, allExcludedFolders, { requirePubspec: true, sort: true }))
            .filter(flutterOnly ? utils_3.isFlutterProjectFolder : () => true);
        if (!selectableFolders || !selectableFolders.length) {
            const projectTypes = flutterOnly ? "Flutter" : "Dart/Flutter";
            vs.window.showWarningMessage(`No ${projectTypes} projects were found.`);
            return undefined;
        }
        return showFolderPicker(selectableFolders, placeHolder); // TODO: What if the user didn't pick anything?
    });
}
exports.getFolderToRunCommandIn = getFolderToRunCommandIn;
function showFolderPicker(folders, placeHolder) {
    return __awaiter(this, void 0, void 0, function* () {
        // No point asking the user if there's only one.
        if (folders.length === 1) {
            return folders[0];
        }
        const items = folders.map((f) => {
            const workspaceFolder = vs.workspace.getWorkspaceFolder(vscode_1.Uri.file(f));
            if (!workspaceFolder)
                return undefined;
            const workspacePathParent = path.dirname(fs_1.fsPath(workspaceFolder.uri));
            return {
                description: utils_3.homeRelativePath(workspacePathParent),
                label: path.relative(workspacePathParent, f),
                path: f,
            };
        }).filter(utils_1.notUndefined);
        const selectedFolder = yield vs.window.showQuickPick(items, { placeHolder });
        return selectedFolder && selectedFolder.path;
    });
}


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartTaskProvider = exports.BaseTaskProvider = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const array_1 = __webpack_require__(19);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
const utils_2 = __webpack_require__(100);
const utils_3 = __webpack_require__(6);
const processes_1 = __webpack_require__(15);
const projects_1 = __webpack_require__(133);
const buildRunnerProblemMatcher = "$dart-build_runner";
const buildRunnerBuildOptions = { problemMatchers: [buildRunnerProblemMatcher], isBackground: true, group: vs.TaskGroup.Build, runtimeArgs: () => config_1.config.buildRunnerAdditionalArgs };
const buildRunnerTestOptions = { problemMatchers: [buildRunnerProblemMatcher], isBackground: true, group: vs.TaskGroup.Test, runtimeArgs: () => config_1.config.buildRunnerAdditionalArgs };
const flutterBuildOptions = { isBackground: true, group: vs.TaskGroup.Build };
const taskOptions = [
    // test must come first so it matches before the next catch-all one
    [["pub", "run", "build_runner", "test"], buildRunnerTestOptions],
    [["pub", "run", "build_runner"], buildRunnerBuildOptions],
    [["build"], flutterBuildOptions],
];
class BaseTaskProvider {
    constructor(logger, context, sdks) {
        this.logger = logger;
        this.context = context;
        this.sdks = sdks;
    }
    /// Tasks that will either be run by Dart or Flutter depending on the project type.
    createSharedTasks(folder) {
        const promises = [];
        promises.push(this.createPubTask(folder, ["get"]));
        promises.push(this.createPubTask(folder, ["upgrade"]));
        if (utils_2.referencesBuildRunner(fs_1.fsPath(folder.uri))) {
            promises.push(this.createPubTask(folder, ["run", "build_runner", "watch"]));
            promises.push(this.createPubTask(folder, ["run", "build_runner", "build"]));
            promises.push(this.createPubTask(folder, ["run", "build_runner", "serve"]));
            promises.push(this.createPubTask(folder, ["run", "build_runner", "test"]));
        }
        return promises;
    }
    resolveTask(task, token) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const scope = task.scope;
            const cwd = "uri" in scope ? fs_1.fsPath(scope.uri) : undefined;
            const definition = task.definition;
            // Pub commands should be run through Flutter if a Flutter project.
            if (definition.command === "pub" && utils_3.isFlutterProjectFolder(cwd)) {
                definition.command = "flutter";
                definition.args = ["pub", ...((_a = definition.args) !== null && _a !== void 0 ? _a : [])];
            }
            const options = this.getOptions(definition);
            if (options === null || options === void 0 ? void 0 : options.runtimeArgs) {
                definition.args = ((_b = definition.args) !== null && _b !== void 0 ? _b : []).concat((_c = (yield (options === null || options === void 0 ? void 0 : options.runtimeArgs()))) !== null && _c !== void 0 ? _c : []);
            }
            this.injectArgs(definition);
            // We *must* return a new Task here, otherwise the task cannot be customised
            // in task.json.
            // https://github.com/microsoft/vscode/issues/58836#issuecomment-696620105
            const newTask = new vs.Task(definition, 
            // This should never be undefined, but the type allows it but the constructor
            // arg does not.
            task.scope || vs.TaskScope.Workspace, task.name, task.source, yield this.createTaskExecution(this.sdks, definition, cwd), undefined);
            newTask.problemMatchers = (_d = (newTask.problemMatchers && newTask.problemMatchers.length ? newTask.problemMatchers : options === null || options === void 0 ? void 0 : options.problemMatchers)) !== null && _d !== void 0 ? _d : [];
            newTask.group = (_e = task.group) !== null && _e !== void 0 ? _e : options === null || options === void 0 ? void 0 : options.group;
            newTask.isBackground = task.isBackground || ((_f = options === null || options === void 0 ? void 0 : options.isBackground) !== null && _f !== void 0 ? _f : false);
            return newTask;
        });
    }
    injectArgs(_) {
    }
    getOptions(def) {
        var _a;
        let taskCommand = [def.command, ...((_a = def.args) !== null && _a !== void 0 ? _a : [])];
        // Strip ""dart" or flutter" from the front for easier matching.
        if (taskCommand[0] === "flutter" || taskCommand[0] === "dart")
            taskCommand = taskCommand.slice(1);
        for (const knownOption of taskOptions) {
            const [command, options] = knownOption;
            if (array_1.arrayStartsWith(taskCommand, command))
                return options;
        }
    }
    createTaskStub(folder, command, args) {
        return new vs.Task({ type: this.type, command, args }, folder, [command, ...args].join(" "), this.type, undefined, undefined);
    }
    createTask(wf, command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const task = this.createTaskStub(wf, command, args);
            return this.resolveTask(task);
        });
    }
    runTask(uri, command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let folder = uri ? vs.workspace.getWorkspaceFolder(uri) : undefined;
            if (!folder) {
                const folderPath = yield projects_1.getFolderToRunCommandIn(this.logger, "Select which project to run the command for");
                if (!folderPath)
                    return;
                folder = vs.workspace.getWorkspaceFolder(vs.Uri.file(folderPath));
            }
            if (!folder)
                return;
            const task = yield this.createTask(folder, command, args);
            return vs.tasks.executeTask(task);
        });
    }
    createTaskExecution(sdks, definition, cwd) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!definition.command)
                return;
            const sdk = definition.command === "flutter" && sdks.flutter ? sdks.flutter : sdks.dart;
            const executable = constants_1.getExecutableName(definition.command);
            const program = path.join(sdk, "bin", executable);
            let args = (_a = definition.args) !== null && _a !== void 0 ? _a : [];
            if (definition.runtimeArgs) {
                const runtimeArgs = yield definition.runtimeArgs();
                if (runtimeArgs)
                    args = args.concat(runtimeArgs);
            }
            return new vs.ProcessExecution(program, args || [], { cwd, env: processes_1.getToolEnv() });
        });
    }
}
exports.BaseTaskProvider = BaseTaskProvider;
class DartTaskProvider extends BaseTaskProvider {
    constructor(logger, context, sdks, dartCapabilities) {
        super(logger, context, sdks);
        this.dartCapabilities = dartCapabilities;
        context.subscriptions.push(vs.commands.registerCommand("dart.task.dartdoc", (uri) => this.runTask(uri, "dartdoc", [])));
    }
    get type() { return DartTaskProvider.type; }
    provideTasks(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const dartProjects = utils_1.getDartWorkspaceFolders();
            let promises = [];
            dartProjects.forEach((folder) => {
                const isFlutter = utils_3.isFlutterWorkspaceFolder(folder);
                if (!isFlutter)
                    promises = promises.concat(this.createSharedTasks(folder));
                promises.push(this.createTask(folder, "dartdoc", []));
                // For testing...
                // tasks.push(this.createTask(folder, "--version"));
            });
            const tasks = (yield Promise.all(promises));
            return tasks;
        });
    }
    createPubTask(folder, args) {
        if (this.dartCapabilities.supportsDartPub)
            return this.createTask(folder, "dart", ["pub", ...args]);
        else
            return this.createTask(folder, "pub", args);
    }
}
exports.DartTaskProvider = DartTaskProvider;
DartTaskProvider.type = "dart"; // also referenced in package.json


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ClosingLabelsDecorations = exports.validLastCharacters = void 0;
const vs = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(6);
exports.validLastCharacters = [")", "]"];
class ClosingLabelsDecorations {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.decorationType = vs.window.createTextEditorDecorationType({
            after: {
                color: new vs.ThemeColor("dart.closingLabels"),
                margin: "2px",
            },
            rangeBehavior: vs.DecorationRangeBehavior.ClosedOpen,
        });
        this.subscriptions.push(this.analyzer.registerForAnalysisClosingLabels((n) => {
            if (this.activeEditor && n.file === fs_1.fsPath(this.activeEditor.document.uri)) {
                this.closingLabels = n;
                this.update();
            }
        }));
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
        if (vs.window.activeTextEditor)
            this.setTrackingFile(vs.window.activeTextEditor);
    }
    update() {
        if (!this.closingLabels || !this.activeEditor || this.closingLabels.file !== fs_1.fsPath(this.activeEditor.document.uri))
            return;
        const decorations = [];
        for (const r of this.closingLabels.labels) {
            // Ensure the label we got looks like a sensible range, otherwise the outline info
            // might be stale (eg. we sent two updates, and the outline from in between them just
            // arrived). In this case, we'll just bail and do nothing, assuming a future update will
            // have the correct info.
            const finalCharacterPosition = this.activeEditor.document.positionAt(r.offset + r.length);
            if (finalCharacterPosition.character < 1)
                return;
            const finalCharacterRange = new vs.Range(finalCharacterPosition.translate({ characterDelta: -1 }), finalCharacterPosition);
            const finalCharacterText = this.activeEditor.document.getText(finalCharacterRange);
            if (exports.validLastCharacters.indexOf(finalCharacterText) === -1)
                return;
            // Get the end of the line where we'll show the labels.
            const endOfLine = this.activeEditor.document.lineAt(finalCharacterPosition).range.end;
            const existingDecorationForLine = decorations[endOfLine.line];
            if (existingDecorationForLine) {
                existingDecorationForLine.renderOptions.after.contentText = " // " + r.label + " " + existingDecorationForLine.renderOptions.after.contentText;
            }
            else {
                const dec = {
                    range: new vs.Range(this.activeEditor.document.positionAt(r.offset), endOfLine),
                    renderOptions: { after: { contentText: " // " + r.label } },
                };
                decorations[endOfLine.line] = dec;
            }
        }
        this.activeEditor.setDecorations(this.decorationType, Object.keys(decorations).map((k) => parseInt(k, 10)).map((k) => decorations[k]));
    }
    setTrackingFile(editor) {
        var _a;
        if (!editor || !utils_1.isAnalyzable(editor.document))
            return;
        if (editor !== this.activeEditor)
            (_a = this.activeEditor) === null || _a === void 0 ? void 0 : _a.setDecorations(this.decorationType, []);
        if (editor) {
            this.activeEditor = editor;
            this.closingLabels = undefined;
            this.analyzer.forceNotificationsFor(fs_1.fsPath(editor.document.uri));
        }
        else {
            this.activeEditor = undefined;
            this.closingLabels = undefined;
        }
    }
    dispose() {
        var _a;
        (_a = this.activeEditor) === null || _a === void 0 ? void 0 : _a.setDecorations(this.decorationType, []);
        this.activeEditor = undefined;
        this.subscriptions.forEach((s) => s.dispose());
    }
}
exports.ClosingLabelsDecorations = ClosingLabelsDecorations;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IconRangeComputerLsp = exports.IconRangeComputer = void 0;
const flutter_outline_1 = __webpack_require__(230);
const utils_1 = __webpack_require__(5);
class IconRangeComputer {
    constructor(logger) {
        this.logger = logger;
    }
    compute(document, outline) {
        const iconVisitor = new FlutterOutlineIconVisitor(this.logger);
        iconVisitor.visit(outline);
        // Now build a map of all possible decorations, with those in this file. We need to include all
        // icons so if any were removed, we will clear their decorations.
        const decs = {};
        iconVisitor.icons.forEach((icon) => {
            const iconFile = `${icon.type}/${icon.iconName}`;
            if (!decs[iconFile])
                decs[iconFile] = [];
            decs[iconFile].push(utils_1.toRange(document, icon.offset, icon.length));
        });
        return decs;
    }
}
exports.IconRangeComputer = IconRangeComputer;
class FlutterOutlineIconVisitor extends flutter_outline_1.FlutterOutlineVisitor {
    constructor() {
        super(...arguments);
        this.icons = [];
        this.materialIconValuePattern = new RegExp("^Icons\\.([\\w_]+)$");
        this.cupertinoIconValuePattern = new RegExp("^CupertinoIcons\\.([\\w_]+)$");
    }
    visitAttribute(attribute) {
        if (attribute.label && attribute.valueLocation) {
            let match = this.materialIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], offset: attribute.valueLocation.offset, type: "material", length: attribute.valueLocation.length });
            match = this.cupertinoIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], offset: attribute.valueLocation.offset, type: "cupertino", length: attribute.valueLocation.length });
        }
    }
}
class IconRangeComputerLsp {
    constructor(logger) {
        this.logger = logger;
    }
    compute(outline) {
        const iconVisitor = new FlutterOutlineIconVisitorLsp(this.logger);
        iconVisitor.visit(outline);
        // Now build a map of all possible decorations, with those in this file. We need to include all
        // icons so if any were removed, we will clear their decorations.
        const decs = {};
        iconVisitor.icons.forEach((icon) => {
            const iconFile = `${icon.type}/${icon.iconName}`;
            if (!decs[iconFile])
                decs[iconFile] = [];
            decs[iconFile].push(utils_1.lspToRange(icon.range));
        });
        return decs;
    }
}
exports.IconRangeComputerLsp = IconRangeComputerLsp;
class FlutterOutlineIconVisitorLsp extends flutter_outline_1.FlutterOutlineVisitorLsp {
    constructor() {
        super(...arguments);
        this.icons = [];
        this.materialIconValuePattern = new RegExp("^Icons\\.([\\w_]+)$");
        this.cupertinoIconValuePattern = new RegExp("^CupertinoIcons\\.([\\w_]+)$");
    }
    visitAttribute(attribute) {
        if (attribute.label && attribute.valueRange) {
            let match = this.materialIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], range: attribute.valueRange, type: "material" });
            match = this.cupertinoIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], range: attribute.valueRange, type: "cupertino" });
        }
    }
}


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterIconDecorations = void 0;
const vs = __webpack_require__(0);
const extension_utils_1 = __webpack_require__(20);
const utils_1 = __webpack_require__(6);
class FlutterIconDecorations {
    constructor(logger) {
        this.logger = logger;
        this.subscriptions = [];
        this.decorationTypes = {};
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            this.setTrackingFile(e);
            this.update();
        }));
        setImmediate(() => {
            this.setTrackingFile(vs.window.activeTextEditor);
            this.update();
        });
    }
    render(results) {
        if (!this.activeEditor)
            return;
        // Each icon type needs to be its own decoration, so here we update our main list
        // with any new ones we hadn't previously created.
        for (const iconName of Object.keys(results)) {
            if (!this.decorationTypes[iconName])
                this.decorationTypes[iconName] = vs.window.createTextEditorDecorationType({
                    gutterIconPath: vs.Uri.parse(extension_utils_1.docsIconPathFormat.replace("$1", iconName)),
                    gutterIconSize: "75%",
                });
        }
        for (const iconName of Object.keys(this.decorationTypes)) {
            this.activeEditor.setDecorations(this.decorationTypes[iconName], results[iconName] || []);
        }
    }
    setTrackingFile(editor) {
        if (editor && utils_1.isAnalyzable(editor.document))
            this.activeEditor = editor;
        else
            this.activeEditor = undefined;
    }
    dispose() {
        this.activeEditor = undefined;
        this.subscriptions.forEach((s) => s.dispose());
    }
}
exports.FlutterIconDecorations = FlutterIconDecorations;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WidgetGuide = exports.FlutterUiGuideDecorations = void 0;
const vs = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const trackers_1 = __webpack_require__(233);
const config_1 = __webpack_require__(10);
const nonBreakingSpace = "\xa0";
const verticalLine = "│";
const horizontalLine = "─";
const bottomCorner = "└";
const middleCorner = "├";
class FlutterUiGuideDecorations {
    constructor() {
        this.disposables = [];
        this.borderDecoration = vs.window.createTextEditorDecorationType({
            rangeBehavior: vs.DecorationRangeBehavior.OpenOpen,
        });
        // Update any editor that becomes active.
        this.disposables.push(vs.window.onDidChangeActiveTextEditor((e) => this.buildForTextEditor(e)));
        if (config_1.config.previewFlutterUiGuidesCustomTracking) {
            this.tracker = new WidgetGuideTracker();
            this.disposables.push(this.tracker);
            // Subscribe to updates from the tracker so we can update on keypress without
            // waiting for new Outlines.
            this.tracker.onGuidesChanged(([doc, guides]) => this.buildFromUpdatedGuides(doc, guides));
        }
        // Update the current visible editor when we were registered.
        setImmediate(() => this.buildForTextEditor(vs.window.activeTextEditor));
    }
    buildFromUpdatedGuides(doc, guides) {
        if (vs.window.activeTextEditor && vs.window.activeTextEditor.document === doc)
            this.renderGuides(vs.window.activeTextEditor, guides, "#A3A3A3" /* "#FFA3A3" */);
    }
    renderGuides(editor, guides, color) {
        const guidesByLine = {};
        for (const guide of guides) {
            for (let line = guide.start.line; line <= guide.end.line; line++) {
                guidesByLine[line] = guidesByLine[line] || [];
                guidesByLine[line].push(guide);
            }
        }
        const decorations = this.buildDecorations(editor.document, editor.options.tabSize, guidesByLine, color);
        editor.setDecorations(this.borderDecoration, decorations);
    }
    buildDecorations(doc, tabSize, guidesByLine, color) {
        const decorations = [];
        for (const line of Object.keys(guidesByLine).map((k) => parseInt(k, 10))) {
            const lineInfo = doc.lineAt(line);
            const firstGuideChar = Math.min(...guidesByLine[line].map((g) => Math.min(g.start.character, g.end.character)));
            const lastGuideChar = Math.max(...guidesByLine[line].map((g) => Math.max(g.start.character, g.end.character)));
            const lastLineCharacter = lineInfo.range.end.character;
            const anchorPoint = Math.max(lastLineCharacter < firstGuideChar ? 0 : firstGuideChar, 0);
            const decorationString = new Array(lastGuideChar).fill(nonBreakingSpace);
            for (const guide of guidesByLine[line]) {
                if (line !== guide.end.line) {
                    // Only put a vertical line in if we haven't already o
                    if (decorationString[guide.start.character] === nonBreakingSpace)
                        decorationString[guide.start.character] = verticalLine;
                    else if (decorationString[guide.start.character] === bottomCorner)
                        decorationString[guide.start.character] = middleCorner;
                }
                else {
                    for (let c = guide.start.character; c <= guide.end.character; c++) {
                        if (c === guide.start.character) {
                            decorationString[c] = bottomCorner;
                        }
                        else {
                            decorationString[c] = horizontalLine;
                        }
                    }
                }
            }
            // For any characters that have users text in them, we should not
            // render any guides.
            decorationString.fill(nonBreakingSpace, lineInfo.firstNonWhitespaceCharacterIndex, lineInfo.range.end.character);
            decorationString.splice(0, anchorPoint);
            // For any tabs in the document string, we need to multiply up the characters
            // by the tab width, since everything up to this point is based on the text line
            // character indexes, but rendering needs to obey tab size.
            const tabAdjustedDecorationString = [];
            for (let i = 0; i < decorationString.length; i++) {
                tabAdjustedDecorationString.push(decorationString[i]);
                if (lineInfo.text[anchorPoint + i] === "\t") {
                    const padCharacter = decorationString[i] === horizontalLine || decorationString[i] === bottomCorner || decorationString[i] === middleCorner
                        ? horizontalLine
                        : nonBreakingSpace;
                    for (let c = 0; c < tabSize - 1; c++)
                        tabAdjustedDecorationString.push(padCharacter);
                }
            }
            decorations.push({
                range: new vs.Range(new vs.Position(line, anchorPoint), new vs.Position(line, anchorPoint)),
                renderOptions: {
                    before: {
                        color,
                        contentText: tabAdjustedDecorationString.join(""),
                        fontStyle: "normal",
                        margin: "0 3px 0 -3px",
                        width: "0",
                    },
                },
            });
        }
        return decorations;
    }
    firstNonWhitespace(document, lineNumber) {
        return new vs.Position(lineNumber, document.lineAt(lineNumber).firstNonWhitespaceCharacterIndex);
    }
    dispose() {
        this.disposables.forEach((s) => s.dispose());
    }
}
exports.FlutterUiGuideDecorations = FlutterUiGuideDecorations;
class WidgetGuide {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
}
exports.WidgetGuide = WidgetGuide;
class WidgetGuideTracker {
    constructor() {
        this.disposables = [];
        this.tracker = new trackers_1.DocumentPositionTracker();
        this.guideMap = new Map();
        this.onGuidesChangedEmitter = new vs.EventEmitter();
        this.onGuidesChanged = this.onGuidesChangedEmitter.event;
        this.disposables.push(this.tracker);
        this.tracker.onPositionsChanged(([doc, positions]) => {
            // Map all our original positions onto new positions based on their
            // new offsets.
            const newGuides = [];
            for (const guide of this.guideMap.keys()) {
                const data = this.guideMap.get(guide);
                const currentStartPos = data[0];
                const currentEndPos = data[1];
                const newStartPos = positions.get(currentStartPos);
                const newEndPos = positions.get(currentEndPos);
                if (newStartPos && newEndPos)
                    newGuides.push(new WidgetGuide(newStartPos, newEndPos));
            }
            this.onGuidesChangedEmitter.fire([doc, newGuides]);
        });
    }
    clear() {
        this.guideMap.clear();
        this.tracker.clear();
    }
    trackDoc(document, guides) {
        // Stash all guides as tuples containing their positions.
        this.guideMap.clear();
        for (const guide of guides)
            this.guideMap.set(guide, [guide.start, guide.end]);
        // Extract a flat list of positions to track.
        const positions = utils_1.flatMap([...this.guideMap.values()], (g) => [g[0], g[1]]);
        this.tracker.trackDoc(document, positions);
    }
    dispose() {
        this.disposables.forEach((s) => s.dispose());
    }
}


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getFutterWebRendererArg = void 0;
function getFutterWebRendererArg(flutterCapabilities, renderer, existingArgs) {
    if (!flutterCapabilities.supportsWebRendererOption)
        return;
    if (!renderer || renderer === "default")
        return;
    const alreadyHasArg = existingArgs === null || existingArgs === void 0 ? void 0 : existingArgs.find((a) => a.startsWith("--web-renderer=") || a === "--web-renderer");
    if (alreadyHasArg)
        return;
    return `--web-renderer=${renderer}`;
}
exports.getFutterWebRendererArg = getFutterWebRendererArg;


/***/ }),
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WebClient = void 0;
const http = __webpack_require__(60);
const https = __webpack_require__(41);
const url = __webpack_require__(30);
class WebClient {
    constructor(extensionVersion) {
        this.userAgent = `Dart-Code/${extensionVersion} (https://dartcode.org/)`;
    }
    // TODO: Move over things over to this...
    fetch(urlString, headers) {
        const u = url.parse(urlString);
        if (u.protocol === "https:" && u.hostname)
            return this.fetchHttps(u.hostname, u.port || "443", u.path || "", headers);
        else if (u.protocol === "http:" && u.hostname)
            return this.fetchHttp(u.hostname, u.port || "80", u.path || "", headers);
        else
            throw new Error(`Cannot fetch URL ${urlString}`);
    }
    fetchHttps(hostname, port, path, headers = {}) {
        return new Promise((resolve, reject) => {
            const options = {
                headers: Object.assign(Object.assign({}, headers), { "User-Agent": this.userAgent }),
                hostname,
                method: "GET",
                path,
                port,
            };
            const req = https.request(options, (resp) => {
                if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                    reject({ message: `Failed to get ${path}: ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
                }
                else {
                    const chunks = [];
                    resp.on("data", (b) => chunks.push(b.toString()));
                    resp.on("end", () => {
                        const data = chunks.join("");
                        resolve(data);
                    });
                }
            });
            req.end();
        });
    }
    fetchHttp(hostname, port, path, headers = {}) {
        return new Promise((resolve, reject) => {
            const options = {
                headers: Object.assign(Object.assign({}, headers), { "User-Agent": this.userAgent }),
                hostname,
                method: "GET",
                path,
                port,
            };
            const req = http.request(options, (resp) => {
                if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                    reject({ message: `Failed to get ${path}: ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
                }
                else {
                    const chunks = [];
                    resp.on("data", (b) => chunks.push(b.toString()));
                    resp.on("end", () => {
                        const data = chunks.join("");
                        resolve(data);
                    });
                }
            });
            req.end();
        });
    }
}
exports.WebClient = WebClient;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubApi = void 0;
class PubApi {
    constructor(webClient) {
        this.webClient = webClient;
        this.pubHost = process.env.PUB_HOSTED_URL || "https://pub.dev";
    }
    getPackage(packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.get(`packages/${packageID}`);
        });
    }
    get(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {
                Accept: "application/vnd.pub.v2+json",
            };
            return JSON.parse(yield this.webClient.fetch(`${this.pubHost}/api/${url}`, headers));
        });
    }
}
exports.PubApi = PubApi;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.internalApiSymbol = void 0;
// TODO: Can we make this work better when webpack'd?
exports.internalApiSymbol = "_privateApi"; // Symbol();


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestSessionCoordindator = void 0;
const enums_1 = __webpack_require__(8);
const events_1 = __webpack_require__(42);
const utils_1 = __webpack_require__(3);
const test_model_1 = __webpack_require__(61);
/// Handles results from a test debug session and provides them to the test model.
class TestSessionCoordindator {
    constructor(logger, data) {
        this.logger = logger;
        this.data = data;
        this.disposables = [];
        this.onDidStartTestsEmitter = new events_1.EventEmitter();
        this.onDidStartTests = this.onDidStartTestsEmitter.event;
        this.onFirstFailureEmitter = new events_1.EventEmitter();
        this.onFirstFailure = this.onFirstFailureEmitter.event;
        /// A link between a suite path and the debug session ID that owns it.
        this.owningDebugSessions = {};
    }
    handleDebugSessionCustomEvent(e) {
        var _a;
        if (e.event === "dart.testRunNotification") {
            // tslint:disable-next-line: no-floating-promises
            // TODO: Why do we get no session in tests???
            this.handleNotification((_a = e.session) === null || _a === void 0 ? void 0 : _a.id, e.body.suitePath, e.body.notification).catch((e) => this.logger.error(e));
        }
    }
    handleDebugSessionEnd(debugSessionID) {
        // Get the suite paths that have us as the owning debug session.
        const suitePaths = Object.keys(this.owningDebugSessions).filter((suitePath) => {
            const owningSessionID = this.owningDebugSessions[suitePath];
            return owningSessionID === debugSessionID;
        });
        // End them all and remove from the lookup.
        for (const suitePath of suitePaths) {
            this.handleSuiteEnd(this.data.suites[suitePath]);
            this.owningDebugSessions[suitePath] = undefined;
            delete this.owningDebugSessions[suitePath];
        }
    }
    handleNotification(debugSessionID, suitePath, evt) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we're starting a suite, record us as the owner so we can clean up later
            if (evt.type === "suite")
                this.owningDebugSessions[suitePath] = debugSessionID;
            const suite = this.data.suites[suitePath];
            switch (evt.type) {
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "start":
                // 	this.handleStartNotification(evt as StartNotification);
                // 	break;
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "allSuites":
                // 	this.handleAllSuitesNotification(evt as AllSuitesNotification);
                // 	break;
                case "suite":
                    this.handleSuiteNotification(suitePath, evt);
                    break;
                case "testStart":
                    this.handleTestStartNotifcation(suite, evt);
                    break;
                case "testDone":
                    this.handleTestDoneNotification(suite, evt);
                    break;
                case "group":
                    this.handleGroupNotification(suite, evt);
                    break;
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "done":
                // 	this.handleDoneNotification(suite, evt as DoneNotification);
                // 	break;
                case "print":
                    this.handlePrintNotification(suite, evt);
                    break;
                case "error":
                    this.handleErrorNotification(suite, evt);
                    break;
            }
        });
    }
    handleSuiteNotification(suitePath, evt) {
        const [suite, didCreate] = this.data.getOrCreateSuite(evt.suite.path);
        suite.node.status = enums_1.TestStatus.Waiting;
        this.data.updateNode(suite.node);
        this.data.updateNode();
        // If this is the first suite, we've started a run and can show the tree.
        // We need to wait for the tree node to have been rendered though so setTimeout :(
        if (this.data.isNewTestRun) {
            this.data.isNewTestRun = false;
            this.onDidStartTestsEmitter.fire(suite.node);
        }
    }
    handleTestStartNotifcation(suite, evt) {
        var _a;
        const existingTest = suite.getCurrentTest(evt.test.id) || suite.reuseMatchingTest(suite.currentRunNumber, evt.test);
        const oldParent = existingTest === null || existingTest === void 0 ? void 0 : existingTest.parent;
        const parent = ((_a = evt.test.groupIDs) === null || _a === void 0 ? void 0 : _a.length) ? suite.getMyGroup(suite.currentRunNumber, evt.test.groupIDs[evt.test.groupIDs.length - 1]) : suite.node;
        const path = (evt.test.root_url || evt.test.url) ? utils_1.uriToFilePath(evt.test.root_url || evt.test.url) : undefined;
        const line = evt.test.root_line || evt.test.line;
        const column = evt.test.root_column || evt.test.column;
        const testNode = existingTest || new test_model_1.TestNode(suite, parent, evt.test.id, evt.test.name, path, line, column);
        if (!existingTest) {
            suite.storeTest(testNode);
        }
        else {
            testNode.parent = parent;
            testNode.id = evt.test.id;
            testNode.name = evt.test.name;
            testNode.path = path;
            testNode.line = line;
            testNode.column = column;
        }
        testNode.testStartTime = evt.time;
        // If this is a "loading" test then mark it as hidden because it looks wonky in
        // the tree with a full path and we already have the "running" icon on the suite.
        if (testNode.name && testNode.name.startsWith("loading ") && testNode.parent instanceof test_model_1.SuiteNode)
            testNode.hidden = true;
        else
            testNode.hidden = false;
        // Remove from old parent if required.
        const hasChangedParent = oldParent && oldParent !== testNode.parent;
        if (oldParent && hasChangedParent) {
            oldParent.tests.splice(oldParent.tests.indexOf(testNode), 1);
            this.data.updateNode(oldParent);
        }
        // Push to new parent if required.
        if (!existingTest || hasChangedParent)
            testNode.parent.tests.push(testNode);
        testNode.status = enums_1.TestStatus.Running;
        this.data.updateNode(testNode);
        this.data.updateNode(testNode.parent);
        if (!testNode.hidden)
            this.data.updateSuiteStatuses(suite);
    }
    handleTestDoneNotification(suite, evt) {
        const testNode = suite.getCurrentTest(evt.testID);
        testNode.hidden = evt.hidden;
        if (evt.skipped) {
            testNode.status = enums_1.TestStatus.Skipped;
        }
        else if (evt.result === "success") {
            testNode.status = enums_1.TestStatus.Passed;
        }
        else if (evt.result === "failure") {
            testNode.status = enums_1.TestStatus.Failed;
        }
        else if (evt.result === "error")
            testNode.status = enums_1.TestStatus.Errored;
        else {
            testNode.status = enums_1.TestStatus.Unknown;
        }
        if (evt.time && testNode.testStartTime) {
            testNode.duration = evt.time - testNode.testStartTime;
            testNode.description = `${testNode.duration}ms`;
            // Don't clear this, as concurrent runws will overwrite each
            // other and then we'll get no time at the end.
            // testNode.testStartTime = undefined;
        }
        this.data.updateNode(testNode);
        this.data.updateNode(testNode.parent);
        this.data.updateSuiteStatuses(suite);
        if ((testNode.status === enums_1.TestStatus.Failed || testNode.status === enums_1.TestStatus.Errored) && this.data.nextFailureIsFirst) {
            this.data.nextFailureIsFirst = false;
            this.onFirstFailureEmitter.fire(testNode);
        }
    }
    handleGroupNotification(suite, evt) {
        const existingGroup = suite.getCurrentGroup(evt.group.id) || suite.reuseMatchingGroup(suite.currentRunNumber, evt.group);
        const oldParent = existingGroup === null || existingGroup === void 0 ? void 0 : existingGroup.parent;
        const parent = evt.group.parentID ? suite.getMyGroup(suite.currentRunNumber, evt.group.parentID) : suite.node;
        const path = (evt.group.root_url || evt.group.url) ? utils_1.uriToFilePath(evt.group.root_url || evt.group.url) : undefined;
        const line = evt.group.root_line || evt.group.line;
        const column = evt.group.root_column || evt.group.column;
        const groupNode = existingGroup || new test_model_1.GroupNode(suite, parent, evt.group.id, evt.group.name, path, line, column);
        if (!existingGroup) {
            suite.storeGroup(groupNode);
        }
        else {
            groupNode.parent = parent;
            groupNode.id = evt.group.id;
            groupNode.name = evt.group.name;
            groupNode.path = path;
            groupNode.line = line;
            groupNode.column = column;
        }
        // Remove from old parent if required
        const hasChangedParent = oldParent !== parent;
        if (oldParent && hasChangedParent) {
            oldParent.groups.splice(oldParent.groups.indexOf(groupNode), 1);
            this.data.updateNode(oldParent);
        }
        // Push to new parent if required.
        if (!existingGroup || hasChangedParent)
            groupNode.parent.groups.push(groupNode);
        groupNode.status = enums_1.TestStatus.Running;
        this.data.updateNode(groupNode);
        this.data.updateNode(groupNode.parent);
    }
    handleSuiteEnd(suite) {
        if (!suite)
            return;
        // TODO: Some notification that things are complete?
        // TODO: Maybe a progress bar during the run?
        // Hide nodes that were marked as potentially deleted and then never updated.
        // This means they weren't run in the last run, so probably were deleted (or
        // renamed and got new nodes, which still means the old ones should be removed).
        suite.getAllTests(true).filter((t) => t.isPotentiallyDeleted || t.hidden).forEach((t) => {
            t.hidden = true;
            this.data.updateNode(t.parent);
        });
        // Anything marked as running should be set back to Unknown
        suite.getAllTests().filter((t) => t.status === enums_1.TestStatus.Running).forEach((t) => {
            t.status = enums_1.TestStatus.Unknown;
            this.data.updateNode(t);
        });
        this.data.updateSuiteStatuses(suite);
    }
    handlePrintNotification(suite, evt) {
        const test = suite.getCurrentTest(evt.testID);
        test.outputEvents.push(evt);
    }
    handleErrorNotification(suite, evt) {
        const test = suite.getCurrentTest(evt.testID);
        test.outputEvents.push(evt);
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.TestSessionCoordindator = TestSessionCoordindator;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterDeviceManager = void 0;
const vs = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const utils_2 = __webpack_require__(5);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const processes_1 = __webpack_require__(43);
const array_1 = __webpack_require__(19);
const utils_3 = __webpack_require__(5);
class FlutterDeviceManager {
    constructor(logger, daemon, config) {
        this.logger = logger;
        this.daemon = daemon;
        this.config = config;
        this.subscriptions = [];
        this.devices = [];
        this.knownEmulatorNames = {};
        this.statusBarItem = vs.window.createStatusBarItem(vs.StatusBarAlignment.Right, 1);
        this.statusBarItem.tooltip = "Flutter";
        this.statusBarItem.command = "flutter.selectDevice";
        this.statusBarItem.show();
        this.updateStatusBar();
        // Force a request for emulators to stash their names, so we can display
        // the better name if the automatically-selected device happens to be an
        // emulator.
        this.getEmulators().then(() => this.updateStatusBar()).catch((e) => console.error(e));
        this.subscriptions.push(this.statusBarItem);
        daemon.registerForDeviceAdded(this.deviceAdded.bind(this));
        daemon.registerForDeviceRemoved(this.deviceRemoved.bind(this));
    }
    dispose() {
        this.subscriptions.forEach((s) => s.dispose());
    }
    isSupported(types, device) {
        // If we don't get any types to filter, assume everything is valid.
        return device && (!types || !types.length || !device.platformType || types.indexOf(device.platformType) !== -1);
    }
    deviceAdded(dev) {
        return __awaiter(this, void 0, void 0, function* () {
            dev = Object.assign(Object.assign({}, dev), { type: "device" });
            this.devices.push(dev);
            // undefined is treated as true for backwards compatibility.
            const canAutoSelectDevice = dev.ephemeral !== false;
            const maySelectThisDevice = () => {
                var _a;
                return !this.currentDevice
                    || (this.config.flutterSelectDeviceWhenConnected && canAutoSelectDevice)
                    // HACK: If the Chrome device becomes available and the selected device is
                    // web-server, allow switching because most users would prefer the Chrome device.
                    // We can revert this in future if Flutter changes the order these devices show up
                    // or has some other way of deciding priority.
                    || (((_a = this.currentDevice) === null || _a === void 0 ? void 0 : _a.id) === "web-server" && dev.id === "chrome");
            };
            if (maySelectThisDevice()) {
                // Finally, check if it's valid for the workspace. We don't want to
                // auto-select to a mobile if you have a web-only project open.
                const supportedPlatforms = yield this.getSupportedPlatformsForWorkspace();
                // We need to re-check maySelectThisDevice() as the answer may have changed if
                // another device was selected while we were awaiting (which would prevent us
                // selecting a non-ephemeral device here).
                if (maySelectThisDevice() && this.isSupported(supportedPlatforms, dev)) {
                    this.currentDevice = dev;
                    this.updateStatusBar();
                }
            }
        });
    }
    deviceRemoved(dev) {
        return __awaiter(this, void 0, void 0, function* () {
            this.devices = this.devices.filter((d) => d.id !== dev.id);
            if (this.currentDevice && this.currentDevice.id === dev.id) {
                this.currentDevice = undefined;
                // Try to select the next-best device
                if (this.devices.length) {
                    const supportedPlatforms = yield this.getSupportedPlatformsForWorkspace();
                    const supportedDevices = this.devices.filter((d) => this.isSupported(supportedPlatforms, d));
                    if (supportedDevices && supportedDevices.length)
                        this.currentDevice = supportedDevices[0];
                }
                this.updateStatusBar();
            }
        });
    }
    showDevicePicker(supportedTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we weren't passed any supported types, we should try to get them for
            // the whole workspace.
            if (!supportedTypes && this.daemon.capabilities.providesPlatformTypes) {
                supportedTypes = yield this.getSupportedPlatformsForWorkspace();
            }
            const quickPick = vs.window.createQuickPick();
            quickPick.placeholder = "Select a device to use";
            quickPick.busy = true;
            let quickPickIsValid = true;
            let emulatorDevices;
            const updatePickableDeviceList = () => {
                if (!quickPickIsValid)
                    return;
                quickPick.items = this.getPickableDevices(supportedTypes, emulatorDevices);
            };
            // Kick off a request to get emulators only once.
            this.getPickableEmulators(true, supportedTypes)
                .then((emulators) => emulatorDevices = emulators)
                .finally(() => quickPick.busy = false)
                .finally(() => updatePickableDeviceList())
                .catch((e) => console.error(e));
            // If new devices are attached while the list is open, add them to the end.
            const deviceAddedSubscription = this.daemon.registerForDeviceAdded((d) => updatePickableDeviceList());
            const deviceRemovedSubscription = this.daemon.registerForDeviceRemoved((d) => updatePickableDeviceList());
            // Build the initial list.
            updatePickableDeviceList();
            const selection = yield new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0]));
                quickPick.onDidHide(() => resolve(undefined));
                quickPick.show();
            });
            quickPickIsValid = false;
            quickPick.dispose();
            deviceAddedSubscription.dispose();
            deviceRemovedSubscription.dispose();
            if (selection && (yield this.selectDevice(selection)))
                return this.currentDevice;
            return undefined;
        });
    }
    selectDevice(selection) {
        return __awaiter(this, void 0, void 0, function* () {
            const emulatorTypeLabel = this.emulatorLabel(selection.device.platformType);
            switch (selection.device.type) {
                case "emulator-creator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Creating ${emulatorTypeLabel}...`;
                    yield this.createEmulator();
                    this.updateStatusBar();
                    break;
                case "emulator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Launching ${emulatorTypeLabel}...`;
                    yield this.launchEmulator(selection.device);
                    this.updateStatusBar();
                    break;
                case "custom-emulator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Launching ${emulatorTypeLabel}...`;
                    yield this.launchCustomEmulator(selection.device);
                    this.updateStatusBar();
                    break;
                case "device":
                    if (!selection.isSupported) {
                        const action = yield vs.window.showInformationMessage(constants_1.runFlutterCreateDotPrompt(selection.device.name), constants_1.runFlutterCreateDotAction, constants_1.cancelAction);
                        if (action === constants_1.runFlutterCreateDotAction)
                            yield vs.commands.executeCommand("_flutter.create");
                        else
                            return false;
                    }
                    this.currentDevice = selection.device;
                    this.updateStatusBar();
                    break;
            }
            return true;
        });
    }
    getDevice(id) {
        return this.devices.find((d) => d.id === id);
    }
    getPickableDevices(supportedTypes, emulatorDevices) {
        const sortedDevices = this.devices.sort(this.deviceSortComparer.bind(this));
        let pickableItems = sortedDevices.filter((d) => this.isSupported(supportedTypes, d))
            .map((d) => ({
            description: d.category || d.platform,
            device: d,
            isSupported: true,
            label: this.labelForDevice(d),
        }));
        // If we've got emulators, add them to the list.
        if (emulatorDevices) {
            // Fliter out any emulators we know are running.
            const emulatorIdsAlreadyRunning = this.devices.map((d) => d.emulatorId).filter((id) => id);
            pickableItems = pickableItems.concat(emulatorDevices.filter((e) => emulatorIdsAlreadyRunning.indexOf(e.device.id) === -1));
        }
        // Add any unsupported platforms that we have devices for (eg. things that could be
        // enabled) to the bottom.
        pickableItems = pickableItems.concat(sortedDevices
            .filter((d) => !this.isSupported(supportedTypes, d))
            .map((d) => ({
            device: d,
            isSupported: false,
            label: `Enable ${this.labelForDevice(d)}`,
        })));
        return pickableItems;
    }
    getSupportedPlatformsForWorkspace() {
        return __awaiter(this, void 0, void 0, function* () {
            // To avoid triggering this lots of times at startup when lots of devices "connect" at
            // the same time, we cache the results for 10 seconds. Every time we set the cache, we
            // set a timer to expire it in 10 seconds.
            if (this.shortCacheForSupportedPlatforms) {
                this.logger.info(`Returning cached promise for getSupportedPlatforms()`);
                return this.shortCacheForSupportedPlatforms;
            }
            this.shortCacheForSupportedPlatforms = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const workspaceFolders = utils_2.getDartWorkspaceFolders();
                const topLevelFolders = workspaceFolders.map((w) => fs_1.fsPath(w.uri));
                const projectFolders = yield fs_1.findProjectFolders(this.logger, topLevelFolders, [], { requirePubspec: true });
                this.logger.info(`Checking ${projectFolders.length} projects for supported platforms`);
                const getPlatformPromises = projectFolders.map((folder) => this.daemon.getSupportedPlatforms(folder));
                const resps = yield Promise.all(getPlatformPromises).catch((e) => {
                    this.logger.error(e);
                    return [];
                });
                const supportedTypes = array_1.unique(utils_1.flatMap(resps, (r) => r.platforms));
                this.logger.info(`Supported platforms for the workspace are ${supportedTypes.join(", ")}`);
                resolve(supportedTypes);
                setTimeout(() => this.shortCacheForSupportedPlatforms = undefined, 10000);
            }));
            return this.shortCacheForSupportedPlatforms;
        });
    }
    labelForDevice(device) {
        return device.emulatorId && this.knownEmulatorNames[device.emulatorId] && device.platformType === "android"
            ? this.knownEmulatorNames[device.emulatorId]
            : device.name;
    }
    deviceSortComparer(d1, d2) {
        // Always consider current device to be first.
        if (d1 === this.currentDevice)
            return -1;
        if (d2 === this.currentDevice)
            return 1;
        // Otherwise, sort by name.
        return d1.name.localeCompare(d2.name);
    }
    updateStatusBar() {
        if (this.currentDevice) {
            const emulatorLabel = this.currentDevice.emulator ? this.emulatorLabel(this.currentDevice.platformType) : "";
            const platformLabel = `${this.currentDevice.platform} ${emulatorLabel}`.trim();
            this.statusBarItem.text = `${this.labelForDevice(this.currentDevice)} (${platformLabel})`.trim();
        }
        else {
            this.statusBarItem.text = "No Device";
        }
        if (this.devices.length > 1) {
            this.statusBarItem.tooltip = `${this.devices.length} Devices Connected`;
        }
        else if (this.devices.length === 1) {
            this.statusBarItem.tooltip = `1 Device Connected`;
        }
        else {
            this.statusBarItem.tooltip = undefined;
        }
    }
    getEmulators() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const emus = yield this.daemon.getEmulators();
                const allEmulatorsByID = {};
                for (const e of emus) {
                    allEmulatorsByID[e.id] = {
                        category: e.category,
                        id: e.id,
                        name: e.name || e.id,
                        platformType: e.platformType,
                        type: "emulator",
                    };
                }
                // Add/update any custom emulators.
                for (const e of this.config.flutterCustomEmulators) {
                    const existing = allEmulatorsByID[e.id];
                    allEmulatorsByID[e.id] = Object.assign(Object.assign(Object.assign({ category: "custom" }, existing), e), { type: "custom-emulator" });
                }
                const allEmulators = Object.values(allEmulatorsByID);
                // Whenever we see emulators, record all their names.
                for (const e of allEmulators)
                    this.knownEmulatorNames[e.id] = e.name;
                return allEmulators;
            }
            catch (e) {
                this.logger.error({ message: e });
                return [];
            }
        });
    }
    promptForAndLaunchEmulator(allowAutomaticSelection = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const emulators = yield this.getPickableEmulators(false);
            // Because the above call is async, it's possible a device was connected while we were calling. If so,
            // just use that instead of showing the prompt.
            if (allowAutomaticSelection && this.currentDevice)
                return true;
            if (emulators.length === 0) {
                return false;
            }
            const cancellationTokenSource = new vs.CancellationTokenSource();
            const waitingForRealDeviceSubscription = this.daemon.registerForDeviceAdded(() => {
                cancellationTokenSource.cancel();
                waitingForRealDeviceSubscription.dispose();
            });
            const selectedEmulator = yield vs.window.showQuickPick(emulators, {
                matchOnDescription: true,
                placeHolder: "Connect a device or select an emulator to launch",
            }, cancellationTokenSource.token);
            waitingForRealDeviceSubscription.dispose();
            if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "emulator-creator") {
                return this.createEmulator();
            }
            else if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "emulator") {
                return this.launchEmulator(selectedEmulator.device);
            }
            else if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "custom-emulator") {
                return this.launchCustomEmulator(selectedEmulator.device);
            }
            else {
                return !!(this.currentDevice);
            }
        });
    }
    createEmulator() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Allow user to create names when we let them customise the emulator type.
            // const name = await vs.window.showInputBox({
            // 	prompt: "Enter a name for your new Android Emulator",
            // 	validateInput: this.validateEmulatorName,
            // });
            // if (!name) bail() // Pressing ENTER doesn't work, but escape does, so if
            // no name, user probably wanted to cancel
            const name = undefined;
            const create = this.daemon.createEmulator(name);
            vs.window.withProgress({
                location: vs.ProgressLocation.Notification,
                title: `${`Creating emulator ${name ? name : ""}`.trim()}...`,
            }, () => create);
            const res = yield create;
            if (res.success) {
                return this.launchEmulator({
                    id: res.emulatorName,
                    name: res.emulatorName,
                });
            }
            else {
                vs.window.showErrorMessage(res.error);
                return false;
            }
        });
    }
    emulatorLabel(platformType) {
        return platformType && (platformType === "ios" || platformType === "macos")
            ? "simulator"
            : "emulator";
    }
    getPickableEmulators(showAsEmulators, supportedTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!utils_3.isRunningLocally)
                return [];
            const emulators = (yield this.getEmulators())
                .filter((e) => this.isSupported(supportedTypes, e))
                .map((e) => ({
                alwaysShow: false,
                description: showAsEmulators ? `${e.category || "mobile"} ${this.emulatorLabel(e.platformType)}` : e.platformType || undefined,
                device: e,
                isSupported: true,
                label: showAsEmulators ? `Start ${e.name}` : e.name,
            }));
            // Add an option to create a new emulator if the daemon supports it.
            if (this.daemon.capabilities.canCreateEmulators && this.isSupported(supportedTypes, { platformType: "android" })) {
                emulators.push({
                    alwaysShow: true,
                    device: { type: "emulator-creator", platformType: "android", name: "Create Android emulator" },
                    isSupported: true,
                    label: "Create Android emulator",
                });
            }
            return emulators;
        });
    }
    launchEmulator(emulator) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                }, (progress) => __awaiter(this, void 0, void 0, function* () {
                    progress.report({ message: `Launching ${emulator.name}...` });
                    yield this.daemon.launchEmulator(emulator.id);
                    progress.report({ message: `Waiting for ${emulator.name} to connect...` });
                    // Wait up to 60 seconds for emulator to launch.
                    for (let i = 0; i < 120; i++) {
                        yield new Promise((resolve) => setTimeout(resolve, 500));
                        if (this.currentDevice)
                            return;
                    }
                    throw new Error("Emulator didn't connect within 60 seconds");
                }));
            }
            catch (e) {
                vs.window.showErrorMessage(`Failed to launch ${emulator.name}: ${e}`);
                return false;
            }
            // Wait an additional second to try and void some possible races.
            yield new Promise((resolve) => setTimeout(resolve, 1000));
            return true;
        });
    }
    launchCustomEmulator(emulator) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                }, (progress) => __awaiter(this, void 0, void 0, function* () {
                    progress.report({ message: `Launching ${emulator.name}...` });
                    const binPath = emulator.executable;
                    const args = emulator.args || [];
                    const customEmulatorProc = processes_1.safeSpawn(undefined, emulator.executable, args, {});
                    this.logger.info(`(PROC ${customEmulatorProc.pid}) Spawned ${binPath} ${args.join(" ")}`, enums_1.LogCategory.CommandProcesses);
                    logging_1.logProcess(this.logger, enums_1.LogCategory.CommandProcesses, customEmulatorProc);
                    progress.report({ message: `Waiting for ${emulator.name} to connect...` });
                    // Wait up to 60 seconds for emulator to launch.
                    for (let i = 0; i < 120; i++) {
                        yield new Promise((resolve) => setTimeout(resolve, 500));
                        if (this.currentDevice)
                            return;
                    }
                    throw new Error("Emulator didn't connect within 60 seconds");
                }));
            }
            catch (e) {
                vs.window.showErrorMessage(`Failed to launch ${emulator.name}: ${e}`);
                return false;
            }
            // Wait an additional second to try and void some possible races.
            yield new Promise((resolve) => setTimeout(resolve, 1000));
            return true;
        });
    }
}
exports.FlutterDeviceManager = FlutterDeviceManager;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartUriHandler = void 0;
const vs = __webpack_require__(0);
const flutter_sample_handler_1 = __webpack_require__(152);
class DartUriHandler {
    constructor(flutterCapabilities) {
        this.handlers = {
            "/flutter/sample/": new flutter_sample_handler_1.FlutterSampleUriHandler(flutterCapabilities),
        };
    }
    handleUri(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const handlerPrefix = Object.keys(this.handlers).find((key) => uri.path.startsWith(key));
            if (handlerPrefix) {
                yield this.handlers[handlerPrefix].handle(uri.path.substr(handlerPrefix.length));
            }
            else {
                vs.window.showErrorMessage(`No handler for '${uri.path}'. Check you have the latest version of the Dart plugin and try again.`);
            }
        });
    }
}
exports.DartUriHandler = DartUriHandler;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterSampleUriHandler = void 0;
const vs = __webpack_require__(0);
const flutter_samples_1 = __webpack_require__(117);
class FlutterSampleUriHandler {
    constructor(flutterCapabilities) {
        this.flutterCapabilities = flutterCapabilities;
        this.validSampleIdentifierPattern = new RegExp("^[\\w\\.]+$");
    }
    handle(sampleID) {
        if (!this.isValidSampleName(sampleID)) {
            vs.window.showErrorMessage(`${sampleID} is not a valid Flutter sample identifier`);
            return;
        }
        flutter_samples_1.createFlutterSampleInTempFolder(this.flutterCapabilities, sampleID);
    }
    isValidSampleName(name) {
        return this.validSampleIdentifierPattern.test(name);
    }
}
exports.FlutterSampleUriHandler = FlutterSampleUriHandler;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
class Context {
    constructor(context) {
        this.context = context;
    }
    static for(context) {
        return new Context(context);
    }
    get devToolsNotificationLastShown() { return this.context.globalState.get("devToolsNotificationLastShown"); }
    set devToolsNotificationLastShown(value) { this.context.globalState.update("devToolsNotificationLastShown", value); }
    get devToolsNotificationDoNotShow() { return !!this.context.globalState.get("devToolsNotificationDoNotShowAgain"); }
    set devToolsNotificationDoNotShow(value) { this.context.globalState.update("devToolsNotificationDoNotShowAgain", value); }
    get breakpointOutsideWorkspaceDoNotShow() { return !!this.context.globalState.get("breakpointOutsideWorkspaceDoNotShowAgain"); }
    set breakpointOutsideWorkspaceDoNotShow(value) { this.context.globalState.update("breakpointOutsideWorkspaceDoNotShowAgain", value); }
    getFlutterSurveyNotificationLastShown(id) { return this.context.globalState.get(`flutterSurvey${id}NotificationLastShown`); }
    setFlutterSurveyNotificationLastShown(id, value) { this.context.globalState.update(`flutterSurvey${id}NotificationLastShown`, value); }
    getFlutterSurveyNotificationDoNotShow(id) { return !!this.context.globalState.get(`flutterSurvey${id}NotificationDoNotShowAgain`); }
    setFlutterSurveyNotificationDoNotShow(id, value) { this.context.globalState.update(`flutterSurvey${id}NotificationDoNotShowAgain`, value); }
    get hasWarnedAboutFormatterSyntaxLimitation() { return !!this.context.globalState.get("hasWarnedAboutFormatterSyntaxLimitation"); }
    set hasWarnedAboutFormatterSyntaxLimitation(value) { this.context.globalState.update("hasWarnedAboutFormatterSyntaxLimitation", value); }
    get lastSeenVersion() { return this.context.globalState.get("lastSeenVersion"); }
    set lastSeenVersion(value) { this.context.globalState.update("lastSeenVersion", value); }
    getPackageLastCheckedForUpdates(packageID) { return this.context.globalState.get(`packageLastCheckedForUpdates:${packageID}`); }
    setPackageLastCheckedForUpdates(packageID, value) { this.context.globalState.update(`packageLastCheckedForUpdates:${packageID}`, value); }
    update(key, value) {
        return this.context.globalState.update(key, value);
    }
    get(key) {
        return this.context.globalState.get(key);
    }
    get subscriptions() { return this.context.subscriptions; }
}
exports.Context = Context;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.tryProcessBazelFlutterConfig = exports.processBazelWorkspace = exports.processFuchsiaWorkspace = exports.processFlutterSnap = exports.processKnownGitRepositories = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const constants_1 = __webpack_require__(4);
function processKnownGitRepositories(logger, config, gitRoot) {
    const isDartSdkRepo = fs.existsSync(path.join(gitRoot, "README.dart-sdk")) && fs.existsSync(path.join(gitRoot, ".packages"));
    if (isDartSdkRepo) {
        config.disableAutomaticPackageGet = true;
        // The Dart SDKs tests cannot run using pub, so also force them to use the VM.
        config.useVmForTests = true;
    }
}
exports.processKnownGitRepositories = processKnownGitRepositories;
function processFlutterSnap(logger, config, snapSdkRoot) {
    config.flutterSdkHome = snapSdkRoot;
    config.flutterScript = { replacesArgs: 0, script: constants_1.flutterSnapScript };
}
exports.processFlutterSnap = processFlutterSnap;
function processFuchsiaWorkspace(logger, config, fuchsiaRoot) {
    config.disableAutomaticPackageGet = true;
    config.disableSdkUpdateChecks = true;
}
exports.processFuchsiaWorkspace = processFuchsiaWorkspace;
function processBazelWorkspace(logger, config, bazelWorkspaceRoot, parseFlutterJson) {
    config.disableAutomaticPackageGet = true;
    config.disableSdkUpdateChecks = true;
    if (parseFlutterJson)
        tryProcessBazelFlutterConfig(logger, config, bazelWorkspaceRoot);
}
exports.processBazelWorkspace = processBazelWorkspace;
function tryProcessBazelFlutterConfig(logger, config, bazelWorkspaceRoot) {
    var _a, _b;
    // flutter.json does not support windows.
    if (constants_1.isWin)
        return;
    try {
        const flutterConfigPath = path.join(bazelWorkspaceRoot, "dart/config/intellij-plugins/flutter.json");
        if (!fs.existsSync(flutterConfigPath))
            return;
        logger.info(`Loading Bazel Flutter config from ${flutterConfigPath}`);
        const flutterConfigJson = fs.readFileSync(flutterConfigPath, "utf8");
        const flutterConfig = JSON.parse(flutterConfigJson);
        function makeFullPath(relOrAbsolute) {
            if (path.isAbsolute(relOrAbsolute))
                return relOrAbsolute;
            return path.join(bazelWorkspaceRoot, relOrAbsolute);
        }
        function makeScript(relOrAbsolute, replacesArgs = 1) {
            if (relOrAbsolute) {
                return {
                    replacesArgs,
                    script: makeFullPath(relOrAbsolute),
                };
            }
        }
        config.activateDevToolsEagerly = !!flutterConfig.devtoolsActivateScript;
        config.dartSdkHomeLinux = makeFullPath((_a = flutterConfig.dartSdkHome) === null || _a === void 0 ? void 0 : _a.linux);
        config.dartSdkHomeMac = makeFullPath((_b = flutterConfig.dartSdkHome) === null || _b === void 0 ? void 0 : _b.macos);
        // This one replaces the args "global activate devtools"
        config.devtoolsActivateScript = makeScript(flutterConfig.devtoolsActivateScript, 3);
        // This one replaces the args "global run devtools"
        config.devtoolsRunScript = makeScript(flutterConfig.devtoolsRunScript, 3);
        config.flutterDaemonScript = makeScript(flutterConfig.daemonScript);
        config.flutterDoctorScript = makeScript(flutterConfig.doctorScript);
        config.flutterRunScript = makeScript(flutterConfig.runScript);
        config.flutterSdkHome = makeFullPath(flutterConfig.sdkHome);
        config.flutterTestScript = makeScript(flutterConfig.testScript);
        config.flutterVersionFile = makeFullPath(flutterConfig.versionFile);
    }
    catch (e) {
        logger.error(e);
    }
}
exports.tryProcessBazelFlutterConfig = tryProcessBazelFlutterConfig;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceContext = void 0;
const events_1 = __webpack_require__(42);
class WorkspaceContext {
    // TODO: Move things from Sdks to this class that aren't related to the SDKs.
    constructor(sdks, config, hasAnyFlutterMobileProjects, hasAnyWebProjects, hasAnyStandardDartProjects, hasProjectsInFuchsiaTree) {
        this.sdks = sdks;
        this.config = config;
        this.hasAnyFlutterMobileProjects = hasAnyFlutterMobileProjects;
        this.hasAnyWebProjects = hasAnyWebProjects;
        this.hasAnyStandardDartProjects = hasAnyStandardDartProjects;
        this.hasProjectsInFuchsiaTree = hasProjectsInFuchsiaTree;
        this.events = new WorkspaceEvents();
        this.workspaceTypeDescription = this.buildWorkspaceTypeDescription();
    }
    get hasAnyFlutterProjects() { return this.hasAnyFlutterMobileProjects; }
    get shouldLoadFlutterExtension() { return this.hasAnyFlutterProjects; }
    /// Used only for display (for ex stats), not behaviour.
    buildWorkspaceTypeDescription() {
        const types = [];
        // Don't re-order these, else stats won't easily combine as we could have
        // Dart, Flutter and also Flutter, Dart.
        if (this.hasAnyStandardDartProjects)
            types.push("Dart");
        if (this.hasAnyFlutterMobileProjects)
            types.push("Flutter");
        if (this.hasProjectsInFuchsiaTree)
            types.push("Fuchsia");
        // If we didn't detect any projects, record as unknown, but include info
        // on the type of SDK we had found.
        if (types.length === 0) {
            if (this.sdks && this.sdks.dartSdkIsFromFlutter)
                types.push("Unknown (Flutter SDK)");
            else if (this.sdks && this.sdks.dart)
                types.push("Unknown (Dart SDK)");
            else
                types.push("Unknown (No SDK)");
        }
        return types.join(", ");
    }
    dispose() {
        this.events.dispose();
    }
}
exports.WorkspaceContext = WorkspaceContext;
class WorkspaceEvents {
    constructor() {
        this.onPackageMapChange = new events_1.EventEmitter();
    }
    dispose() {
        this.onPackageMapChange.dispose();
    }
}


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeFlutterSdk = void 0;
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const extension_1 = __webpack_require__(40);
const utils_1 = __webpack_require__(6);
const processes_1 = __webpack_require__(15);
function initializeFlutterSdk(logger, flutterScript, promptText) {
    return __awaiter(this, void 0, void 0, function* () {
        const selectedItem = promptText ? yield vscode_1.window.showInformationMessage(promptText, constants_1.yesAction, constants_1.noAction) : constants_1.yesAction;
        if (selectedItem === constants_1.yesAction) {
            logger.info(`Flutter is not initialized, running 'flutter config --machine'...`);
            yield vscode_1.window.withProgress({
                location: vscode_1.ProgressLocation.Notification,
                title: constants_1.initializingFlutterMessage,
            }, (progress, cancellationToken) => __awaiter(this, void 0, void 0, function* () {
                const proc = processes_1.safeToolSpawn(undefined, flutterScript, ["config", "--machine"]);
                cancellationToken.onCancellationRequested((e) => {
                    logger.info(`User canceled!`);
                    proc.kill();
                });
                // Log this to general as it's startup stuff that can't be captured with
                // Capture Logs so log it to the main log file.
                logging_1.logProcess(logger, enums_1.LogCategory.General, proc);
                return new Promise((resolve, reject) => proc.on("exit", (code) => {
                    if (code) {
                        const ringLogContents = extension_1.ringLog.toString();
                        logger.error(`Failed to initialize Flutter: Process exited with code ${code}.`);
                        vscode_1.window.showErrorMessage(`Failed to initialize Flutter: Process exited with code ${code}.`, constants_1.showLogAction).then((chosenAction) => {
                            if (chosenAction === constants_1.showLogAction)
                                utils_1.openLogContents(undefined, ringLogContents);
                        });
                        reject();
                    }
                    else
                        resolve();
                }));
            }));
            logger.info(`Flutter initialized!`);
        }
        else {
            logger.info(`User cancelled Flutter initialization`);
        }
    });
}
exports.initializeFlutterSdk = initializeFlutterSdk;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable */
// This file was generated by Dart-Code-Class-Builder
// and should not be hand-edited!
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyzerGen = void 0;
const stdio_service_1 = __webpack_require__(44);
class AnalyzerGen extends stdio_service_1.StdIOService {
    constructor(logger, maxLogLineLength) {
        super(logger, maxLogLineLength);
        this.serverConnectedSubscriptions = [];
        this.serverErrorSubscriptions = [];
        this.serverStatusSubscriptions = [];
        this.analysisAnalyzedFilesSubscriptions = [];
        this.analysisClosingLabelsSubscriptions = [];
        this.analysisErrorsSubscriptions = [];
        this.analysisFlushResultsSubscriptions = [];
        this.analysisFoldingSubscriptions = [];
        this.analysisHighlightsSubscriptions = [];
        this.analysisImplementedSubscriptions = [];
        this.analysisInvalidateSubscriptions = [];
        this.analysisNavigationSubscriptions = [];
        this.analysisOccurrencesSubscriptions = [];
        this.analysisOutlineSubscriptions = [];
        this.analysisOverridesSubscriptions = [];
        this.completionResultsSubscriptions = [];
        this.completionAvailableSuggestionsSubscriptions = [];
        this.completionExistingImportsSubscriptions = [];
        this.searchResultsSubscriptions = [];
        this.executionLaunchDataSubscriptions = [];
        this.flutterOutlineSubscriptions = [];
    }
    buildRequest(id, method, params) {
        return Object.assign(super.buildRequest(id, method, params), { clientRequestTime: Date.now() });
    }
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.event) {
                case "server.connected":
                    yield this.notify(this.serverConnectedSubscriptions, evt.params);
                    break;
                case "server.error":
                    yield this.notify(this.serverErrorSubscriptions, evt.params);
                    break;
                case "server.status":
                    yield this.notify(this.serverStatusSubscriptions, evt.params);
                    break;
                case "analysis.analyzedFiles":
                    yield this.notify(this.analysisAnalyzedFilesSubscriptions, evt.params);
                    break;
                case "analysis.closingLabels":
                    yield this.notify(this.analysisClosingLabelsSubscriptions, evt.params);
                    break;
                case "analysis.errors":
                    yield this.notify(this.analysisErrorsSubscriptions, evt.params);
                    break;
                case "analysis.flushResults":
                    yield this.notify(this.analysisFlushResultsSubscriptions, evt.params);
                    break;
                case "analysis.folding":
                    yield this.notify(this.analysisFoldingSubscriptions, evt.params);
                    break;
                case "analysis.highlights":
                    yield this.notify(this.analysisHighlightsSubscriptions, evt.params);
                    break;
                case "analysis.implemented":
                    yield this.notify(this.analysisImplementedSubscriptions, evt.params);
                    break;
                case "analysis.invalidate":
                    yield this.notify(this.analysisInvalidateSubscriptions, evt.params);
                    break;
                case "analysis.navigation":
                    yield this.notify(this.analysisNavigationSubscriptions, evt.params);
                    break;
                case "analysis.occurrences":
                    yield this.notify(this.analysisOccurrencesSubscriptions, evt.params);
                    break;
                case "analysis.outline":
                    yield this.notify(this.analysisOutlineSubscriptions, evt.params);
                    break;
                case "analysis.overrides":
                    yield this.notify(this.analysisOverridesSubscriptions, evt.params);
                    break;
                case "completion.results":
                    yield this.notify(this.completionResultsSubscriptions, evt.params);
                    break;
                case "completion.availableSuggestions":
                    yield this.notify(this.completionAvailableSuggestionsSubscriptions, evt.params);
                    break;
                case "completion.existingImports":
                    yield this.notify(this.completionExistingImportsSubscriptions, evt.params);
                    break;
                case "search.results":
                    yield this.notify(this.searchResultsSubscriptions, evt.params);
                    break;
                case "execution.launchData":
                    yield this.notify(this.executionLaunchDataSubscriptions, evt.params);
                    break;
                case "flutter.outline":
                    yield this.notify(this.flutterOutlineSubscriptions, evt.params);
                    break;
            }
        });
    }
    /**
    Reports that the server is running. This notification is
    issued once after the server has started running but before
    any requests are processed to let the client know that it
    started correctly.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForServerConnected(subscriber) {
        return this.subscribe(this.serverConnectedSubscriptions, subscriber);
    }
    /**
    Reports that an unexpected error has occurred while
    executing the server. This notification is not used for
    problems with specific requests (which are returned as part
    of the response) but is used for exceptions that occur while
    performing other tasks, such as analysis or preparing
    notifications.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForServerError(subscriber) {
        return this.subscribe(this.serverErrorSubscriptions, subscriber);
    }
    /**
    Reports the current status of the server. Parameters are
    omitted if there has been no change in the status
    represented by that parameter.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "STATUS" in
    the list of services passed in a server.setSubscriptions
    request.
    */
    registerForServerStatus(subscriber) {
        return this.subscribe(this.serverStatusSubscriptions, subscriber);
    }
    /**
    Reports the paths of the files that are being analyzed.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "ANALYZED_FILES" in the list
    of services passed in an analysis.setGeneralSubscriptions request.
    */
    registerForAnalysisAnalyzedFiles(subscriber) {
        return this.subscribe(this.analysisAnalyzedFilesSubscriptions, subscriber);
    }
    /**
    Reports closing labels relevant to a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "CLOSING_LABELS"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisClosingLabels(subscriber) {
        return this.subscribe(this.analysisClosingLabelsSubscriptions, subscriber);
    }
    /**
    Reports the errors associated with a given file. The set of
    errors included in the notification is always a complete
    list that supersedes any previously reported errors.
    */
    registerForAnalysisErrors(subscriber) {
        return this.subscribe(this.analysisErrorsSubscriptions, subscriber);
    }
    /**
    Reports that any analysis results that were previously
    associated with the given files should be considered to be
    invalid because those files are no longer being analyzed,
    either because the analysis root that contained it is no
    longer being analyzed or because the file no longer exists.
    If a file is included in this notification and at some later
    time a notification with results for the file is received,
    clients should assume that the file is once again being
    analyzed and the information should be processed.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForAnalysisFlushResults(subscriber) {
        return this.subscribe(this.analysisFlushResultsSubscriptions, subscriber);
    }
    /**
    Reports the folding regions associated with a given
    file. Folding regions can be nested, but will not be
    overlapping. Nesting occurs when a foldable element, such as
    a method, is nested inside another foldable element such as
    a class.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "FOLDING" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisFolding(subscriber) {
        return this.subscribe(this.analysisFoldingSubscriptions, subscriber);
    }
    /**
    Reports the highlight regions associated with a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "HIGHLIGHTS"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisHighlights(subscriber) {
        return this.subscribe(this.analysisHighlightsSubscriptions, subscriber);
    }
    /**
    Reports the classes that are implemented or extended and
    class members that are implemented or overridden in a file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "IMPLEMENTED" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisImplemented(subscriber) {
        return this.subscribe(this.analysisImplementedSubscriptions, subscriber);
    }
    /**
    Reports that the navigation information associated with a region of a
    single file has become invalid and should be re-requested.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "INVALIDATE" in the list of
    services passed in an analysis.setSubscriptions request.
    */
    registerForAnalysisInvalidate(subscriber) {
        return this.subscribe(this.analysisInvalidateSubscriptions, subscriber);
    }
    /**
    Reports the navigation targets associated with a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "NAVIGATION"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisNavigation(subscriber) {
        return this.subscribe(this.analysisNavigationSubscriptions, subscriber);
    }
    /**
    Reports the occurrences of references to elements within a
    single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OCCURRENCES"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisOccurrences(subscriber) {
        return this.subscribe(this.analysisOccurrencesSubscriptions, subscriber);
    }
    /**
    Reports the outline associated with a single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OUTLINE" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisOutline(subscriber) {
        return this.subscribe(this.analysisOutlineSubscriptions, subscriber);
    }
    /**
    Reports the overriding members in a file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OVERRIDES" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisOverrides(subscriber) {
        return this.subscribe(this.analysisOverridesSubscriptions, subscriber);
    }
    /**
    Reports the completion suggestions that should be presented
    to the user. The set of suggestions included in the
    notification is always a complete list that supersedes any
    previously reported suggestions.
    */
    registerForCompletionResults(subscriber) {
        return this.subscribe(this.completionResultsSubscriptions, subscriber);
    }
    /**
    Reports the pre-computed, candidate completions from symbols defined
    in a corresponding library. This notification may be sent multiple times.
    When a notification is processed, clients should replace any previous
    information about the libraries in the list of changedLibraries, discard
    any information about the libraries in the list of removedLibraries, and
    preserve any previously received information about any libraries that are
    not included in either list.
    */
    registerForCompletionAvailableSuggestions(subscriber) {
        return this.subscribe(this.completionAvailableSuggestionsSubscriptions, subscriber);
    }
    /**
    Reports existing imports in a library. This notification may be sent
    multiple times for a library. When a notification is processed, clients
    should replace any previous information for the library.
    */
    registerForCompletionExistingImports(subscriber) {
        return this.subscribe(this.completionExistingImportsSubscriptions, subscriber);
    }
    /**
    Reports some or all of the results of performing a requested
    search. Unlike other notifications, this notification
    contains search results that should be added to any
    previously received search results associated with the same
    search id.
    */
    registerForSearchResults(subscriber) {
        return this.subscribe(this.searchResultsSubscriptions, subscriber);
    }
    /**
    Reports information needed to allow a single file to be launched.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "LAUNCH_DATA" in the list of services
    passed in an execution.setSubscriptions request.
    */
    registerForExecutionLaunchData(subscriber) {
        return this.subscribe(this.executionLaunchDataSubscriptions, subscriber);
    }
    /**
    Reports the Flutter outline associated with a single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OUTLINE" in
    the list of services passed in an flutter.setSubscriptions
    request.
    */
    registerForFlutterOutline(subscriber) {
        return this.subscribe(this.flutterOutlineSubscriptions, subscriber);
    }
    /**
    Return the version number of the analysis server.
    */
    serverGetVersion() {
        return this.sendRequest("server.getVersion");
    }
    /**
    Cleanly shutdown the analysis server. Requests that are
    received after this request will not be processed. Requests
    that were received before this request, but for which a
    response has not yet been sent, will not be responded to. No
    further responses or notifications will be sent after the
    response to this request has been sent.
    */
    serverShutdown() {
        return this.sendRequest("server.shutdown");
    }
    /**
    Subscribe for services. All previous subscriptions are
    replaced by the given set of services.
    It is an error if any of the elements in the list are not
    valid services. If there is an error, then the current
    subscriptions will remain unchanged.
    */
    serverSetSubscriptions(request) {
        return this.sendRequest("server.setSubscriptions", request);
    }
    /**
    Return the errors associated with the given file. If the
    errors for the given file have not yet been computed, or the
    most recently computed errors for the given file are out of
    date, then the response for this request will be delayed
    until they have been computed. If some or all of the errors
    for the file cannot be computed, then the subset of the
    errors that can be computed will be returned and the
    response will contain an error to indicate why the errors
    could not be computed. If the content of the file changes after this
    request was received but before a response could be sent, then an
    error of type CONTENT_MODIFIED will be generated.
    This request is intended to be used by clients that cannot
    asynchronously apply updated error information. Clients that
    can apply error information as it becomes available
    should use the information provided by the 'analysis.errors'
    notification.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_ERRORS_INVALID_FILE will be generated.
    */
    analysisGetErrors(request) {
        return this.sendRequest("analysis.getErrors", request);
    }
    /**
    Return the hover information associate with the given
    location. If some or all of the hover information is not
    available at the time this request is processed the
    information will be omitted from the response.
    */
    analysisGetHover(request) {
        return this.sendRequest("analysis.getHover", request);
    }
    /**
    Return a description of all of the elements referenced in a given region
    of a given file that come from imported libraries.
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified via analysis.setAnalysisRoots), an error of type
    GET_IMPORTED_ELEMENTS_INVALID_FILE will be generated.
    */
    analysisGetImportedElements(request) {
        return this.sendRequest("analysis.getImportedElements", request);
    }
    /**
    Return library dependency information for use in client-side indexing
    and package URI resolution.
    Clients that are only using the libraries field should consider using the
    analyzedFiles notification instead.
    */
    analysisGetLibraryDependencies() {
        return this.sendRequest("analysis.getLibraryDependencies");
    }
    /**
    Return the navigation information associated with the given region of
    the given file. If the navigation information for the given file has
    not yet been computed, or the most recently computed navigation
    information for the given file is out of date, then the response for
    this request will be delayed until it has been computed. If the
    content of the file changes after this request was received but before
    a response could be sent, then an error of type
    CONTENT_MODIFIED will be generated.
    If a navigation region overlaps (but extends either before or after)
    the given region of the file it will be included in the result. This
    means that it is theoretically possible to get the same navigation
    region in response to multiple requests. Clients can avoid this by
    always choosing a region that starts at the beginning of a line and
    ends at the end of a (possibly different) line in the file.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_NAVIGATION_INVALID_FILE will be generated.
    */
    analysisGetNavigation(request) {
        return this.sendRequest("analysis.getNavigation", request);
    }
    /**
    Return the transitive closure of reachable sources for a given file.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_REACHABLE_SOURCES_INVALID_FILE will be generated.
    */
    analysisGetReachableSources(request) {
        return this.sendRequest("analysis.getReachableSources", request);
    }
    /**
    Return the signature information associated with the given
    location in the given file. If the signature information
    for the given file has not yet been computed, or the most
    recently computed signature information for the given file
    is out of date, then the response for this request will be
    delayed until it has been computed.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_SIGNATURE_INVALID_FILE will be generated.
    If the location given is not inside the argument list for a
    function (including method and constructor) invocation, then
    an error of type GET_SIGNATURE_INVALID_OFFSET will
    be generated. If the location is inside an argument list but
    the function is not defined or cannot be determined (such as
    a method invocation where the target has type 'dynamic')
    then an error of type GET_SIGNATURE_UNKNOWN_FUNCTION
    will be generated.
    */
    analysisGetSignature(request) {
        return this.sendRequest("analysis.getSignature", request);
    }
    /**
    Force re-reading of all potentially changed files, re-resolving of all
    referenced URIs, and corresponding re-analysis of everything affected in
    the current analysis roots.
    */
    analysisReanalyze() {
        return this.sendRequest("analysis.reanalyze");
    }
    /**
    Sets the root paths used to determine which files to analyze. The set
    of files to be analyzed are all of the files in one of the root paths
    that are not either explicitly or implicitly excluded. A file is
    explicitly excluded if it is in one of the excluded paths. A file is
    implicitly excluded if it is in a subdirectory of one of the root
    paths where the name of the subdirectory starts with a period (that
    is, a hidden directory).
    Note that this request determines the set of requested
    analysis roots. The actual set of analysis roots at any
    given time is the intersection of this set with the set of
    files and directories actually present on the
    filesystem. When the filesystem changes, the actual set of
    analysis roots is automatically updated, but the set of
    requested analysis roots is unchanged. This means that if
    the client sets an analysis root before the root becomes
    visible to server in the filesystem, there is no error; once
    the server sees the root in the filesystem it will start
    analyzing it. Similarly, server will stop analyzing files
    that are removed from the file system but they will remain
    in the set of requested roots.
    If an included path represents a file, then server will look
    in the directory containing the file for a pubspec.yaml
    file. If none is found, then the parents of the directory
    will be searched until such a file is found or the root of
    the file system is reached. If such a file is found, it will
    be used to resolve package: URI’s within the file.
    */
    analysisSetAnalysisRoots(request) {
        return this.sendRequest("analysis.setAnalysisRoots", request);
    }
    /**
    Subscribe for general services (that is, services that are not
    specific to individual files). All previous subscriptions are replaced
    by the given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    analysisSetGeneralSubscriptions(request) {
        return this.sendRequest("analysis.setGeneralSubscriptions", request);
    }
    /**
    Set the priority files to the files in the given list. A
    priority file is a file that is given priority when
    scheduling which analysis work to do first. The list
    typically contains those files that are visible to the user
    and those for which analysis results will have the biggest
    impact on the user experience. The order of the files within
    the list is significant: the first file will be given higher
    priority than the second, the second higher priority than
    the third, and so on.
    Note that this request determines the set of requested
    priority files. The actual set of priority files is the
    intersection of the requested set of priority files with the
    set of files currently subject to analysis. (See
    analysis.setSubscriptions for a description of files that
    are subject to analysis.)
    If a requested priority file is a directory it is ignored,
    but remains in the set of requested priority files so that
    if it later becomes a file it can be included in the set of
    actual priority files.
    */
    analysisSetPriorityFiles(request) {
        return this.sendRequest("analysis.setPriorityFiles", request);
    }
    /**
    Subscribe for services that are specific to individual files.
    All previous subscriptions are replaced by the current set of
    subscriptions. If a given service is not included as a key in the map
    then no files will be subscribed to the service, exactly as if the
    service had been included in the map with an explicit empty list of
    files.
    Note that this request determines the set of requested
    subscriptions. The actual set of subscriptions at any given
    time is the intersection of this set with the set of files
    currently subject to analysis. The files currently subject
    to analysis are the set of files contained within an actual
    analysis root but not excluded, plus all of the files
    transitively reachable from those files via import, export
    and part directives. (See analysis.setAnalysisRoots for an
    explanation of how the actual analysis roots are
    determined.) When the actual analysis roots change, the
    actual set of subscriptions is automatically updated, but
    the set of requested subscriptions is unchanged.
    If a requested subscription is a directory it is ignored,
    but remains in the set of requested subscriptions so that if
    it later becomes a file it can be included in the set of
    actual subscriptions.
    It is an error if any of the keys in the map are not valid
    services. If there is an error, then the existing
    subscriptions will remain unchanged.
    */
    analysisSetSubscriptions(request) {
        return this.sendRequest("analysis.setSubscriptions", request);
    }
    /**
    Update the content of one or more files. Files that were
    previously updated but not included in this update remain
    unchanged. This effectively represents an overlay of the
    filesystem. The files whose content is overridden are
    therefore seen by server as being files with the given
    content, even if the files do not exist on the filesystem or
    if the file path represents the path to a directory on the
    filesystem.
    */
    analysisUpdateContent(request) {
        return this.sendRequest("analysis.updateContent", request);
    }
    /**
    Deprecated: all of the options can be set by users in
    an analysis options file.
    Update the options controlling analysis based on the given
    set of options. Any options that are not included in the
    analysis options will not be changed. If there are options
    in the analysis options that are not valid, they will be
    silently ignored.
    */
    analysisUpdateOptions(request) {
        return this.sendRequest("analysis.updateOptions", request);
    }
    /**
    Request that completion suggestions for the given offset in
    the given file be returned.
    */
    completionGetSuggestions(request) {
        return this.sendRequest("completion.getSuggestions", request);
    }
    /**
    Subscribe for completion services. All previous subscriptions are
    replaced by the given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    completionSetSubscriptions(request) {
        return this.sendRequest("completion.setSubscriptions", request);
    }
    /**
    The client can make this request to express interest in certain
    libraries to receive completion suggestions from based on the client path.
    If this request is received before the client has used
    'completion.setSubscriptions' to subscribe to the AVAILABLE_SUGGESTION_SETS
    service, then an error of type NOT_SUBSCRIBED_TO_AVAILABLE_SUGGESTION_SETS
    will be generated. All previous paths are replaced by the given set of paths.
    */
    completionRegisterLibraryPaths(request) {
        return this.sendRequest("completion.registerLibraryPaths", request);
    }
    /**
    Clients must make this request when the user has selected a completion
    suggestion from an AvailableSuggestionSet. Analysis server will respond with
    the text to insert as well as any SourceChange that needs to be applied
    in case the completion requires an additional import to be added. It is an error
    if the id is no longer valid, for instance if the library has been removed after
    the completion suggestion is accepted.
    */
    completionGetSuggestionDetails(request) {
        return this.sendRequest("completion.getSuggestionDetails", request);
    }
    /**
    Inspect analysis server's knowledge about all of a file's tokens including
    their lexeme, type, and what element kinds would have been appropriate for
    the token's program location.
    */
    completionListTokenDetails(request) {
        return this.sendRequest("completion.listTokenDetails", request);
    }
    /**
    Perform a search for references to the element defined or
    referenced at the given offset in the given file.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindElementReferences(request) {
        return this.sendRequest("search.findElementReferences", request);
    }
    /**
    Perform a search for declarations of members whose name is
    equal to the given name.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindMemberDeclarations(request) {
        return this.sendRequest("search.findMemberDeclarations", request);
    }
    /**
    Perform a search for references to members whose name is
    equal to the given name. This search does not check to see
    that there is a member defined with the given name, so it is
    able to find references to undefined members as well.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindMemberReferences(request) {
        return this.sendRequest("search.findMemberReferences", request);
    }
    /**
    Perform a search for declarations of top-level elements
    (classes, typedefs, getters, setters, functions and fields)
    whose name matches the given pattern.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindTopLevelDeclarations(request) {
        return this.sendRequest("search.findTopLevelDeclarations", request);
    }
    /**
    Return top-level and class member declarations.
    */
    searchGetElementDeclarations(request) {
        return this.sendRequest("search.getElementDeclarations", request);
    }
    /**
    Return the type hierarchy of the class declared or
    referenced at the given location.
    */
    searchGetTypeHierarchy(request) {
        return this.sendRequest("search.getTypeHierarchy", request);
    }
    /**
    Format the contents of a single file. The currently selected region of
    text is passed in so that the selection can be preserved across the
    formatting operation. The updated selection will be as close to
    matching the original as possible, but whitespace at the beginning or
    end of the selected region will be ignored. If preserving selection
    information is not required, zero (0) can be specified for both the
    selection offset and selection length.
    If a request is made for a file which does not exist, or which is not
    currently subject to analysis (e.g. because it is not associated with
    any analysis root specified to analysis.setAnalysisRoots), an error of
    type FORMAT_INVALID_FILE will be generated. If the source
    contains syntax errors, an error of type FORMAT_WITH_ERRORS
    will be generated.
    */
    editFormat(request) {
        return this.sendRequest("edit.format", request);
    }
    /**
    Return the set of assists that are available at the given
    location. An assist is distinguished from a refactoring
    primarily by the fact that it affects a single file and does
    not require user input in order to be performed.
    */
    editGetAssists(request) {
        return this.sendRequest("edit.getAssists", request);
    }
    /**
    Get a list of the kinds of refactorings that are valid for
    the given selection in the given file.
    */
    editGetAvailableRefactorings(request) {
        return this.sendRequest("edit.getAvailableRefactorings", request);
    }
    /**
    Request information about edit.dartfix
    such as the list of known fixes that can be specified
    in an edit.dartfix request.
    */
    editGetDartfixInfo() {
        return this.sendRequest("edit.getDartfixInfo");
    }
    /**
    Analyze the specified sources for recommended changes
    and return a set of suggested edits for those sources.
    These edits may include changes to sources outside the set
    of specified sources if a change in a specified source requires it.
    If includedFixes is specified, then those fixes will be applied.
    If includeRequiredFixes is specified, then "required" fixes will be applied
    in addition to whatever fixes are specified in includedFixes if any.
    If neither includedFixes nor includeRequiredFixes is specified,
    then all fixes will be applied.
    If excludedFixes is specified, then those fixes will not be applied
    regardless of whether they are "required" or specified in includedFixes.
    */
    editDartfix(request) {
        return this.sendRequest("edit.dartfix", request);
    }
    /**
    Return the set of fixes that are available for the errors at
    a given offset in a given file.
    */
    editGetFixes(request) {
        return this.sendRequest("edit.getFixes", request);
    }
    /**
    Get the changes required to convert the postfix template at the given
    location into the template's expanded form.
    */
    editGetPostfixCompletion(request) {
        return this.sendRequest("edit.getPostfixCompletion", request);
    }
    /**
    Get the changes required to perform a refactoring.
    If another refactoring request is received during the processing
    of this one, an error of type REFACTORING_REQUEST_CANCELLED
    will be generated.
    */
    editGetRefactoring(request) {
        return this.sendRequest("edit.getRefactoring", request);
    }
    /**
    Get the changes required to convert the partial statement at the given
    location into a syntactically valid statement. If the current statement
    is already valid the change will insert a newline plus appropriate
    indentation at the end of the line containing the offset.
    If a change that makes the statement valid cannot be determined (perhaps
    because it has not yet been implemented) the statement will be considered
    already valid and the appropriate change returned.
    */
    editGetStatementCompletion(request) {
        return this.sendRequest("edit.getStatementCompletion", request);
    }
    /**
    Determine if the request postfix completion template is applicable at
    the given location in the given file.
    */
    editIsPostfixCompletionApplicable(request) {
        return this.sendRequest("edit.isPostfixCompletionApplicable", request);
    }
    /**
    Return a list of all postfix templates currently available.
    */
    editListPostfixCompletionTemplates() {
        return this.sendRequest("edit.listPostfixCompletionTemplates");
    }
    /**
    Return a list of edits that would need to be applied in order to ensure
    that all of the elements in the specified list of imported elements are
    accessible within the library.
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified via analysis.setAnalysisRoots), an error of type
    IMPORT_ELEMENTS_INVALID_FILE will be generated.
    */
    editImportElements(request) {
        return this.sendRequest("edit.importElements", request);
    }
    /**
    Sort all of the directives, unit and class members
    of the given Dart file.
    If a request is made for a file that does not exist, does not belong
    to an analysis root or is not a Dart file,
    SORT_MEMBERS_INVALID_FILE will be generated.
    If the Dart file has scan or parse errors,
    SORT_MEMBERS_PARSE_ERRORS will be generated.
    */
    editSortMembers(request) {
        return this.sendRequest("edit.sortMembers", request);
    }
    /**
    Organizes all of the directives - removes unused imports and sorts
    directives of the given Dart file according to the
    Dart Style
    Guide.
    If a request is made for a file that does not exist, does not belong
    to an analysis root or is not a Dart file,
    FILE_NOT_ANALYZED will be generated.
    If directives of the Dart file cannot be organized, for example
    because it has scan or parse errors, or by other reasons,
    ORGANIZE_DIRECTIVES_ERROR will be generated. The message
    will provide details about the reason.
    */
    editOrganizeDirectives(request) {
        return this.sendRequest("edit.organizeDirectives", request);
    }
    /**
    Create an execution context for the executable file with the given
    path. The context that is created will persist until
    execution.deleteContext is used to delete it. Clients, therefore, are
    responsible for managing the lifetime of execution contexts.
    */
    executionCreateContext(request) {
        return this.sendRequest("execution.createContext", request);
    }
    /**
    Delete the execution context with the given identifier. The context id
    is no longer valid after this command. The server is allowed to re-use
    ids when they are no longer valid.
    */
    executionDeleteContext(request) {
        return this.sendRequest("execution.deleteContext", request);
    }
    /**
    Request completion suggestions for the given runtime context.
    It might take one or two requests of this type to get completion
    suggestions. The first request should have only "code", "offset",
    and "variables", but not "expressions". If there are sub-expressions that
    can have different runtime types, and are considered to be safe to
    evaluate at runtime (e.g. getters), so using their actual runtime types
    can improve completion results, the server will not include the
    "suggestions" field in the response, and instead will return the
    "expressions" field. The client will use debug API to get current runtime
    types for these sub-expressions and send another request, this time with
    "expressions". If there are no interesting sub-expressions to get
    runtime types for, or when the "expressions" field is provided by the
    client, the server will return "suggestions" in the response.
    */
    executionGetSuggestions(request) {
        return this.sendRequest("execution.getSuggestions", request);
    }
    /**
    Map a URI from the execution context to the file that it corresponds
    to, or map a file to the URI that it corresponds to in the execution
    context.
    Exactly one of the file and uri fields must be provided. If both
    fields are provided, then an error of type INVALID_PARAMETER
    will be generated. Similarly, if neither field is provided, then an
    error of type INVALID_PARAMETER will be generated.
    If the file field is provided and the value is not the path of a file
    (either the file does not exist or the path references something other
    than a file), then an error of type INVALID_PARAMETER will
    be generated.
    If the uri field is provided and the value is not a valid URI or if
    the URI references something that is not a file (either a file that
    does not exist or something other than a file), then an error of type
    INVALID_PARAMETER will be generated.
    If the contextRoot used to create the execution context does not
    exist, then an error of type INVALID_EXECUTION_CONTEXT will
    be generated.
    */
    executionMapUri(request) {
        return this.sendRequest("execution.mapUri", request);
    }
    /**
    Deprecated: the analysis server no longer fires
    LAUNCH_DATA events.
    Subscribe for services. All previous subscriptions are replaced by the
    given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    executionSetSubscriptions(request) {
        return this.sendRequest("execution.setSubscriptions", request);
    }
    /**
    Return server diagnostics.
    */
    diagnosticGetDiagnostics() {
        return this.sendRequest("diagnostic.getDiagnostics");
    }
    /**
    Return the port of the diagnostic web server. If the server is not running
    this call will start the server. If unable to start the diagnostic web
    server,
    this call will return an error of DEBUG_PORT_COULD_NOT_BE_OPENED.
    */
    diagnosticGetServerPort() {
        return this.sendRequest("diagnostic.getServerPort");
    }
    /**
    Query whether analytics is enabled.
    This flag controls whether the analysis server sends any analytics data to
    the cloud. If disabled, the analysis server does not send any analytics
    data, and any data sent to it by clients (from sendEvent and
    sendTiming) will be ignored.
    The value of this flag can be changed by other tools outside of the
    analysis server's process. When you query the flag, you get the value of
    the flag at a given moment. Clients should not use the value returned to
    decide whether or not to send the sendEvent and
    sendTiming requests. Those requests should be used
    unconditionally and server will determine whether or not it is appropriate
    to forward the information to the cloud at the time each request is
    received.
    */
    analyticsIsEnabled() {
        return this.sendRequest("analytics.isEnabled");
    }
    /**
    Enable or disable the sending of analytics data. Note that there are other
    ways for users to change this setting, so clients cannot assume that they
    have complete control over this setting. In particular, there is no
    guarantee that the result returned by the isEnabled request will
    match the last value set via this request.
    */
    analyticsEnable(request) {
        return this.sendRequest("analytics.enable", request);
    }
    /**
    Send information about client events.
    Ask the analysis server to include the fact that an action was performed
    in the client as part of the analytics data being sent. The data will only
    be included if the sending of analytics data is enabled at the time the
    request is processed. The action that was performed is indicated by the
    value of the action field.
    The value of the action field should not include the identity of the
    client. The analytics data sent by server will include the client id
    passed in using the --client-id command-line argument. The
    request will be ignored if the client id was not provided when server was
    started.
    */
    analyticsSendEvent(request) {
        return this.sendRequest("analytics.sendEvent", request);
    }
    /**
    Send timing information for client events (e.g. code completions).
    Ask the analysis server to include the fact that a timed event occurred as
    part of the analytics data being sent. The data will only be included if
    the sending of analytics data is enabled at the time the request is
    processed.
    The value of the event field should not include the identity of the
    client. The analytics data sent by server will include the client id
    passed in using the --client-id command-line argument. The
    request will be ignored if the client id was not provided when server was
    started.
    */
    analyticsSendTiming(request) {
        return this.sendRequest("analytics.sendTiming", request);
    }
    /**
    Return the list of KytheEntry objects for some file, given the
    current state of the file system populated by "analysis.updateContent".
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified to analysis.setAnalysisRoots), an error of type
    GET_KYTHE_ENTRIES_INVALID_FILE will be generated.
    */
    kytheGetKytheEntries(request) {
        return this.sendRequest("kythe.getKytheEntries", request);
    }
    /**
    Subscribe for services that are specific to individual files.
    All previous subscriptions are replaced by the current set of
    subscriptions. If a given service is not included as a key in the map
    then no files will be subscribed to the service, exactly as if the
    service had been included in the map with an explicit empty list of
    files.
    Note that this request determines the set of requested
    subscriptions. The actual set of subscriptions at any given
    time is the intersection of this set with the set of files
    currently subject to analysis. The files currently subject
    to analysis are the set of files contained within an actual
    analysis root but not excluded, plus all of the files
    transitively reachable from those files via import, export
    and part directives. (See analysis.setAnalysisRoots for an
    explanation of how the actual analysis roots are
    determined.) When the actual analysis roots change, the
    actual set of subscriptions is automatically updated, but
    the set of requested subscriptions is unchanged.
    If a requested subscription is a directory it is ignored,
    but remains in the set of requested subscriptions so that if
    it later becomes a file it can be included in the set of
    actual subscriptions.
    It is an error if any of the keys in the map are not valid
    services. If there is an error, then the existing
    subscriptions will remain unchanged.
    */
    flutterSetSubscriptions(request) {
        return this.sendRequest("flutter.setSubscriptions", request);
    }
}
exports.AnalyzerGen = AnalyzerGen;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DasFileTracker = void 0;
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const promises_1 = __webpack_require__(31);
const project_1 = __webpack_require__(51);
const util = __webpack_require__(6);
class DasFileTracker {
    constructor(logger, analyzer, wsContext) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.wsContext = wsContext;
        this.disposables = [];
        this.outlines = {};
        this.flutterOutlines = {};
        this.occurrences = {};
        this.folding = {};
        this.pubRunTestSupport = {};
        this.lastPriorityFiles = [];
        this.lastSubscribedFiles = [];
        // Reset these, since they're state from the last analysis server
        // (when we change SDK and thus change this).
        this.lastPriorityFiles = [];
        this.lastSubscribedFiles = [];
        this.disposables.push(vscode_1.workspace.onDidOpenTextDocument((td) => __awaiter(this, void 0, void 0, function* () {
            yield this.updateSubscriptions();
        })));
        this.disposables.push(vscode_1.workspace.onDidCloseTextDocument((td) => __awaiter(this, void 0, void 0, function* () {
            const path = fs_1.fsPath(td.uri);
            delete this.outlines[path];
            delete this.flutterOutlines[path];
            delete this.occurrences[path];
            delete this.folding[path];
            delete this.pubRunTestSupport[path];
            yield this.updateSubscriptions();
        })));
        this.disposables.push(vscode_1.window.onDidChangeVisibleTextEditors((e) => this.updatePriorityFiles()));
        this.disposables.push(this.analyzer.registerForAnalysisOutline((o) => this.outlines[o.file] = o.outline));
        this.disposables.push(this.analyzer.registerForFlutterOutline((o) => this.flutterOutlines[o.file] = o.outline));
        this.disposables.push(this.analyzer.registerForAnalysisOccurrences((o) => this.occurrences[o.file] = o.occurrences));
        this.disposables.push(this.analyzer.registerForAnalysisFolding((f) => this.folding[f.file] = f.regions));
        // It's possible that after the server gives us the version, we may send different subscriptions (eg.
        // based on capabilities, like supporting priority files outside of the workspace root) so we may need
        // to send again.
        this.disposables.push(this.analyzer.registerForServerConnected((s) => this.updateSubscriptions(true)));
        // Handle already-open files.
        // tslint:disable-next-line: no-floating-promises
        this.updatePriorityFiles();
        // tslint:disable-next-line: no-floating-promises
        this.updateSubscriptions();
        this.watchPubspec();
    }
    updatePriorityFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            const visibleFiles = this.validPathsFor(vscode_1.window.visibleTextEditors.map((editor) => editor.document));
            if (!this.pathsHaveChanged(this.lastPriorityFiles, visibleFiles))
                return;
            // Keep track of files to compare next time.
            this.lastPriorityFiles = visibleFiles;
            // Set priority files.
            try {
                yield this.analyzer.analysisSetPriorityFiles({ files: visibleFiles });
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    updateSubscriptions(force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const openFiles = this.validPathsFor(vscode_1.workspace.textDocuments);
            if (!force && !this.pathsHaveChanged(this.lastSubscribedFiles, openFiles))
                return;
            // Keep track of files to compare next time.
            this.lastSubscribedFiles = openFiles;
            // Set subscriptions.
            try {
                yield this.analyzer.analysisSetSubscriptions({
                    subscriptions: {
                        CLOSING_LABELS: this.analyzer.capabilities.supportsClosingLabels ? openFiles : undefined,
                        FOLDING: this.wsContext.config.useLsp ? undefined : openFiles,
                        OCCURRENCES: this.wsContext.config.useLsp ? undefined : openFiles,
                        OUTLINE: openFiles,
                    },
                });
            }
            catch (e) {
                this.logger.error(e);
            }
            // Set subscriptions.
            if (this.wsContext.hasAnyFlutterProjects && this.analyzer.capabilities.supportsFlutterOutline) {
                try {
                    yield this.analyzer.flutterSetSubscriptions({
                        subscriptions: {
                            OUTLINE: openFiles,
                        },
                    });
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
        });
    }
    pathsHaveChanged(last, current) {
        return last.length !== current.length
            || last.some((f, i) => f !== current[i]);
    }
    validPathsFor(paths) {
        const isAnalyzeable = this.analyzer.capabilities.supportsPriorityFilesOutsideAnalysisRoots
            ? util.isAnalyzable
            : util.isAnalyzableAndInWorkspace;
        return paths
            .filter((doc) => !doc.isClosed && isAnalyzeable(doc))
            .map((doc) => fs_1.fsPath(doc.uri))
            .sort((path1, path2) => path1.localeCompare(path2));
    }
    getOutlineFor(file) {
        return this.outlines[fs_1.fsPath(file)];
    }
    waitForOutlineWithLength(file, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return promises_1.waitFor(() => {
                const outline = this.outlines[fs_1.fsPath(file)];
                return (outline === null || outline === void 0 ? void 0 : outline.length) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getFlutterOutlineFor(file) {
        return this.flutterOutlines[fs_1.fsPath(file)];
    }
    waitForFlutterOutlineWithLength(file, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return promises_1.waitFor(() => {
                const outline = this.flutterOutlines[fs_1.fsPath(file)];
                return (outline === null || outline === void 0 ? void 0 : outline.length) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getOccurrencesFor(file) {
        return this.occurrences[fs_1.fsPath(file)];
    }
    supportsPubRunTest(file) {
        // TODO: Both FileTrackers have a copy of this!
        const path = fs_1.fsPath(file);
        if (!util.isPubRunnableTestFile(path))
            return false;
        if (this.pubRunTestSupport[path] === undefined) {
            const projectRoot = project_1.locateBestProjectRoot(path);
            this.pubRunTestSupport[path] = !!(projectRoot && util.projectShouldUsePubForTests(projectRoot, this.wsContext.config));
        }
        return this.pubRunTestSupport[fs_1.fsPath(file)];
    }
    watchPubspec() {
        const clearCachedPubRunTestData = () => Object.keys(this.pubRunTestSupport).forEach((f) => delete this.pubRunTestSupport[f]);
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(clearCachedPubRunTestData, this);
        watcher.onDidCreate(clearCachedPubRunTestData, this);
    }
    getFoldingRegionsFor(file) {
        return this.folding[fs_1.fsPath(file)];
    }
    getLastPriorityFiles() {
        return this.lastPriorityFiles.slice();
    }
    getLastSubscribedFiles() {
        return this.lastSubscribedFiles.slice();
    }
    dispose() {
        // TODO: This (and others) should probably await, in case they're promises.
        // And also not fail on first error.
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.DasFileTracker = DasFileTracker;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspAnalyzer = void 0;
const path = __webpack_require__(2);
const stream = __webpack_require__(63);
const vscode_1 = __webpack_require__(0);
const vscode_languageclient_1 = __webpack_require__(101);
const custom_protocol_1 = __webpack_require__(104);
const analyzer_1 = __webpack_require__(119);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const config_1 = __webpack_require__(10);
const misc_1 = __webpack_require__(62);
const processes_1 = __webpack_require__(15);
const analyzer_2 = __webpack_require__(120);
const file_tracker_lsp_1 = __webpack_require__(195);
class LspAnalyzer extends analyzer_1.Analyzer {
    constructor(logger, sdks, dartCapabilities, wsContext) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.Analyzer));
        this.client = createClient(this.logger, sdks, dartCapabilities, wsContext);
        this.fileTracker = new file_tracker_lsp_1.LspFileTracker(logger, this.client, wsContext);
        this.disposables.push(this.client.start());
        this.disposables.push(this.fileTracker);
        // tslint:disable-next-line: no-floating-promises
        this.client.onReady().then(() => {
            // Reminder: These onNotification calls only hold ONE handler!
            // https://github.com/microsoft/vscode-languageserver-node/issues/174
            this.client.onNotification(custom_protocol_1.AnalyzerStatusNotification.type, (params) => {
                this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: params.isAnalyzing });
            });
            this.onReadyCompleter.resolve();
        });
    }
    getDiagnosticServerPort() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.DiagnosticServerRequest.type, undefined);
        });
    }
    forceReanalyze() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.sendRequest(custom_protocol_1.ReanalyzeRequest.type, undefined);
            }
            catch (e) {
                vscode_1.window.showErrorMessage("Reanalyze is not supported by this version of the Dart SDK's LSP server.");
            }
        });
    }
    getSuper(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.SuperRequest.type, params);
        });
    }
    completeStatement(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.CompleteStatementRequest.type, params);
        });
    }
}
exports.LspAnalyzer = LspAnalyzer;
function createClient(logger, sdks, dartCapabilities, wsContext) {
    const clientOptions = {
        initializationOptions: {
            // 	onlyAnalyzeProjectsWithOpenFiles: true,
            closingLabels: config_1.config.closingLabels,
            flutterOutline: wsContext.hasAnyFlutterProjects,
            outline: true,
        },
        outputChannelName: "LSP",
    };
    const client = new vscode_languageclient_1.LanguageClient("dartAnalysisLSP", "Dart Analysis Server", () => spawnServer(logger, sdks, dartCapabilities), clientOptions);
    return client;
}
function spawnServer(logger, sdks, dartCapabilities) {
    // TODO: Replace with constructing an Analyzer that passes LSP flag (but still reads config
    // from paths etc) and provide it's process.
    const vmPath = path.join(sdks.dart, constants_1.dartVMPath);
    const args = analyzer_2.getAnalyzerArgs(logger, sdks, dartCapabilities, true);
    logger.info(`Spawning ${vmPath} with args ${JSON.stringify(args)}`);
    const process = processes_1.safeToolSpawn(undefined, vmPath, args);
    logger.info(`    PID: ${process.pid}`);
    const reader = process.stdout.pipe(new LoggingTransform(logger, "<=="));
    const writer = new LoggingTransform(logger, "==>");
    writer.pipe(process.stdin);
    process.stderr.on("data", (data) => logger.error(data.toString()));
    process.on("exit", (code, signal) => {
        if (code)
            misc_1.reportAnalyzerTerminatedWithError();
    });
    return Promise.resolve({ reader, writer });
}
class LoggingTransform extends stream.Transform {
    constructor(logger, prefix, opts) {
        super(opts);
        this.logger = logger;
        this.prefix = prefix;
    }
    _transform(chunk, encoding, callback) {
        this.logger.info(`${this.prefix} ${chunk}`);
        this.push(chunk, encoding);
        callback();
    }
}


/***/ }),
/* 160 */
/***/ (function(module, exports) {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var t = exports.tokens = {}
var R = 0

function tok (n) {
  t[n] = R++
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

tok('NUMERICIDENTIFIER')
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
tok('NUMERICIDENTIFIERLOOSE')
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER')
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION')
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')'

tok('MAINVERSIONLOOSE')
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER')
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +
                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'

tok('PRERELEASEIDENTIFIERLOOSE')
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE')
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'

tok('PRERELEASELOOSE')
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER')
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD')
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] +
             '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL')
tok('FULLPLAIN')
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +
                  src[t.PRERELEASE] + '?' +
                  src[t.BUILD] + '?'

src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
tok('LOOSEPLAIN')
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] +
                  src[t.PRERELEASELOOSE] + '?' +
                  src[t.BUILD] + '?'

tok('LOOSE')
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'

tok('GTLT')
src[t.GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
tok('XRANGEIDENTIFIERLOOSE')
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
tok('XRANGEIDENTIFIER')
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*'

tok('XRANGEPLAIN')
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[t.PRERELEASE] + ')?' +
                   src[t.BUILD] + '?' +
                   ')?)?'

tok('XRANGEPLAINLOOSE')
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +
                        src[t.BUILD] + '?' +
                        ')?)?'

tok('XRANGE')
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$'
tok('XRANGELOOSE')
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
tok('COERCE')
src[t.COERCE] = '(^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'
tok('COERCERTL')
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')

// Tilde ranges.
// Meaning is "reasonably at or greater than"
tok('LONETILDE')
src[t.LONETILDE] = '(?:~>?)'

tok('TILDETRIM')
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+'
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

tok('TILDE')
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'
tok('TILDELOOSE')
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
tok('LONECARET')
src[t.LONECARET] = '(?:\\^)'

tok('CARETTRIM')
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+'
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')
var caretTrimReplace = '$1^'

tok('CARET')
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'
tok('CARETLOOSE')
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
tok('COMPARATORLOOSE')
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'
tok('COMPARATOR')
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
tok('COMPARATORTRIM')
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] +
                      '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
tok('HYPHENRANGE')
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s*$'

tok('HYPHENRANGELOOSE')
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
tok('STAR')
src[t.STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  var i = 0
  do {
    var a = this.build[i]
    var b = other.build[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.compareBuild = compareBuild
function compareBuild (a, b, loose) {
  var versionA = new SemVer(a, loose)
  var versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1] !== undefined ? m[1] : ''
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY || version === ANY) {
    return true
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    if (this.value === '') {
      return true
    }
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true
    }
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[t.COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[t.CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return (
      isSatisfiable(thisComparators, options) &&
      range.set.some(function (rangeComparators) {
        return (
          isSatisfiable(rangeComparators, options) &&
          thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        )
      })
    )
  })
}

// take a set of comparators and determine whether there
// exists a version which can satisfy it
function isSatisfiable (comparators, options) {
  var result = true
  var remainingComparators = comparators.slice()
  var testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr +
        ' <' + M + '.' + (+m + 1) + '.0' + pr
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version, options) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  var match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next
    while ((next = re[t.COERCERTL].exec(version)) &&
      (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
          next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(match[2] +
    '.' + (match[3] || '0') +
    '.' + (match[4] || '0'), options)
}


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const is = __webpack_require__(53);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    ErrorCodes.serverErrorStart = -32099;
    ErrorCodes.serverErrorEnd = -32000;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    // Defined by the protocol.
    ErrorCodes.RequestCancelled = -32800;
    ErrorCodes.ContentModified = -32801;
    // Defined by VSCode library.
    ErrorCodes.MessageWriteError = 1;
    ErrorCodes.MessageReadError = 2;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageType {
    constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
    }
    get method() {
        return this._method;
    }
    get numberOfParams() {
        return this._numberOfParams;
    }
}
exports.AbstractMessageType = AbstractMessageType;
/**
 * Classes to type request response pairs
 *
 * The type parameter RO will be removed in the next major version
 * of the JSON RPC library since it is a LSP concept and doesn't
 * belong here. For now it is tagged as default never.
 */
class RequestType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
/**
 * The type parameter RO will be removed in the next major version
 * of the JSON RPC library since it is a LSP concept and doesn't
 * belong here. For now it is tagged as default never.
 */
class NotificationType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(64);
const Is = __webpack_require__(53);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.Last = 2;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
    }
    delete(key) {
        const item = this._map.get(key);
        if (!item) {
            return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.next;
        }
    }
    forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.previous;
        }
    }
    values() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }
    keys() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.key);
            current = current.next;
        }
        return result;
    }
    /* JSON RPC run on es5 which has no Symbol.iterator
    public keys(): IterableIterator<K> {
        let current = this._head;
        let iterator: IterableIterator<K> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<K> {
                if (current) {
                    let result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }

    public values(): IterableIterator<V> {
        let current = this._head;
        let iterator: IterableIterator<V> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<V> {
                if (current) {
                    let result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    */
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            this._head = item.next;
        }
        else if (item === this._tail) {
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
        }
    }
}
exports.LinkedMap = LinkedMap;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(2);
const os_1 = __webpack_require__(18);
const crypto_1 = __webpack_require__(54);
const net_1 = __webpack_require__(55);
const messageReader_1 = __webpack_require__(102);
const messageWriter_1 = __webpack_require__(103);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    else {
        // Mac/Unix: use socket file
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __webpack_require__(55);
const messageReader_1 = __webpack_require__(102);
const messageWriter_1 = __webpack_require__(103);
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Location", function() { return Location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationLink", function() { return LocationLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorInformation", function() { return ColorInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPresentation", function() { return ColorPresentation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FoldingRangeKind", function() { return FoldingRangeKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FoldingRange", function() { return FoldingRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticRelatedInformation", function() { return DiagnosticRelatedInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticSeverity", function() { return DiagnosticSeverity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticTag", function() { return DiagnosticTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Diagnostic", function() { return Diagnostic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Command", function() { return Command; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEdit", function() { return TextEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentEdit", function() { return TextDocumentEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CreateFile", function() { return CreateFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenameFile", function() { return RenameFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeleteFile", function() { return DeleteFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorkspaceEdit", function() { return WorkspaceEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorkspaceChange", function() { return WorkspaceChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentIdentifier", function() { return TextDocumentIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VersionedTextDocumentIdentifier", function() { return VersionedTextDocumentIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentItem", function() { return TextDocumentItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkupKind", function() { return MarkupKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkupContent", function() { return MarkupContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItemKind", function() { return CompletionItemKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InsertTextFormat", function() { return InsertTextFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItemTag", function() { return CompletionItemTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItem", function() { return CompletionItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionList", function() { return CompletionList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkedString", function() { return MarkedString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hover", function() { return Hover; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParameterInformation", function() { return ParameterInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignatureInformation", function() { return SignatureInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentHighlightKind", function() { return DocumentHighlightKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentHighlight", function() { return DocumentHighlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolKind", function() { return SymbolKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolTag", function() { return SymbolTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolInformation", function() { return SymbolInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentSymbol", function() { return DocumentSymbol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeActionKind", function() { return CodeActionKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeActionContext", function() { return CodeActionContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeAction", function() { return CodeAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeLens", function() { return CodeLens; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormattingOptions", function() { return FormattingOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentLink", function() { return DocumentLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionRange", function() { return SelectionRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EOL", function() { return EOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocument", function() { return TextDocument; });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given liternal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.red)
            && Is.number(candidate.green)
            && Is.number(candidate.blue)
            && Is.number(candidate.alpha);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.startLine) && Is.number(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && VersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&
            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits) {
        this.edits = edits;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText) {
        this.edits.push(TextEdit.insert(position, newText));
    };
    TextEditChangeImpl.prototype.replace = function (range, newText) {
        this.edits.push(TextEdit.replace(range, newText));
    };
    TextEditChangeImpl.prototype.delete = function (range) {
        this.edits.push(TextEdit.del(range));
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            return this._workspaceEdit;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (VersionedTextDocumentIdentifier.is(key)) {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    documentChanges: []
                };
            }
            if (!this._workspaceEdit.documentChanges) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = key;
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    changes: Object.create(null)
                };
            }
            if (!this._workspaceEdit.changes) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
    };
    WorkspaceChange.prototype.deleteFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
    };
    WorkspaceChange.prototype.checkDocumentChanges = function () {
        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.15
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== void 0) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === void 0 || Is.string(candidate.detail)) &&
            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&
            (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== void 0 && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, commandOrEdit, kind) {
        var result = { title: title };
        if (Command.is(commandOrEdit)) {
            result.command = commandOrEdit;
        }
        else {
            result.edit = commandOrEdit;
        }
        if (kind !== void 0) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === void 0 || Is.string(candidate.kind)) &&
            (candidate.edit !== void 0 || candidate.command !== void 0) &&
            (candidate.command === void 0 || Command.is(candidate.command)) &&
            (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const Is = __webpack_require__(168);
const vscode_jsonrpc_1 = __webpack_require__(23);
const messages_1 = __webpack_require__(21);
const protocol_implementation_1 = __webpack_require__(169);
exports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
const protocol_typeDefinition_1 = __webpack_require__(170);
exports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
const protocol_workspaceFolders_1 = __webpack_require__(171);
exports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
exports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
const protocol_configuration_1 = __webpack_require__(172);
exports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
const protocol_colorProvider_1 = __webpack_require__(173);
exports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
exports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
const protocol_foldingRange_1 = __webpack_require__(174);
exports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
const protocol_declaration_1 = __webpack_require__(175);
exports.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
const protocol_selectionRange_1 = __webpack_require__(176);
exports.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;
const protocol_progress_1 = __webpack_require__(177);
exports.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;
exports.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;
exports.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling startegy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The intialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
    /** @deprecated Use CompletionRequest.type */
    CompletionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
    /** @deprecated Use DefinitionRequest.type */
    DefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
    /** @deprecated Use ReferencesRequest.type */
    ReferencesRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
    /** @deprecated Use DocumentHighlightRequest.type */
    DocumentHighlightRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
    /** @deprecated Use DocumentSymbolRequest.type */
    DocumentSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
    /** @deprecated Use CodeActionRequest.type */
    CodeActionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
    /** @deprecated Use WorkspaceSymbolRequest.type */
    WorkspaceSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.type = new messages_1.ProtocolRequestType('textDocument/codeLens');
    /** @deprecated Use CodeLensRequest.type */
    CodeLensRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType('codeLens/resolve');
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
    /** @deprecated Use DocumentLinkRequest.type */
    DocumentLinkRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType('documentLink/resolve');
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
const messages_1 = __webpack_require__(21);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
    /** @deprecated Use ImplementationRequest.type */
    ImplementationRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
const messages_1 = __webpack_require__(21);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
    /** @deprecated Use TypeDefinitionRequest.type */
    TypeDefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(21);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(21);
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
const messages_1 = __webpack_require__(21);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
    /** @deprecated Use DocumentColorRequest.type */
    DocumentColorRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
const messages_1 = __webpack_require__(21);
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
    /** @deprecated Use FoldingRangeRequest.type */
    FoldingRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
const messages_1 = __webpack_require__(21);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
    /** @deprecated Use DeclarationRequest.type */
    DeclarationRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
const messages_1 = __webpack_require__(21);
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
    /** @deprecated  Use SelectionRangeRequest.type */
    SelectionRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(23);
const messages_1 = __webpack_require__(21);
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(21);
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0 - Proposed state
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(21);
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0 - Proposed state
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    SemanticTokenTypes["namespace"] = "namespace";
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["member"] = "member";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["label"] = "label";
})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0 - Proposed state
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["reference"] = "reference";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["volatile"] = "volatile";
    SemanticTokenModifiers["readonly"] = "readonly";
})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensEditsRequest;
(function (SemanticTokensEditsRequest) {
    SemanticTokensEditsRequest.method = 'textDocument/semanticTokens/edits';
    SemanticTokensEditsRequest.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest.method);
})(SemanticTokensEditsRequest = exports.SemanticTokensEditsRequest || (exports.SemanticTokensEditsRequest = {}));
/**
 * @since 3.16.0 - Proposed state
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const code = __webpack_require__(0);
const proto = __webpack_require__(14);
const Is = __webpack_require__(56);
const protocolCompletionItem_1 = __webpack_require__(121);
const protocolCodeLens_1 = __webpack_require__(122);
const protocolDocumentLink_1 = __webpack_require__(123);
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: {
                uri: _uriConverter(textDocument.uri),
                languageId: textDocument.languageId,
                version: textDocument.version,
                text: textDocument.getText()
            }
        };
    }
    function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
            let result = {
                textDocument: {
                    uri: _uriConverter(arg.uri),
                    version: arg.version
                },
                contentChanges: [{ text: arg.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg)) {
            let document = arg.document;
            let result = {
                textDocument: {
                    uri: _uriConverter(document.uri),
                    version: document.version
                },
                contentChanges: arg.contentChanges.map((change) => {
                    let range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asVersionedTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.text = textDocument.getText();
        }
        return result;
    }
    function asTextDocumentSaveReason(reason) {
        switch (reason) {
            case code.TextDocumentSaveReason.Manual:
                return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
                return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
                return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
                return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return proto.CompletionTriggerKind.Invoked;
        }
    }
    function asCompletionParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                triggerKind: asCompletionTriggerKind(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            }
        };
    }
    function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
                return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
                return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
                return proto.SignatureHelpTriggerKind.ContentChange;
        }
    }
    function asParameterInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label
        };
    }
    function asParameterInformations(values) {
        return values.map(asParameterInformation);
    }
    function asSignatureInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
        };
    }
    function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
    }
    function asSignatureHelp(value) {
        if (value === undefined) {
            return value;
        }
        return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
        };
    }
    function asSignatureHelpParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                isRetrigger: context.isRetrigger,
                triggerCharacter: context.triggerCharacter,
                triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
                activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asPosition(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { line: value.line, character: value.character };
    }
    function asPositions(value) {
        let result = [];
        for (let elem of value) {
            result.push(asPosition(elem));
        }
        return result;
    }
    function isInsertReplace(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    function asRange(value) {
        if (value === undefined || value === null) {
            return value;
        }
        // The LSP has no support yet for insert replace. So this can never happen.
        if (isInsertReplace(value)) {
            throw new Error(`Receving unknown insert replace range.`);
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asLocation(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
                return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
                return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
                return proto.DiagnosticSeverity.Hint;
        }
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case code.DiagnosticTag.Unnecessary:
                return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
                return proto.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asRelatedInformation(item) {
        return {
            message: item.message,
            location: asLocation(item.location)
        };
    }
    function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
    }
    function asDiagnostic(item) {
        let result = proto.Diagnostic.create(asRange(item.range), item.message);
        if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Is.number(item.code) || Is.string(item.code)) {
            result.code = item.code;
        }
        if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
            result.source = item.source;
        }
        return result;
    }
    function asDiagnostics(items) {
        if (items === undefined || items === null) {
            return items;
        }
        return items.map(asDiagnostic);
    }
    function asDocumentation(format, documentation) {
        switch (format) {
            case '$string':
                return documentation;
            case proto.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return `Unsupported Markup content received. Kind is: ${format}`;
        }
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case code.CompletionItemTag.Deprecated:
                return proto.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined) {
            return tags;
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItemKind(value, original) {
        if (original !== undefined) {
            return original;
        }
        return value + 1;
    }
    function asCompletionItem(item) {
        let result = { label: item.label };
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === '$string') {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
            if (protocolItem.data !== undefined) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                if (protocolItem.deprecated === true && tags !== undefined && tags.length > 0) {
                    const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                    if (index !== -1) {
                        tags.splice(index, 1);
                    }
                }
                result.deprecated = protocolItem.deprecated;
            }
        }
        if (tags !== undefined && tags.length > 0) {
            result.tags = tags;
        }
        return result;
    }
    function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = undefined;
        let range = undefined;
        if (source.textEdit) {
            text = source.textEdit.newText;
            range = asRange(source.textEdit.range);
        }
        else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        else {
            text = source.insertText;
        }
        if (source.range) {
            range = asRange(source.range);
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== undefined && range !== undefined) {
            target.textEdit = { newText: text, range: range };
        }
        else {
            target.insertText = text;
        }
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (edits === undefined || edits === null) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return (item + 1);
        }
        return proto.SymbolKind.Property;
    }
    function asSymbolTag(item) {
        return item;
    }
    function asSymbolTags(items) {
        return items.map(asSymbolTag);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    function asCodeActionContext(context) {
        if (context === undefined || context === null) {
            return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
            only = [context.only.value];
        }
        return proto.CodeActionContext.create(asDiagnostics(context.diagnostics), only);
    }
    function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
                result.data = item.data;
            }
        }
        return result;
    }
    function asFormattingOptions(item) {
        return { tabSize: item.tabSize, insertSpaces: item.insertSpaces };
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
            result.target = asUri(item.target);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;
        if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
        }
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeActionContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams
    };
}
exports.createConverter = createConverter;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const code = __webpack_require__(0);
const ls = __webpack_require__(14);
const Is = __webpack_require__(56);
const protocolCompletionItem_1 = __webpack_require__(121);
const protocolCodeLens_1 = __webpack_require__(122);
const protocolDocumentLink_1 = __webpack_require__(123);
var CodeBlock;
(function (CodeBlock) {
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    CodeBlock.is = is;
})(CodeBlock || (CodeBlock = {}));
function createConverter(uriConverter) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asDiagnostics(diagnostics) {
        return diagnostics.map(asDiagnostic);
    }
    function asDiagnostic(diagnostic) {
        let result = new code.Diagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity));
        if (Is.number(diagnostic.code) || Is.string(diagnostic.code)) {
            result.code = diagnostic.code;
        }
        if (diagnostic.source) {
            result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
    }
    function asRelatedInformation(relatedInformation) {
        return relatedInformation.map(asDiagnosticRelatedInformation);
    }
    function asDiagnosticRelatedInformation(information) {
        return new code.DiagnosticRelatedInformation(asLocation(information.location), information.message);
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
                return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
                return code.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asPosition(value) {
        if (!value) {
            return undefined;
        }
        return new code.Position(value.line, value.character);
    }
    function asRange(value) {
        if (!value) {
            return undefined;
        }
        return new code.Range(asPosition(value.start), asPosition(value.end));
    }
    function asRanges(value) {
        return value.map(value => asRange(value));
    }
    function asDiagnosticSeverity(value) {
        if (value === undefined || value === null) {
            return code.DiagnosticSeverity.Error;
        }
        switch (value) {
            case ls.DiagnosticSeverity.Error:
                return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
                return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
                return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
                return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
        if (Is.string(value)) {
            return new code.MarkdownString(value);
        }
        else if (CodeBlock.is(value)) {
            let result = new code.MarkdownString();
            return result.appendCodeblock(value.value, value.language);
        }
        else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
                let item = new code.MarkdownString();
                if (CodeBlock.is(element)) {
                    item.appendCodeblock(element.value, element.language);
                }
                else {
                    item.appendMarkdown(element);
                }
                result.push(item);
            }
            return result;
        }
        else {
            let result;
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return new code.MarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    result = new code.MarkdownString();
                    result.appendText(value.value);
                    return result;
                default:
                    result = new code.MarkdownString();
                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                    return result;
            }
        }
    }
    function asDocumentation(value) {
        if (Is.string(value)) {
            return value;
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return new code.MarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    return value.value;
                default:
                    return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
        }
    }
    function asHover(hover) {
        if (!hover) {
            return undefined;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    function asCompletionResult(result) {
        if (!result) {
            return undefined;
        }
        if (Array.isArray(result)) {
            let items = result;
            return items.map(asCompletionItem);
        }
        let list = result;
        return new code.CompletionList(list.items.map(asCompletionItem), list.isIncomplete);
    }
    function asCompletionItemKind(value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case ls.CompletionItemTag.Deprecated:
                return code.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined || tags === null) {
            return [];
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItem(item) {
        let tags = asCompletionItemTags(item.tags);
        let result = new protocolCompletionItem_1.default(item.label);
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        let insertText = asCompletionInsertText(item);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (Is.stringArray(item.commitCharacters)) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
                tags.push(code.CompletionItemTag.Deprecated);
            }
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        if (item.data !== undefined) {
            result.data = item.data;
        }
        if (tags.length > 0) {
            result.tags = tags;
        }
        return result;
    }
    function asCompletionInsertText(item) {
        if (item.textEdit) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.textEdit.newText), range: asRange(item.textEdit.range), fromEdit: true };
            }
            else {
                return { text: item.textEdit.newText, range: asRange(item.textEdit.range), fromEdit: true };
            }
        }
        else if (item.insertText) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.insertText), fromEdit: false };
            }
            else {
                return { text: item.insertText, fromEdit: false };
            }
        }
        else {
            return undefined;
        }
    }
    function asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    function asTextEdits(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asTextEdit);
    }
    function asSignatureHelp(item) {
        if (!item) {
            return undefined;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = asSignatureInformations(item.signatures);
        }
        return result;
    }
    function asSignatureInformations(items) {
        return items.map(asSignatureInformation);
    }
    function asSignatureInformation(item) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters) {
            result.parameters = asParameterInformations(item.parameters);
        }
        return result;
    }
    function asParameterInformations(item) {
        return item.map(asParameterInformation);
    }
    function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        return result;
    }
    function asLocation(item) {
        if (!item) {
            return undefined;
        }
        return new code.Location(_uriConverter(item.uri), asRange(item.range));
    }
    function asDeclarationResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asDefinitionResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asLocationLink(item) {
        if (!item) {
            return undefined;
        }
        let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetSelectionRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
    }
    function asLocationResult(item) {
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            if (item.length === 0) {
                return [];
            }
            else if (ls.LocationLink.is(item[0])) {
                let links = item;
                return links.map((link) => asLocationLink(link));
            }
            else {
                let locations = item;
                return locations.map((location) => asLocation(location));
            }
        }
        else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
        }
        else {
            return asLocation(item);
        }
    }
    function asReferences(values) {
        if (!values) {
            return undefined;
        }
        return values.map(location => asLocation(location));
    }
    function asDocumentHighlights(values) {
        if (!values) {
            return undefined;
        }
        return values.map(asDocumentHighlight);
    }
    function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
    }
    function asDocumentHighlightKind(item) {
        switch (item) {
            case ls.DocumentHighlightKind.Text:
                return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
                return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
                return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
    }
    function asSymbolInformations(values, uri) {
        if (!values) {
            return undefined;
        }
        return values.map(information => asSymbolInformation(information, uri));
    }
    function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return code.SymbolKind.Property;
    }
    function asSymbolTag(value) {
        return value;
    }
    function asSymbolTags(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        return items.map(asSymbolTag);
    }
    function asSymbolInformation(item, uri) {
        // Symbol kind is one based in the protocol and zero based in code.
        let result = new code.SymbolInformation(item.name, asSymbolKind(item.kind), asRange(item.location.range), item.location.uri ? _uriConverter(item.location.uri) : uri);
        if (item.containerName) {
            result.containerName = item.containerName;
        }
        return result;
    }
    function asDocumentSymbols(values) {
        if (values === undefined || values === null) {
            return undefined;
        }
        return values.map(asDocumentSymbol);
    }
    function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        if (value.children !== undefined && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
                children.push(asDocumentSymbol(child));
            }
            result.children = children;
        }
        return result;
    }
    function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCommands(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asCommand);
    }
    const kindMapping = new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = kindMapping.get(item);
        if (result) {
            return result;
        }
        let parts = item.split('.');
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
            result = result.append(part);
        }
        return result;
    }
    function asCodeActionKinds(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        return items.map(kind => asCodeActionKind(kind));
    }
    function asCodeAction(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = new code.CodeAction(item.title);
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics) {
            result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit) {
            result.edit = asWorkspaceEdit(item.edit);
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        return result;
    }
    function asCodeLens(item) {
        if (!item) {
            return undefined;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.data !== undefined && item.data !== null) {
            result.data = item.data;
        }
        return result;
    }
    function asCodeLenses(items) {
        if (!items) {
            return undefined;
        }
        return items.map((codeLens) => asCodeLens(codeLens));
    }
    function asWorkspaceEdit(item) {
        if (!item) {
            return undefined;
        }
        let result = new code.WorkspaceEdit();
        if (item.documentChanges) {
            item.documentChanges.forEach(change => {
                if (ls.CreateFile.is(change)) {
                    result.createFile(_uriConverter(change.uri), change.options);
                }
                else if (ls.RenameFile.is(change)) {
                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options);
                }
                else if (ls.DeleteFile.is(change)) {
                    result.deleteFile(_uriConverter(change.uri), change.options);
                }
                else if (ls.TextDocumentEdit.is(change)) {
                    result.set(_uriConverter(change.textDocument.uri), asTextEdits(change.edits));
                }
                else {
                    console.error(`Unknown workspace edit change received:\n${JSON.stringify(change, undefined, 4)}`);
                }
            });
        }
        else if (item.changes) {
            Object.keys(item.changes).forEach(key => {
                result.set(_uriConverter(key), asTextEdits(item.changes[key]));
            });
        }
        return result;
    }
    function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : undefined;
        // target must be optional in DocumentLink
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== undefined) {
            link.tooltip = item.tooltip;
        }
        if (item.data !== undefined && item.data !== null) {
            link.data = item.data;
        }
        return link;
    }
    function asDocumentLinks(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asDocumentLink);
    }
    function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    function asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(asColorInformation);
        }
        return undefined;
    }
    function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEdits(cp.additionalTextEdits);
        if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
    }
    function asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(asColorPresentation);
        }
        return undefined;
    }
    function asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case ls.FoldingRangeKind.Comment:
                    return code.FoldingRangeKind.Comment;
                case ls.FoldingRangeKind.Imports:
                    return code.FoldingRangeKind.Imports;
                case ls.FoldingRangeKind.Region:
                    return code.FoldingRangeKind.Region;
            }
        }
        return undefined;
    }
    function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    function asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(asFoldingRange);
        }
        return undefined;
    }
    function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : undefined);
    }
    function asSelectionRanges(selectionRanges) {
        if (!Array.isArray(selectionRanges)) {
            return [];
        }
        let result = [];
        for (let range of selectionRanges) {
            result.push(asSelectionRange(range));
        }
        return result;
    }
    return {
        asUri,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges
    };
}
exports.createConverter = createConverter;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = undefined;
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
            this.cancelTimeout();
        }
        if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve) => {
                this.onSuccess = resolve;
            }).then(() => {
                this.completionPromise = undefined;
                this.onSuccess = undefined;
                var result = this.task();
                this.task = undefined;
                return result;
            });
        }
        if (delay >= 0 || this.timeout === void 0) {
            this.timeout = setTimeout(() => {
                this.timeout = undefined;
                this.onSuccess(undefined);
            }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
    }
    forceDelivery() {
        if (!this.completionPromise) {
            return undefined;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
        return result;
    }
    isTriggered() {
        return this.timeout !== void 0;
    }
    cancel() {
        this.cancelTimeout();
        this.completionPromise = undefined;
    }
    cancelTimeout() {
        if (this.timeout !== void 0) {
            clearTimeout(this.timeout);
            this.timeout = undefined;
        }
    }
}
exports.Delayer = Delayer;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const client_1 = __webpack_require__(22);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ColorProviderFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'colorProvider').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideColorPresentations: (color, context, token) => {
                const client = this._client;
                const provideColorPresentations = (color, context, token) => {
                    const requestParams = {
                        color,
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context.document),
                        range: client.code2ProtocolConverter.asRange(context.range)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then(this.asColorPresentations.bind(this), (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideColorPresentations
                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)
                    : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document, token) => {
                const client = this._client;
                const provideDocumentColors = (document, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then(this.asColorInformations.bind(this), (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentColors
                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)
                    : provideDocumentColors(document, token);
            }
        };
        return [vscode_1.languages.registerColorProvider(options.documentSelector, provider), provider];
    }
    asColor(color) {
        return new vscode_1.Color(color.red, color.green, color.blue, color.alpha);
    }
    asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(ci => {
                return new vscode_1.ColorInformation(this._client.protocol2CodeConverter.asRange(ci.range), this.asColor(ci.color));
            });
        }
        return [];
    }
    asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(cp => {
                let presentation = new vscode_1.ColorPresentation(cp.label);
                presentation.additionalTextEdits = this._client.protocol2CodeConverter.asTextEdits(cp.additionalTextEdits);
                presentation.textEdit = this._client.protocol2CodeConverter.asTextEdit(cp.textEdit);
                return presentation;
            });
        }
        return [];
    }
}
exports.ColorProviderFeature = ColorProviderFeature;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params) => {
                let result = [];
                for (let item of params.items) {
                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;
                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));
                }
                return result;
            };
            let middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = vscode_1.workspace.getConfiguration(undefined, resource).get(section);
            }
            else {
                let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
                if (config) {
                    result = config.get(section.substr(index + 1));
                }
            }
        }
        else {
            let config = vscode_1.workspace.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = config.get(key);
                }
            }
        }
        if (!result) {
            return null;
        }
        return result;
    }
}
exports.ConfigurationFeature = ConfigurationFeature;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const client_1 = __webpack_require__(22);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ImplementationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let implementationSupport = ensure(ensure(capabilites, 'textDocument'), 'implementation');
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideImplementation: (document, position, token) => {
                const client = this._client;
                const provideImplementation = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideImplementation
                    ? middleware.provideImplementation(document, position, token, provideImplementation)
                    : provideImplementation(document, position, token);
            }
        };
        return [vscode_1.languages.registerImplementationProvider(options.documentSelector, provider), provider];
    }
}
exports.ImplementationFeature = ImplementationFeature;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const client_1 = __webpack_require__(22);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class TypeDefinitionFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'typeDefinition').dynamicRegistration = true;
        let typeDefinitionSupport = ensure(ensure(capabilites, 'textDocument'), 'typeDefinition');
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideTypeDefinition: (document, position, token) => {
                const client = this._client;
                const provideTypeDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideTypeDefinition
                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)
                    : provideTypeDefinition(document, position, token);
            }
        };
        return [vscode_1.languages.registerTypeDefinitionProvider(options.documentSelector, provider), provider];
    }
}
exports.TypeDefinitionFeature = TypeDefinitionFeature;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const UUID = __webpack_require__(124);
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
function arrayDiff(left, right) {
    return left.filter(element => right.indexOf(element) < 0);
}
exports.arrayDiff = arrayDiff;
class WorkspaceFoldersFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
        let folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            let workspaceFolders = () => {
                let folders = vscode_1.workspace.workspaceFolders;
                if (folders === void 0) {
                    return null;
                }
                let result = folders.map((folder) => {
                    return this.asProtocol(folder);
                });
                return result;
            };
            let middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        let value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register(this.messages, {
                id: id,
                registerOptions: undefined
            });
        }
    }
    sendInitialEvent(currentWorkspaceFolders) {
        if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
                this.doSendEvent(added, removed);
            }
        }
        else if (this._initialFolders) {
            this.doSendEvent([], this._initialFolders);
        }
        else if (currentWorkspaceFolders) {
            this.doSendEvent(currentWorkspaceFolders, []);
        }
    }
    doSendEvent(addedFolders, removedFolders) {
        let params = {
            event: {
                added: addedFolders.map(folder => this.asProtocol(folder)),
                removed: removedFolders.map(folder => this.asProtocol(folder))
            }
        };
        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    register(_message, data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event) => {
                this.doSendEvent(event.added, event.removed);
            };
            let middleware = client.clientOptions.middleware.workspace;
            middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const client_1 = __webpack_require__(22);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class FoldingRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let capability = ensure(ensure(capabilites, 'textDocument'), 'foldingRange');
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5000;
        capability.lineFoldingOnly = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideFoldingRanges: (document, context, token) => {
                const client = this._client;
                const provideFoldingRanges = (document, _, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then(this.asFoldingRanges.bind(this), (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideFoldingRanges
                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)
                    : provideFoldingRanges(document, context, token);
            }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(options.documentSelector, provider), provider];
    }
    asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case vscode_languageserver_protocol_1.FoldingRangeKind.Comment:
                    return vscode_1.FoldingRangeKind.Comment;
                case vscode_languageserver_protocol_1.FoldingRangeKind.Imports:
                    return vscode_1.FoldingRangeKind.Imports;
                case vscode_languageserver_protocol_1.FoldingRangeKind.Region:
                    return vscode_1.FoldingRangeKind.Region;
            }
        }
        return void 0;
    }
    asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(r => {
                return new vscode_1.FoldingRange(r.startLine, r.endLine, this.asFoldingRangeKind(r.kind));
            });
        }
        return [];
    }
}
exports.FoldingRangeFeature = FoldingRangeFeature;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const client_1 = __webpack_require__(22);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class DeclarationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const declarationSupport = ensure(ensure(capabilites, 'textDocument'), 'declaration');
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDeclaration: (document, position, token) => {
                const client = this._client;
                const provideDeclaration = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDeclarationResult, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDeclaration
                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)
                    : provideDeclaration(document, position, token);
            }
        };
        return [vscode_1.languages.registerDeclarationProvider(options.documentSelector, provider), provider];
    }
}
exports.DeclarationFeature = DeclarationFeature;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const client_1 = __webpack_require__(22);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class SelectionRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let capability = ensure(ensure(capabilites, 'textDocument'), 'selectionRange');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSelectionRanges: (document, positions, token) => {
                const client = this._client;
                const provideSelectionRanges = (document, positions, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        positions: client.code2ProtocolConverter.asPositions(positions)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token).then((ranges) => client.protocol2CodeConverter.asSelectionRanges(ranges), (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, error);
                        return Promise.resolve(null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideSelectionRanges
                    ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges)
                    : provideSelectionRanges(document, positions, token);
            }
        };
        return [vscode_1.languages.registerSelectionRangeProvider(options.documentSelector, provider), provider];
    }
}
exports.SelectionRangeFeature = SelectionRangeFeature;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const progressPart_1 = __webpack_require__(125);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class ProgressFeature {
    constructor(_client) {
        this._client = _client;
    }
    fillClientCapabilities(capabilities) {
        ensure(capabilities, 'window').workDoneProgress = true;
    }
    initialize() {
        let client = this._client;
        let createHandler = (params) => {
            new progressPart_1.ProgressPart(this._client, params.token);
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
    }
}
exports.ProgressFeature = ProgressFeature;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = __webpack_require__(0);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
const client_1 = __webpack_require__(22);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var protocol2code;
(function (protocol2code) {
    function asCallHierarchyItem(converter, item) {
        if (item === null) {
            return undefined;
        }
        let result = new vscode_1.CallHierarchyItem(converter.asSymbolKind(item.kind), item.name, item.detail || '', converter.asUri(item.uri), converter.asRange(item.range), converter.asRange(item.selectionRange));
        if (item.tags !== undefined) {
            result.tags = converter.asSymbolTags(item.tags);
        }
        return result;
    }
    protocol2code.asCallHierarchyItem = asCallHierarchyItem;
    function asCallHierarchyItems(converter, items) {
        if (items === null) {
            return undefined;
        }
        let result = items.map(item => asCallHierarchyItem(converter, item));
        return result[0];
    }
    protocol2code.asCallHierarchyItems = asCallHierarchyItems;
    function asCallHierarchyIncomingCall(converter, item) {
        return new vscode_1.CallHierarchyIncomingCall(asCallHierarchyItem(converter, item.from), converter.asRanges(item.fromRanges));
    }
    protocol2code.asCallHierarchyIncomingCall = asCallHierarchyIncomingCall;
    function asCallHierarchyIncomingCalls(converter, items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyIncomingCall(converter, item));
    }
    protocol2code.asCallHierarchyIncomingCalls = asCallHierarchyIncomingCalls;
    function asCallHierarchyOutgoingCall(converter, item) {
        return new vscode_1.CallHierarchyOutgoingCall(asCallHierarchyItem(converter, item.to), converter.asRanges(item.fromRanges));
    }
    protocol2code.asCallHierarchyOutgoingCall = asCallHierarchyOutgoingCall;
    function asCallHierarchyOutgoingCalls(converter, items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyOutgoingCall(converter, item));
    }
    protocol2code.asCallHierarchyOutgoingCalls = asCallHierarchyOutgoingCalls;
})(protocol2code || (protocol2code = {}));
var code2protocol;
(function (code2protocol) {
    function asCallHierarchyItem(converter, value) {
        const result = {
            name: value.name,
            kind: converter.asSymbolKind(value.kind),
            uri: converter.asUri(value.uri),
            range: converter.asRange(value.range),
            selectionRange: converter.asRange(value.selectionRange)
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = converter.asSymbolTags(value.tags);
        }
        return result;
    }
    code2protocol.asCallHierarchyItem = asCallHierarchyItem;
})(code2protocol || (code2protocol = {}));
class CallHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.clientOptions.middleware;
    }
    prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.Proposed.CallHierarchyPrepareRequest.type, params, token).then((result) => {
                return protocol2code.asCallHierarchyItems(this.client.protocol2CodeConverter, result);
            }, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.Proposed.CallHierarchyPrepareRequest.type, error);
                return Promise.resolve(null);
            });
        };
        return middleware.prepareCallHierarchy
            ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy)
            : prepareCallHierarchy(document, position, token);
    }
    provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item, token) => {
            const params = {
                item: code2protocol.asCallHierarchyItem(client.code2ProtocolConverter, item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.Proposed.CallHierarchyIncomingCallsRequest.type, params, token).then((result) => {
                return protocol2code.asCallHierarchyIncomingCalls(client.protocol2CodeConverter, result);
            }, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.Proposed.CallHierarchyIncomingCallsRequest.type, error);
                return Promise.resolve(null);
            });
        };
        return middleware.provideCallHierarchyIncomingCalls
            ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls)
            : provideCallHierarchyIncomingCalls(item, token);
    }
    provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item, token) => {
            const params = {
                item: code2protocol.asCallHierarchyItem(client.code2ProtocolConverter, item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.Proposed.CallHierarchyOutgoingCallsRequest.type, params, token).then((result) => {
                return protocol2code.asCallHierarchyOutgoingCalls(client.protocol2CodeConverter, result);
            }, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.Proposed.CallHierarchyOutgoingCallsRequest.type, error);
                return Promise.resolve(null);
            });
        };
        return middleware.provideCallHierarchyOutgingCalls
            ? middleware.provideCallHierarchyOutgingCalls(item, token, provideCallHierarchyOutgoingCalls)
            : provideCallHierarchyOutgoingCalls(item, token);
    }
}
class CallHierarchyFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.Proposed.CallHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(cap) {
        const capabilites = cap;
        const capability = ensure(ensure(capabilites, 'textDocument'), 'callHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(cap, documentSelector) {
        const capabilities = cap;
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(options.documentSelector, provider), provider];
    }
}
exports.CallHierarchyFeature = CallHierarchyFeature;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode = __webpack_require__(0);
const client_1 = __webpack_require__(22);
const vscode_languageserver_protocol_1 = __webpack_require__(14);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var protocol2code;
(function (protocol2code) {
    function asSemanticTokens(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new vscode.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    protocol2code.asSemanticTokens = asSemanticTokens;
    function asSemanticTokensEdit(value) {
        return new vscode.SemanticTokensEdit(value.start, value.deleteCount, value.data !== undefined ? new Uint32Array(value.data) : undefined);
    }
    protocol2code.asSemanticTokensEdit = asSemanticTokensEdit;
    function asSemanticTokensEdits(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new vscode.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    protocol2code.asSemanticTokensEdits = asSemanticTokensEdits;
    function asLegend(value) {
        return value;
    }
    protocol2code.asLegend = asLegend;
})(protocol2code || (protocol2code = {}));
class SemanticTokensFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.Proposed.SemanticTokensRequest.type);
    }
    fillClientCapabilities(cap) {
        const capabilites = cap;
        let capability = ensure(ensure(capabilites, 'textDocument'), 'semanticTokens');
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.comment,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.keyword,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.number,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.regexp,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.operator,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.namespace,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.type,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.struct,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.class,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.interface,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.enum,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.typeParameter,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.function,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.member,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.macro,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.variable,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.parameter,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.property,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenTypes.label
        ];
        capability.tokenModifiers = [
            vscode_languageserver_protocol_1.Proposed.SemanticTokenModifiers.declaration,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenModifiers.documentation,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenModifiers.static,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenModifiers.abstract,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenModifiers.deprecated,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenModifiers.async,
            vscode_languageserver_protocol_1.Proposed.SemanticTokenModifiers.readonly
        ];
    }
    initialize(cap, documentSelector) {
        const capabilities = cap;
        let [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
            return;
        }
        this.register(this.messages, { id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const hasEditProvider = options.documentProvider !== undefined && typeof options.documentProvider !== 'boolean' && options.documentProvider.edits === true;
        const documentProvider = {
            provideDocumentSemanticTokens: (document, token) => {
                const client = this._client;
                const middleware = client.clientOptions.middleware;
                const provideDocumentSemanticTokens = (document, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.Proposed.SemanticTokensRequest.type, params, token).then((result) => {
                        return protocol2code.asSemanticTokens(result);
                    }, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.Proposed.SemanticTokensRequest.type, error);
                        return undefined;
                    });
                };
                return middleware.provideDocumentSemanticTokens
                    ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens)
                    : provideDocumentSemanticTokens(document, token);
            },
            provideDocumentSemanticTokensEdits: hasEditProvider
                ? (document, previousResultId, token) => {
                    const client = this._client;
                    const middleware = client.clientOptions.middleware;
                    const provideDocumentSemanticTokensEdits = (document, previousResultId, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            previousResultId
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.Proposed.SemanticTokensEditsRequest.type, params, token).then((result) => {
                            if (vscode_languageserver_protocol_1.Proposed.SemanticTokens.is(result)) {
                                return protocol2code.asSemanticTokens(result);
                            }
                            else {
                                return protocol2code.asSemanticTokensEdits(result);
                            }
                        }, (error) => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.Proposed.SemanticTokensEditsRequest.type, error);
                            return undefined;
                        });
                    };
                    return middleware.provideDocumentSemanticTokensEdits
                        ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits)
                        : provideDocumentSemanticTokensEdits(document, previousResultId, token);
                }
                : undefined
        };
        const hasRangeProvider = options.rangeProvider === true;
        const rangeProvider = hasRangeProvider
            ? {
                provideDocumentRangeSemanticTokens: (document, range, token) => {
                    const client = this._client;
                    const middleware = client.clientOptions.middleware;
                    const provideDocumentRangeSemanticTokens = (document, range, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            range: client.code2ProtocolConverter.asRange(range)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.Proposed.SemanticTokensRangeRequest.type, params, token).then((result) => {
                            return protocol2code.asSemanticTokens(result);
                        }, (error) => {
                            client.logFailedRequest(vscode_languageserver_protocol_1.Proposed.SemanticTokensRangeRequest.type, error);
                            return undefined;
                        });
                    };
                    return middleware.provideDocumentRangeSemanticTokens
                        ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens)
                        : provideDocumentRangeSemanticTokens(document, range, token);
                }
            }
            : undefined;
        const disposables = [];
        const legend = protocol2code.asLegend(options.legend);
        disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(options.documentSelector, documentProvider, legend));
        if (rangeProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(options.documentSelector, rangeProvider, legend));
        }
        return [new vscode.Disposable(() => disposables.forEach(item => item.dispose())), { document: documentProvider, range: rangeProvider }];
    }
}
exports.SemanticTokensFeature = SemanticTokensFeature;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const cp = __webpack_require__(49);
const path_1 = __webpack_require__(2);
const isWindows = (process.platform === 'win32');
const isMacintosh = (process.platform === 'darwin');
const isLinux = (process.platform === 'linux');
function terminate(process, cwd) {
    if (isWindows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd) {
                options.cwd = cwd;
            }
            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (isLinux || isMacintosh) {
        try {
            var cmd = path_1.join(__dirname, 'terminateProcess.sh');
            var result = cp.spawnSync(cmd, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;

/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspFileTracker = void 0;
const vscode_1 = __webpack_require__(0);
const custom_protocol_1 = __webpack_require__(104);
const events_1 = __webpack_require__(42);
const fs_1 = __webpack_require__(1);
const promises_1 = __webpack_require__(31);
const utils_1 = __webpack_require__(5);
const project_1 = __webpack_require__(51);
const util = __webpack_require__(6);
class LspFileTracker {
    constructor(logger, analyzer, wsContext) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.wsContext = wsContext;
        this.disposables = [];
        this.outlines = {};
        this.flutterOutlines = {};
        this.pubRunTestSupport = {};
        this.onOutlineEmitter = new events_1.EventEmitter();
        this.onOutline = this.onOutlineEmitter.event;
        this.onFlutterOutlineEmitter = new events_1.EventEmitter();
        this.onFlutterOutline = this.onFlutterOutlineEmitter.event;
        // tslint:disable-next-line: no-floating-promises
        analyzer.onReady().then(() => {
            this.analyzer.onNotification(custom_protocol_1.PublishOutlineNotification.type, (n) => {
                const filePath = fs_1.fsPath(vscode_1.Uri.parse(n.uri));
                this.outlines[filePath] = n.outline;
                this.onOutlineEmitter.fire(n);
            });
            this.analyzer.onNotification(custom_protocol_1.PublishFlutterOutlineNotification.type, (n) => {
                const filePath = fs_1.fsPath(vscode_1.Uri.parse(n.uri));
                this.flutterOutlines[filePath] = n.outline;
                this.onFlutterOutlineEmitter.fire(n);
            });
        });
        this.watchPubspec();
    }
    getOutlineFor(file) {
        return this.outlines[fs_1.fsPath(file)];
    }
    // TODO: Change this to withVersion when server sends versions.
    waitForOutlineWithLength(document, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return promises_1.waitFor(() => {
                const outline = this.outlines[fs_1.fsPath(document.uri)];
                return outline && document.offsetAt(utils_1.lspToPosition(outline.range.end)) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getFlutterOutlineFor(file) {
        return this.flutterOutlines[fs_1.fsPath(file)];
    }
    // TODO: Change this to withVersion when server sends versions.
    waitForFlutterOutlineWithLength(document, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return promises_1.waitFor(() => {
                const outline = this.flutterOutlines[fs_1.fsPath(document.uri)];
                return outline && document.offsetAt(utils_1.lspToPosition(outline.range.end)) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    supportsPubRunTest(file) {
        // TODO: Both FileTrackers have a copy of this!
        const path = fs_1.fsPath(file);
        if (!util.isPubRunnableTestFile(path))
            return false;
        if (this.pubRunTestSupport[path] === undefined) {
            const projectRoot = project_1.locateBestProjectRoot(path);
            this.pubRunTestSupport[path] = !!(projectRoot && util.projectShouldUsePubForTests(projectRoot, this.wsContext.config));
        }
        return this.pubRunTestSupport[fs_1.fsPath(file)];
    }
    watchPubspec() {
        const clearCachedPubRunTestData = () => Object.keys(this.pubRunTestSupport).forEach((f) => delete this.pubRunTestSupport[f]);
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(clearCachedPubRunTestData, this);
        watcher.onDidCreate(clearCachedPubRunTestData, this);
    }
    dispose() {
        // TODO: This (and others) should probably await, in case they're promises.
        // And also not fail on first error.
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.LspFileTracker = LspFileTracker;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyzerStatusReporter = void 0;
const vscode_1 = __webpack_require__(0);
const enums_1 = __webpack_require__(8);
const utils_1 = __webpack_require__(3);
const extension_utils_1 = __webpack_require__(20);
const config_1 = __webpack_require__(10);
const utils_2 = __webpack_require__(6);
const maxErrorReportCount = 3;
const sendFakeErrorAtStartup = false;
let errorCount = 0;
class AnalyzerStatusReporter {
    constructor(logger, analyzer, workspaceContext, analytics) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.workspaceContext = workspaceContext;
        this.analytics = analytics;
        this.analysisInProgress = false;
        // TODO: Should these go in disposables?
        // If so, do we need to worry about server cleaning them up if it disposes first?
        analyzer.registerForServerStatus((n) => this.handleServerStatus(n));
        analyzer.registerForServerError((e) => this.handleServerError(e));
        analyzer.registerForRequestError((e) => this.handleRequestError(e));
        analyzer.registerForServerTerminated(() => this.handleServerTerminated());
        if (sendFakeErrorAtStartup) {
            setTimeout(() => {
                this.handleServerError({
                    isFatal: false,
                    message: "This is a fake error for testing the error reporting!",
                    stackTrace: new Error().stack || "",
                }, "testError");
            }, 5000);
        }
    }
    handleServerStatus(status) {
        if (!status.analysis)
            return;
        this.analysisInProgress = status.analysis.isAnalyzing;
        if (this.analysisInProgress) {
            // Debounce short analysis times.
            setTimeout(() => {
                // When the timeout fires, we need to check analysisInProgress again in case
                // analysis has already finished.
                if (this.analysisInProgress && !this.analyzingPromise) {
                    vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, title: "Analyzing…" }, () => {
                        if (!this.analyzingPromise) // Re-check, since we don't know how long before this callback is called.
                            this.analyzingPromise = new utils_1.PromiseCompleter();
                        return this.analyzingPromise.promise;
                    });
                }
            }, 500);
        }
        else {
            if (this.analyzingPromise) {
                this.analyzingPromise.resolve();
                this.analyzingPromise = undefined;
            }
        }
    }
    handleServerTerminated() {
        this.analysisInProgress = false;
        if (this.analyzingPromise) {
            this.analyzingPromise.resolve();
            this.analyzingPromise = undefined;
        }
    }
    handleRequestError(error) {
        // Map this request error to a server error to reuse the shared code.
        this.handleServerError({
            isFatal: false,
            message: error.message,
            stackTrace: error.stackTrace || "",
        }, error.method);
    }
    handleServerError(error, method) {
        // Always log to the console.
        this.logger.error(error.message, enums_1.LogCategory.Analyzer);
        if (error.stackTrace)
            this.logger.error(error.stackTrace, enums_1.LogCategory.Analyzer);
        this.analytics.logError(`Analyzer server error${method ? ` (${method})` : ""}`, error.isFatal);
        errorCount++;
        // Offer to report the error.
        if (config_1.config.notifyAnalyzerErrors && errorCount <= maxErrorReportCount) {
            const showLog = "Show log";
            vscode_1.window.showErrorMessage(`Exception from the Dart analysis server: ${error.message}`, showLog).then((res) => {
                if (res === showLog)
                    this.showErrorLog(error, method);
            });
        }
    }
    showErrorLog(error, method) {
        const sdkVersion = this.workspaceContext.sdks.dartVersion;
        const flutterSdkVersion = this.workspaceContext.sdks.flutterVersion;
        const analyzerArgs = this.analyzer.getAnalyzerLaunchArgs();
        const data = `
${method ? "### Request\n\nServer was responding to request: `" + method + "`\n" : ""}
### Versions

- ${vscode_1.env.appName} v${vscode_1.version}
- Dart Code v${extension_utils_1.extensionVersion}
- ${flutterSdkVersion ? `Flutter SDK v${flutterSdkVersion}` : `Dart SDK v${sdkVersion}`}

### Analyzer Info

The analyzer was launched using the arguments:

${analyzerArgs.map((a) => `- ${a}`).join("\n")}

### Exception${error.isFatal ? " (fatal)" : ""}

${error.message}

${error.stackTrace.trim()}
`;
        utils_2.openLogContents("md", data);
    }
}
exports.AnalyzerStatusReporter = AnalyzerStatusReporter;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FileChangeHandler = void 0;
const vs = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const util = __webpack_require__(6);
class FileChangeHandler {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.filesWarnedAbout = new Set();
        this.disposables.push(vs.workspace.onDidOpenTextDocument((td) => this.onDidOpenTextDocument(td)), vs.workspace.onDidChangeTextDocument((e) => this.onDidChangeTextDocument(e)), vs.workspace.onDidCloseTextDocument((td) => this.onDidCloseTextDocument(td)));
        // Handle already-open files.
        vs.workspace.textDocuments.forEach((td) => this.onDidOpenTextDocument(td));
    }
    onDidOpenTextDocument(document) {
        if (!util.isAnalyzable(document))
            return;
        const files = {};
        files[fs_1.fsPath(document.uri)] = {
            content: document.getText(),
            type: "add",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    onDidChangeTextDocument(e) {
        if (!util.isAnalyzable(e.document))
            return;
        if (e.contentChanges.length === 0) // This event fires for metadata changes (dirty?) so don't need to notify AS then.
            return;
        const files = {};
        files[fs_1.fsPath(e.document.uri)] = {
            edits: e.contentChanges.map((c) => this.convertChange(e.document, c)),
            type: "change",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    onDidCloseTextDocument(document) {
        if (!util.isAnalyzable(document))
            return;
        const files = {};
        files[fs_1.fsPath(document.uri)] = {
            type: "remove",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    convertChange(document, change) {
        return {
            id: "",
            length: change.rangeLength,
            offset: change.rangeOffset,
            replacement: change.text,
        };
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.FileChangeHandler = FileChangeHandler;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileChangeWarnings = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
const util = __webpack_require__(6);
class FileChangeWarnings {
    constructor() {
        this.disposables = [];
        this.filesWarnedAbout = new Set();
        this.disposables.push(vs.workspace.onDidChangeTextDocument((e) => this.onDidChangeTextDocument(e)));
    }
    onDidChangeTextDocument(e) {
        if (!util.isAnalyzable(e.document))
            return;
        if (e.contentChanges.length === 0) // This event fires for metadata changes (dirty?) so don't need to notify AS then.
            return;
        const filePath = fs_1.fsPath(e.document.uri);
        if (vs.workspace.workspaceFolders
            && vs.workspace.workspaceFolders.length // Only prompt if we actually have workspace folders open
            && !util.isWithinWorkspace(filePath)
            && !this.filesWarnedAbout.has(filePath)) {
            const isInPubCache = filePath.indexOf(`${path.sep}hosted${path.sep}pub.dartlang.org${path.sep}`) !== -1;
            const shouldWarn = isInPubCache
                ? config_1.config.warnWhenEditingFilesInPubCache
                : config_1.config.warnWhenEditingFilesOutsideWorkspace;
            const promptText = isInPubCache
                ? "You are modifying a file in the Pub cache!"
                : "You are modifying a file outside of your open folders";
            const dontShowAgainSetter = isInPubCache
                ? () => config_1.config.setWarnWhenEditingFilesInPubCache(false)
                : () => config_1.config.setWarnWhenEditingFilesOutsideWorkspace(false);
            const dontShowAgainAction = "Don't Warn Me";
            if (shouldWarn) {
                vs.window.showWarningMessage(promptText, constants_1.moreInfoAction, dontShowAgainAction)
                    .then((action) => __awaiter(this, void 0, void 0, function* () {
                    if (action === constants_1.moreInfoAction) {
                        yield utils_1.envUtils.openInBrowser(constants_1.modifyingFilesOutsideWorkspaceInfoUrl);
                    }
                    else if (action === dontShowAgainAction)
                        dontShowAgainSetter();
                }));
                this.filesWarnedAbout.add(filePath);
            }
        }
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.FileChangeWarnings = FileChangeWarnings;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Analytics = void 0;
const https = __webpack_require__(41);
const querystring = __webpack_require__(200);
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const extension_utils_1 = __webpack_require__(20);
const config_1 = __webpack_require__(10);
// Set to true for analytics to be sent to the debug endpoint (non-logging) for validation.
// This is only required for debugging analytics and needn't be sent for standard Dart Code development (dev hits are already filtered with isDevelopment).
const debug = false;
/// Analytics require that we send a value for uid or cid, but when running in the VS Code
// dev host we don't have either.
const sendAnalyticsFromExtensionDevHost = false;
// Machine ID is not set for extension dev host unless the boolean above is set to true (which
// is usually done for testing purposes).
const machineId = vscode_1.env.machineId !== "someValue.machineId"
    ? vscode_1.env.machineId
    : (sendAnalyticsFromExtensionDevHost ? "35009a79-1a05-49d7-dede-dededededede" : undefined);
var Category;
(function (Category) {
    Category[Category["Extension"] = 0] = "Extension";
    Category[Category["Analyzer"] = 1] = "Analyzer";
    Category[Category["Debugger"] = 2] = "Debugger";
})(Category || (Category = {}));
var EventAction;
(function (EventAction) {
    EventAction[EventAction["Activated"] = 0] = "Activated";
    EventAction[EventAction["SdkDetectionFailure"] = 1] = "SdkDetectionFailure";
    EventAction[EventAction["Deactivated"] = 2] = "Deactivated";
    EventAction[EventAction["Restart"] = 3] = "Restart";
    EventAction[EventAction["HotReload"] = 4] = "HotReload";
    EventAction[EventAction["OpenObservatory"] = 5] = "OpenObservatory";
    EventAction[EventAction["OpenTimeline"] = 6] = "OpenTimeline";
    EventAction[EventAction["OpenDevTools"] = 7] = "OpenDevTools";
})(EventAction || (EventAction = {}));
var TimingVariable;
(function (TimingVariable) {
    TimingVariable[TimingVariable["Startup"] = 0] = "Startup";
    TimingVariable[TimingVariable["FirstAnalysis"] = 1] = "FirstAnalysis";
    TimingVariable[TimingVariable["SessionDuration"] = 2] = "SessionDuration";
})(TimingVariable || (TimingVariable = {}));
class Analytics {
    constructor(logger, workspaceContext) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.dummyDartFile = vscode_1.Uri.parse("untitled:foo.dart");
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        this.dartConfig = vscode_1.workspace.getConfiguration("", this.dummyDartFile).get("[dart]");
        this.formatter = this.getFormatterSetting();
    }
    getFormatterSetting() {
        try {
            // If there are multiple formatters for Dart, the user can select one, so check
            // that first so we don't record their formatter being enabled as ours.
            const otherDefaultFormatter = this.getAppliedConfig("editor", "defaultFormatter", false);
            if (otherDefaultFormatter && otherDefaultFormatter !== constants_1.dartCodeExtensionIdentifier)
                return otherDefaultFormatter;
            // If the user has explicitly disabled ours (without having another selected
            // then record that).
            if (!config_1.config.enableSdkFormatter)
                return "Disabled";
            // Otherwise record as enabled (and whether on-save).
            return this.getAppliedConfig("editor", "formatOnSave")
                ? "Enabled on Save"
                : "Enabled";
        }
        catch (_a) {
            return "Unknown";
        }
    }
    getAppliedConfig(section, key, isResourceScoped = true) {
        const dartValue = this.dartConfig ? this.dartConfig[`${section}.${key}`] : undefined;
        return dartValue !== undefined && dartValue !== null
            ? dartValue
            : vscode_1.workspace.getConfiguration(section, isResourceScoped ? this.dummyDartFile : undefined).get(key);
    }
    logExtensionStartup(timeInMS) {
        this.event(Category.Extension, EventAction.Activated).catch((e) => this.logger.info(e));
        this.time(Category.Extension, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(e));
    }
    logExtensionRestart(timeInMS) {
        this.event(Category.Extension, EventAction.Restart).catch((e) => this.logger.info(e));
        this.time(Category.Extension, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(e));
    }
    logAnalyzerRestart() {
        this.event(Category.Analyzer, EventAction.Restart).catch((e) => this.logger.info(e));
    }
    logExtensionShutdown() { return this.event(Category.Extension, EventAction.Deactivated); }
    logSdkDetectionFailure() { this.event(Category.Extension, EventAction.SdkDetectionFailure).catch((e) => this.logger.info(e)); }
    logError(description, fatal) { this.error(description, fatal).catch((e) => this.logger.info(e)); }
    logAnalyzerStartupTime(timeInMS) { this.time(Category.Analyzer, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(e)); }
    logDebugSessionDuration(debuggerType, timeInMS) { this.time(Category.Debugger, TimingVariable.SessionDuration, timeInMS, debuggerType).catch((e) => this.logger.info(e)); }
    logAnalyzerFirstAnalysisTime(timeInMS) { this.time(Category.Analyzer, TimingVariable.FirstAnalysis, timeInMS).catch((e) => this.logger.info(e)); }
    logDebuggerStart(resourceUri, debuggerType, runType) {
        const customData = {
            cd15: debuggerType,
            cd16: runType,
        };
        this.event(Category.Debugger, EventAction.Activated, resourceUri, customData).catch((e) => this.logger.info(e));
    }
    logDebuggerRestart() { this.event(Category.Debugger, EventAction.Restart).catch((e) => this.logger.info(e)); }
    logDebuggerHotReload() { this.event(Category.Debugger, EventAction.HotReload).catch((e) => this.logger.info(e)); }
    logDebuggerOpenObservatory() { this.event(Category.Debugger, EventAction.OpenObservatory).catch((e) => this.logger.info(e)); }
    logDebuggerOpenTimeline() { this.event(Category.Debugger, EventAction.OpenTimeline).catch((e) => this.logger.info(e)); }
    logDebuggerOpenDevTools() { this.event(Category.Debugger, EventAction.OpenDevTools).catch((e) => this.logger.info(e)); }
    event(category, action, resourceUri, customData) {
        const data = {
            ea: EventAction[action],
            ec: Category[category],
            t: "event",
        };
        // Copy custom data over.
        Object.assign(data, customData);
        // Force a session start if this is extension activation.
        if (category === Category.Extension && action === EventAction.Activated)
            data.sc = "start";
        // Force a session end if this is extension deactivation.
        if (category === Category.Extension && action === EventAction.Deactivated)
            data.sc = "end";
        return this.send(data, resourceUri);
    }
    time(category, timingVariable, timeInMS, label) {
        const data = {
            t: "timing",
            utc: Category[category],
            utl: label,
            utt: Math.round(timeInMS),
            utv: TimingVariable[timingVariable],
        };
        this.logger.info(`${data.utc}:${data.utv} timing: ${Math.round(timeInMS)}ms ${label ? `(${label})` : ""}`);
        // if (isDevExtension)
        // 	console.log(`${data.utc}:${data.utv} timing: ${Math.round(timeInMS)}ms ${label ? `(${label})` : ""}`);
        return this.send(data);
    }
    error(description, fatal) {
        const data = {
            exd: description.trim(),
            exf: fatal ? 1 : 0,
            t: "exception",
        };
        return this.send(data);
    }
    send(customData, resourceUri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!machineId || !config_1.config.allowAnalytics || process.env.DART_CODE_IS_TEST_RUN)
                return;
            const data = {
                aip: 1,
                an: "Dart Code",
                av: extension_utils_1.extensionVersion,
                cd1: extension_utils_1.isDevExtension,
                cd10: config_1.config.showTodos ? "On" : "Off",
                cd11: this.workspaceContext.config.useLsp ? "LSP" : "DAS",
                cd12: this.formatter,
                cd13: this.flutterSdkVersion,
                cd14: extension_utils_1.hasFlutterExtension ? "Installed" : "Not Installed",
                cd17: this.workspaceContext.hasAnyFlutterProjects
                    ? (config_1.config.previewFlutterUiGuides ? (config_1.config.previewFlutterUiGuidesCustomTracking ? "On + Custom Tracking" : "On") : "Off")
                    : null,
                cd18: this.workspaceContext.hasAnyFlutterProjects && resourceUri
                    ? config_1.config.for(resourceUri).flutterStructuredErrors ? "On" : "Off"
                    : null,
                cd19: vscode_1.env.remoteName || "None",
                cd2: constants_1.isChromeOS ? `${process.platform} (ChromeOS)` : process.platform,
                cd20: vscode_1.env.appName || "Unknown",
                cd3: this.sdkVersion,
                cd4: this.analysisServerVersion,
                cd5: vscode_1.version,
                cd6: resourceUri ? this.getDebuggerPreference() : null,
                cd7: this.workspaceContext.workspaceTypeDescription,
                cd8: config_1.config.closingLabels ? "On" : "Off",
                cd9: this.workspaceContext.hasAnyFlutterProjects ? (config_1.config.flutterHotReloadOnSave ? "On" : "Off") : null,
                // TODO: Auto-save
                // TODO: Hot-restart-on-save
                cid: machineId,
                tid: "UA-2201586-19",
                ul: vscode_1.env.language,
                v: "1",
            };
            // Copy custom data over.
            Object.assign(data, customData);
            if (debug)
                this.logger.info("Sending analytic: " + JSON.stringify(data));
            const options = {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                },
                hostname: "www.google-analytics.com",
                method: "POST",
                path: debug ? "/debug/collect" : "/collect",
                port: 443,
            };
            yield new Promise((resolve) => {
                try {
                    const req = https.request(options, (resp) => {
                        if (debug)
                            resp.on("data", (c) => {
                                try {
                                    const gaDebugResp = JSON.parse(c.toString());
                                    if (gaDebugResp && gaDebugResp.hitParsingResult && gaDebugResp.hitParsingResult[0].valid === true)
                                        this.logger.info("Sent OK!");
                                    else if (gaDebugResp && gaDebugResp.hitParsingResult && gaDebugResp.hitParsingResult[0].valid === false)
                                        this.logger.warn(c.toString());
                                    else
                                        this.logger.warn(`Unexpected GA debug response: ${c === null || c === void 0 ? void 0 : c.toString()}`);
                                }
                                catch (e) {
                                    this.logger.warn(`Error in GA debug response: ${c === null || c === void 0 ? void 0 : c.toString()}`);
                                }
                            });
                        if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                            this.logger.info(`Failed to send analytics ${resp && resp.statusCode}: ${resp && resp.statusMessage}`);
                        }
                        resolve();
                    });
                    req.write(querystring.stringify(data));
                    req.end();
                }
                catch (e) {
                    this.logger.error(`Failed to send analytics: ${e}`);
                    resolve();
                }
            });
        });
    }
    getDebuggerPreference() {
        if (config_1.config.debugSdkLibraries && config_1.config.debugExternalLibraries)
            return "All code";
        else if (config_1.config.debugSdkLibraries)
            return "My code + SDK";
        else if (config_1.config.debugExternalLibraries)
            return "My code + Libraries";
        else
            return "My code";
    }
}
exports.Analytics = Analytics;


/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DartExtensionApi = void 0;
const vs = __webpack_require__(0);
class DartExtensionApi {
    constructor() {
        this.version = 1;
        this.flutterCreateSampleProject = () => vs.commands.executeCommand("_dart.flutter.createSampleProject");
    }
}
exports.DartExtensionApi = DartExtensionApi;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterDartPadSamplesCodeLensProvider = void 0;
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const outline_das_1 = __webpack_require__(105);
const utils_1 = __webpack_require__(5);
const dartPadSamplePattern = new RegExp("\\{@tool\\s+dartpad");
class FlutterDartPadSamplesCodeLensProvider {
    constructor(logger, analyzer, sdks) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.sdks = sdks;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
        this.disposables.push(vscode_1.commands.registerCommand("_dart.openDartPadSample", (sample) => __awaiter(this, void 0, void 0, function* () {
            // Link down to first code snippet.
            const fragment = `#${sample.libraryName}.${sample.className}.1`;
            const url = `https://api.flutter.dev/flutter/${sample.libraryName}/${sample.className}-class.html${fragment}`;
            yield utils_1.envUtils.openInBrowser(url);
        })));
        this.flutterPackagesFolder = path.join(sdks.flutter, "packages/flutter/lib/src/").toLowerCase();
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure this file is a Flutter package file.
            const filePath = fs_1.fsPath(document.uri);
            if (!filePath.toLowerCase().startsWith(this.flutterPackagesFolder))
                return;
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const libraryName = filePath.substr(this.flutterPackagesFolder.length).replace("\\", "/").split("/")[0];
            const visitor = new outline_das_1.ClassOutlineVisitor(this.logger);
            visitor.visit(outline);
            // Filter classes to those with DartPad samples.
            const samples = visitor.classes.filter((cl) => {
                // HACK: DartDocs are between the main offset and codeOffset.
                const docs = document.getText(utils_1.toRange(document, cl.offset, cl.codeOffset - cl.offset));
                return dartPadSamplePattern.test(docs);
            }).map((cl) => (Object.assign(Object.assign({}, cl), { libraryName })));
            return samples
                .filter((sample) => sample.codeOffset && sample.codeLength)
                .map((sample) => new vscode_1.CodeLens(utils_1.toRange(document, sample.codeOffset, sample.codeLength), {
                arguments: [sample],
                command: "_dart.openDartPadSample",
                title: `Open online interactive samples for ${sample.className}`,
            }));
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.FlutterDartPadSamplesCodeLensProvider = FlutterDartPadSamplesCodeLensProvider;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspFlutterDartPadSamplesCodeLensProvider = void 0;
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const outline_lsp_1 = __webpack_require__(65);
const utils_1 = __webpack_require__(5);
const dartPadSamplePattern = new RegExp("\\{@tool\\s+dartpad");
class LspFlutterDartPadSamplesCodeLensProvider {
    constructor(logger, analyzer, sdks) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.sdks = sdks;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
        this.disposables.push(vscode_1.commands.registerCommand("_dart.openDartPadSample", (sample) => __awaiter(this, void 0, void 0, function* () {
            // Link down to first code snippet.
            const fragment = `#${sample.libraryName}.${sample.className}.1`;
            const url = `https://api.flutter.dev/flutter/${sample.libraryName}/${sample.className}-class.html${fragment}`;
            yield utils_1.envUtils.openInBrowser(url);
        })));
        this.flutterPackagesFolder = path.join(sdks.flutter, "packages/flutter/lib/src/").toLowerCase();
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure this file is a Flutter package file.
            const filePath = fs_1.fsPath(document.uri);
            if (!filePath.toLowerCase().startsWith(this.flutterPackagesFolder))
                return;
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const libraryName = filePath.substr(this.flutterPackagesFolder.length).replace("\\", "/").split("/")[0];
            const visitor = new outline_lsp_1.LspClassOutlineVisitor(this.logger);
            visitor.visit(outline);
            // Filter classes to those with DartPad samples.
            const samples = visitor.classes.filter((cl) => {
                // HACK: DartDocs are between the main offset and codeOffset.
                const docs = document.getText(new vscode_1.Range(utils_1.lspToPosition(cl.range.start), utils_1.lspToPosition(cl.codeRange.start)));
                return dartPadSamplePattern.test(docs);
            }).map((cl) => (Object.assign(Object.assign({}, cl), { libraryName })));
            return samples
                .filter((sample) => sample.codeRange)
                .map((sample) => new vscode_1.CodeLens(utils_1.lspToRange(sample.codeRange), {
                arguments: [sample],
                command: "_dart.openDartPadSample",
                title: `Open online interactive samples for ${sample.className}`,
            }));
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.LspFlutterDartPadSamplesCodeLensProvider = LspFlutterDartPadSamplesCodeLensProvider;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const debugger_1 = __webpack_require__(66);
const utils_1 = __webpack_require__(5);
const utils_2 = __webpack_require__(6);
class MainCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const fileType = utils_2.isTestFile(fs_1.fsPath(document.uri)) ? "test-file" : "file";
            const templates = debugger_1.getTemplatedLaunchConfigs(document, fileType);
            const mainFunction = (_a = outline.children) === null || _a === void 0 ? void 0 : _a.find((o) => o.element.name === "main");
            if (!mainFunction)
                return;
            return [
                new vscode_1.CodeLens(utils_1.toRange(document, mainFunction.offset, mainFunction.length), {
                    arguments: [document.uri],
                    command: "dart.startWithoutDebugging",
                    title: "Run",
                }),
                new vscode_1.CodeLens(utils_1.toRange(document, mainFunction.offset, mainFunction.length), {
                    arguments: [document.uri],
                    command: "dart.startDebugging",
                    title: "Debug",
                }),
            ].concat(templates.map((t) => new vscode_1.CodeLens(utils_1.toRange(document, mainFunction.offset, mainFunction.length), {
                arguments: [document.uri, t],
                command: t.template === `run-${fileType}` ? "dart.startWithoutDebugging" : "dart.startDebugging",
                title: t.name,
            })));
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.MainCodeLensProvider = MainCodeLensProvider;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspMainCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const debugger_1 = __webpack_require__(66);
const utils_1 = __webpack_require__(5);
const utils_2 = __webpack_require__(6);
class LspMainCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const fileType = utils_2.isTestFile(fs_1.fsPath(document.uri)) ? "test-file" : "file";
            const templates = debugger_1.getTemplatedLaunchConfigs(document, fileType);
            const mainFunction = (_a = outline.children) === null || _a === void 0 ? void 0 : _a.find((o) => o.element.name === "main");
            if (!mainFunction)
                return;
            return [
                new vscode_1.CodeLens(utils_1.lspToRange(mainFunction.range), {
                    arguments: [document.uri],
                    command: "dart.startWithoutDebugging",
                    title: "Run",
                }),
                new vscode_1.CodeLens(utils_1.lspToRange(mainFunction.range), {
                    arguments: [document.uri],
                    command: "dart.startDebugging",
                    title: "Debug",
                }),
            ].concat(templates.map((t) => new vscode_1.CodeLens(utils_1.lspToRange(mainFunction.range), {
                arguments: [document.uri, t],
                command: t.template === `run-${fileType}` ? "dart.startWithoutDebugging" : "dart.startDebugging",
                title: t.name,
            })));
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.LspMainCodeLensProvider = LspMainCodeLensProvider;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const outline_das_1 = __webpack_require__(105);
const debugger_1 = __webpack_require__(66);
const utils_2 = __webpack_require__(5);
const utils_3 = __webpack_require__(6);
class TestCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            // We should only show the CodeLens for projects we know can actually handle `pub run` (for ex. the
            // SDK codebase cannot, and will therefore run all tests when you click them).
            if (!this.analyzer.fileTracker.supportsPubRunTest(document.uri))
                return;
            // If we don't consider this a test file, we should also not show links (since we may try to run the
            // app with 'flutter run' instead of 'flutter test' which will fail due to no `-name` argument).
            if (!utils_3.isTestFile(fs_1.fsPath(document.uri)))
                return;
            const templates = debugger_1.getTemplatedLaunchConfigs(document, "test");
            const visitor = new outline_das_1.TestOutlineVisitor(this.logger);
            visitor.visit(outline);
            return utils_1.flatMap(visitor.tests
                .filter((test) => test.offset && test.length)
                .map((test) => [
                new vscode_1.CodeLens(utils_2.toRange(document, test.offset, test.length), {
                    arguments: [test],
                    command: "_dart.startWithoutDebuggingTestFromOutline",
                    title: "Run",
                }),
                new vscode_1.CodeLens(utils_2.toRange(document, test.offset, test.length), {
                    arguments: [test],
                    command: "_dart.startDebuggingTestFromOutline",
                    title: "Debug",
                }),
            ].concat(templates.map((t) => new vscode_1.CodeLens(utils_2.toRange(document, test.offset, test.length), {
                arguments: [test, t],
                command: t.template === "run-test" ? "_dart.startWithoutDebuggingTestFromOutline" : "_dart.startDebuggingTestFromOutline",
                title: t.name,
            })))), (x) => x);
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.TestCodeLensProvider = TestCodeLensProvider;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspTestCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const outline_lsp_1 = __webpack_require__(65);
const debugger_1 = __webpack_require__(66);
const utils_2 = __webpack_require__(5);
const utils_3 = __webpack_require__(6);
class LspTestCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            // We should only show the CodeLens for projects we know can actually handle `pub run` (for ex. the
            // SDK codebase cannot, and will therefore run all tests when you click them).
            if (!this.analyzer.fileTracker.supportsPubRunTest(document.uri))
                return;
            // If we don't consider this a test file, we should also not show links (since we may try to run the
            // app with 'flutter run' instead of 'flutter test' which will fail due to no `-name` argument).
            if (!utils_3.isTestFile(fs_1.fsPath(document.uri)))
                return;
            const templates = debugger_1.getTemplatedLaunchConfigs(document, "test");
            const visitor = new outline_lsp_1.LspTestOutlineVisitor(this.logger, fs_1.fsPath(document.uri));
            visitor.visit(outline);
            return utils_1.flatMap(visitor.tests
                .filter((test) => test.range)
                .map((test) => [
                new vscode_1.CodeLens(utils_2.lspToRange(test.range), {
                    arguments: [test],
                    command: "_dart.startWithoutDebuggingTestFromOutline",
                    title: "Run",
                }),
                new vscode_1.CodeLens(utils_2.lspToRange(test.range), {
                    arguments: [test],
                    command: "_dart.startDebuggingTestFromOutline",
                    title: "Debug",
                }),
            ].concat(templates.map((t) => new vscode_1.CodeLens(utils_2.lspToRange(test.range), {
                arguments: [test, t],
                command: t.template === "run-test" ? "_dart.startWithoutDebuggingTestFromOutline" : "_dart.startDebuggingTestFromOutline",
                title: t.name,
            })))), (x) => x);
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.LspTestCodeLensProvider = LspTestCodeLensProvider;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyzerCommands = void 0;
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(5);
// Must be global, as all classes are created during an extension restart.
let forcedReanalyzeCount = 0;
class AnalyzerCommands {
    constructor(context, logger, analyzer, analytics) {
        this.logger = logger;
        context.subscriptions.push(vs.commands.registerCommand("dart.openAnalyzerDiagnostics", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield analyzer.getDiagnosticServerPort();
            yield utils_1.envUtils.openInBrowser(`http://127.0.0.1:${res.port}/`);
        })));
        context.subscriptions.push(vs.commands.registerCommand("dart.restartAnalysisServer", () => __awaiter(this, void 0, void 0, function* () {
            forcedReanalyzeCount++;
            if (forcedReanalyzeCount === 10)
                this.showServerRestartPrompt().catch((e) => logger.error(e));
            analytics.logAnalyzerRestart();
            vs.commands.executeCommand("_dart.reloadExtension");
        })));
        context.subscriptions.push(vs.commands.registerCommand("dart.forceReanalyze", () => __awaiter(this, void 0, void 0, function* () {
            forcedReanalyzeCount++;
            if (forcedReanalyzeCount === 10)
                this.showServerRestartPrompt().catch((e) => logger.error(e));
            analytics.logAnalyzerRestart();
            yield analyzer.forceReanalyze();
        })));
    }
    showServerRestartPrompt() {
        return __awaiter(this, void 0, void 0, function* () {
            const choice = yield vs.window.showInformationMessage("Needing to reanalyze a lot? Please consider filing a bug with a server instrumentation log", constants_1.issueTrackerAction);
            if (choice === constants_1.issueTrackerAction)
                yield utils_1.envUtils.openInBrowser(constants_1.issueTrackerUri, this.logger);
        });
    }
}
exports.AnalyzerCommands = AnalyzerCommands;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VmServiceExtensions = exports.timeDilationSlow = exports.timeDilationNormal = exports.IS_INSPECTING_WIDGET_CONTEXT = void 0;
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const extension_1 = __webpack_require__(40);
exports.IS_INSPECTING_WIDGET_CONTEXT = "dart-code:flutter.isInspectingWidget";
const keyTimeDilation = "timeDilation";
const keyEnabled = "enabled";
const keyValue = "value";
/// Service extension values must be wrapped in objects when sent to the VM, eg:
///
///     { timeDilation: x.x }
///     { enabled: true }
///
/// This map tracks the name of the key for a given extension.
const toggleExtensionStateKeys = {
    [enums_1.VmServiceExtension.PlatformOverride]: keyValue,
    [enums_1.VmServiceExtension.DebugBanner]: keyEnabled,
    [enums_1.VmServiceExtension.CheckElevations]: keyEnabled,
    [enums_1.VmServiceExtension.DebugPaint]: keyEnabled,
    [enums_1.VmServiceExtension.PaintBaselines]: keyEnabled,
    [enums_1.VmServiceExtension.InspectorSelectMode]: keyEnabled,
    [enums_1.VmServiceExtension.BrightnessOverride]: keyValue,
    [enums_1.VmServiceExtension.RepaintRainbow]: keyEnabled,
    [enums_1.VmServiceExtension.PerformanceOverlay]: keyEnabled,
    [enums_1.VmServiceExtension.SlowAnimations]: keyTimeDilation,
};
exports.timeDilationNormal = 1.0;
exports.timeDilationSlow = 5.0;
/// Default values for each service extension.
const defaultToggleExtensionState = {
    [enums_1.VmServiceExtension.PlatformOverride]: null,
    [enums_1.VmServiceExtension.DebugBanner]: true,
    [enums_1.VmServiceExtension.CheckElevations]: false,
    [enums_1.VmServiceExtension.DebugPaint]: false,
    [enums_1.VmServiceExtension.PaintBaselines]: false,
    [enums_1.VmServiceExtension.InspectorSelectMode]: false,
    [enums_1.VmServiceExtension.BrightnessOverride]: null,
    [enums_1.VmServiceExtension.RepaintRainbow]: false,
    [enums_1.VmServiceExtension.PerformanceOverlay]: false,
    [enums_1.VmServiceExtension.SlowAnimations]: exports.timeDilationNormal,
};
/// Manages state for (mostly Flutter) VM service extensions.
class VmServiceExtensions {
    constructor(logger, sendRequest) {
        this.logger = logger;
        this.registeredServices = {};
        this.loadedServiceExtensions = [];
        this.currentExtensionState = Object.assign({}, defaultToggleExtensionState);
        // To avoid any code in this class accidentally calling sendRequestToFlutter directly, we wrap it here and don't
        // keep a reference to it.
        this.sendValueToVM = (extension) => {
            // Only ever send values for enabled and known extensions.
            if (this.loadedServiceExtensions.indexOf(extension) !== -1 && toggleExtensionStateKeys[extension] !== undefined) {
                // Build the args in the required format using the correct key and value.
                const params = { [toggleExtensionStateKeys[extension]]: this.currentExtensionState[extension] };
                const args = { type: extension, params };
                sendRequest(args);
                this.syncInspectingWidgetContext(extension);
            }
        };
    }
    /// Handles an event from the Debugger, such as extension services being loaded and values updated.
    handleDebugEvent(session, e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e.event === "dart.serviceExtensionAdded") {
                this.handleServiceExtensionLoaded(session, e.body.id);
                try {
                    // If the isWidgetCreationTracked extension loads, send a command to the debug adapter
                    // asking it to query whether it's enabled (it'll send us an event back with the answer).
                    if (e.body.id === "ext.flutter.inspector.isWidgetCreationTracked") {
                        // TODO: Why do we send these events to the editor for it to send one back? Why don't we just
                        // do the second request in the debug adapter directly and only transmit the result?
                        yield e.session.customRequest("checkIsWidgetCreationTracked");
                        // If it's the PlatformOverride, send a request to get the current value.
                    }
                    else if (e.body.id === enums_1.VmServiceExtension.PlatformOverride) {
                        yield e.session.customRequest("checkPlatformOverride");
                    }
                    else if (e.body.id === enums_1.VmServiceExtension.BrightnessOverride) {
                        yield e.session.customRequest("checkBrightnessOverride");
                    }
                    else if (e.body.id === enums_1.VmServiceExtension.InspectorSetPubRootDirectories) {
                        // TODO: We should send all open workspaces (arg0, arg1, arg2) so that it
                        // works for open packages too.
                        const debuggerType = e.session.configuration.debuggerType;
                        if (debuggerType !== enums_1.DebuggerType.Web) {
                            yield e.session.customRequest("serviceExtension", {
                                params: {
                                    arg0: this.formatPathForPubRootDirectories(e.session.configuration.cwd),
                                    arg1: e.session.configuration.cwd,
                                    // TODO: Is this OK???
                                    isolateId: e.body.isolateId,
                                },
                                type: "ext.flutter.inspector.setPubRootDirectories",
                            });
                        }
                    }
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
            else if (e.event === "dart.serviceRegistered") {
                this.handleServiceRegistered(e.body.service, e.body.method);
            }
            else if (e.event === "dart.flutter.firstFrame") {
                // Send all values back to the VM on the first frame so that they persist across restarts.
                for (const extension in enums_1.VmServiceExtension) {
                    if (!isNaN(Number(extension)))
                        continue;
                    this.sendValueToVM(extension);
                }
            }
            else if (e.event === "dart.flutter.updateIsWidgetCreationTracked") {
                vs.commands.executeCommand("setContext", constants_1.TRACK_WIDGET_CREATION_ENABLED, e.body.isWidgetCreationTracked);
            }
            else if (e.event === "dart.flutter.updatePlatformOverride") {
                this.currentExtensionState[enums_1.VmServiceExtension.PlatformOverride] = e.body.platform;
            }
            else if (e.event === "dart.flutter.updateBrightnessOverride") {
                this.currentExtensionState[enums_1.VmServiceExtension.BrightnessOverride] = e.body.brightness;
            }
            else if (e.event === "dart.flutter.serviceExtensionStateChanged") {
                this.handleRemoteValueUpdate(e.body.extension, e.body.value);
            }
        });
    }
    // TODO: Remove this function (and the call to it) once the fix has rolled to Flutter beta.
    // https://github.com/flutter/flutter-intellij/issues/2217
    formatPathForPubRootDirectories(path) {
        return constants_1.isWin
            ? path && `file:///${path.replace(/\\/g, "/")}`
            : path;
    }
    /// Toggles between two values. Always picks the value1 if the current value
    // is not already value1 (eg. if it's neither of those, it'll pick val1).
    toggle(id, val1 = true, val2 = false) {
        this.currentExtensionState[id] = this.currentExtensionState[id] !== val1 ? val1 : val2;
        this.sendValueToVM(id);
    }
    /// Keep the context in sync so that the "Cancel Inspect Widget" command is enabled/disabled.
    syncInspectingWidgetContext(id) {
        vs.commands.executeCommand("setContext", exports.IS_INSPECTING_WIDGET_CONTEXT, this.currentExtensionState[enums_1.VmServiceExtension.InspectorSelectMode]);
    }
    /// Handles updates that come from the VM (eg. were updated by another tool).
    handleRemoteValueUpdate(id, value) {
        // Don't try to process service extension we don't know about.
        if (this.currentExtensionState[id] === undefined) {
            return;
        }
        // HACK: Everything comes through as strings, but we need bools/ints and sometimes strings,
        // so attempt to parse it, but keep the original string in the case of failure.
        if (typeof value === "string") {
            try {
                value = JSON.parse(value);
            }
            catch (_a) {
            }
        }
        this.currentExtensionState[id] = value;
        this.syncInspectingWidgetContext(id);
    }
    /// Resets all local state to defaults - used when terminating the last debug session (or
    // starting the first) to ensure debug toggles don't "persist" across sessions.
    resetToDefaults() {
        this.currentExtensionState = Object.assign({}, defaultToggleExtensionState);
    }
    /// Tracks registered services and updates contexts to enable VS Code commands.
    handleServiceRegistered(service, method) {
        this.registeredServices[service] = method;
        vs.commands.executeCommand("setContext", `${extension_1.SERVICE_CONTEXT_PREFIX}${service}`, true);
    }
    /// Tracks loaded service extensions and updates contexts to enable VS Code commands.
    handleServiceExtensionLoaded(session, id) {
        session.loadedServiceExtensions.push(id);
        this.loadedServiceExtensions.push(id);
        vs.commands.executeCommand("setContext", `${extension_1.SERVICE_EXTENSION_CONTEXT_PREFIX}${id}`, true);
    }
    /// Marks all services and service extensions as not-loaded in the context to disable VS Code Commands.
    markAllServicesUnloaded() {
        for (const id of Object.keys(this.registeredServices)) {
            vs.commands.executeCommand("setContext", `${extension_1.SERVICE_CONTEXT_PREFIX}${id}`, undefined);
        }
        this.registeredServices = {};
        for (const id of this.loadedServiceExtensions) {
            vs.commands.executeCommand("setContext", `${extension_1.SERVICE_EXTENSION_CONTEXT_PREFIX}${id}`, undefined);
        }
        this.loadedServiceExtensions.length = 0;
        vs.commands.executeCommand("setContext", constants_1.TRACK_WIDGET_CREATION_ENABLED, false);
    }
    // TODO: These services should be per-session!
    serviceIsRegistered(service) {
        return !!this.registeredServices[service];
    }
    getServiceMethodName(service) {
        return this.registeredServices[service];
    }
    serviceExtensionIsLoaded(id) {
        return !!this.loadedServiceExtensions.find((loadedID) => loadedID === id);
    }
}
exports.VmServiceExtensions = VmServiceExtensions;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevToolsManager = void 0;
const fs = __webpack_require__(7);
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const vscode_1 = __webpack_require__(0);
const devtools_1 = __webpack_require__(211);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const stdio_service_1 = __webpack_require__(44);
const utils_1 = __webpack_require__(3);
const array_1 = __webpack_require__(19);
const fs_1 = __webpack_require__(1);
const promises_1 = __webpack_require__(31);
const utils_2 = __webpack_require__(5);
const debug_1 = __webpack_require__(106);
const config_1 = __webpack_require__(10);
const processes_1 = __webpack_require__(15);
const embedded_view_1 = __webpack_require__(212);
const devtoolsPackageID = "devtools";
const devtoolsPackageName = "Dart DevTools";
// This starts off undefined, which means we'll read from config.devToolsPort and fall back to undefined (use default).
// Once we get a port we'll update this variable so that if we restart (eg. a silent extension restart due to
// SDK change or similar) we will try to use the same port, so if the user has browser windows open they're
// still valid.
let portToBind;
/// Handles launching DevTools in the browser and managing the underlying service.
class DevToolsManager {
    constructor(logger, workspaceContext, debugCommands, analytics, pubGlobal) {
        var _a;
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.debugCommands = debugCommands;
        this.analytics = analytics;
        this.pubGlobal = pubGlobal;
        this.disposables = [];
        this.devToolsStatusBarItem = vs.window.createStatusBarItem(vs.StatusBarAlignment.Right, 100);
        this.devToolsEmbeddedViews = {};
        this.capabilities = devtools_1.DevToolsCapabilities.empty;
        this.disposables.push(this.devToolsStatusBarItem);
        if ((_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.activateDevToolsEagerly) {
            this.preActivate(true).then(() => { this.logger.info(`Finished background activating DevTools`); }, (e) => {
                this.logger.error("Failed to background activate DevTools");
                this.logger.error(e);
                vs.window.showErrorMessage(`Failed to activate DevTools: ${e}`);
            });
        }
    }
    get devToolsActivation() { return this.devToolsActivationPromise; }
    preActivate(silent) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.devToolsActivationPromise = this.pubGlobal.backgroundActivate(devtoolsPackageName, devtoolsPackageID, silent, (_a = this.workspaceContext.config) === null || _a === void 0 ? void 0 : _a.devtoolsActivateScript);
            yield this.devToolsActivationPromise;
        });
    }
    routeIdForPage(page) {
        if (!page)
            return undefined;
        if (this.capabilities.usesLegacyPageIds && page.legacyPageId)
            return page.legacyPageId;
        return page.pageId;
    }
    /// Spawns DevTools and returns the full URL to open for that session
    ///   eg. http://127.0.0.1:8123/?port=8543
    spawnForSession(session, options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.analytics.logDebuggerOpenDevTools();
            // If we're mid-silent-activation, wait until that's finished.
            yield this.devToolsActivationPromise;
            if (this.service && !this.service.isValidForCurrentSettings) {
                this.service.dispose();
                this.service = undefined;
                this.devtoolsUrl = undefined;
            }
            if (!this.devtoolsUrl) {
                // Don't try to check for install when we run eagerly.
                if (!((_a = this.workspaceContext.config) === null || _a === void 0 ? void 0 : _a.activateDevToolsEagerly)) {
                    const installedVersion = yield this.pubGlobal.promptToInstallIfRequired(devtoolsPackageName, devtoolsPackageID, undefined, "0.8.0", (_b = this.workspaceContext.config) === null || _b === void 0 ? void 0 : _b.devtoolsActivateScript, true);
                    if (!installedVersion) {
                        return undefined;
                    }
                    this.capabilities.version = installedVersion;
                }
                this.devtoolsUrl = vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                    title: "Starting Dart DevTools...",
                }, () => __awaiter(this, void 0, void 0, function* () { return this.startServer(); }));
            }
            // If the launched versin of DevTools doesn't support embedding, remove the flag.
            if (!this.capabilities.supportsEmbedFlag)
                options.embed = false;
            // When we're running embedded and were asked to open without a page, we should prompt for a page (plus give an option
            // to open non-embedded view).
            if (options.embed && !options.page) {
                const choice = yield this.promptForDevToolsPage();
                if (!choice) // User cancelled
                    return;
                else if (choice === "EXTERNAL")
                    options.embed = false;
                else
                    options.page = choice.page;
            }
            try {
                const url = yield this.devtoolsUrl;
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                    title: "Opening Dart DevTools...",
                }, () => __awaiter(this, void 0, void 0, function* () {
                    const canLaunchDevToolsThroughService = utils_2.isRunningLocally
                        && !options.embed
                        && !process.env.DART_CODE_IS_TEST_RUN
                        && config_1.config.devToolsBrowser === "chrome"
                        && (yield promises_1.waitFor(() => this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.LaunchDevTools), 500));
                    yield this.launch(!!canLaunchDevToolsThroughService, session, options);
                }));
                this.devToolsStatusBarItem.text = "Dart DevTools";
                this.devToolsStatusBarItem.tooltip = `Dart DevTools is running at ${url}`;
                this.devToolsStatusBarItem.command = "dart.openDevTools";
                this.devToolsStatusBarItem.show();
                return { url, dispose: () => this.dispose() };
            }
            catch (e) {
                this.devToolsStatusBarItem.hide();
                this.showError(e);
            }
        });
    }
    promptForDevToolsPage() {
        return __awaiter(this, void 0, void 0, function* () {
            const choices = [
                ...constants_1.devToolsPages.map((page) => ({
                    label: `Open ${page.title} Page`,
                    page,
                })),
                { label: `Open DevTools in Web Browser`, isExternal: true },
            ];
            const choice = yield vs.window.showQuickPick(choices, { placeHolder: "Which DevTools page?" });
            if (!choice)
                return undefined;
            else if (choice.isExternal)
                return "EXTERNAL";
            else if (choice.page)
                return { page: choice.page };
            else
                return undefined; // Shouldn't get here...
        });
    }
    showError(e) {
        this.logger.error(e);
        vs.window.showErrorMessage(`${e}`);
    }
    /// When a new Debug session starts, we can reconnect any views that are still open
    // in the disconnected state.
    reconnectDisconnectedEmbeddedViews(session) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.devtoolsUrl)
                return;
            for (const pageId of Object.keys(this.devToolsEmbeddedViews)) {
                const page = constants_1.devToolsPages.find((p) => p.pageId === pageId);
                const panels = this.devToolsEmbeddedViews[pageId];
                if (!panels)
                    continue;
                // If there are disconnected panels for this page, trigger a launch
                // of the page to reuse it.
                const reusablePanel = panels.find((p) => p.session.hasEnded);
                if (reusablePanel) {
                    reusablePanel.session = session;
                    yield this.launch(false, session, { embed: true, page });
                }
            }
        });
    }
    launch(allowLaunchThroughService, session, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this.devtoolsUrl;
            if (!url) {
                this.showError(`DevTools URL not available`);
                return;
            }
            const queryParams = {
                hide: "debugger",
                ide: "VSCode",
                theme: config_1.config.useDevToolsDarkTheme && !options.embed ? "dark" : undefined,
            };
            // Try to launch via service if allowed.
            if (allowLaunchThroughService && (yield this.launchThroughService(session, Object.assign(Object.assign({}, options), { queryParams, page: this.routeIdForPage(options.page) }))))
                return true;
            // Otherwise, fall back to embedded or launching manually.
            if (options.page)
                queryParams.page = this.routeIdForPage(options.page);
            if (options.embed)
                queryParams.embed = "true";
            const fullUrl = yield this.buildDevToolsUrl(queryParams, session, url);
            if (options.embed)
                // TODO: What should really we do it we don't have a page?
                this.launchInEmbeddedWebView(fullUrl, session, (_a = options.page) !== null && _a !== void 0 ? _a : constants_1.devToolsPages[0]);
            else
                yield utils_2.envUtils.openInBrowser(fullUrl.toString(), this.logger);
        });
    }
    buildDevToolsUrl(queryParams, session, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const paramsString = Object.keys(queryParams)
                .filter((key) => queryParams[key] !== undefined)
                .map((key) => { var _a; return `${encodeURIComponent(key)}=${encodeURIComponent((_a = queryParams[key]) !== null && _a !== void 0 ? _a : "")}`; })
                .join("&");
            const vmServiceUri = vs.Uri.parse(session.vmServiceUri);
            const exposedUrl = yield utils_2.envUtils.exposeUrl(vmServiceUri, this.logger);
            return vs.Uri.parse(`${url}?${paramsString}&uri=${encodeURIComponent(exposedUrl)}`);
        });
    }
    launchInEmbeddedWebView(uri, session, page) {
        var _a, _b;
        const pageId = page.pageId;
        if (!this.devToolsEmbeddedViews[pageId]) {
            this.devToolsEmbeddedViews[pageId] = [];
        }
        // Look through any open DevTools frames for this page, to see if any are already our session, or
        // are for a session that has been stopped.
        let frame = (_a = this.devToolsEmbeddedViews[pageId]) === null || _a === void 0 ? void 0 : _a.find((dtev) => dtev.session === session || dtev.session.hasEnded);
        if (!frame) {
            frame = new embedded_view_1.DevToolsEmbeddedView(session, uri, page);
            frame.onDispose.listen(() => delete this.devToolsEmbeddedViews[pageId]);
            (_b = this.devToolsEmbeddedViews[pageId]) === null || _b === void 0 ? void 0 : _b.push(frame);
        }
        frame === null || frame === void 0 ? void 0 : frame.load(session, uri);
    }
    launchThroughService(session, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield session.session.customRequest("service", {
                    params,
                    type: this.debugCommands.vmServices.getServiceMethodName(enums_1.VmService.LaunchDevTools),
                });
                return true;
            }
            catch (e) {
                this.logger.error(`DevTools failed to launch Chrome, will launch default browser locally instead: ${e.message}`);
                vs.window.showWarningMessage(`Dart DevTools was unable to launch Chrome so your default browser was launched instead.`, "Show Full Error").then((res) => {
                    if (res) {
                        const fileName = `bug-${fs_1.getRandomInt(0x1000, 0x10000).toString(16)}.txt`;
                        const tempPath = path.join(os.tmpdir(), fileName);
                        fs.writeFileSync(tempPath, e.message || e);
                        vscode_1.workspace.openTextDocument(tempPath).then((document) => {
                            vscode_1.window.showTextDocument(document);
                        });
                    }
                });
                return false;
            }
        });
    }
    /// Starts the devtools server and returns the URL of the running app.
    startServer(hasReinstalled = false) {
        return new Promise((resolve, reject) => {
            var _a;
            if (this.service) {
                try {
                    this.service.dispose();
                    this.service = undefined;
                    this.devtoolsUrl = undefined;
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
            this.service = new DevToolsService(this.logger, this.workspaceContext, this.capabilities);
            const service = this.service;
            this.disposables.push(service);
            service.registerForServerStarted((n) => {
                // When a new debug session starts, we need to wait for its VM
                // Service, then register it with this server.
                this.disposables.push(this.debugCommands.onDebugSessionVmServiceAvailable((session) => __awaiter(this, void 0, void 0, function* () {
                    if (session.vmServiceUri) {
                        service.vmRegister({ uri: session.vmServiceUri });
                        // Also reconnect any orphaned DevTools views.
                        yield this.reconnectDisconnectedEmbeddedViews(session);
                    }
                })));
                // And send any existing sessions we have.
                for (const session of debug_1.debugSessions) {
                    if (session.vmServiceUri)
                        service.vmRegister({ uri: session.vmServiceUri });
                }
                portToBind = n.port;
                resolve(`http://${n.host}:${n.port}/`);
            });
            (_a = service.process) === null || _a === void 0 ? void 0 : _a.on("close", (code) => __awaiter(this, void 0, void 0, function* () {
                var _b;
                this.devtoolsUrl = undefined;
                this.devToolsStatusBarItem.hide();
                if (code && code !== 0) {
                    // Reset the port to 0 on error in case it was from us trying to reuse the previous port.
                    portToBind = 0;
                    const errorMessage = `${devtoolsPackageName} exited with code ${code}.`;
                    this.logger.error(errorMessage);
                    // If we haven't tried reinstalling and we don't have a custom activate script, prompt
                    // to retry.
                    if (!hasReinstalled && !((_b = this.workspaceContext.config) === null || _b === void 0 ? void 0 : _b.devtoolsActivateScript)) {
                        const resp = yield vs.window.showErrorMessage(`${errorMessage} Would you like to try reactivating DevTools?`, constants_1.reactivateDevToolsAction, constants_1.skipAction);
                        if (resp === constants_1.reactivateDevToolsAction) {
                            try {
                                yield this.preActivate(false);
                                resolve(yield this.startServer(true));
                            }
                            catch (e) {
                                reject(e);
                            }
                            return;
                        }
                    }
                    reject(errorMessage);
                }
            }));
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.DevToolsManager = DevToolsManager;
class DevToolsService extends stdio_service_1.StdIOService {
    constructor(logger, workspaceContext, capabilities) {
        var _a;
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.DevTools), config_1.config.maxLogLineLength);
        this.capabilities = capabilities;
        this.serverStartedSubscriptions = [];
        this.spawnedArgs = this.getDevToolsArgs();
        const { binPath, binArgs } = utils_1.usingCustomScript(path.join(workspaceContext.sdks.dart, constants_1.pubPath), this.spawnedArgs, (_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.devtoolsRunScript);
        // Store the port we'll use for later so we can re-bind to the same port if we restart.
        portToBind = config_1.config.devToolsPort // Always config first
            || portToBind // Then try the last port we bound this session
            || (constants_1.isChromeOS && config_1.config.useKnownChromeOSPorts ? constants_1.CHROME_OS_DEVTOOLS_PORT : undefined);
        if (portToBind) {
            binArgs.push("--port");
            binArgs.push(portToBind.toString());
        }
        this.registerForServerStarted((n) => this.additionalPidsToTerminate.push(n.pid));
        this.createProcess(undefined, binPath, binArgs, { toolEnv: processes_1.getToolEnv() });
    }
    get isValidForCurrentSettings() {
        return this.spawnedArgs && array_1.arraysEqual(this.spawnedArgs, this.getDevToolsArgs());
    }
    getDevToolsArgs() {
        const additionalArgs = this.capabilities.supportsEmbedFlag
            ? ["--allow-embedding"]
            : ["--enable-notifications"];
        const args = ["global", "run", "devtools", "--machine", "--try-ports", "10"].concat(additionalArgs);
        return args;
    }
    shouldHandleMessage(message) {
        return message.startsWith("{") && message.endsWith("}");
    }
    // TODO: Remove this if we fix the DevTools server (and rev min version) to not use method for
    // the server.started event.
    isNotification(msg) { return msg.event || msg.method === "server.started"; }
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.method || evt.event) {
                case "server.started":
                    yield this.notify(this.serverStartedSubscriptions, evt.params);
                    break;
            }
        });
    }
    registerForServerStarted(subscriber) {
        return this.subscribe(this.serverStartedSubscriptions, subscriber);
    }
    vmRegister(request) {
        return this.sendRequest("vm.register", request);
    }
}


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DevToolsCapabilities = void 0;
const utils_1 = __webpack_require__(3);
class DevToolsCapabilities {
    constructor(dartVersion) {
        this.version = dartVersion;
    }
    static get empty() { return new DevToolsCapabilities("0.0.0"); }
    get supportsEmbedFlag() { return utils_1.versionIsAtLeast(this.version, "0.8.0"); }
    get usesLegacyPageIds() { return !utils_1.versionIsAtLeast(this.version, "0.9.6"); }
}
exports.DevToolsCapabilities = DevToolsCapabilities;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DevToolsEmbeddedView = void 0;
const vs = __webpack_require__(0);
const events_1 = __webpack_require__(42);
const utils_1 = __webpack_require__(5);
const pageScript = `
window.addEventListener('message', (event) => {
	const message = event.data;
	const devToolsFrame = document.getElementById('devToolsFrame');
	switch (message.command) {
		case "setUrl":
			const theme = document.body.classList.contains('vscode-light') ? 'light': 'dark';
			const background = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-background');
			const foreground = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-foreground');
			const url = \`\${message.url}&theme=\${theme}&backgroundColor=\${encodeURIComponent(background)}&foregroundColor=\${encodeURIComponent(foreground)}\`;
			if (devToolsFrame.src !== url)
				devToolsFrame.src = url;
			break;
	}
});
`;
const scriptNonce = Buffer.from(pageScript).toString("base64");
const frameCss = "position: absolute; top: 0; left: 0; width: 100%; height: 100%";
const cssNonce = Buffer.from(frameCss).toString("base64");
class DevToolsEmbeddedView {
    constructor(session, devToolsUri, page) {
        this.session = session;
        this.devToolsUri = devToolsUri;
        this.page = page;
        this.onDisposeEmitter = new events_1.EventEmitter();
        this.onDispose = this.onDisposeEmitter.event;
        const column = utils_1.firstNonEditorColumn() || vs.ViewColumn.Beside;
        this.panel = vs.window.createWebviewPanel("dartDevTools", page.title, column, {
            enableScripts: true,
            localResourceRoots: [],
            retainContextWhenHidden: true,
        });
        this.panel.onDidDispose(() => this.dispose(true));
        this.panel.webview.html = `
			<html>
			<head>
			<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'nonce-${scriptNonce}' 'nonce-${cssNonce}' http://${devToolsUri.authority};">
			<script nonce="${scriptNonce}">${pageScript}</script>
			<style nonce="${cssNonce}">#devToolsFrame { ${frameCss} }</style>
			</head>
			<body><iframe id="devToolsFrame" src="about:blank" frameborder="0"></iframe></body>
			</html>
			`;
    }
    load(session, uri) {
        this.session = session;
        this.panel.webview.postMessage({ command: "setUrl", url: uri.toString() });
        this.panel.reveal();
    }
    dispose(panelDisposed = false) {
        if (!panelDisposed)
            this.panel.dispose();
        this.onDisposeEmitter.fire();
    }
}
exports.DevToolsEmbeddedView = DevToolsEmbeddedView;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ProgressMessage = exports.DartDebugSessionInformation = void 0;
class DartDebugSessionInformation {
    constructor(session, debuggerType) {
        this.session = session;
        this.debuggerType = debuggerType;
        this.sessionStart = new Date();
        this.hasEnded = false;
        this.progress = {};
        this.loadedServiceExtensions = [];
    }
}
exports.DartDebugSessionInformation = DartDebugSessionInformation;
class ProgressMessage {
    constructor(reporter, completer) {
        this.reporter = reporter;
        this.completer = completer;
    }
    report(message) {
        this.reporter.report({ message });
    }
    complete() {
        this.completer.resolve();
    }
}
exports.ProgressMessage = ProgressMessage;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditCommands = void 0;
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(5);
const terminals_1 = __webpack_require__(127);
class EditCommands {
    constructor() {
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("_dart.jumpToLineColInUri", this.jumpToLineColInUri, this), vs.commands.registerCommand("_dart.showCode", utils_1.showCode, this), vs.commands.registerCommand("dart.writeRecommendedSettings", this.writeRecommendedSettings, this), vs.commands.registerCommand("dart.printSelectionToTerminal", this.printSelectionToTerminal, this));
    }
    jumpToLineColInUri(uri, lineNumber, columnNumber, inOtherEditorColumn) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || uri.scheme !== "file")
                return;
            // When navigating while using the inspector, we don't expect this file to replace
            // the inspector tab, so we always target a column that's showing an editor.
            const column = inOtherEditorColumn
                ? utils_1.firstEditorColumn() || vs.ViewColumn.Beside
                : vs.ViewColumn.Active;
            const doc = yield vs.workspace.openTextDocument(uri);
            const editor = yield vs.window.showTextDocument(doc, column, inOtherEditorColumn);
            if (lineNumber) {
                const line = doc.lineAt(lineNumber > 0 ? lineNumber - 1 : 0);
                if (!columnNumber || columnNumber > line.range.end.character)
                    columnNumber = line.firstNonWhitespaceCharacterIndex;
                const char = line.range.start.translate({ characterDelta: columnNumber });
                utils_1.showCode(editor, line.range, line.range, new vs.Range(char, char));
            }
        });
    }
    writeRecommendedSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            const topLevelConfig = vs.workspace.getConfiguration("", null);
            const dartLanguageConfig = topLevelConfig.inspect("[dart]");
            const existingConfig = dartLanguageConfig ? dartLanguageConfig.globalValue : undefined;
            const newValues = Object.assign({}, constants_1.dartRecommendedConfig, existingConfig);
            yield topLevelConfig.update("[dart]", newValues, vs.ConfigurationTarget.Global);
            const action = yield vs.window.showInformationMessage("Recommended settings were written to the [dart] section of your global settings file", constants_1.openSettingsAction);
            if (action === constants_1.openSettingsAction)
                yield vs.commands.executeCommand("workbench.action.openSettingsJson");
        });
    }
    printSelectionToTerminal() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vs.window.activeTextEditor;
            const selection = editor === null || editor === void 0 ? void 0 : editor.selection;
            const text = (_a = editor === null || editor === void 0 ? void 0 : editor.document) === null || _a === void 0 ? void 0 : _a.getText(selection);
            if (text) {
                terminals_1.writeToPseudoTerminal([text]);
            }
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
}
exports.EditCommands = EditCommands;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspEditCommands = void 0;
const vs = __webpack_require__(0);
const vscode_languageclient_1 = __webpack_require__(101);
class LspEditCommands {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("dart.sortMembers", () => this.runCodeAction("source.sortMembers")));
        // TODO: Enable this when https://github.com/dart-lang/sdk/issues/33521
        // is resolved.
        // this.commands.push(
        // 	vs.commands.registerCommand("dart.completeStatement", this.completeStatement, this),
        // );
    }
    runCodeAction(action) {
        return __awaiter(this, void 0, void 0, function* () {
            return vs.commands.executeCommand("editor.action.codeAction", { kind: action, apply: "ifSingle" });
        });
    }
    completeStatement() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vs.window.activeTextEditor;
            if (!editor || !editor.selection)
                return;
            const edit = yield this.analyzer.completeStatement({
                position: this.analyzer.client.code2ProtocolConverter.asPosition(editor.selection.start),
                textDocument: this.analyzer.client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(editor.document),
            });
            if (edit) {
                if (yield this.validDocumentVersionsStillMatch(edit)) {
                    const codeEdit = this.analyzer.client.protocol2CodeConverter.asWorkspaceEdit(edit);
                    if (!(yield vs.workspace.applyEdit(codeEdit))) {
                        vs.window.showErrorMessage("VS Code failed to apply edits");
                    }
                }
                else {
                    vs.window.showErrorMessage("Documents have been modified so edits could not be applied");
                }
            }
        });
    }
    validDocumentVersionsStillMatch(edit) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the edit didn't have any documentChanges (it has changes) we have
            // to assume it's all up-to-date.
            if (!edit.documentChanges)
                return true;
            const openTextDocuments = new Map();
            vs.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
            for (const change of edit.documentChanges) {
                if (vscode_languageclient_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    if (vscode_languageclient_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                        const textDocument = openTextDocuments.get(change.textDocument.uri);
                        if (textDocument && textDocument.version !== change.textDocument.version) {
                            return false;
                        }
                    }
                }
            }
            return true;
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
}
exports.LspEditCommands = LspEditCommands;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoToSuperCommand = void 0;
const vs = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(5);
const editors = __webpack_require__(58);
const outline_1 = __webpack_require__(129);
class GoToSuperCommand {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.goToSuper", this.goToSuper, this));
    }
    goToSuper() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const document = editor.document;
            const position = editor.selection.start;
            const outlineNode = outline_1.findNearestOutlineNode(this.analyzer.fileTracker, document, position);
            const offset = outlineNode && outlineNode.element && outlineNode.element.location
                ? outlineNode.element.location.offset
                : document.offsetAt(position);
            const hierarchy = yield this.analyzer.client.searchGetTypeHierarchy({
                file: fs_1.fsPath(document.uri),
                offset,
                superOnly: true,
            });
            if (!hierarchy || !hierarchy.hierarchyItems || !hierarchy.hierarchyItems.length || hierarchy.hierarchyItems.length === 1)
                return;
            // The first item is the current node, so skip that one and walk up till we find a matching member.
            const isClass = !hierarchy.hierarchyItems[0].memberElement;
            const item = hierarchy.hierarchyItems.slice(1).find((h) => isClass ? !!h.classElement : !!h.memberElement);
            const element = isClass ? item && item.classElement : item && item.memberElement;
            if (!element || !element.location)
                return;
            const elementDocument = yield vs.workspace.openTextDocument(element.location.file);
            const elementEditor = yield vs.window.showTextDocument(elementDocument);
            const range = utils_1.toRangeOnLine(element.location);
            utils_1.showCode(elementEditor, range, range, range);
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.GoToSuperCommand = GoToSuperCommand;


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenInOtherEditorCommands = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const fs_1 = __webpack_require__(1);
const processes_1 = __webpack_require__(15);
class OpenInOtherEditorCommands {
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("flutter.openInAndroidStudio", this.openInAndroidStudio, this), vs.commands.registerCommand("flutter.openInXcode", this.openInXcode, this));
    }
    openInAndroidStudio(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = fs_1.fsPath(resource);
            let androidStudioDir = yield this.getAndroidStudioDir(folder);
            if (!androidStudioDir) {
                vs.window.showErrorMessage("Unable to find Android Studio");
                return;
            }
            if (constants_1.isMac && androidStudioDir.endsWith("/Contents")) {
                androidStudioDir = androidStudioDir.substr(0, androidStudioDir.length - "/Contents".length);
                processes_1.safeToolSpawn(folder, "open", ["-a", androidStudioDir, folder]);
                return;
            }
            else {
                for (const androidStudioPath of constants_1.androidStudioPaths) {
                    const fullPath = path.join(androidStudioDir, androidStudioPath);
                    if (fs.existsSync(fullPath)) {
                        processes_1.safeToolSpawn(folder, fullPath, [folder]);
                        return;
                    }
                }
            }
            vs.window.showErrorMessage("Unable to locate Android Studio executable");
        });
    }
    openInXcode(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = fs_1.fsPath(resource);
            const files = fs
                .readdirSync(folder, { withFileTypes: true })
                .filter((item) => item.isDirectory())
                .filter((item) => item.name.endsWith(".xcworkspace") || item.name.endsWith(".xcodeproj"))
                .sort((f1, f2) => f1.name.endsWith(".xcworkspace") ? -1 : 1);
            if (!files || !files.length) {
                vs.window.showErrorMessage(`Unable to find an Xcode project in your 'ios' folder`);
                return;
            }
            const file = path.join(folder, files[0].name);
            processes_1.safeToolSpawn(folder, "open", [file]);
        });
    }
    getAndroidStudioDir(folder) {
        // TODO: Move this to call shared runProcess().
        return new Promise((resolve, reject) => {
            if (!this.sdks.flutter) {
                reject("Cannot find Android Studio without a Flutter SDK");
                return;
            }
            const binPath = path.join(this.sdks.flutter, constants_1.flutterPath);
            const proc = processes_1.safeToolSpawn(folder, binPath, ["config", "--machine"]);
            logging_1.logProcess(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const output = [];
            proc.stdout.on("data", (data) => {
                output.push(data.toString());
            });
            proc.on("exit", () => {
                try {
                    if (output.length) {
                        const json = JSON.parse(output.join(""));
                        resolve(json["android-studio-dir"]);
                        return;
                    }
                }
                catch (e) {
                    this.logger.error(e);
                }
                reject();
            });
        });
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
exports.OpenInOtherEditorCommands = OpenInOtherEditorCommands;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RefactorCommands = void 0;
const fs = __webpack_require__(7);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(3);
const array_1 = __webpack_require__(19);
const fs_1 = __webpack_require__(1);
const promises_1 = __webpack_require__(31);
const config_1 = __webpack_require__(10);
const edit_das_1 = __webpack_require__(107);
const refactorOptions = {
    EXTRACT_LOCAL_VARIABLE: getExtractLocalVariableArgs,
    EXTRACT_METHOD: getExtractMethodArgs,
    EXTRACT_WIDGET: getExtractWidgetArgs,
};
class RefactorCommands {
    constructor(logger, context, analyzer) {
        this.logger = logger;
        this.context = context;
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.isProcessingMoveEvent = false;
        /// Server only supports one refactoring at a time, so we need to ensure we
        /// wait for any previous one to finish before sending this.
        this.inProgressRefactor = promises_1.resolvedPromise;
        this.subscriptions.push(vs.commands.registerCommand("_dart.performRefactor", this.performRefactor, this));
        if (analyzer.capabilities.supportsMoveFile && config_1.config.updateImportsOnRename)
            this.subscriptions.push(vs.workspace.onWillRenameFiles((e) => this.onWillRenameFiles(e)));
    }
    performRefactor(document, range, refactorKind) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure the document is still valid.
            if (!document || document.isClosed)
                return;
            const originalDocumentVersion = document.version;
            // Validate that there are no problems if we execute this refactor.
            const validationResult = yield this.getRefactor(document, refactorKind, range, true);
            if (this.shouldAbortRefactor(validationResult))
                return;
            // Request the options from the user if required.
            let options;
            if (refactorOptions[refactorKind]) {
                options = yield refactorOptions[refactorKind](validationResult.feedback);
                if (!options)
                    return;
            }
            // Send the request for the refactor edits and prompt to apply if required.
            const editResult = yield this.getRefactor(document, refactorKind, range, false, options);
            const applyEdits = yield this.shouldApplyEdits(editResult, document, originalDocumentVersion);
            if (applyEdits)
                yield vs.commands.executeCommand("_dart.applySourceChange", document, editResult.change);
        });
    }
    getRefactor(document, refactorKind, range, validateOnly, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let remainingTries = 3;
            while (true) {
                try {
                    remainingTries--;
                    // await is important for the catch!
                    return yield this.analyzer.editGetRefactoring({
                        file: fs_1.fsPath(document.uri),
                        kind: refactorKind,
                        length: document.offsetAt(range.end) - document.offsetAt(range.start),
                        offset: document.offsetAt(range.start),
                        options,
                        validateOnly,
                    });
                }
                catch (e) {
                    this.logger.error(e);
                    if (remainingTries <= 0 || e.code !== "REFACTORING_REQUEST_CANCELLED")
                        throw e;
                    else
                        this.logger.info(`getRefactor failed, will try ${remainingTries} more times...`);
                }
            }
        });
    }
    shouldAbortRefactor(validationResult) {
        const validationProblems = validationResult.initialProblems
            .concat(validationResult.optionsProblems)
            .concat(validationResult.finalProblems)
            .filter((e) => e.severity === "FATAL");
        if (validationProblems.length) {
            vs.window.showErrorMessage(validationProblems[0].message);
            return true;
        }
        return false;
    }
    shouldApplyEdits(editResult, document, originalDocumentVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const allProblems = editResult.initialProblems
                .concat(editResult.optionsProblems)
                .concat(editResult.finalProblems);
            const editFatals = allProblems.filter((e) => e.severity === "FATAL");
            const editWarnings = allProblems.filter((e) => e.severity === "ERROR" || e.severity === "WARNING");
            const hasErrors = !!allProblems.find((e) => e.severity === "ERROR");
            // Fatal errors can never be applied, just tell the user and quit.
            if (editFatals.length) {
                vs.window.showErrorMessage(array_1.unique(editFatals.map((e) => e.message)).join("\n\n") + "\n\nYour refactor was not applied.");
                return false;
            }
            // If we somehow got here with no change, we also cannot apply them.
            if (!editResult.change)
                return false;
            let applyEdits = true;
            // If we have warnings/errors, the user can decide whether to go ahead.
            if (editWarnings.length) {
                const show = hasErrors ? vs.window.showErrorMessage : vs.window.showWarningMessage;
                applyEdits = (constants_1.REFACTOR_ANYWAY === (yield show(array_1.unique(editWarnings.map((w) => w.message)).join("\n\n"), constants_1.REFACTOR_ANYWAY)));
            }
            // If we're trying to apply changes but the document is modified, we have to quit.
            if (applyEdits && document && document.version !== originalDocumentVersion) {
                vs.window.showErrorMessage(constants_1.REFACTOR_FAILED_DOC_MODIFIED);
                return false;
            }
            return applyEdits;
        });
    }
    onWillRenameFiles(e) {
        // TODO: VS Code always calls this once-per-file, concurrently for multiple files moved at once
        // which currently results in REFACTOR_CANCELLED for all but the first since the server doesn't
        // support multiple refactors at the same time. Running them sequentially fixes this, however it
        // hits an issue in VS Code (https://github.com/microsoft/vscode/issues/98309) so for now, we will
        // only process a single event at a time.
        if (this.isProcessingMoveEvent) {
            this.logger.info(`Skipping rename event for some files because another is in progress`);
            return;
        }
        this.isProcessingMoveEvent = true;
        try {
            const filesToRename = utils_1.flatMap(e.files, (f) => this.getResourcesToRename({ oldPath: fs_1.fsPath(f.oldUri), newPath: fs_1.fsPath(f.newUri) }));
            const edits = this.getRenameEdits(filesToRename);
            e.waitUntil(edits.finally(() => this.isProcessingMoveEvent = false));
        }
        catch (e) {
            this.isProcessingMoveEvent = false;
        }
    }
    runSequentially(func) {
        return __awaiter(this, void 0, void 0, function* () {
            this.inProgressRefactor = this.inProgressRefactor.then(() => func());
            return this.inProgressRefactor;
        });
    }
    getRenameEdits(filesToRename) {
        return __awaiter(this, void 0, void 0, function* () {
            const changes = new vs.WorkspaceEdit();
            for (const file of filesToRename) {
                const editResult = yield this.runSequentially(() => this.analyzer.editGetRefactoring({
                    file: file.oldPath,
                    kind: "MOVE_FILE",
                    length: 0,
                    offset: 0,
                    options: { newFile: file.newPath },
                    validateOnly: false,
                }));
                if (!editResult.change)
                    continue;
                const applyEdits = yield this.shouldApplyEdits(editResult);
                if (!applyEdits)
                    continue;
                if (edit_das_1.hasOverlappingEdits(editResult.change)) {
                    vs.window.showErrorMessage("Unable to update references; edits contain ambigious positions.");
                    this.logger.error(`Unable to apply MOVE_FILE edits due to ambigious edits:\n\n${JSON.stringify(editResult.change, undefined, 4)}`);
                    return;
                }
                for (const edit of editResult.change.edits) {
                    for (const e of edit.edits) {
                        const uri = vs.Uri.file(edit.file);
                        const document = yield vs.workspace.openTextDocument(uri);
                        changes.replace(vs.Uri.file(edit.file), new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length)), e.replacement);
                    }
                }
            }
            return changes;
        });
    }
    getResourcesToRename(rename) {
        const filesToRename = [];
        if (fs.statSync(rename.oldPath).isFile()) {
            // TODO: if (isAnalyzableAndInWorkspace(rename.oldPath))
            filesToRename.push(rename);
        }
        return filesToRename;
    }
    dispose() {
        for (const command of this.subscriptions)
            command.dispose();
    }
}
exports.RefactorCommands = RefactorCommands;
function getExtractLocalVariableArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const feedback = f;
        const proposedName = feedback && feedback.names && feedback.names.length ? feedback.names[0] : "x";
        return { name: proposedName, extractAll: false };
    });
}
function getExtractMethodArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const feedback = f;
        const suggestedName = feedback && feedback.names && feedback.names.length ? feedback.names[0] : undefined;
        const name = yield vs.window.showInputBox({ prompt: "Enter a name for the method", value: suggestedName });
        if (!name)
            return;
        return {
            createGetter: false,
            extractAll: false,
            name,
            parameters: feedback && feedback.parameters,
            returnType: feedback && feedback.returnType,
        };
    });
}
function getExtractWidgetArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = yield vs.window.showInputBox({ prompt: "Enter a name for the widget" });
        return name ? { name } : undefined;
    });
}


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.promptToRunPubGet = exports.isPubGetProbablyRequired = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
// TODO: Wrap these up into a class.
function isPubGetProbablyRequired(folderUri) {
    const folder = fs_1.fsPath(folderUri);
    const pubspecPath = path.join(folder, "pubspec.yaml");
    const packagesPath = path.join(folder, ".packages");
    if (!folder || !fs.existsSync(pubspecPath))
        return false;
    // If we don't appear to have deps listed in pubspec, then no point prompting.
    const regex = new RegExp("dependencies\\s*:", "i");
    if (!regex.test(fs.readFileSync(pubspecPath).toString()))
        return false;
    // If we don't have .packages, we probably need running.
    if (!fs.existsSync(packagesPath))
        return true;
    const pubspecModified = fs.statSync(pubspecPath).mtime;
    const packagesModified = fs.statSync(packagesPath).mtime;
    return pubspecModified > packagesModified;
}
exports.isPubGetProbablyRequired = isPubGetProbablyRequired;
function promptToRunPubGet(folders) {
    const label = "Get packages";
    vscode_1.window.showInformationMessage("Some packages are missing or out of date, would you like to get them now?", label).then((clickedButton) => {
        if (clickedButton === label)
            getPackages(folders);
    });
}
exports.promptToRunPubGet = promptToRunPubGet;
function getPackages(folders) {
    let task = vscode_1.commands.executeCommand("dart.getPackages", folders[0]);
    for (let i = 1; i < folders.length; i++) {
        task = task.then((code) => {
            if (code === 0) // Continue with next one only if success
                return vscode_1.commands.executeCommand("dart.getPackages", folders[i]);
        });
    }
}


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stagehand = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const utils_1 = __webpack_require__(221);
const processes_1 = __webpack_require__(15);
const packageName = "Stagehand";
const packageID = "stagehand";
class Stagehand {
    constructor(logger, sdks, pubGlobal) {
        this.logger = logger;
        this.sdks = sdks;
        this.pubGlobal = pubGlobal;
    }
    promptToInstallIfRequired() {
        return this.pubGlobal.promptToInstallIfRequired(packageName, packageID, constants_1.stagehandInstallationInstructionsUrl, "3.3.0");
    }
    getTemplates() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.getTemplateJson();
            return JSON.parse(json);
        });
    }
    getTemplateJson() {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.cleanPubOutput(yield this.runCommandWithProgress("Fetching Stagehand templates...", ["global", "run", "stagehand", "--machine"]));
        });
    }
    runCommandWithProgress(title, args) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(args));
    }
    runCommand(args) {
        const dartSdkPath = this.sdks.dart;
        const pubBinPath = path.join(dartSdkPath, constants_1.pubPath);
        return new Promise((resolve, reject) => {
            const proc = processes_1.safeToolSpawn(undefined, pubBinPath, args);
            logging_1.logProcess(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`Stagehand exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.Stagehand = Stagehand;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanPubOutput = void 0;
function cleanPubOutput(pubOutput) {
    // Sometimes pub will output additional text that we need to discard:
    // Precompiling executable...\nPrecompiled stagehand:stagehand.\n[{"name":"console-full","label"
    const precompilingHeaderPattern = RegExp("^Precompil(?:ing|ed).*$", "gm");
    const json = pubOutput.replace(precompilingHeaderPattern, "");
    return json;
}
exports.cleanPubOutput = cleanPubOutput;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFlutterSnippets = void 0;
const fs = __webpack_require__(7);
const https = __webpack_require__(41);
const os = __webpack_require__(18);
const path = __webpack_require__(2);
const constants_1 = __webpack_require__(4);
const fs_1 = __webpack_require__(1);
const processes_1 = __webpack_require__(15);
function getFlutterSnippets(logger, sdks, capabilities) {
    if (capabilities.supportsFlutterCreateListSamples)
        return getFlutterSnippetsFromSdk(logger, sdks);
    return getFlutterSnippetsFromWeb();
}
exports.getFlutterSnippets = getFlutterSnippets;
function getFlutterSnippetsFromSdk(logger, sdks) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!sdks.flutter)
            throw new Error("Flutter SDK not available");
        const binPath = path.join(sdks.flutter, constants_1.flutterPath);
        const fileName = `flutter-samples-${fs_1.getRandomInt(0x1000, 0x10000).toString(16)}.txt`;
        const tempPath = path.join(os.tmpdir(), fileName);
        try {
            const res = yield processes_1.runProcess(logger, undefined, binPath, ["create", "--list-samples", tempPath]);
            if (res.exitCode !== 0)
                throw new Error(`Failed to get Flutter samples from SDK (${res.exitCode})\n\n${res.stderr}\n\n${res.stdout}`);
            const json = fs.readFileSync(tempPath, { encoding: "utf8" });
            return JSON.parse(json);
        }
        finally {
            fs_1.tryDeleteFile(tempPath);
        }
    });
}
function getFlutterSnippetsFromWeb() {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: "api.flutter.dev",
            method: "GET",
            path: "/snippets/index.json",
            port: 443,
        };
        const req = https.request(options, (resp) => {
            if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                reject({ message: `Failed to get Flutter samples ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                const chunks = [];
                resp.on("data", (b) => chunks.push(b.toString()));
                resp.on("end", () => {
                    const json = chunks.join("");
                    resolve(JSON.parse(json));
                });
            }
        });
        req.end();
    });
}


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterSdkManager = exports.DartSdkManager = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const config_1 = __webpack_require__(10);
class SdkManager {
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
    }
    changeSdk() {
        if (this.sdkPaths)
            this.searchForSdks(this.sdkPaths).catch((e) => console.error(e));
        else
            vs.window.showWarningMessage("Set `${configName}` to enable fast SDK switching.");
    }
    searchForSdks(sdkPaths) {
        return __awaiter(this, void 0, void 0, function* () {
            let allPaths = [];
            for (const sdkPath of sdkPaths.filter(fs.existsSync)) {
                allPaths.push(sdkPath);
                // Add immediate children to support folders-of-SDKs.
                allPaths = allPaths.concat(yield fs_1.getChildFolders(this.logger, sdkPath));
            }
            // Add in the current path if it's not there.
            if (this.currentSdk && allPaths.indexOf(this.currentSdk) === -1)
                allPaths.push(this.currentSdk);
            const sdkFolders = allPaths
                // We don't need to check isDirectory, since existsSync() will just return false
                // if we join a filename on the end of another.
                // .filter((f) => fs.statSync(f).isDirectory()) // Only directories.
                .filter((f) => fs.existsSync(path.join(f, this.executablePath))); // Only those that look like SDKs.
            const sdkItems = sdkFolders.map((f) => {
                // Resolve synlinks so we look in correct folder for version file.
                const actualBinary = fs.realpathSync(path.join(f, this.executablePath));
                // Then we need to take the executable name and /bin back off
                const actualFolder = path.dirname(path.dirname(actualBinary));
                const version = fs_1.getSdkVersion(this.logger, { sdkRoot: actualFolder });
                return {
                    description: f === this.currentSdk && this.configuredSdk ? "Current setting" : "",
                    detail: f,
                    folder: f,
                    label: version ? this.getLabel(version) : "Unknown version",
                    version,
                };
            })
                .sort((a, b) => utils_1.versionIsAtLeast(a.version || "0.0.0", b.version || "0.0.0") ? 1 : -1);
            if (sdkItems.length === 0)
                return;
            const items = [{
                    description: !this.configuredSdk ? "Current setting" : "",
                    detail: !this.configuredSdk ? `Found at ${this.currentSdk}` : undefined,
                    folder: undefined,
                    label: "Auto-detect SDK location",
                    version: undefined,
                }].concat(sdkItems);
            vs.window.showQuickPick(items, { placeHolder: "Select an SDK to use" })
                .then((sdk) => { if (sdk)
                this.setSdk(sdk.folder); });
        });
    }
}
class DartSdkManager extends SdkManager {
    get sdkPaths() { return config_1.config.sdkPaths; }
    get currentSdk() { return this.sdks.dart; }
    get configuredSdk() { return config_1.config.sdkPath; }
    get configName() { return "dart.sdkPaths"; }
    get executablePath() { return constants_1.dartVMPath; }
    getLabel(version) {
        return `Dart SDK ${version}`;
    }
    setSdk(folder) { config_1.config.setSdkPath(folder); }
}
exports.DartSdkManager = DartSdkManager;
class FlutterSdkManager extends SdkManager {
    get sdkPaths() { return config_1.config.flutterSdkPaths; }
    get currentSdk() { return this.sdks.flutter; }
    get configuredSdk() { return config_1.config.flutterSdkPath; }
    get configName() { return "dart.flutterSdkPaths"; }
    get executablePath() { return constants_1.flutterPath; }
    getLabel(version) {
        return `Flutter SDK ${version}`;
    }
    setSdk(folder) { config_1.config.setFlutterSdkPath(folder); }
}
exports.FlutterSdkManager = FlutterSdkManager;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspTestCommands = exports.DasTestCommands = exports.isInImplementationFileThatCanHaveTest = exports.isInTestFileThatHasImplementation = exports.cursorIsInTest = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const outline_das_1 = __webpack_require__(105);
const outline_lsp_1 = __webpack_require__(65);
const test_1 = __webpack_require__(57);
const editors_1 = __webpack_require__(58);
const utils_2 = __webpack_require__(6);
const CURSOR_IS_IN_TEST = "dart-code:cursorIsInTest";
const CAN_JUMP_BETWEEN_TEST_IMPLEMENTATION = "dart-code:canGoToTestOrImplementationFile";
// HACK: Used for testing since we can't read contexts?
exports.cursorIsInTest = false;
exports.isInTestFileThatHasImplementation = false;
exports.isInImplementationFileThatCanHaveTest = false;
class TestCommands {
    constructor(logger, wsContext) {
        this.logger = logger;
        this.wsContext = wsContext;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.runTestAtCursor", () => this.runTestAtCursor(false), this), vs.commands.registerCommand("dart.goToTests", (resource) => this.goToTestOrImplementationFile(resource), this), vs.commands.registerCommand("dart.goToTestOrImplementationFile", () => this.goToTestOrImplementationFile(), this), vs.commands.registerCommand("dart.debugTestAtCursor", () => this.runTestAtCursor(true), this), vs.window.onDidChangeTextEditorSelection((e) => this.updateSelectionContexts(e)), vs.window.onDidChangeActiveTextEditor((e) => this.updateEditorContexts(e)));
        // Run for current open editor.
        this.updateEditorContexts(vs.window.activeTextEditor);
        this.disposables.push(vs.commands.registerCommand("_dart.startDebuggingTestFromOutline", (test, launchTemplate) => vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(vs.Uri.file(test.file)), test_1.getLaunchConfig(false, test.file, [test.fullName], test.isGroup, launchTemplate))));
        this.disposables.push(vs.commands.registerCommand("_dart.startWithoutDebuggingTestFromOutline", (test, launchTemplate) => vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(vs.Uri.file(test.file)), test_1.getLaunchConfig(true, test.file, [test.fullName], test.isGroup, launchTemplate))));
    }
    runTestAtCursor(debug) {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vs.window.activeTextEditor;
            const test = editor && editor.selection && this.testForCursor(editor);
            if (test) {
                const command = debug
                    ? "_dart.startDebuggingTestFromOutline"
                    : "_dart.startWithoutDebuggingTestFromOutline";
                vs.commands.executeCommand(command, test);
            }
            else {
                vs.window.showWarningMessage("There is no test at the current location.");
            }
        });
    }
    goToTestOrImplementationFile(resource) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const doc = resource
                ? yield vs.workspace.openTextDocument(resource)
                : (_a = vs.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document;
            if (doc && editors_1.isDartDocument(doc)) {
                const filePath = fs_1.fsPath(doc.uri);
                const isTest = utils_2.isTestFile(filePath);
                const otherFile = isTest
                    ? this.getImplementationFileForTest(filePath)
                    : this.getTestFileForImplementation(filePath);
                if (!otherFile || (isTest && !fs.existsSync(otherFile)))
                    return;
                let selectionOffset;
                let selectionLength;
                // Offer to create test files.
                if (!fs.existsSync(otherFile)) {
                    if (isTest)
                        return;
                    const relativePath = vs.workspace.asRelativePath(otherFile, false);
                    const yesAction = test_1.createTestFileAction(relativePath);
                    const response = yield vs.window.showInformationMessage(`Would you like to create a test file at ${relativePath}?`, yesAction, constants_1.noAction);
                    if (response !== yesAction)
                        return;
                    fs_1.mkDirRecursive(path.dirname(otherFile));
                    const testFileInfo = test_1.defaultTestFileContents(this.wsContext.hasAnyFlutterProjects, utils_1.escapeDartString(utils_1.generateTestNameFromFileName(relativePath)));
                    fs.writeFileSync(otherFile, testFileInfo.contents);
                    selectionOffset = testFileInfo.selectionOffset;
                    selectionLength = testFileInfo.selectionLength;
                }
                const document = yield vs.workspace.openTextDocument(otherFile);
                const editor = yield vs.window.showTextDocument(document);
                if (selectionOffset && selectionLength)
                    editor.selection = new vs.Selection(document.positionAt(selectionOffset), document.positionAt(selectionOffset + selectionLength));
            }
        });
    }
    updateSelectionContexts(e) {
        const isValidTestLocation = !!(e.textEditor && e.selections && e.selections.length === 1 && this.testForCursor(e.textEditor));
        vs.commands.executeCommand("setContext", CURSOR_IS_IN_TEST, isValidTestLocation);
        exports.cursorIsInTest = isValidTestLocation;
    }
    updateEditorContexts(e) {
        exports.isInTestFileThatHasImplementation = false;
        exports.isInImplementationFileThatCanHaveTest = false;
        if (e && e.document && editors_1.isDartDocument(e.document)) {
            const filePath = fs_1.fsPath(e.document.uri);
            if (utils_2.isTestFile(filePath)) {
                // Implementation files must exist.
                const implementationFilePath = this.getImplementationFileForTest(filePath);
                exports.isInTestFileThatHasImplementation = !!implementationFilePath && fs.existsSync(implementationFilePath);
            }
            else {
                exports.isInImplementationFileThatCanHaveTest = !!this.getTestFileForImplementation(filePath);
            }
        }
        vs.commands.executeCommand("setContext", CAN_JUMP_BETWEEN_TEST_IMPLEMENTATION, exports.isInTestFileThatHasImplementation || exports.isInImplementationFileThatCanHaveTest);
    }
    getImplementationFileForTest(filePath) {
        const pathSegments = filePath.split(path.sep);
        // Replace test folder with lib.
        const testFolderIndex = pathSegments.lastIndexOf("test");
        if (testFolderIndex !== -1)
            pathSegments[testFolderIndex] = "lib";
        // Remove _test from the filename.
        pathSegments[pathSegments.length - 1] = pathSegments[pathSegments.length - 1].replace(/_test\.dart/, ".dart");
        return pathSegments.join(path.sep);
    }
    getTestFileForImplementation(filePath) {
        const pathSegments = filePath.split(path.sep);
        // Replace lib folder with test.
        const libFolderIndex = pathSegments.lastIndexOf("lib");
        if (libFolderIndex === -1)
            return undefined;
        pathSegments[libFolderIndex] = "test";
        // Add _test to the filename.
        pathSegments[pathSegments.length - 1] = pathSegments[pathSegments.length - 1].replace(/\.dart/, "_test.dart");
        return pathSegments.join(path.sep);
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
class DasTestCommands extends TestCommands {
    constructor(logger, wsContext, fileTracker) {
        super(logger, wsContext);
        this.fileTracker = fileTracker;
    }
    testForCursor(editor) {
        const document = editor.document;
        const outline = this.fileTracker.getOutlineFor(document.uri);
        if (!outline || !outline.children || !outline.children.length)
            return;
        // We should only allow running for projects we know can actually handle `pub run` (for ex. the
        // SDK codebase cannot, and will therefore run all tests).
        if (!this.fileTracker.supportsPubRunTest(document.uri))
            return;
        const visitor = new outline_das_1.TestOutlineVisitor(this.logger);
        visitor.visit(outline);
        return visitor.tests.reverse().find((t) => {
            let start = document.positionAt(t.offset);
            let end = document.positionAt(t.offset + t.length);
            // Widen the range to start/end of lines.
            start = document.lineAt(start.line).rangeIncludingLineBreak.start;
            end = document.lineAt(end.line).rangeIncludingLineBreak.end;
            return new vs.Range(start, end).contains(editor.selection);
        });
    }
}
exports.DasTestCommands = DasTestCommands;
class LspTestCommands extends TestCommands {
    constructor(logger, wsContext, fileTracker) {
        super(logger, wsContext);
        this.fileTracker = fileTracker;
    }
    testForCursor(editor) {
        const document = editor.document;
        const outline = this.fileTracker.getOutlineFor(document.uri);
        if (!outline || !outline.children || !outline.children.length)
            return;
        // We should only allow running for projects we know can actually handle `pub run` (for ex. the
        // SDK codebase cannot, and will therefore run all tests).
        if (!this.fileTracker.supportsPubRunTest(document.uri))
            return;
        const visitor = new outline_lsp_1.LspTestOutlineVisitor(this.logger, fs_1.fsPath(document.uri));
        visitor.visit(outline);
        return visitor.tests.reverse().find((t) => {
            let start = t.range.start;
            let end = t.range.end;
            // Widen the range to start/end of lines.
            start = document.lineAt(start.line).rangeIncludingLineBreak.start;
            end = document.lineAt(end.line).rangeIncludingLineBreak.end;
            const vsRange = new vs.Range(start.line, start.character, end.line, end.character);
            return vsRange.contains(editor.selection);
        });
    }
}
exports.LspTestCommands = LspTestCommands;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeHierarchyCommand = void 0;
const vs = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(5);
const editors = __webpack_require__(58);
class TypeHierarchyCommand {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.showTypeHierarchy", this.showTypeHierarchy, this));
    }
    showTypeHierarchy() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const document = editor.document;
            const originalSelection = editor.selection;
            const response = yield this.analyzer.searchGetTypeHierarchy({
                file: fs_1.fsPath(document.uri),
                offset: document.offsetAt(editor.selection.active),
            });
            const items = response.hierarchyItems;
            if (!items) {
                vs.window.showInformationMessage("Type hierarchy not available.");
                return;
            }
            const options = {
                onDidSelectItem: (item) => this.openLocation(item, true),
                placeHolder: name(items, 0),
            };
            // TODO: How / where to show implements?
            const tree = [];
            const startItem = items[0];
            tree.push(startItem);
            addParents(items, tree, startItem);
            addChildren(items, tree, startItem);
            const result = yield vs.window.showQuickPick(tree.map((item) => itemToPick(item, items)), options);
            if (result && result.location) {
                yield this.openLocation(result);
            }
            else {
                // Move the use back to where they were.
                const ed = yield vs.window.showTextDocument(document);
                ed.revealRange(editor.selection, vs.TextEditorRevealType.InCenterIfOutsideViewport);
                ed.selection = originalSelection;
            }
        });
    }
    openLocation(result, asPreview = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!result.location) {
                this.logger.warn(`Unable to open item with no location`);
                return;
            }
            const location = result.location;
            const document = yield vs.workspace.openTextDocument(location.file);
            const editor = yield vs.window.showTextDocument(document, {
                preserveFocus: asPreview,
                preview: asPreview,
            });
            const range = utils_1.toRangeOnLine(location);
            utils_1.showCode(editor, range, range, range);
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.TypeHierarchyCommand = TypeHierarchyCommand;
function addParents(items, tree, item) {
    if (item.superclass) {
        const parent = items[item.superclass];
        if (parent.classElement.name !== "Object") {
            tree.unshift(parent);
            addParents(items, tree, parent);
        }
    }
}
function addChildren(items, tree, item) {
    // Handle direct children.
    for (const index of item.subclasses) {
        const child = items[index];
        tree.push(child);
    }
    // Handle grandchildren.
    for (const index of item.subclasses) {
        const child = items[index];
        if (child.subclasses.length > 0)
            addChildren(items, tree, child);
    }
}
function itemToPick(item, items) {
    let desc = "";
    // extends
    if (item.superclass !== undefined && name(items, item.superclass) !== "Object")
        desc += `extends ${name(items, item.superclass)}`;
    // implements
    if (item.interfaces.length > 0) {
        if (desc.length > 0)
            desc += ", ";
        desc += `implements ${item.interfaces.map((i) => name(items, i)).join(", ")}`;
    }
    // with
    if (item.mixins.length > 0) {
        if (desc.length > 0)
            desc += ", ";
        desc += `with ${item.mixins.map((i) => name(items, i)).join(", ")}`;
    }
    const result = {
        description: desc,
        label: item.classElement.name,
        location: item.classElement.location,
    };
    return result;
}
function name(items, index) {
    return items[index].classElement.name;
}


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterColorDecorations = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const color_range_computer_1 = __webpack_require__(227);
const utils_1 = __webpack_require__(6);
class FlutterColorDecorations {
    constructor(logger, imageStoragePath) {
        this.logger = logger;
        this.imageStoragePath = imageStoragePath;
        this.subscriptions = [];
        this.decorationTypes = {};
        this.computer = new color_range_computer_1.ColorRangeComputer();
        this.subscriptions.push(vs.workspace.onDidChangeTextDocument((e) => {
            if (this.activeEditor && e.document === this.activeEditor.document) {
                // Delay this so if we're getting lots of updates we don't flicker.
                if (this.updateTimeout)
                    clearTimeout(this.updateTimeout);
                this.updateTimeout = setTimeout(() => this.update(), 1000);
            }
        }));
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            this.setTrackingFile(e);
            this.update();
        }));
        if (vs.window.activeTextEditor) {
            this.setTrackingFile(vs.window.activeTextEditor);
            this.update();
        }
    }
    update() {
        if (!this.activeEditor)
            return;
        const results = this.computer.compute(this.activeEditor.document);
        // Each color needs to be its own decoration, so here we update our main list
        // with any new ones we hadn't previously created.
        for (const colorHex of Object.keys(results)) {
            const filePath = this.createImageFile(colorHex);
            if (filePath && !this.decorationTypes[colorHex])
                this.decorationTypes[colorHex] = vs.window.createTextEditorDecorationType({
                    gutterIconPath: vs.Uri.file(filePath),
                    gutterIconSize: "50%",
                });
        }
        for (const colorHex of Object.keys(this.decorationTypes)) {
            this.activeEditor.setDecorations(this.decorationTypes[colorHex], results[colorHex] || []);
        }
    }
    setTrackingFile(editor) {
        if (editor && utils_1.isAnalyzable(editor.document)) {
            this.activeEditor = editor;
        }
        else
            this.activeEditor = undefined;
    }
    createImageFile(hex) {
        // Add a version number to the folder in case we need to change these
        // and invalidate the old ones.
        const imageFolder = path.join(this.imageStoragePath, "v1");
        fs_1.mkDirRecursive(imageFolder);
        const file = path.join(imageFolder, `${hex}.svg`);
        if (fs.existsSync(file))
            return file;
        try {
            const hex6 = hex.substr(2);
            const opacity = parseInt(hex.substr(0, 2), 16) / 255;
            const imageContents = svgContents
                .replace("{HEX-6}", hex6)
                .replace("{OPACITY}", opacity.toString());
            fs.writeFileSync(file, imageContents);
            return file;
        }
        catch (e) {
            this.logger.warn(e);
        }
    }
    dispose() {
        this.activeEditor = undefined;
        this.subscriptions.forEach((s) => s.dispose());
    }
}
exports.FlutterColorDecorations = FlutterColorDecorations;
const svgContents = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">
	<rect fill="#{HEX-6}" x="0" y="0" width="16" height="16" fill-opacity="{OPACITY}" />
</svg>
`;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorRangeComputer = void 0;
const colors_1 = __webpack_require__(228);
const utils_1 = __webpack_require__(3);
const utils_2 = __webpack_require__(5);
class ColorRangeComputer {
    constructor() {
        this.materialNameColorPattern = "\\bColors\\.(?<mc>[\\w_\\[\\]\\.]+)";
        this.cupertinoNameColorPattern = "\\bCupertinoColors\\.(?<cc>[\\w_\\[\\]\\.]+)";
        this.colorConstructorPattern = "\\bColor\\(\\s*0x(?<cons>[A-Fa-f0-9]{8}),{0,1}\\s*\\)";
        this.colorConstructorRgbo = "\\bColor\\.fromRGBO\\(\\s*(?<rgboR>[\\w_]+),\\s*(?<rgboG>[\\w_]+),\\s*(?<rgboB>[\\w_]+),\\s*(?<rgboA>[\\w_.]+),{0,1}\\s*\\)";
        this.colorConstructorArgb = "\\bColor\\.fromARGB\\(\\s*(?<argbA>[\\w_]+),\\s*(?<argbR>[\\w_]+),\\s*(?<argbG>[\\w_]+),\\s*(?<argbB>[\\w_]+),{0,1}\\s*\\)";
        this.allColors = [
            this.materialNameColorPattern,
            this.cupertinoNameColorPattern,
            this.colorConstructorPattern,
            this.colorConstructorRgbo,
            this.colorConstructorArgb,
        ];
        this.allColorsPattern = new RegExp(`^.*?(?<range>${this.allColors.join("|")})`, "gm");
    }
    compute(document) {
        const text = document.getText();
        // Build a map of all possible decorations, with those in this file. We need to include all
        // colors so if any were removed, we will clear their decorations.
        const decs = {};
        let result;
        this.allColorsPattern.lastIndex = -1;
        // eslint-disable-next-line no-cond-assign
        while (result = this.allColorsPattern.exec(text)) {
            if (!result.groups)
                continue;
            let colorHex;
            if (result.groups.mc)
                colorHex = this.extractMaterialColor(result.groups.mc);
            else if (result.groups.cc)
                colorHex = this.extractCupertinoColor(result.groups.cc);
            else if (result.groups.cons)
                colorHex = result.groups.cons.toLowerCase();
            else if (result.groups.rgboR && result.groups.rgboG && result.groups.rgboB && result.groups.rgboO)
                colorHex = this.extractRgboColor(result.groups.rgboR, result.groups.rgboG, result.groups.rgboB, result.groups.rgboO);
            else if (result.groups.argbA && result.groups.argbR && result.groups.argbG && result.groups.argbB)
                colorHex = this.extractArgbColor(result.groups.argbA, result.groups.argbR, result.groups.argbG, result.groups.argbB);
            if (colorHex) {
                if (!decs[colorHex])
                    decs[colorHex] = [];
                // We can't get the index of the captures yet (https://github.com/tc39/proposal-regexp-match-indices) but we do know
                // - the length of the whole match
                // - the length of the main capture
                // - that the main capture ends at the same point as the whole match
                // Therefore the index we want, is the (match index + match length - capture length).
                const index = result.index + result[0].length - result.groups.range.length;
                decs[colorHex].push(utils_2.toRange(document, index, result.groups.range.length));
            }
        }
        return decs;
    }
    extractMaterialColor(input) {
        const colorName = input.replace(/\.shade(\d+)/, "[$1]");
        if (!(colorName in colors_1.flutterMaterialColors || `${colorName}.primary` in colors_1.flutterMaterialColors))
            return;
        return (colors_1.flutterMaterialColors[colorName] || colors_1.flutterMaterialColors[`${colorName}.primary`]).toLowerCase();
    }
    extractCupertinoColor(input) {
        const colorName = input.replace(/\.color/, "[$1]");
        if (!(colorName in colors_1.flutterCupertinoColors || `${colorName}.color` in colors_1.flutterCupertinoColors))
            return;
        return (colors_1.flutterCupertinoColors[colorName] || colors_1.flutterCupertinoColors[`${colorName}.color`]).toLowerCase();
    }
    extractRgboColor(inputR, inputG, inputB, inputO) {
        const r = parseInt(inputR);
        const g = parseInt(inputG);
        const b = parseInt(inputB);
        const opacity = parseFloat(inputO);
        if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(opacity))
            return;
        return utils_1.asHexColor({ r, g, b, a: opacity * 255 });
    }
    extractArgbColor(inputA, inputR, inputG, inputB) {
        const a = parseInt(inputA);
        const r = parseInt(inputR);
        const g = parseInt(inputG);
        const b = parseInt(inputB);
        if (isNaN(a) || isNaN(r) || isNaN(g) || isNaN(b))
            return;
        return utils_1.asHexColor({ a, r, g, b });
    }
}
exports.ColorRangeComputer = ColorRangeComputer;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Generated file - do not edit.
Object.defineProperty(exports, "__esModule", { value: true });
exports.flutterCupertinoColors = exports.flutterMaterialColors = void 0;
// tslint:disable: object-literal-sort-keys
exports.flutterMaterialColors = {
    "amber.primary": "ffffc107",
    "amber[50]": "fffff8e1",
    "amber[100]": "ffffecb3",
    "amber[200]": "ffffe082",
    "amber[300]": "ffffd54f",
    "amber[400]": "ffffca28",
    "amber[500]": "ffffc107",
    "amber[600]": "ffffb300",
    "amber[700]": "ffffa000",
    "amber[800]": "ffff8f00",
    "amber[900]": "ffff6f00",
    "amberAccent.primary": "ffffd740",
    "amberAccent[100]": "ffffe57f",
    "amberAccent[200]": "ffffd740",
    "amberAccent[400]": "ffffc400",
    "amberAccent[700]": "ffffab00",
    "black": "ff000000",
    "black12": "1f000000",
    "black26": "42000000",
    "black38": "61000000",
    "black45": "73000000",
    "black54": "8a000000",
    "black87": "dd000000",
    "blue.primary": "ff2196f3",
    "blue[50]": "ffe3f2fd",
    "blue[100]": "ffbbdefb",
    "blue[200]": "ff90caf9",
    "blue[300]": "ff64b5f6",
    "blue[400]": "ff42a5f5",
    "blue[500]": "ff2196f3",
    "blue[600]": "ff1e88e5",
    "blue[700]": "ff1976d2",
    "blue[800]": "ff1565c0",
    "blue[900]": "ff0d47a1",
    "blueAccent.primary": "ff448aff",
    "blueAccent[100]": "ff82b1ff",
    "blueAccent[200]": "ff448aff",
    "blueAccent[400]": "ff2979ff",
    "blueAccent[700]": "ff2962ff",
    "blueGrey.primary": "ff607d8b",
    "blueGrey[50]": "ffeceff1",
    "blueGrey[100]": "ffcfd8dc",
    "blueGrey[200]": "ffb0bec5",
    "blueGrey[300]": "ff90a4ae",
    "blueGrey[400]": "ff78909c",
    "blueGrey[500]": "ff607d8b",
    "blueGrey[600]": "ff546e7a",
    "blueGrey[700]": "ff455a64",
    "blueGrey[800]": "ff37474f",
    "blueGrey[900]": "ff263238",
    "brown.primary": "ff795548",
    "brown[50]": "ffefebe9",
    "brown[100]": "ffd7ccc8",
    "brown[200]": "ffbcaaa4",
    "brown[300]": "ffa1887f",
    "brown[400]": "ff8d6e63",
    "brown[500]": "ff795548",
    "brown[600]": "ff6d4c41",
    "brown[700]": "ff5d4037",
    "brown[800]": "ff4e342e",
    "brown[900]": "ff3e2723",
    "cyan.primary": "ff00bcd4",
    "cyan[50]": "ffe0f7fa",
    "cyan[100]": "ffb2ebf2",
    "cyan[200]": "ff80deea",
    "cyan[300]": "ff4dd0e1",
    "cyan[400]": "ff26c6da",
    "cyan[500]": "ff00bcd4",
    "cyan[600]": "ff00acc1",
    "cyan[700]": "ff0097a7",
    "cyan[800]": "ff00838f",
    "cyan[900]": "ff006064",
    "cyanAccent.primary": "ff18ffff",
    "cyanAccent[100]": "ff84ffff",
    "cyanAccent[200]": "ff18ffff",
    "cyanAccent[400]": "ff00e5ff",
    "cyanAccent[700]": "ff00b8d4",
    "deepOrange.primary": "ffff5722",
    "deepOrange[50]": "fffbe9e7",
    "deepOrange[100]": "ffffccbc",
    "deepOrange[200]": "ffffab91",
    "deepOrange[300]": "ffff8a65",
    "deepOrange[400]": "ffff7043",
    "deepOrange[500]": "ffff5722",
    "deepOrange[600]": "fff4511e",
    "deepOrange[700]": "ffe64a19",
    "deepOrange[800]": "ffd84315",
    "deepOrange[900]": "ffbf360c",
    "deepOrangeAccent.primary": "ffff6e40",
    "deepOrangeAccent[100]": "ffff9e80",
    "deepOrangeAccent[200]": "ffff6e40",
    "deepOrangeAccent[400]": "ffff3d00",
    "deepOrangeAccent[700]": "ffdd2c00",
    "deepPurple.primary": "ff673ab7",
    "deepPurple[50]": "ffede7f6",
    "deepPurple[100]": "ffd1c4e9",
    "deepPurple[200]": "ffb39ddb",
    "deepPurple[300]": "ff9575cd",
    "deepPurple[400]": "ff7e57c2",
    "deepPurple[500]": "ff673ab7",
    "deepPurple[600]": "ff5e35b1",
    "deepPurple[700]": "ff512da8",
    "deepPurple[800]": "ff4527a0",
    "deepPurple[900]": "ff311b92",
    "deepPurpleAccent.primary": "ff7c4dff",
    "deepPurpleAccent[100]": "ffb388ff",
    "deepPurpleAccent[200]": "ff7c4dff",
    "deepPurpleAccent[400]": "ff651fff",
    "deepPurpleAccent[700]": "ff6200ea",
    "green.primary": "ff4caf50",
    "green[50]": "ffe8f5e9",
    "green[100]": "ffc8e6c9",
    "green[200]": "ffa5d6a7",
    "green[300]": "ff81c784",
    "green[400]": "ff66bb6a",
    "green[500]": "ff4caf50",
    "green[600]": "ff43a047",
    "green[700]": "ff388e3c",
    "green[800]": "ff2e7d32",
    "green[900]": "ff1b5e20",
    "greenAccent.primary": "ff69f0ae",
    "greenAccent[100]": "ffb9f6ca",
    "greenAccent[200]": "ff69f0ae",
    "greenAccent[400]": "ff00e676",
    "greenAccent[700]": "ff00c853",
    "grey.primary": "ff9e9e9e",
    "grey[50]": "fffafafa",
    "grey[100]": "fff5f5f5",
    "grey[200]": "ffeeeeee",
    "grey[300]": "ffe0e0e0",
    "grey[350]": "ffd6d6d6",
    "grey[400]": "ffbdbdbd",
    "grey[500]": "ff9e9e9e",
    "grey[600]": "ff757575",
    "grey[700]": "ff616161",
    "grey[800]": "ff424242",
    "grey[850]": "ff303030",
    "grey[900]": "ff212121",
    "indigo.primary": "ff3f51b5",
    "indigo[50]": "ffe8eaf6",
    "indigo[100]": "ffc5cae9",
    "indigo[200]": "ff9fa8da",
    "indigo[300]": "ff7986cb",
    "indigo[400]": "ff5c6bc0",
    "indigo[500]": "ff3f51b5",
    "indigo[600]": "ff3949ab",
    "indigo[700]": "ff303f9f",
    "indigo[800]": "ff283593",
    "indigo[900]": "ff1a237e",
    "indigoAccent.primary": "ff536dfe",
    "indigoAccent[100]": "ff8c9eff",
    "indigoAccent[200]": "ff536dfe",
    "indigoAccent[400]": "ff3d5afe",
    "indigoAccent[700]": "ff304ffe",
    "lightBlue.primary": "ff03a9f4",
    "lightBlue[50]": "ffe1f5fe",
    "lightBlue[100]": "ffb3e5fc",
    "lightBlue[200]": "ff81d4fa",
    "lightBlue[300]": "ff4fc3f7",
    "lightBlue[400]": "ff29b6f6",
    "lightBlue[500]": "ff03a9f4",
    "lightBlue[600]": "ff039be5",
    "lightBlue[700]": "ff0288d1",
    "lightBlue[800]": "ff0277bd",
    "lightBlue[900]": "ff01579b",
    "lightBlueAccent.primary": "ff40c4ff",
    "lightBlueAccent[100]": "ff80d8ff",
    "lightBlueAccent[200]": "ff40c4ff",
    "lightBlueAccent[400]": "ff00b0ff",
    "lightBlueAccent[700]": "ff0091ea",
    "lightGreen.primary": "ff8bc34a",
    "lightGreen[50]": "fff1f8e9",
    "lightGreen[100]": "ffdcedc8",
    "lightGreen[200]": "ffc5e1a5",
    "lightGreen[300]": "ffaed581",
    "lightGreen[400]": "ff9ccc65",
    "lightGreen[500]": "ff8bc34a",
    "lightGreen[600]": "ff7cb342",
    "lightGreen[700]": "ff689f38",
    "lightGreen[800]": "ff558b2f",
    "lightGreen[900]": "ff33691e",
    "lightGreenAccent.primary": "ffb2ff59",
    "lightGreenAccent[100]": "ffccff90",
    "lightGreenAccent[200]": "ffb2ff59",
    "lightGreenAccent[400]": "ff76ff03",
    "lightGreenAccent[700]": "ff64dd17",
    "lime.primary": "ffcddc39",
    "lime[50]": "fff9fbe7",
    "lime[100]": "fff0f4c3",
    "lime[200]": "ffe6ee9c",
    "lime[300]": "ffdce775",
    "lime[400]": "ffd4e157",
    "lime[500]": "ffcddc39",
    "lime[600]": "ffc0ca33",
    "lime[700]": "ffafb42b",
    "lime[800]": "ff9e9d24",
    "lime[900]": "ff827717",
    "limeAccent.primary": "ffeeff41",
    "limeAccent[100]": "fff4ff81",
    "limeAccent[200]": "ffeeff41",
    "limeAccent[400]": "ffc6ff00",
    "limeAccent[700]": "ffaeea00",
    "orange.primary": "ffff9800",
    "orange[50]": "fffff3e0",
    "orange[100]": "ffffe0b2",
    "orange[200]": "ffffcc80",
    "orange[300]": "ffffb74d",
    "orange[400]": "ffffa726",
    "orange[500]": "ffff9800",
    "orange[600]": "fffb8c00",
    "orange[700]": "fff57c00",
    "orange[800]": "ffef6c00",
    "orange[900]": "ffe65100",
    "orangeAccent.primary": "ffffab40",
    "orangeAccent[100]": "ffffd180",
    "orangeAccent[200]": "ffffab40",
    "orangeAccent[400]": "ffff9100",
    "orangeAccent[700]": "ffff6d00",
    "pink.primary": "ffe91e63",
    "pink[50]": "fffce4ec",
    "pink[100]": "fff8bbd0",
    "pink[200]": "fff48fb1",
    "pink[300]": "fff06292",
    "pink[400]": "ffec407a",
    "pink[500]": "ffe91e63",
    "pink[600]": "ffd81b60",
    "pink[700]": "ffc2185b",
    "pink[800]": "ffad1457",
    "pink[900]": "ff880e4f",
    "pinkAccent.primary": "ffff4081",
    "pinkAccent[100]": "ffff80ab",
    "pinkAccent[200]": "ffff4081",
    "pinkAccent[400]": "fff50057",
    "pinkAccent[700]": "ffc51162",
    "purple.primary": "ff9c27b0",
    "purple[50]": "fff3e5f5",
    "purple[100]": "ffe1bee7",
    "purple[200]": "ffce93d8",
    "purple[300]": "ffba68c8",
    "purple[400]": "ffab47bc",
    "purple[500]": "ff9c27b0",
    "purple[600]": "ff8e24aa",
    "purple[700]": "ff7b1fa2",
    "purple[800]": "ff6a1b9a",
    "purple[900]": "ff4a148c",
    "purpleAccent.primary": "ffe040fb",
    "purpleAccent[100]": "ffea80fc",
    "purpleAccent[200]": "ffe040fb",
    "purpleAccent[400]": "ffd500f9",
    "purpleAccent[700]": "ffaa00ff",
    "red.primary": "fff44336",
    "red[50]": "ffffebee",
    "red[100]": "ffffcdd2",
    "red[200]": "ffef9a9a",
    "red[300]": "ffe57373",
    "red[400]": "ffef5350",
    "red[500]": "fff44336",
    "red[600]": "ffe53935",
    "red[700]": "ffd32f2f",
    "red[800]": "ffc62828",
    "red[900]": "ffb71c1c",
    "redAccent.primary": "ffff5252",
    "redAccent[100]": "ffff8a80",
    "redAccent[200]": "ffff5252",
    "redAccent[400]": "ffff1744",
    "redAccent[700]": "ffd50000",
    "teal.primary": "ff009688",
    "teal[50]": "ffe0f2f1",
    "teal[100]": "ffb2dfdb",
    "teal[200]": "ff80cbc4",
    "teal[300]": "ff4db6ac",
    "teal[400]": "ff26a69a",
    "teal[500]": "ff009688",
    "teal[600]": "ff00897b",
    "teal[700]": "ff00796b",
    "teal[800]": "ff00695c",
    "teal[900]": "ff004d40",
    "tealAccent.primary": "ff64ffda",
    "tealAccent[100]": "ffa7ffeb",
    "tealAccent[200]": "ff64ffda",
    "tealAccent[400]": "ff1de9b6",
    "tealAccent[700]": "ff00bfa5",
    "transparent": "00000000",
    "white": "ffffffff",
    "white10": "1affffff",
    "white12": "1fffffff",
    "white24": "3dffffff",
    "white30": "4dffffff",
    "white38": "62ffffff",
    "white54": "8affffff",
    "white60": "99ffffff",
    "white70": "b3ffffff",
    "yellow.primary": "ffffeb3b",
    "yellow[50]": "fffffde7",
    "yellow[100]": "fffff9c4",
    "yellow[200]": "fffff59d",
    "yellow[300]": "fffff176",
    "yellow[400]": "ffffee58",
    "yellow[500]": "ffffeb3b",
    "yellow[600]": "fffdd835",
    "yellow[700]": "fffbc02d",
    "yellow[800]": "fff9a825",
    "yellow[900]": "fff57f17",
    "yellowAccent.primary": "ffffff00",
    "yellowAccent[100]": "ffffff8d",
    "yellowAccent[200]": "ffffff00",
    "yellowAccent[400]": "ffffea00",
    "yellowAccent[700]": "ffffd600",
};
exports.flutterCupertinoColors = {
    "activeBlue": "ff007aff",
    "activeBlue.darkColor": "ff0a84ff",
    "activeBlue.darkElevatedColor": "ff0a84ff",
    "activeBlue.darkHighContrastColor": "ff409cff",
    "activeBlue.darkHighContrastElevatedColor": "ff409cff",
    "activeBlue.elevatedColor": "ff007aff",
    "activeBlue.highContrastColor": "ff0040dd",
    "activeBlue.highContrastElevatedColor": "ff0040dd",
    "activeGreen": "ff34c759",
    "activeGreen.darkColor": "ff30d158",
    "activeGreen.darkElevatedColor": "ff30d158",
    "activeGreen.darkHighContrastColor": "ff30db5b",
    "activeGreen.darkHighContrastElevatedColor": "ff30db5b",
    "activeGreen.elevatedColor": "ff34c759",
    "activeGreen.highContrastColor": "ff248a3d",
    "activeGreen.highContrastElevatedColor": "ff248a3d",
    "activeOrange": "ffff9500",
    "activeOrange.darkColor": "ffff9f0a",
    "activeOrange.darkElevatedColor": "ffff9f0a",
    "activeOrange.darkHighContrastColor": "ffffb340",
    "activeOrange.darkHighContrastElevatedColor": "ffffb340",
    "activeOrange.elevatedColor": "ffff9500",
    "activeOrange.highContrastColor": "ffc93400",
    "activeOrange.highContrastElevatedColor": "ffc93400",
    "black": "ff000000",
    "darkBackgroundGray": "ff171717",
    "destructiveRed": "ffff3b30",
    "destructiveRed.darkColor": "ffff453a",
    "destructiveRed.darkElevatedColor": "ffff453a",
    "destructiveRed.darkHighContrastColor": "ffff6961",
    "destructiveRed.darkHighContrastElevatedColor": "ffff6961",
    "destructiveRed.elevatedColor": "ffff3b30",
    "destructiveRed.highContrastColor": "ffd70015",
    "destructiveRed.highContrastElevatedColor": "ffd70015",
    "extraLightBackgroundGray": "ffefeff4",
    "inactiveGray": "ff999999",
    "inactiveGray.darkColor": "ff757575",
    "inactiveGray.darkElevatedColor": "ff757575",
    "inactiveGray.darkHighContrastColor": "ff757575",
    "inactiveGray.darkHighContrastElevatedColor": "ff757575",
    "inactiveGray.elevatedColor": "ff999999",
    "inactiveGray.highContrastColor": "ff999999",
    "inactiveGray.highContrastElevatedColor": "ff999999",
    "label": "ff000000",
    "label.darkColor": "ffffffff",
    "label.darkElevatedColor": "ffffffff",
    "label.darkHighContrastColor": "ffffffff",
    "label.darkHighContrastElevatedColor": "ffffffff",
    "label.elevatedColor": "ff000000",
    "label.highContrastColor": "ff000000",
    "label.highContrastElevatedColor": "ff000000",
    "lightBackgroundGray": "ffe5e5ea",
    "link": "ff007aff",
    "link.darkColor": "ff0984ff",
    "link.darkElevatedColor": "ff0984ff",
    "link.darkHighContrastColor": "ff0984ff",
    "link.darkHighContrastElevatedColor": "ff0984ff",
    "link.elevatedColor": "ff007aff",
    "link.highContrastColor": "ff007aff",
    "link.highContrastElevatedColor": "ff007aff",
    "opaqueSeparator": "ffc6c6c8",
    "opaqueSeparator.darkColor": "ff38383a",
    "opaqueSeparator.darkElevatedColor": "ff38383a",
    "opaqueSeparator.darkHighContrastColor": "ff38383a",
    "opaqueSeparator.darkHighContrastElevatedColor": "ff38383a",
    "opaqueSeparator.elevatedColor": "ffc6c6c8",
    "opaqueSeparator.highContrastColor": "ffc6c6c8",
    "opaqueSeparator.highContrastElevatedColor": "ffc6c6c8",
    "placeholderText": "4c3c3c43",
    "placeholderText.darkColor": "4cebebf5",
    "placeholderText.darkElevatedColor": "4cebebf5",
    "placeholderText.darkHighContrastColor": "60ebebf5",
    "placeholderText.darkHighContrastElevatedColor": "60ebebf5",
    "placeholderText.elevatedColor": "4c3c3c43",
    "placeholderText.highContrastColor": "603c3c43",
    "placeholderText.highContrastElevatedColor": "603c3c43",
    "quaternaryLabel": "2d3c3c43",
    "quaternaryLabel.darkColor": "28ebebf5",
    "quaternaryLabel.darkElevatedColor": "28ebebf5",
    "quaternaryLabel.darkHighContrastColor": "3debebf5",
    "quaternaryLabel.darkHighContrastElevatedColor": "3debebf5",
    "quaternaryLabel.elevatedColor": "2d3c3c43",
    "quaternaryLabel.highContrastColor": "423c3c43",
    "quaternaryLabel.highContrastElevatedColor": "423c3c43",
    "quaternarySystemFill": "14747480",
    "quaternarySystemFill.darkColor": "2d767680",
    "quaternarySystemFill.darkElevatedColor": "2d767680",
    "quaternarySystemFill.darkHighContrastColor": "42767680",
    "quaternarySystemFill.darkHighContrastElevatedColor": "42767680",
    "quaternarySystemFill.elevatedColor": "14747480",
    "quaternarySystemFill.highContrastColor": "28747480",
    "quaternarySystemFill.highContrastElevatedColor": "28747480",
    "secondaryLabel": "993c3c43",
    "secondaryLabel.darkColor": "99ebebf5",
    "secondaryLabel.darkElevatedColor": "99ebebf5",
    "secondaryLabel.darkHighContrastColor": "adebebf5",
    "secondaryLabel.darkHighContrastElevatedColor": "adebebf5",
    "secondaryLabel.elevatedColor": "993c3c43",
    "secondaryLabel.highContrastColor": "ad3c3c43",
    "secondaryLabel.highContrastElevatedColor": "ad3c3c43",
    "secondarySystemBackground": "fff2f2f7",
    "secondarySystemBackground.darkColor": "ff1c1c1e",
    "secondarySystemBackground.darkElevatedColor": "ff2c2c2e",
    "secondarySystemBackground.darkHighContrastColor": "ff242426",
    "secondarySystemBackground.darkHighContrastElevatedColor": "ff363638",
    "secondarySystemBackground.elevatedColor": "fff2f2f7",
    "secondarySystemBackground.highContrastColor": "ffebebf0",
    "secondarySystemBackground.highContrastElevatedColor": "ffebebf0",
    "secondarySystemFill": "28787880",
    "secondarySystemFill.darkColor": "51787880",
    "secondarySystemFill.darkElevatedColor": "51787880",
    "secondarySystemFill.darkHighContrastColor": "66787880",
    "secondarySystemFill.darkHighContrastElevatedColor": "66787880",
    "secondarySystemFill.elevatedColor": "28787880",
    "secondarySystemFill.highContrastColor": "3d787880",
    "secondarySystemFill.highContrastElevatedColor": "3d787880",
    "secondarySystemGroupedBackground": "ffffffff",
    "secondarySystemGroupedBackground.darkColor": "ff1c1c1e",
    "secondarySystemGroupedBackground.darkElevatedColor": "ff2c2c2e",
    "secondarySystemGroupedBackground.darkHighContrastColor": "ff242426",
    "secondarySystemGroupedBackground.darkHighContrastElevatedColor": "ff363638",
    "secondarySystemGroupedBackground.elevatedColor": "ffffffff",
    "secondarySystemGroupedBackground.highContrastColor": "ffffffff",
    "secondarySystemGroupedBackground.highContrastElevatedColor": "ffffffff",
    "separator": "493c3c43",
    "separator.darkColor": "99545458",
    "separator.darkElevatedColor": "99545458",
    "separator.darkHighContrastColor": "ad545458",
    "separator.darkHighContrastElevatedColor": "ad545458",
    "separator.elevatedColor": "493c3c43",
    "separator.highContrastColor": "5e3c3c43",
    "separator.highContrastElevatedColor": "5e3c3c43",
    "systemBackground": "ffffffff",
    "systemBackground.darkColor": "ff000000",
    "systemBackground.darkElevatedColor": "ff1c1c1e",
    "systemBackground.darkHighContrastColor": "ff000000",
    "systemBackground.darkHighContrastElevatedColor": "ff242426",
    "systemBackground.elevatedColor": "ffffffff",
    "systemBackground.highContrastColor": "ffffffff",
    "systemBackground.highContrastElevatedColor": "ffffffff",
    "systemBlue": "ff007aff",
    "systemBlue.darkColor": "ff0a84ff",
    "systemBlue.darkElevatedColor": "ff0a84ff",
    "systemBlue.darkHighContrastColor": "ff409cff",
    "systemBlue.darkHighContrastElevatedColor": "ff409cff",
    "systemBlue.elevatedColor": "ff007aff",
    "systemBlue.highContrastColor": "ff0040dd",
    "systemBlue.highContrastElevatedColor": "ff0040dd",
    "systemFill": "33787880",
    "systemFill.darkColor": "5b787880",
    "systemFill.darkElevatedColor": "5b787880",
    "systemFill.darkHighContrastColor": "70787880",
    "systemFill.darkHighContrastElevatedColor": "70787880",
    "systemFill.elevatedColor": "33787880",
    "systemFill.highContrastColor": "47787880",
    "systemFill.highContrastElevatedColor": "47787880",
    "systemGreen": "ff34c759",
    "systemGreen.darkColor": "ff30d158",
    "systemGreen.darkElevatedColor": "ff30d158",
    "systemGreen.darkHighContrastColor": "ff30db5b",
    "systemGreen.darkHighContrastElevatedColor": "ff30db5b",
    "systemGreen.elevatedColor": "ff34c759",
    "systemGreen.highContrastColor": "ff248a3d",
    "systemGreen.highContrastElevatedColor": "ff248a3d",
    "systemGrey": "ff8e8e93",
    "systemGrey.darkColor": "ff8e8e93",
    "systemGrey.darkElevatedColor": "ff8e8e93",
    "systemGrey.darkHighContrastColor": "ffaeaeb2",
    "systemGrey.darkHighContrastElevatedColor": "ffaeaeb2",
    "systemGrey.elevatedColor": "ff8e8e93",
    "systemGrey.highContrastColor": "ff6c6c70",
    "systemGrey.highContrastElevatedColor": "ff6c6c70",
    "systemGrey2": "ffaeaeb2",
    "systemGrey2.darkColor": "ff636366",
    "systemGrey2.darkElevatedColor": "ff636366",
    "systemGrey2.darkHighContrastColor": "ff7c7c80",
    "systemGrey2.darkHighContrastElevatedColor": "ff7c7c80",
    "systemGrey2.elevatedColor": "ffaeaeb2",
    "systemGrey2.highContrastColor": "ff8e8e93",
    "systemGrey2.highContrastElevatedColor": "ff8e8e93",
    "systemGrey3": "ffc7c7cc",
    "systemGrey3.darkColor": "ff48484a",
    "systemGrey3.darkElevatedColor": "ff48484a",
    "systemGrey3.darkHighContrastColor": "ff545456",
    "systemGrey3.darkHighContrastElevatedColor": "ff545456",
    "systemGrey3.elevatedColor": "ffc7c7cc",
    "systemGrey3.highContrastColor": "ffaeaeb2",
    "systemGrey3.highContrastElevatedColor": "ffaeaeb2",
    "systemGrey4": "ffd1d1d6",
    "systemGrey4.darkColor": "ff3a3a3c",
    "systemGrey4.darkElevatedColor": "ff3a3a3c",
    "systemGrey4.darkHighContrastColor": "ff444446",
    "systemGrey4.darkHighContrastElevatedColor": "ff444446",
    "systemGrey4.elevatedColor": "ffd1d1d6",
    "systemGrey4.highContrastColor": "ffbcbcc0",
    "systemGrey4.highContrastElevatedColor": "ffbcbcc0",
    "systemGrey5": "ffe5e5ea",
    "systemGrey5.darkColor": "ff2c2c2e",
    "systemGrey5.darkElevatedColor": "ff2c2c2e",
    "systemGrey5.darkHighContrastColor": "ff363638",
    "systemGrey5.darkHighContrastElevatedColor": "ff363638",
    "systemGrey5.elevatedColor": "ffe5e5ea",
    "systemGrey5.highContrastColor": "ffd8d8dc",
    "systemGrey5.highContrastElevatedColor": "ffd8d8dc",
    "systemGrey6": "fff2f2f7",
    "systemGrey6.darkColor": "ff1c1c1e",
    "systemGrey6.darkElevatedColor": "ff1c1c1e",
    "systemGrey6.darkHighContrastColor": "ff242426",
    "systemGrey6.darkHighContrastElevatedColor": "ff242426",
    "systemGrey6.elevatedColor": "fff2f2f7",
    "systemGrey6.highContrastColor": "ffebebf0",
    "systemGrey6.highContrastElevatedColor": "ffebebf0",
    "systemGroupedBackground": "fff2f2f7",
    "systemGroupedBackground.darkColor": "ff000000",
    "systemGroupedBackground.darkElevatedColor": "ff1c1c1e",
    "systemGroupedBackground.darkHighContrastColor": "ff000000",
    "systemGroupedBackground.darkHighContrastElevatedColor": "ff242426",
    "systemGroupedBackground.elevatedColor": "fff2f2f7",
    "systemGroupedBackground.highContrastColor": "ffebebf0",
    "systemGroupedBackground.highContrastElevatedColor": "ffebebf0",
    "systemIndigo": "ff5856d6",
    "systemIndigo.darkColor": "ff5e5ce6",
    "systemIndigo.darkElevatedColor": "ff5e5ce6",
    "systemIndigo.darkHighContrastColor": "ff7d7aff",
    "systemIndigo.darkHighContrastElevatedColor": "ff7d7aff",
    "systemIndigo.elevatedColor": "ff5856d6",
    "systemIndigo.highContrastColor": "ff3634a3",
    "systemIndigo.highContrastElevatedColor": "ff3634a3",
    "systemOrange": "ffff9500",
    "systemOrange.darkColor": "ffff9f0a",
    "systemOrange.darkElevatedColor": "ffff9f0a",
    "systemOrange.darkHighContrastColor": "ffffb340",
    "systemOrange.darkHighContrastElevatedColor": "ffffb340",
    "systemOrange.elevatedColor": "ffff9500",
    "systemOrange.highContrastColor": "ffc93400",
    "systemOrange.highContrastElevatedColor": "ffc93400",
    "systemPink": "ffff2d55",
    "systemPink.darkColor": "ffff375f",
    "systemPink.darkElevatedColor": "ffff375f",
    "systemPink.darkHighContrastColor": "ffff6482",
    "systemPink.darkHighContrastElevatedColor": "ffff6482",
    "systemPink.elevatedColor": "ffff2d55",
    "systemPink.highContrastColor": "ffd30f45",
    "systemPink.highContrastElevatedColor": "ffd30f45",
    "systemPurple": "ffaf52de",
    "systemPurple.darkColor": "ffbf5af2",
    "systemPurple.darkElevatedColor": "ffbf5af2",
    "systemPurple.darkHighContrastColor": "ffda8fff",
    "systemPurple.darkHighContrastElevatedColor": "ffda8fff",
    "systemPurple.elevatedColor": "ffaf52de",
    "systemPurple.highContrastColor": "ff8944ab",
    "systemPurple.highContrastElevatedColor": "ff8944ab",
    "systemRed": "ffff3b30",
    "systemRed.darkColor": "ffff453a",
    "systemRed.darkElevatedColor": "ffff453a",
    "systemRed.darkHighContrastColor": "ffff6961",
    "systemRed.darkHighContrastElevatedColor": "ffff6961",
    "systemRed.elevatedColor": "ffff3b30",
    "systemRed.highContrastColor": "ffd70015",
    "systemRed.highContrastElevatedColor": "ffd70015",
    "systemTeal": "ff5ac8fa",
    "systemTeal.darkColor": "ff64d2ff",
    "systemTeal.darkElevatedColor": "ff64d2ff",
    "systemTeal.darkHighContrastColor": "ff70d7ff",
    "systemTeal.darkHighContrastElevatedColor": "ff70d7ff",
    "systemTeal.elevatedColor": "ff5ac8fa",
    "systemTeal.highContrastColor": "ff0071a4",
    "systemTeal.highContrastElevatedColor": "ff0071a4",
    "systemYellow": "ffffcc00",
    "systemYellow.darkColor": "ffffd60a",
    "systemYellow.darkElevatedColor": "ffffd60a",
    "systemYellow.darkHighContrastColor": "ffffd426",
    "systemYellow.darkHighContrastElevatedColor": "ffffd426",
    "systemYellow.elevatedColor": "ffffcc00",
    "systemYellow.highContrastColor": "ffa05a00",
    "systemYellow.highContrastElevatedColor": "ffa05a00",
    "tertiaryLabel": "4c3c3c43",
    "tertiaryLabel.darkColor": "4cebebf5",
    "tertiaryLabel.darkElevatedColor": "4cebebf5",
    "tertiaryLabel.darkHighContrastColor": "60ebebf5",
    "tertiaryLabel.darkHighContrastElevatedColor": "60ebebf5",
    "tertiaryLabel.elevatedColor": "4c3c3c43",
    "tertiaryLabel.highContrastColor": "603c3c43",
    "tertiaryLabel.highContrastElevatedColor": "603c3c43",
    "tertiarySystemBackground": "ffffffff",
    "tertiarySystemBackground.darkColor": "ff2c2c2e",
    "tertiarySystemBackground.darkElevatedColor": "ff3a3a3c",
    "tertiarySystemBackground.darkHighContrastColor": "ff363638",
    "tertiarySystemBackground.darkHighContrastElevatedColor": "ff444446",
    "tertiarySystemBackground.elevatedColor": "ffffffff",
    "tertiarySystemBackground.highContrastColor": "ffffffff",
    "tertiarySystemBackground.highContrastElevatedColor": "ffffffff",
    "tertiarySystemFill": "1e767680",
    "tertiarySystemFill.darkColor": "3d767680",
    "tertiarySystemFill.darkElevatedColor": "3d767680",
    "tertiarySystemFill.darkHighContrastColor": "51767680",
    "tertiarySystemFill.darkHighContrastElevatedColor": "51767680",
    "tertiarySystemFill.elevatedColor": "1e767680",
    "tertiarySystemFill.highContrastColor": "33767680",
    "tertiarySystemFill.highContrastElevatedColor": "33767680",
    "tertiarySystemGroupedBackground": "fff2f2f7",
    "tertiarySystemGroupedBackground.darkColor": "ff2c2c2e",
    "tertiarySystemGroupedBackground.darkElevatedColor": "ff3a3a3c",
    "tertiarySystemGroupedBackground.darkHighContrastColor": "ff363638",
    "tertiarySystemGroupedBackground.darkHighContrastElevatedColor": "ff444446",
    "tertiarySystemGroupedBackground.elevatedColor": "fff2f2f7",
    "tertiarySystemGroupedBackground.highContrastColor": "ffebebf0",
    "tertiarySystemGroupedBackground.highContrastElevatedColor": "ffebebf0",
    "white": "ffffffff",
};


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterIconDecorationsDas = void 0;
const fs_1 = __webpack_require__(1);
const icon_range_computer_1 = __webpack_require__(136);
const flutter_icon_decorations_1 = __webpack_require__(137);
class FlutterIconDecorationsDas extends flutter_icon_decorations_1.FlutterIconDecorations {
    constructor(logger, analyzer) {
        super(logger);
        this.analyzer = analyzer;
        this.computer = new icon_range_computer_1.IconRangeComputer(logger);
        this.subscriptions.push(this.analyzer.client.registerForFlutterOutline((n) => __awaiter(this, void 0, void 0, function* () {
            if (this.activeEditor && fs_1.fsPath(this.activeEditor.document.uri) === n.file) {
                this.update(n.outline);
            }
        })));
    }
    update(outline) {
        if (!this.activeEditor)
            return;
        if (!outline)
            outline = this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri);
        if (!outline)
            return;
        const results = this.computer.compute(this.activeEditor.document, outline);
        this.render(results);
    }
}
exports.FlutterIconDecorationsDas = FlutterIconDecorationsDas;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterOutlineVisitorLsp = exports.FlutterOutlineVisitor = void 0;
class FlutterOutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.kind) {
            case "DART_ELEMENT":
                this.visitDartElement(outline);
                break;
            case "GENERIC":
                this.visitGeneric(outline);
                break;
            case "NEW_INSTANCE":
                this.visitNewInstance(outline);
                break;
            case "INVOCATION":
                this.visitInvocation(outline);
                break;
            case "VARIABLE":
                this.visitVariable(outline);
                break;
            case "PLACEHOLDER":
                this.visitPlaceholder(outline);
                break;
            default:
                this.logger.error(`Unknown Flutter Outline item! ${outline && outline.kind}`);
        }
        if (outline.attributes) {
            for (const attribute of outline.attributes)
                this.visitAttribute(attribute);
        }
    }
    visitDartElement(outline) { this.visitChildren(outline); }
    visitGeneric(outline) { this.visitChildren(outline); }
    visitNewInstance(outline) { this.visitChildren(outline); }
    visitInvocation(outline) { this.visitChildren(outline); }
    visitVariable(outline) { this.visitChildren(outline); }
    visitPlaceholder(outline) { this.visitChildren(outline); }
    // tslint:disable-next-line: no-empty
    visitAttribute(attribute) { }
}
exports.FlutterOutlineVisitor = FlutterOutlineVisitor;
class FlutterOutlineVisitorLsp {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.kind) {
            case "DART_ELEMENT":
                this.visitDartElement(outline);
                break;
            case "GENERIC":
                this.visitGeneric(outline);
                break;
            case "NEW_INSTANCE":
                this.visitNewInstance(outline);
                break;
            case "INVOCATION":
                this.visitInvocation(outline);
                break;
            case "VARIABLE":
                this.visitVariable(outline);
                break;
            case "PLACEHOLDER":
                this.visitPlaceholder(outline);
                break;
            default:
                this.logger.error(`Unknown Flutter Outline item! ${outline && outline.kind}`);
        }
        if (outline.attributes) {
            for (const attribute of outline.attributes)
                this.visitAttribute(attribute);
        }
    }
    visitDartElement(outline) { this.visitChildren(outline); }
    visitGeneric(outline) { this.visitChildren(outline); }
    visitNewInstance(outline) { this.visitChildren(outline); }
    visitInvocation(outline) { this.visitChildren(outline); }
    visitVariable(outline) { this.visitChildren(outline); }
    visitPlaceholder(outline) { this.visitChildren(outline); }
    // tslint:disable-next-line: no-empty
    visitAttribute(attribute) { }
}
exports.FlutterOutlineVisitorLsp = FlutterOutlineVisitorLsp;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterIconDecorationsLsp = void 0;
const fs_1 = __webpack_require__(1);
const icon_range_computer_1 = __webpack_require__(136);
const flutter_icon_decorations_1 = __webpack_require__(137);
class FlutterIconDecorationsLsp extends flutter_icon_decorations_1.FlutterIconDecorations {
    constructor(logger, analyzer) {
        super(logger);
        this.analyzer = analyzer;
        this.computer = new icon_range_computer_1.IconRangeComputerLsp(logger);
        this.subscriptions.push(this.analyzer.fileTracker.onFlutterOutline.listen((op) => __awaiter(this, void 0, void 0, function* () {
            if (this.activeEditor && fs_1.fsPath(this.activeEditor.document.uri) === fs_1.fsPath(op.uri)) {
                this.update(op.outline);
            }
        })));
    }
    update(outline) {
        if (!this.activeEditor)
            return;
        if (!outline)
            outline = this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri);
        if (!outline)
            return;
        const results = this.computer.compute(outline);
        this.render(results);
    }
}
exports.FlutterIconDecorationsLsp = FlutterIconDecorationsLsp;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterUiGuideDecorationsDas = void 0;
const vs = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const flutter_ui_guides_decorations_1 = __webpack_require__(138);
class FlutterUiGuideDecorationsDas extends flutter_ui_guides_decorations_1.FlutterUiGuideDecorations {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        // Whenever we get a new Flutter Outline, if it's for the active document,
        // update that too.
        this.disposables.push(this.analyzer.client.registerForFlutterOutline((on) => {
            const editor = vs.window.activeTextEditor;
            if (editor && editor.document && fs_1.fsPath(editor.document.uri) === on.file)
                this.buildFromOutline(editor, on.outline);
        }));
    }
    buildForTextEditor(editor) {
        if (editor && editor.document)
            this.buildFromOutline(editor, this.analyzer.fileTracker.getFlutterOutlineFor(editor.document.uri));
    }
    buildFromOutline(editor, outline) {
        if (this.tracker)
            this.tracker.clear();
        if (!editor || !editor.document || !outline)
            return;
        // Check that the outline we got looks like it still matches the document.
        // If the lengths are different, just bail without doing anything since
        // there have probably been new edits and we'll get a new outline soon.
        if (editor.document.getText().length !== outline.length)
            return;
        const guides = this.extractGuides(editor.document, outline);
        if (this.tracker)
            this.tracker.trackDoc(editor.document, guides);
        this.renderGuides(editor, guides, "#A3A3A3");
    }
    extractGuides(document, node) {
        let guides = [];
        if (node.kind === "NEW_INSTANCE") {
            const parentLine = document.positionAt(node.offset).line;
            const childLines = node.children && node.children
                .map((c) => document.positionAt(c.offset).line)
                .filter((cl) => cl > parentLine);
            if (childLines) {
                const startPos = this
                    .firstNonWhitespace(document, parentLine);
                childLines.forEach((childLine, i) => {
                    const firstCodeChar = this.firstNonWhitespace(document, childLine);
                    guides.push(new flutter_ui_guides_decorations_1.WidgetGuide(startPos, firstCodeChar));
                });
            }
        }
        // Recurse down the tree to include childrens (and they'll include their
        // childrens, etc.).
        if (node.children)
            guides = guides.concat(utils_1.flatMap(node.children, (c) => this.extractGuides(document, c)));
        return guides;
    }
}
exports.FlutterUiGuideDecorationsDas = FlutterUiGuideDecorationsDas;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentOffsetTracker = exports.DocumentPositionTracker = void 0;
const vs = __webpack_require__(0);
class DocumentPositionTracker {
    constructor() {
        this.disposables = [];
        this.tracker = new DocumentOffsetTracker();
        this.positionMap = new Map();
        this.onPositionsChangedEmitter = new vs.EventEmitter();
        this.onPositionsChanged = this.onPositionsChangedEmitter.event;
        this.disposables.push(this.tracker);
        this.tracker.onOffsetsChanged(([doc, offsets]) => {
            // Map all our original positions onto new positions based on their
            // new offsets.
            const newPositions = new Map();
            for (const position of this.positionMap.keys()) {
                const currentOffset = this.positionMap.get(position);
                const newOffset = offsets.get(currentOffset);
                if (newOffset)
                    newPositions.set(position, doc.positionAt(newOffset));
                else
                    newPositions.delete(position);
            }
            this.onPositionsChangedEmitter.fire([doc, newPositions]);
        });
    }
    clear() {
        this.positionMap.clear();
        this.tracker.clear();
    }
    trackDoc(document, positions) {
        // Stash all positions as offsets.
        this.positionMap.clear();
        for (const position of positions)
            this.positionMap.set(position, document.offsetAt(position));
        // Track via the offset tracker.
        this.tracker.trackDoc(document, [...this.positionMap.values()]);
    }
    dispose() {
        this.disposables.forEach((s) => s.dispose());
    }
}
exports.DocumentPositionTracker = DocumentPositionTracker;
class DocumentOffsetTracker {
    constructor() {
        this.disposables = [];
        this.offsetMap = new Map();
        this.onOffsetsChangedEmitter = new vs.EventEmitter();
        this.onOffsetsChanged = this.onOffsetsChangedEmitter.event;
        this.disposables.push(vs.workspace.onDidChangeTextDocument((e) => this.handleUpdate(e)));
    }
    trackDoc(document, offsets) {
        this.document = document;
        // Set all offsets to just point to themeselves.
        this.offsetMap.clear();
        for (const offset of offsets)
            this.offsetMap.set(offset, offset);
    }
    clear() {
        this.document = undefined;
        this.offsetMap.clear();
    }
    handleUpdate(e) {
        if (e.document !== this.document)
            return;
        for (const offset of [...this.offsetMap.keys()]) {
            // The key (offset) is the original offset, which we must use in the
            // map to track the current offset.
            // updateOffset takes the *value*, since we need to map the "current" (not
            // original) value, and then updates the value in the map.
            const currentOffset = this.offsetMap.get(offset);
            const newOffset = this.updateOffset(currentOffset, e);
            if (newOffset)
                this.offsetMap.set(offset, newOffset);
            else
                this.offsetMap.delete(offset);
        }
        this.onOffsetsChangedEmitter.fire([e.document, this.offsetMap]);
    }
    updateOffset(offset, change) {
        // If any edit spans us, consider us deleted.
        if (change.contentChanges.find((edit) => edit.rangeOffset < offset && edit.rangeOffset + edit.rangeLength > offset)) {
            return undefined;
        }
        // Otherwise, shift us along to account for any edits before us.
        const totalDiff = change.contentChanges
            // Edits that end before us.
            .filter((edit) => edit.rangeOffset + edit.rangeLength <= offset)
            // Get the difference in lengths to know if we inserted or removed.
            .map((edit) => edit.text.length - edit.rangeLength)
            .reduce((total, n) => total + n, 0);
        return offset + totalDiff;
    }
    dispose() {
        this.disposables.forEach((s) => s.dispose());
    }
}
exports.DocumentOffsetTracker = DocumentOffsetTracker;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterUiGuideDecorationsLsp = void 0;
const vs = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const utils_2 = __webpack_require__(5);
const flutter_ui_guides_decorations_1 = __webpack_require__(138);
class FlutterUiGuideDecorationsLsp extends flutter_ui_guides_decorations_1.FlutterUiGuideDecorations {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        // Whenever we get a new Flutter Outline, if it's for the active document,
        // update that too.
        this.disposables.push(this.analyzer.fileTracker.onFlutterOutline.listen((op) => {
            const editor = vs.window.activeTextEditor;
            if (editor && editor.document && fs_1.fsPath(editor.document.uri) === fs_1.fsPath(op.uri))
                this.buildFromOutline(editor, op.outline);
        }));
    }
    buildForTextEditor(editor) {
        if (editor && editor.document)
            this.buildFromOutline(editor, this.analyzer.fileTracker.getFlutterOutlineFor(editor.document.uri));
    }
    buildFromOutline(editor, outline) {
        if (this.tracker)
            this.tracker.clear();
        if (!editor || !editor.document || !outline)
            return;
        // Check that the outline we got looks like it still matches the document.
        // If the lengths are different, just bail without doing anything since
        // there have probably been new edits and we'll get a new outline soon.
        const outlineLength = editor.document.offsetAt(utils_2.lspToPosition(outline.range.end));
        if (editor.document.getText().length !== outlineLength)
            return;
        const guides = this.extractGuides(editor.document, outline);
        if (this.tracker)
            this.tracker.trackDoc(editor.document, guides);
        this.renderGuides(editor, guides, "#A3A3A3");
    }
    extractGuides(document, node) {
        let guides = [];
        if (node.kind === "NEW_INSTANCE") {
            const parentLine = node.codeRange.start.line;
            const childLines = node.children && node.children
                .map((c) => c.codeRange.start.line)
                .filter((cl) => cl > parentLine);
            if (childLines) {
                const startPos = this
                    .firstNonWhitespace(document, parentLine);
                childLines.forEach((childLine, i) => {
                    const firstCodeChar = this.firstNonWhitespace(document, childLine);
                    guides.push(new flutter_ui_guides_decorations_1.WidgetGuide(startPos, firstCodeChar));
                });
            }
        }
        // Recurse down the tree to include childrens (and they'll include their
        // childrens, etc.).
        if (node.children)
            guides = guides.concat(utils_1.flatMap(node.children, (c) => this.extractGuides(document, c)));
        return guides;
    }
}
exports.FlutterUiGuideDecorationsLsp = FlutterUiGuideDecorationsLsp;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExperiments = void 0;
const vs = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const config_1 = __webpack_require__(10);
// Used for testing. DO NOT COMMIT AS TRUE.
const clearAllExperiments = false;
function getExperiments(logger, workspaceContext, context) {
    return {
        lspPrompt: new LspExperiment(logger, workspaceContext, context),
    };
}
exports.getExperiments = getExperiments;
class Experiment {
    constructor(logger, workspaceContext, context, id, currentPercent) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.context = context;
        this.id = id;
        this.currentPercent = currentPercent;
        // If this is the first time we've seen this experiment, generate a random number
        // from 1-100.
        const contextKey = `experiement-${id}`;
        const contextHasActivatedKey = `${contextKey}-hasActivated`;
        if (clearAllExperiments) {
            context.update(contextKey, undefined);
            context.update(contextHasActivatedKey, undefined);
        }
        this.randomNumber = context.get(contextKey);
        if (!this.randomNumber) {
            this.randomNumber = fs_1.getRandomInt(1, 100);
            context.update(contextKey, this.randomNumber);
            logger.info(`Generated random number ${this.randomNumber} for new experiement '${id}'. Experiment is enabled for <= ${this.currentPercent}`);
        }
        else {
            logger.info(`Experiment random number is ${this.randomNumber} for experiement '${id}'. Experiment is enabled for <= ${this.currentPercent}`);
        }
        if (this.applies) {
            const isFirst = !context.get(contextHasActivatedKey);
            context.update(contextHasActivatedKey, true);
            logger.info(`Experiment '${id}' is activating (${isFirst ? "first time" : "not first time"})`);
            this.activate(isFirst)
                // Activate is allowed to return false if it skipped activating (eg. not relevant) so
                // first activation can re-run in future.
                .then((v) => {
                if (v === false) {
                    logger.info(`Experiment '${id}' aborted. Clearing hasActivated flag`);
                    context.update(contextHasActivatedKey, undefined);
                }
            });
        }
    }
    get applies() { return this.randomNumber <= this.currentPercent; }
    /// Activates the experiment. If returns false, resets the hasActivated flag so it
    /// is not considered to have run.
    activate(isFirstActivation) {
        return __awaiter(this, void 0, void 0, function* () { return; });
    }
}
class LspExperiment extends Experiment {
    constructor(logger, workspaceContext, context) {
        super(logger, workspaceContext, context, "lsp-prompt", 40);
    }
    activate(isFirstActivation) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we don't have any projects, skip this and return false so we can re-trigger in future.
            if (!this.workspaceContext.hasAnyStandardDartProjects && !this.workspaceContext.hasAnyFlutterProjects)
                return false;
            // Never prompt if LSP is already enabled or this isn't the first activation.
            if (config_1.config.previewLsp || !isFirstActivation)
                return;
            const yesPleaseAction = "Yes please!";
            const noThanksAction = "No thanks";
            const action = yield vs.window.showInformationMessage("Dart-Code is switching to using the Language Server Protocol for improved performance. Would you like to enable it now?", yesPleaseAction, noThanksAction);
            if (action === yesPleaseAction) {
                this.logger.info("Enabling LSP preview and reloading!");
                yield config_1.config.setPreviewLsp(true);
                vs.commands.executeCommand("workbench.action.reloadWindow");
            }
        });
    }
}


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.setUpDaemonMessageHandler = void 0;
const vscode_1 = __webpack_require__(0);
const channels_1 = __webpack_require__(108);
function setUpDaemonMessageHandler(logger, context, daemon) {
    const channel = channels_1.createChannel("flutter daemon");
    context.subscriptions.push(daemon.registerForDaemonLog((l) => {
        // Don't show, as we get errors from this just when disconnected devices!
        // channel.show(true);
        channel.appendLine(`${l.error ? "[ERR] " : ""}${l.log}`);
    }));
    context.subscriptions.push(daemon.registerForDaemonShowMessage((l) => {
        const title = l.title.trim().endsWith(".") ? l.title.trim() : `${l.title.trim()}.`;
        const message = `${title} ${l.message}`.trim();
        switch (l.level) {
            case "info":
                vscode_1.window.showInformationMessage(message);
                break;
            case "warning":
                vscode_1.window.showWarningMessage(message);
                break;
            case "error":
                vscode_1.window.showErrorMessage(message);
                break;
            default:
                logger.warn(`Unexpected daemon.showMessage type: ${l.level}`);
        }
    }));
}
exports.setUpDaemonMessageHandler = setUpDaemonMessageHandler;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterDaemon = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const vscode_1 = __webpack_require__(0);
const flutter_1 = __webpack_require__(59);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const stdio_service_1 = __webpack_require__(44);
const utils_1 = __webpack_require__(3);
const utils_2 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
const extension_1 = __webpack_require__(40);
const utils_3 = __webpack_require__(6);
const processes_1 = __webpack_require__(15);
class FlutterDaemon extends stdio_service_1.StdIOService {
    constructor(logger, workspaceContext, flutterCapabilities) {
        var _a, _b;
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.FlutterDaemon), config_1.config.maxLogLineLength, true, true);
        this.hasStarted = false;
        this.daemonStartedCompleter = new utils_1.PromiseCompleter();
        this.capabilities = flutter_1.DaemonCapabilities.empty;
        this.hasShownStartupError = false;
        // Subscription lists.
        this.daemonConnectedSubscriptions = [];
        this.deviceAddedSubscriptions = [];
        this.deviceRemovedSubscriptions = [];
        this.daemonLogMessageSubscriptions = [];
        this.daemonLogSubscriptions = [];
        this.daemonShowMessageSubscriptions = [];
        const folder = workspaceContext.sdks.flutter;
        this.registerForDaemonConnected((e) => {
            this.additionalPidsToTerminate.push(e.pid);
            this.capabilities.version = e.version;
            vs.commands.executeCommand("setContext", extension_1.FLUTTER_SUPPORTS_ATTACH, this.capabilities.canFlutterAttach);
            this.deviceEnable();
        });
        const daemonArgs = [];
        // If we're running remotely, we need to pass this flag for web-server device to show up.
        if (!utils_2.isRunningLocally && flutterCapabilities.supportsShowWebServerDevice)
            daemonArgs.push("--show-web-server-device");
        const { binPath, binArgs } = utils_1.usingCustomScript(path.join(workspaceContext.sdks.flutter, constants_1.flutterPath), ["daemon"].concat(daemonArgs), ((_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.flutterDaemonScript) || ((_b = workspaceContext.config) === null || _b === void 0 ? void 0 : _b.flutterScript));
        const flutterAdditionalArgs = config_1.config.for(vs.Uri.file(folder)).flutterAdditionalArgs;
        const args = processes_1.getGlobalFlutterArgs().concat(flutterAdditionalArgs).concat(binArgs);
        this.createProcess(folder, binPath, args, { toolEnv: processes_1.getToolEnv() });
        if (constants_1.isChromeOS && config_1.config.flutterAdbConnectOnChromeOs) {
            logger.info("Running ADB Connect on Chrome OS");
            const adbConnectProc = processes_1.safeToolSpawn(undefined, "adb", ["connect", "100.115.92.2:5555"]);
            logging_1.logProcess(logger, enums_1.LogCategory.General, adbConnectProc);
        }
    }
    dispose() {
        super.dispose();
    }
    sendMessage(json) {
        try {
            super.sendMessage(json);
        }
        catch (e) {
            // tslint:disable-next-line: no-floating-promises
            utils_3.promptToReloadExtension("The Flutter Daemon has terminated.", undefined, true);
            throw e;
        }
    }
    shouldHandleMessage(message) {
        // Everything in flutter is wrapped in [] so we can tell what to handle.
        if (message.startsWith("[{") && message.endsWith("}]")) {
            // When we get the first message to handle, complete the status notifications.
            if (!this.hasStarted) {
                this.hasStarted = true;
                this.daemonStartedCompleter.resolve();
            }
            return true;
        }
        return false;
    }
    processUnhandledMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let upgradeMessage;
            const matches = FlutterDaemon.outOfDateWarning.exec(message);
            if (matches && matches.length === 2)
                upgradeMessage = `Your installation of Flutter is ${matches[1]} days old.`;
            else if (message.indexOf(FlutterDaemon.newVersionMessage) !== -1)
                upgradeMessage = "A new version of Flutter is available";
            if (upgradeMessage) {
                if (yield vs.window.showWarningMessage(upgradeMessage, "Upgrade Flutter"))
                    vs.commands.executeCommand("flutter.upgrade");
                return;
            }
            if (!this.hasShownStartupError && message.startsWith("Flutter requires")) {
                this.logger.error(message, enums_1.LogCategory.FlutterDaemon);
                vs.window.showErrorMessage(message);
                this.hasShownStartupError = true;
                return;
            }
            // Show as progress message, this is likely "Building flutter tool" or "downloading Dart SDK" messages.
            if ((message.startsWith("Building ") || message.startsWith("Downloading ") || message.startsWith("Starting ") || message.startsWith("Running "))
                && !message.startsWith("Starting device daemon") // Don't show this one as it happens for normal startups too.
            ) {
                if (!this.hasStarted) {
                    if (this.startupReporter) {
                        this.startupReporter.report({ message });
                    }
                    else {
                        vs.window.withProgress({
                            location: vscode_1.ProgressLocation.Notification,
                            title: "Flutter Setup",
                        }, (progressReporter) => {
                            this.startupReporter = progressReporter;
                            this.startupReporter.report({ message });
                            return this.daemonStartedCompleter.promise;
                        });
                    }
                }
            }
        });
    }
    // TODO: Can we code-gen all this like the analysis server?
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.event) {
                case "daemon.connected":
                    yield this.notify(this.daemonConnectedSubscriptions, evt.params);
                    break;
                case "device.added":
                    yield this.notify(this.deviceAddedSubscriptions, evt.params);
                    break;
                case "device.removed":
                    yield this.notify(this.deviceRemovedSubscriptions, evt.params);
                    break;
                case "daemon.logMessage":
                    yield this.notify(this.daemonLogMessageSubscriptions, evt.params);
                    break;
                case "daemon.log":
                    yield this.notify(this.daemonLogSubscriptions, evt.params);
                    break;
                case "daemon.showMessage":
                    yield this.notify(this.daemonShowMessageSubscriptions, evt.params);
                    break;
            }
        });
    }
    // Request methods.
    deviceEnable() {
        return this.sendRequest("device.enable");
    }
    getEmulators() {
        return this.sendRequest("emulator.getEmulators");
    }
    launchEmulator(emulatorId) {
        return this.sendRequest("emulator.launch", { emulatorId });
    }
    createEmulator(name) {
        return this.sendRequest("emulator.create", { name });
    }
    getSupportedPlatforms(projectRoot) {
        return this.sendRequest("daemon.getSupportedPlatforms", { projectRoot });
    }
    // Subscription methods.
    registerForDaemonConnected(subscriber) {
        return this.subscribe(this.daemonConnectedSubscriptions, subscriber);
    }
    registerForDeviceAdded(subscriber) {
        return this.subscribe(this.deviceAddedSubscriptions, subscriber);
    }
    registerForDeviceRemoved(subscriber) {
        return this.subscribe(this.deviceRemovedSubscriptions, subscriber);
    }
    registerForDaemonLogMessage(subscriber) {
        return this.subscribe(this.daemonLogMessageSubscriptions, subscriber);
    }
    registerForDaemonLog(subscriber) {
        return this.subscribe(this.daemonLogSubscriptions, subscriber);
    }
    registerForDaemonShowMessage(subscriber) {
        return this.subscribe(this.daemonShowMessageSubscriptions, subscriber);
    }
}
exports.FlutterDaemon = FlutterDaemon;
FlutterDaemon.outOfDateWarning = new RegExp("WARNING: .* Flutter is (\\d+) days old");
FlutterDaemon.newVersionMessage = "A new version of Flutter is available";


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterWidgetItem = exports.LspFlutterOutlineProvider = exports.DasFlutterOutlineProvider = exports.FlutterOutlineProvider = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const logging_1 = __webpack_require__(13);
const fs_1 = __webpack_require__(1);
const extension_utils_1 = __webpack_require__(20);
const mappings_1 = __webpack_require__(239);
const utils_1 = __webpack_require__(5);
const analyzer_das_1 = __webpack_require__(50);
const flutter_outline_1 = __webpack_require__(128);
const utils_2 = __webpack_require__(6);
const DART_SHOW_FLUTTER_OUTLINE = "dart-code:showFlutterOutline";
const WIDGET_SELECTED_CONTEXT = "dart-code:isSelectedWidget";
const WIDGET_SUPPORTS_CONTEXT_PREFIX = "dart-code:widgetSupports:";
class FlutterOutlineProvider {
    constructor() {
        this.subscriptions = [];
        this.treeNodesByLine = [];
        this.onDidChangeTreeDataEmitter = new vs.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
    }
    setTrackingFile(editor) {
        if (editor && utils_2.isAnalyzable(editor.document)) {
            this.activeEditor = editor;
            // tslint:disable-next-line: no-floating-promises
            this.loadExistingOutline();
        }
        else if (editor && editor.document.uri.scheme === "file") {
            // HACK: We can't currently reliably tell when editors are changed that are only real
            // text editors (debug window is considered an editor) so we should only hide the tree
            // when we know a file that is not ours is selected.
            // https://github.com/Microsoft/vscode/issues/45188
            this.activeEditor = undefined;
            FlutterOutlineProvider.hideTree();
        }
        else {
            // HACK: If there are no valid open editors, hide the tree.
            // The timeout is because the open editors disappear briefly during a closing
            // of one preview and opening of another :(
            // https://github.com/Microsoft/vscode/issues/45188.
            setTimeout(() => {
                if (!vs.window.visibleTextEditors.filter((e) => utils_2.isAnalyzable(e.document)).length) {
                    FlutterOutlineProvider.hideTree();
                }
            }, 100);
        }
    }
    setContexts(selection) {
        return __awaiter(this, void 0, void 0, function* () {
            // Unmark the old node as being selected.
            if (this.lastSelectedWidget) {
                this.lastSelectedWidget.contextValue = undefined;
                this.refresh(this.lastSelectedWidget);
            }
            // Clear all contexts that enabled refactors.
            for (const refactor of flutter_outline_1.flutterOutlineCommands) {
                vs.commands.executeCommand("setContext", WIDGET_SUPPORTS_CONTEXT_PREFIX + refactor, false);
            }
            // Set up the new contexts for our node and mark is as current.
            if (this.activeEditor && selection && selection.length === 1 && isWidget(selection[0].outline)) {
                const fixes = (yield getFixes(this.activeEditor, selection[0].outline))
                    .filter((f) => f instanceof vs.CodeAction)
                    .filter((ca) => ca.kind && ca.kind.value && flutter_outline_1.flutterOutlineCommands.indexOf(ca.kind.value) !== -1);
                // Stash the fixes, as we may need to call them later.
                selection[0].fixes = fixes;
                for (const fix of fixes)
                    vs.commands.executeCommand("setContext", WIDGET_SUPPORTS_CONTEXT_PREFIX + (fix.kind ? fix.kind.value : "NOKIND"), true);
                // Used so we can show context menu if you right-click the selected one.
                // We can't support arbitrary context menus, because we can't get the fixes up-front (see
                // https://github.com/dart-lang/sdk/issues/32462) so we fetch when you select an item
                // and then just support it if it's selected.
                selection[0].contextValue = WIDGET_SELECTED_CONTEXT;
                this.lastSelectedWidget = selection[0];
                this.refresh(selection[0]);
            }
        });
    }
    getNodeAt(uri, pos) {
        if (!this.activeEditor || !this.flutterOutline || fs_1.fsPath(this.activeEditor.document.uri) !== fs_1.fsPath(uri) || !this.treeNodesByLine[pos.line])
            return;
        const nodes = this.treeNodesByLine[pos.line];
        // We want the last node that started before the position (eg. most specific).
        let currentBest;
        for (const item of nodes) {
            const range = "range" in item.outline
                ? utils_1.lspToRange(item.outline.range)
                : utils_1.toRange(this.activeEditor.document, item.outline.offset, item.outline.length);
            if (range.contains(pos))
                currentBest = item;
        }
        if (currentBest === this.rootNode)
            return undefined; // Root node isn't actually in the tree.
        return currentBest;
    }
    refresh(item) {
        this.onDidChangeTreeDataEmitter.fire(item);
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (element)
            return element.children;
        if (this.rootNode)
            return this.rootNode.children;
        return [];
    }
    getParent(element) {
        return element.parent;
    }
    static setTreeVisible(visible) {
        vs.commands.executeCommand("setContext", DART_SHOW_FLUTTER_OUTLINE, visible);
    }
    static showTree() { this.setTreeVisible(true); }
    static hideTree() { this.setTreeVisible(false); }
    dispose() {
        this.activeEditor = undefined;
        this.subscriptions.forEach((s) => s.dispose());
    }
}
exports.FlutterOutlineProvider = FlutterOutlineProvider;
class DasFlutterOutlineProvider extends FlutterOutlineProvider {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        this.analyzer.client.registerForServerConnected((c) => {
            if (analyzer.client.capabilities.supportsFlutterOutline) {
                this.analyzer.client.registerForFlutterOutline((n) => {
                    if (this.activeEditor && n.file === fs_1.fsPath(this.activeEditor.document.uri)) {
                        this.flutterOutline = n.outline;
                        this.treeNodesByLine = [];
                        // Delay this so if we're getting lots of updates we don't flicker.
                        if (this.updateTimeout)
                            clearTimeout(this.updateTimeout);
                        if (!this.rootNode)
                            // tslint:disable-next-line: no-floating-promises
                            this.update();
                        else
                            this.updateTimeout = setTimeout(() => this.update(), 200);
                    }
                });
                this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
                if (vs.window.activeTextEditor) {
                    this.setTrackingFile(vs.window.activeTextEditor);
                }
            }
        });
    }
    loadExistingOutline() {
        return __awaiter(this, void 0, void 0, function* () {
            this.flutterOutline = this.activeEditor ? this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri) : undefined;
            if (this.flutterOutline)
                yield this.update();
            else {
                this.rootNode = undefined;
                this.refresh(); // Force update (to nothing) while requests are in-flight.
            }
            if (this.activeEditor)
                this.analyzer.client.forceNotificationsFor(fs_1.fsPath(this.activeEditor.document.uri));
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            // Build the tree from our outline
            if (this.flutterOutline) {
                this.rootNode = yield this.createTreeNode(undefined, this.flutterOutline, this.activeEditor);
                FlutterOutlineProvider.showTree();
            }
            else {
                this.rootNode = undefined;
                FlutterOutlineProvider.hideTree();
            }
            this.refresh();
        });
    }
    createTreeNode(parent, element, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure we're still active editor before trying to use.
            if (editor && editor.document && !editor.document.isClosed && this.activeEditor === editor) {
                const node = new FlutterWidgetItem(parent, element, editor);
                // Add this node to a lookup by line so we can quickly find it as the user moves around the doc.
                const startLine = editor.document.positionAt(element.offset).line;
                const endLine = editor.document.positionAt(element.offset + element.length).line;
                for (let line = startLine; line <= endLine; line++) {
                    if (!this.treeNodesByLine[line]) {
                        this.treeNodesByLine[line] = [];
                    }
                    this.treeNodesByLine[line].push(node);
                }
                if (element.children)
                    node.children = (yield Promise.all(element.children.map((c) => this.createTreeNode(node, c, editor)))).filter((n) => n).map((n) => n);
                return node;
            }
            return undefined;
        });
    }
}
exports.DasFlutterOutlineProvider = DasFlutterOutlineProvider;
class LspFlutterOutlineProvider extends FlutterOutlineProvider {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        this.analyzer.fileTracker.onFlutterOutline.listen((n) => {
            if (this.activeEditor && fs_1.fsPath(vs.Uri.parse(n.uri)) === fs_1.fsPath(this.activeEditor.document.uri)) {
                this.flutterOutline = n.outline;
                this.treeNodesByLine = [];
                // Delay this so if we're getting lots of updates we don't flicker.
                if (this.updateTimeout)
                    clearTimeout(this.updateTimeout);
                if (!this.rootNode)
                    // tslint:disable-next-line: no-floating-promises
                    this.update();
                else
                    this.updateTimeout = setTimeout(() => this.update(), 200);
            }
        });
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
        if (vs.window.activeTextEditor) {
            this.setTrackingFile(vs.window.activeTextEditor);
        }
    }
    loadExistingOutline() {
        return __awaiter(this, void 0, void 0, function* () {
            this.flutterOutline = this.activeEditor ? this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri) : undefined;
            if (this.flutterOutline)
                yield this.update();
            else {
                this.rootNode = undefined;
                this.refresh(); // Force update (to nothing) while requests are in-flight.
            }
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            // Build the tree from our outline
            if (this.flutterOutline) {
                this.rootNode = yield this.createTreeNode(undefined, this.flutterOutline, this.activeEditor);
                FlutterOutlineProvider.showTree();
            }
            else {
                this.rootNode = undefined;
                FlutterOutlineProvider.hideTree();
            }
            this.refresh();
        });
    }
    createTreeNode(parent, outline, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure we're still active editor before trying to use.
            if (editor && editor.document && !editor.document.isClosed && this.activeEditor === editor) {
                const node = new FlutterWidgetItem(parent, outline, editor);
                // Add this node to a lookup by line so we can quickly find it as the user moves around the doc.
                const startLine = outline.range.start.line;
                const endLine = outline.range.end.line;
                for (let line = startLine; line <= endLine; line++) {
                    if (!this.treeNodesByLine[line]) {
                        this.treeNodesByLine[line] = [];
                    }
                    this.treeNodesByLine[line].push(node);
                }
                if (outline.children)
                    node.children = (yield Promise.all(outline.children.map((c) => this.createTreeNode(node, c, editor)))).filter((n) => n).map((n) => n);
                return node;
            }
            return undefined;
        });
    }
}
exports.LspFlutterOutlineProvider = LspFlutterOutlineProvider;
function isWidget(outline) {
    return outline.kind !== "DART_ELEMENT";
}
function getFixes(editor, outline) {
    return __awaiter(this, void 0, void 0, function* () {
        const pos = "range" in outline
            ? utils_1.lspToPosition(outline.range.start)
            : editor.document.positionAt(outline.offset);
        const range = new vs.Range(pos, pos);
        const fixes = yield vs.commands.executeCommand("vscode.executeCodeActionProvider", editor.document.uri, range);
        return fixes || [];
    });
}
class FlutterWidgetItem extends vs.TreeItem {
    constructor(parent, outline, editor) {
        super(FlutterWidgetItem.getLabel(outline), (outline.children && outline.children.length)
            ? vs.TreeItemCollapsibleState.Expanded
            : vs.TreeItemCollapsibleState.None);
        this.parent = parent;
        this.outline = outline;
        this.children = [];
        this.fixes = [];
        this.description = FlutterWidgetItem.getDescription(outline);
        if (isWidget(outline)) {
            this.iconPath = vs.Uri.file(path.join(extension_utils_1.extensionPath, "media/icons/flutter_widget.svg"));
        }
        else if (outline.dartElement) {
            const icon = mappings_1.getIconForSymbolKind(analyzer_das_1.getSymbolKindForElementKind(logging_1.nullLogger, outline.dartElement.kind));
            this.iconPath = {
                dark: vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/vscode_symbols/${icon}-dark.svg`)),
                light: vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/vscode_symbols/${icon}-light.svg`)),
            };
        }
        const displayRange = "range" in outline
            ? outline.range
            : new vs.Range(editor.document.positionAt(outline.offset), editor.document.positionAt(outline.offset + outline.length));
        const highlightRange = "codeRange" in outline
            ? outline.codeRange
            : new vs.Range(editor.document.positionAt(outline.codeOffset), editor.document.positionAt(outline.codeOffset + outline.codeLength));
        const selectionPos = "range" in outline
            ? outline.dartElement && outline.dartElement.range
                ? utils_1.lspToPosition(outline.dartElement.range.start)
                : utils_1.lspToPosition(outline.range.start)
            : outline.dartElement && outline.dartElement.location && outline.dartElement.location.offset
                ? editor.document.positionAt(outline.dartElement.location.offset)
                : editor.document.positionAt(outline.offset);
        this.command = {
            arguments: [
                editor,
                // Code to fit on screen
                displayRange,
                // Code to highlight
                highlightRange,
                // Selection (we just want to move cursor, so it's 0-length)
                new vs.Range(selectionPos, selectionPos),
            ],
            command: "_dart.showCode",
            title: "",
        };
        this.tooltip = utils_1.treeLabel(this);
        if (outline.attributes && outline.attributes.length) {
            this.tooltip += "\n  " + outline.attributes.map((a) => `${a.name}: ${a.label}`).join("\n   ");
        }
    }
    static getLabel(outline) {
        let label = "";
        if (outline.dartElement) {
            label += " " + outline.dartElement.name;
            if (outline.dartElement.typeParameters)
                label += outline.dartElement.typeParameters;
        }
        if (outline.variableName)
            label += " " + outline.variableName;
        if (outline.className)
            label += " " + outline.className;
        if (outline.label)
            label += " " + outline.label;
        return label.trim();
    }
    static getDescription(outline) {
        var _a, _b;
        let label = "";
        if (outline.dartElement) {
            if (outline.dartElement.parameters)
                label += outline.dartElement.parameters;
            if (outline.dartElement.returnType)
                label += " → " + outline.dartElement.returnType;
        }
        // Prefer an attribute named "data", but otherwise try some others
        // in order that appear useful.
        const attributeToShow = ((_a = outline.attributes) === null || _a === void 0 ? void 0 : _a.find((a) => a.name === "data")) || ((_b = outline.attributes) === null || _b === void 0 ? void 0 : _b.find((a) => a.name === "icon" || a.name === "value"));
        if (attributeToShow)
            label += " " + attributeToShow.label;
        return label.trim();
    }
}
exports.FlutterWidgetItem = FlutterWidgetItem;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getIconForSymbolKind = void 0;
const vs = __webpack_require__(0);
const iconsForKind = {
    [vs.SymbolKind.Array]: "indexer",
    [vs.SymbolKind.Boolean]: "boolean",
    [vs.SymbolKind.Class]: "class",
    [vs.SymbolKind.Constant]: "constant",
    [vs.SymbolKind.Constructor]: "method",
    [vs.SymbolKind.Enum]: "enumerator",
    [vs.SymbolKind.EnumMember]: "enumerator-item",
    [vs.SymbolKind.Event]: "event",
    [vs.SymbolKind.Field]: "field",
    [vs.SymbolKind.File]: "file",
    [vs.SymbolKind.Function]: "method",
    [vs.SymbolKind.Interface]: "interface",
    [vs.SymbolKind.Key]: "string",
    [vs.SymbolKind.Method]: "method",
    [vs.SymbolKind.Module]: "namespace",
    [vs.SymbolKind.Namespace]: "namespace",
    [vs.SymbolKind.Null]: "boolean",
    [vs.SymbolKind.Number]: "numeric",
    [vs.SymbolKind.Object]: "namespace",
    [vs.SymbolKind.Operator]: "operator",
    [vs.SymbolKind.Package]: "namespace",
    [vs.SymbolKind.Property]: "property",
    [vs.SymbolKind.String]: "string",
    [vs.SymbolKind.Struct]: "structure",
    [vs.SymbolKind.TypeParameter]: "type-parameter",
    [vs.SymbolKind.Variable]: "variable",
};
function getIconForSymbolKind(kind) {
    return iconsForKind[kind] || "field";
}
exports.getIconForSymbolKind = getIconForSymbolKind;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlutterTaskProvider = void 0;
const utils_1 = __webpack_require__(139);
const utils_2 = __webpack_require__(3);
const array_1 = __webpack_require__(19);
const utils_3 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
const dart_task_provider_1 = __webpack_require__(134);
const utils_4 = __webpack_require__(6);
class FlutterTaskProvider extends dart_task_provider_1.BaseTaskProvider {
    constructor(logger, context, sdks, flutterCapabilities) {
        super(logger, context, sdks);
        this.flutterCapabilities = flutterCapabilities;
    }
    get type() { return FlutterTaskProvider.type; }
    provideTasks(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const dartProjects = utils_3.getDartWorkspaceFolders();
            let promises = [];
            dartProjects.forEach((folder) => {
                const isFlutter = utils_4.isFlutterWorkspaceFolder(folder);
                if (isFlutter) {
                    promises = promises.concat(this.createSharedTasks(folder));
                    promises.push(this.createTask(folder, "flutter", ["build", "apk"]));
                    promises.push(this.createTask(folder, "flutter", ["build", "ios"]));
                    promises.push(this.createTask(folder, "flutter", ["build", "macos"]));
                    promises.push(this.createTask(folder, "flutter", ["build", "web"]));
                    promises.push(this.createTask(folder, "flutter", ["install"]));
                }
            });
            const tasks = (yield Promise.all(promises)).filter(utils_2.notUndefined);
            return tasks;
        });
    }
    createPubTask(folder, args) {
        return this.createTask(folder, "flutter", ["pub", ...args]);
    }
    injectArgs(definition) {
        var _a;
        definition.args = (_a = definition.args) !== null && _a !== void 0 ? _a : [];
        if (definition.command === "flutter") {
            // Inject web-renderer if required.
            const isWebBuild = array_1.arrayStartsWith(definition.args, ["build", "web"]);
            if (isWebBuild) {
                const rendererArg = utils_1.getFutterWebRendererArg(this.flutterCapabilities, config_1.config.flutterWebRenderer, definition.args);
                if (rendererArg)
                    definition.args.push(rendererArg);
            }
        }
    }
}
exports.FlutterTaskProvider = FlutterTaskProvider;
FlutterTaskProvider.type = "flutter"; // also referenced in package.json


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HotReloadOnSaveHandler = void 0;
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const fs_1 = __webpack_require__(1);
const config_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(6);
class HotReloadOnSaveHandler {
    constructor(debugCommands, flutterCapabilities) {
        this.debugCommands = debugCommands;
        this.flutterCapabilities = flutterCapabilities;
        this.disposables = [];
        // Non-FS-watcher version (onDidSave).
        this.disposables.push(vscode_1.workspace.onDidSaveTextDocument((td) => {
            // Bail if we're using fs-watcher instead. We still wire this
            // handler up so we don't need to reload for this setting change.
            if (config_1.config.previewHotReloadOnSaveWatcher)
                return;
            this.triggerReload(td);
        }));
        // FS-watcher version.
        // TODO: Make this support everything that shouldHotReloadFor() does.
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/*.dart");
        this.disposables.push(watcher);
        watcher.onDidChange(this.handleFileSystemChange, this);
        watcher.onDidCreate(this.handleFileSystemChange, this);
    }
    handleFileSystemChange(uri) {
        // Bail if we're not using fs-watcher instead. We still wire this
        // handler up so we don't need to reload for this setting change.
        if (!config_1.config.previewHotReloadOnSaveWatcher)
            return;
        this.triggerReload({ uri });
    }
    triggerReload(file) {
        // Never do anything for files inside .dart_tool folders.
        if (fs_1.fsPath(file.uri).indexOf(`${path.sep}.dart_tool${path.sep}`) !== -1)
            return;
        const shouldHotReload = this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.HotReload)
            && config_1.config.flutterHotReloadOnSave;
        const shouldHotRestart = !this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.HotReload)
            && this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.HotRestart)
            && config_1.config.flutterHotRestartOnSave;
        // Don't do if there are no debug sessions that support it.
        if (!shouldHotReload && !shouldHotRestart)
            return;
        const commandToRun = shouldHotReload ? "flutter.hotReload" : "flutter.hotRestart";
        // Bail out if we're in an external file, or not Dart.
        if (!utils_1.isWithinWorkspace(fs_1.fsPath(file.uri)) || !utils_1.shouldHotReloadFor(file))
            return;
        // Don't do if we have errors for the saved file.
        const errors = vscode_1.languages.getDiagnostics(file.uri);
        const hasErrors = errors && errors.find((d) => d.source === "dart" && d.severity === vscode_1.DiagnosticSeverity.Error) != null;
        if (hasErrors)
            return;
        const args = { reason: constants_1.restartReasonSave, debounce: this.flutterCapabilities.supportsRestartDebounce };
        if (this.flutterCapabilities.supportsRestartDebounce) {
            vscode_1.commands.executeCommand(commandToRun, args);
        }
        else {
            // Debounce to avoid reloading multiple times during multi-file-save (Save All).
            // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
            if (this.hotReloadDelayTimer) {
                clearTimeout(this.hotReloadDelayTimer);
            }
            this.hotReloadDelayTimer = setTimeout(() => {
                this.hotReloadDelayTimer = undefined;
                vscode_1.commands.executeCommand(commandToRun, args);
            }, 200);
        }
    }
    dispose() {
        if (this.hotReloadDelayTimer)
            clearTimeout(this.hotReloadDelayTimer);
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.HotReloadOnSaveHandler = HotReloadOnSaveHandler;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LspAnalyzerStatusReporter = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
class LspAnalyzerStatusReporter {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.analysisInProgress = false;
        analyzer.onAnalysisStatusChange.listen((params) => this.handleServerStatus(params.isAnalyzing));
    }
    handleServerStatus(isAnalyzing) {
        this.analysisInProgress = isAnalyzing;
        if (this.analysisInProgress) {
            // Debounce short analysis times.
            setTimeout(() => {
                // When the timeout fires, we need to check analysisInProgress again in case
                // analysis has already finished.
                if (this.analysisInProgress && !this.analyzingPromise) {
                    vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, title: "Analyzing…" }, () => {
                        if (!this.analyzingPromise) // Re-check, since we don't know how long before this callback is called.
                            this.analyzingPromise = new utils_1.PromiseCompleter();
                        return this.analyzingPromise.promise;
                    });
                }
            }, 100);
        }
        else {
            if (this.analyzingPromise) {
                this.analyzingPromise.resolve();
                this.analyzingPromise = undefined;
            }
        }
    }
}
exports.LspAnalyzerStatusReporter = LspAnalyzerStatusReporter;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LspClosingLabelsDecorations = void 0;
const vs = __webpack_require__(0);
const custom_protocol_1 = __webpack_require__(104);
const fs_1 = __webpack_require__(1);
const closing_labels_decorations_1 = __webpack_require__(135);
class LspClosingLabelsDecorations {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.closingLabels = {};
        this.editors = {};
        this.decorationType = vs.window.createTextEditorDecorationType({
            after: {
                color: new vs.ThemeColor("dart.closingLabels"),
                margin: "2px",
            },
            rangeBehavior: vs.DecorationRangeBehavior.ClosedOpen,
        });
        // tslint:disable-next-line: no-floating-promises
        analyzer.onReady().then(() => {
            this.analyzer.onNotification(custom_protocol_1.PublishClosingLabelsNotification.type, (n) => {
                const filePath = fs_1.fsPath(vs.Uri.parse(n.uri));
                this.closingLabels[filePath] = n;
                // Fire an update if it was for the active document.
                if (vs.window.activeTextEditor
                    && vs.window.activeTextEditor.document
                    && filePath === fs_1.fsPath(vs.window.activeTextEditor.document.uri)) {
                    // Delay this so if we're getting lots of updates we don't flicker.
                    if (this.updateTimeout)
                        clearTimeout(this.updateTimeout);
                    this.updateTimeout = setTimeout(() => this.update(), 500);
                }
            });
        });
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor(() => this.update()));
        this.subscriptions.push(vs.workspace.onDidCloseTextDocument((td) => {
            const filePath = fs_1.fsPath(td.uri);
            delete this.closingLabels[filePath];
        }));
        if (vs.window.activeTextEditor)
            this.update();
    }
    update() {
        const editor = vs.window.activeTextEditor;
        if (!editor || !editor.document)
            return;
        const filePath = fs_1.fsPath(editor.document.uri);
        if (!this.closingLabels[filePath])
            return;
        const decorations = [];
        for (const r of this.closingLabels[filePath].labels) {
            const labelRange = this.analyzer.protocol2CodeConverter.asRange(r.range);
            // Ensure the label we got looks like a sensible range, otherwise the outline info
            // might be stale (eg. we sent two updates, and the outline from in between them just
            // arrived). In this case, we'll just bail and do nothing, assuming a future update will
            // have the correct info.
            const finalCharacterPosition = labelRange.end;
            if (finalCharacterPosition.character < 1)
                return;
            const finalCharacterRange = new vs.Range(finalCharacterPosition.translate({ characterDelta: -1 }), finalCharacterPosition);
            const finalCharacterText = editor.document.getText(finalCharacterRange);
            if (closing_labels_decorations_1.validLastCharacters.indexOf(finalCharacterText) === -1)
                return;
            // Get the end of the line where we'll show the labels.
            const endOfLine = editor.document.lineAt(finalCharacterPosition).range.end;
            const existingDecorationForLine = decorations[endOfLine.line];
            if (existingDecorationForLine) {
                existingDecorationForLine.renderOptions.after.contentText = " // " + r.label + " " + existingDecorationForLine.renderOptions.after.contentText;
            }
            else {
                const dec = {
                    range: new vs.Range(labelRange.start, endOfLine),
                    renderOptions: { after: { contentText: " // " + r.label } },
                };
                decorations[endOfLine.line] = dec;
            }
        }
        this.editors[filePath] = editor;
        editor.setDecorations(this.decorationType, Object.keys(decorations).map((k) => parseInt(k, 10)).map((k) => decorations[k]));
    }
    dispose() {
        for (const editor of Object.values(this.editors)) {
            try {
                editor.setDecorations(this.decorationType, []);
            }
            catch (_a) {
                // It's possible the editor was closed, but there
                // doesn't seem to be a way to tell.
            }
        }
        this.subscriptions.forEach((s) => s.dispose());
    }
}
exports.LspClosingLabelsDecorations = LspClosingLabelsDecorations;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspGoToSuperCommand = void 0;
const vs = __webpack_require__(0);
const utils_1 = __webpack_require__(5);
const editors = __webpack_require__(58);
class LspGoToSuperCommand {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.goToSuper", this.goToSuper, this));
    }
    goToSuper() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const location = yield this.analyzer.getSuper({
                position: this.analyzer.client.code2ProtocolConverter.asPosition(editor.selection.start),
                textDocument: this.analyzer.client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(editor.document),
            });
            if (!location)
                return;
            const codeLocation = this.analyzer.client.protocol2CodeConverter.asLocation(location);
            const elementDocument = yield vs.workspace.openTextDocument(codeLocation.uri);
            const elementEditor = yield vs.window.showTextDocument(elementDocument);
            utils_1.showCode(elementEditor, codeLocation.range, codeLocation.range, codeLocation.range);
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.LspGoToSuperCommand = LspGoToSuperCommand;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Move this to Shared (and remove dependencies on extension/)
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestDiscoverer = void 0;
const test_model_1 = __webpack_require__(61);
const utils_1 = __webpack_require__(3);
const outline_lsp_1 = __webpack_require__(65);
const test_1 = __webpack_require__(57);
const utils_2 = __webpack_require__(6);
class TestDiscoverer {
    constructor(logger, fileTracker, model) {
        this.logger = logger;
        this.model = model;
        this.disposables = [];
        this.disposables.push(fileTracker.onOutline.listen((o) => this.handleOutline(o)));
    }
    handleOutline(outline) {
        const suitePath = utils_1.uriToFilePath(outline.uri);
        if (utils_2.isTestFile(suitePath)) {
            // Force creation of a node.
            const [suite, didCreate] = this.model.getOrCreateSuite(suitePath);
            if (didCreate) {
                const stack = [suite.node];
                let id = 1;
                const visitor = new class extends outline_lsp_1.LspOutlineVisitor {
                    visitUnitTestTest(outline) {
                        this.handleItem(outline, false, super.visitUnitTestTest);
                    }
                    visitUnitTestGroup(outline) {
                        this.handleItem(outline, true, super.visitUnitTestGroup);
                    }
                    handleItem(outline, isGroup, base) {
                        const name = test_1.extractTestNameFromOutline(outline.element.name);
                        if (!name || !outline.element.range)
                            return;
                        if (!test_1.isSimpleTestName(name))
                            return;
                        const range = outline.codeRange || outline.range || (outline.element ? outline.element.range : undefined);
                        const parent = stack[stack.length - 1];
                        const fullName = parent instanceof test_model_1.GroupNode && parent.name
                            ? `${parent.name} ${name}`
                            : name;
                        const item = isGroup
                            ? new test_model_1.GroupNode(suite, parent, id++, fullName, suitePath, range.start.line + 1, range.start.character)
                            : new test_model_1.TestNode(suite, parent, id++, fullName, suitePath, range.start.line + 1, range.start.character);
                        if (item instanceof test_model_1.GroupNode) {
                            suite.storeGroup(item);
                            parent.groups.push(item);
                        }
                        else {
                            suite.storeTest(item);
                            parent.tests.push(item);
                        }
                        if (item instanceof test_model_1.GroupNode)
                            stack.push(item);
                        try {
                            base.bind(this)(outline);
                        }
                        finally {
                            if (item instanceof test_model_1.GroupNode)
                                stack.pop();
                        }
                    }
                }(this.logger);
                visitor.visit(outline.outline);
            }
            this.model.updateNode(suite.node);
            this.model.updateNode();
        }
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.TestDiscoverer = TestDiscoverer;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssistCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(6);
const ranking_code_action_provider_1 = __webpack_require__(109);
class AssistCodeActionProvider {
    constructor(logger, selector, analyzer) {
        this.logger = logger;
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 10;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.Refactor],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!utils_1.isAnalyzableAndInWorkspace(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // refactor (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.Refactor.contains(context.only))
                return undefined;
            try {
                const startOffset = document.offsetAt(range.start);
                const endOffset = document.offsetAt(range.end);
                const assists = yield this.analyzer.editGetAssists({
                    file: fs_1.fsPath(document.uri),
                    length: endOffset - startOffset,
                    offset: startOffset,
                });
                const allAssists = assists.assists.map((assist) => this.convertResult(document, assist));
                return context.only
                    ? allAssists.filter((ca) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(ca.kind); })
                    : allAssists;
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    convertResult(document, change) {
        const title = change.message;
        const kind = ranking_code_action_provider_1.getKindFor(change.id, vscode_1.CodeActionKind.Refactor);
        const action = new vscode_1.CodeAction(title, kind);
        action.command = {
            arguments: [document, change],
            command: "_dart.applySourceChange",
            title,
        };
        return action;
    }
}
exports.AssistCodeActionProvider = AssistCodeActionProvider;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartCompletionItemProvider = void 0;
/* eslint-disable no-underscore-dangle */
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const promises_1 = __webpack_require__(31);
const extension_utils_1 = __webpack_require__(20);
const edit_das_1 = __webpack_require__(107);
const config_1 = __webpack_require__(10);
// TODO: This code has become messy with the SuggestionSet changes. It could do with some refactoring
// (such as creating a mapping from CompletionSuggestion -> x and SuggestionSet -> x, and then x -> CompletionItem).
class DartCompletionItemProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.cachedCompletions = {};
        this.existingImports = {};
        this.disposables.push(analyzer.registerForCompletionAvailableSuggestions((n) => this.storeCompletionSuggestions(n)));
        this.disposables.push(analyzer.registerForCompletionExistingImports((n) => this.storeExistingImports(n)));
    }
    provideCompletionItems(document, position, token, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const line = document.lineAt(position.line).text.slice(0, position.character);
            const nextCharacter = document.getText(new vscode_1.Range(position, position.translate({ characterDelta: 200 }))).trim().substr(0, 1);
            const conf = config_1.config.for(document.uri);
            const enableCommitCharacters = conf.enableCompletionCommitCharacters;
            const insertArgumentPlaceholders = !enableCommitCharacters && conf.insertArgumentPlaceholders && this.shouldAllowArgPlaceholders(line);
            if (!this.shouldAllowCompletion(line, context))
                return;
            const offset = document.offsetAt(position);
            const resp = yield this.analyzer.completionGetSuggestionsResults({
                file: fs_1.fsPath(document.uri),
                offset,
            });
            if (token && token.isCancellationRequested) {
                return undefined;
            }
            const includedResults = resp.results.map((r) => this.convertResult(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, resp, r));
            const cachedResults = yield this.getCachedResults(document, token, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, document.offsetAt(position), resp);
            yield promises_1.resolvedPromise;
            if (token && token.isCancellationRequested) {
                return undefined;
            }
            const allResults = [...includedResults, ...cachedResults];
            return new vscode_1.CompletionList(allResults);
        });
    }
    shouldAllowCompletion(line, context) {
        line = line.trim();
        // Filter out auto triggered completions on certain characters based on the previous
        // characters (eg. to allow completion on " if it's part of an import).
        if (context.triggerKind === vscode_1.CompletionTriggerKind.TriggerCharacter) {
            switch (context.triggerCharacter) {
                case "{":
                    return line.endsWith("${");
                case "'":
                    return line.endsWith("import '") || line.endsWith("export '");
                case "\"":
                    return line.endsWith("import \"") || line.endsWith("export \"");
                case "/":
                case "\\":
                    return line.startsWith("import \"") || line.startsWith("export \"")
                        || line.startsWith("import '") || line.startsWith("export '");
            }
        }
        // Otherwise, allow through.
        return true;
    }
    shouldAllowArgPlaceholders(line) {
        line = line.trim();
        // Disallow args on imports/exports since they're likely show/hide and
        // we only want the function name. This doesn't catch all cases (for ex.
        // where a show/hide is split across multiple lines) but it's better than
        // nothing. We'd need more semantic info to handle this better, and probably
        // this will go away if commit characters is fixed properly.
        if (line.startsWith("import \"") || line.startsWith("export \"")
            || line.startsWith("import '") || line.startsWith("export '")) {
            return false;
        }
        return true;
    }
    storeCompletionSuggestions(notification) {
        if (notification.changedLibraries) {
            for (const completionSet of notification.changedLibraries) {
                this.cachedCompletions[completionSet.id] = completionSet;
            }
        }
        if (notification.removedLibraries) {
            for (const completionSetID of notification.removedLibraries) {
                delete this.cachedCompletions[completionSetID];
            }
        }
    }
    storeExistingImports(notification) {
        const existingImports = notification.imports;
        // Map with key "elementName/elementDeclaringLibraryUri"
        // Value is a set of imported URIs that import that element.
        const alreadyImportedSymbols = {};
        for (const existingImport of existingImports.imports) {
            for (const importedElement of existingImport.elements) {
                // This is the symbol name and declaring library. That is, the
                // library that declares the symbol, not the one that was imported.
                // This wil be the same for an element that is re-exported by other
                // libraries, so we can avoid showing the exact duplicate.
                const elementName = existingImports.elements.strings[existingImports.elements.names[importedElement]];
                const elementDeclaringLibraryUri = existingImports.elements.strings[existingImports.elements.uris[importedElement]];
                const importedUri = existingImports.elements.strings[existingImport.uri];
                const key = `${elementName}/${elementDeclaringLibraryUri}`;
                if (!alreadyImportedSymbols[key])
                    alreadyImportedSymbols[key] = {};
                alreadyImportedSymbols[key][importedUri] = true;
            }
        }
        this.existingImports[notification.file] = alreadyImportedSymbols;
    }
    resolveCompletionItem(item, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!item.suggestion) {
                if (!item.documentation && item._documentation) {
                    item.documentation = item._documentation;
                }
                return item;
            }
            const res = yield this.analyzer.completionGetSuggestionDetails({
                file: item.filePath,
                id: item.suggestionSetID,
                label: item.suggestion.label,
                offset: item.offset,
            });
            if (token && token.isCancellationRequested) {
                return;
            }
            // Rebuild the completion using the additional resolved info.
            return this.createCompletionItemFromSuggestion(item.document, item.offset, item.nextCharacter, item.enableCommitCharacters, item.insertArgumentPlaceholders, item.replacementOffset, item.replacementLength, item.autoImportUri, item.relevance, item.suggestion, res);
        });
    }
    createCompletionItemFromSuggestion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, replacementOffset, replacementLength, displayUri, relevance, suggestion, resolvedResult) {
        const completionItem = this.makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, {
            autoImportUri: displayUri,
            completionText: (resolvedResult && resolvedResult.completion) || suggestion.label,
            defaultArgumentListString: suggestion.defaultArgumentListString,
            defaultArgumentListTextRanges: suggestion.defaultArgumentListTextRanges,
            displayText: suggestion.label,
            elementKind: suggestion.element ? suggestion.element.kind : undefined,
            isDeprecated: false,
            kind: undefined,
            parameterNames: suggestion.parameterNames,
            parameterType: undefined,
            parameters: suggestion.element ? suggestion.element.parameters : undefined,
            relevance,
            replacementLength,
            replacementOffset,
            requiredParameterCount: suggestion.requiredParameterCount,
            returnType: suggestion.element ? suggestion.element.returnType : undefined,
            selectionLength: resolvedResult && resolvedResult.change && resolvedResult.change.selection ? 0 : undefined,
            selectionOffset: resolvedResult && resolvedResult.change && resolvedResult.change.selection ? resolvedResult.change.selection.offset : undefined,
        });
        // Additional edits for the imports.
        if (resolvedResult && resolvedResult.change && resolvedResult.change.edits && resolvedResult.change.edits.length) {
            this.appendAdditionalEdits(completionItem, document, resolvedResult.change);
            if (displayUri)
                completionItem.detail = `Auto import from '${displayUri}'` + (completionItem.detail ? `\n\n${completionItem.detail}` : "");
        }
        // Copy the lazy docs over.
        if (resolvedResult && !completionItem.documentation && completionItem._documentation) {
            completionItem.documentation = completionItem._documentation;
        }
        return completionItem;
    }
    getCachedResults(document, token, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, offset, resp) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!resp.includedSuggestionSets || !resp.includedElementKinds)
                return [];
            const existingImports = resp.libraryFile ? this.existingImports[resp.libraryFile] : undefined;
            // Create a fast lookup for which kinds to include.
            const elementKinds = {};
            resp.includedElementKinds.forEach((k) => elementKinds[k] = true);
            // Create a fast lookup for relevance boosts based on tag string.
            const tagBoosts = {};
            if (resp.includedSuggestionRelevanceTags)
                resp.includedSuggestionRelevanceTags.forEach((r) => tagBoosts[r.tag] = r.relevanceBoost);
            const filePath = fs_1.fsPath(document.uri);
            const suggestionSetResults = [];
            // Keep track of suggestion sets we've seen to avoid included them twice.
            // See https://github.com/dart-lang/sdk/issues/37211.
            const usedSuggestionSets = {};
            // Keep track of items items we've included so we don't show dupes if
            // there are multiple libraries importing the same thing.
            const includedItems = {};
            for (const includedSuggestionSet of resp.includedSuggestionSets) {
                if (usedSuggestionSets[includedSuggestionSet.id])
                    continue;
                // Mark that we've done this one so we don't do it again.
                usedSuggestionSets[includedSuggestionSet.id] = true;
                // Because this work is expensive, we periodically (per suggestion
                // set) yield and check whether cancellation is pending and if so
                // stop and bail out to avoid doing redundant work.
                yield promises_1.resolvedPromise;
                if (token && token.isCancellationRequested) {
                    return [];
                }
                const suggestionSet = this.cachedCompletions[includedSuggestionSet.id];
                if (!suggestionSet) {
                    this.logger.warn(`Suggestion set ${includedSuggestionSet.id} was not available and therefore not included in the completion results`);
                    return [];
                }
                const unresolvedItems = suggestionSet.items
                    .filter((r) => elementKinds[r.element.kind])
                    .filter((suggestion) => {
                    // Check existing imports to ensure we don't already import
                    // this element (note: this exact element from its declaring
                    // library, not just something with the same name). If we do
                    // we'll want to skip it.
                    // Trim back to the . to handle enum values
                    // https://github.com/Dart-Code/Dart-Code/issues/1835
                    const key = `${suggestion.label.split(".")[0]}/${suggestion.declaringLibraryUri}`;
                    const importingUris = existingImports && existingImports[key];
                    // If there are no URIs already importing this, then include it
                    // as an auto-import.
                    if (!importingUris)
                        return true;
                    // Otherwise, it is imported but if it's not by this file, then skip it.
                    if (!importingUris[suggestionSet.uri])
                        return false;
                    // Finally, we're importing a file that has this item, so include
                    // it only if it has not already been included by another imported file.
                    // Unlike the above, we include the Kind here so that things with similar labels
                    // like Constructors+Class are still included.
                    const fullItemKey = `${suggestion.label}/${suggestion.element.kind}/${suggestion.declaringLibraryUri}`;
                    const itemHasAlreadyBeenIncluded = includedItems[fullItemKey];
                    includedItems[fullItemKey] = true;
                    return !itemHasAlreadyBeenIncluded;
                })
                    .map((suggestion) => {
                    // Calculate the relevance for this item.
                    let relevanceBoost = 0;
                    if (suggestion.relevanceTags)
                        suggestion.relevanceTags.forEach((t) => relevanceBoost = Math.max(relevanceBoost, tagBoosts[t] || 0));
                    const completionItem = this.createCompletionItemFromSuggestion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, resp.replacementOffset, resp.replacementLength, undefined, includedSuggestionSet.relevance + relevanceBoost, suggestion, undefined);
                    // Attach additional info that resolve will need.
                    const delayedCompletionItem = Object.assign({ autoImportUri: includedSuggestionSet.displayUri || suggestionSet.uri, document,
                        enableCommitCharacters,
                        filePath,
                        insertArgumentPlaceholders,
                        nextCharacter,
                        offset, relevance: includedSuggestionSet.relevance + relevanceBoost, replacementLength: resp.replacementLength, replacementOffset: resp.replacementOffset, suggestion, suggestionSetID: includedSuggestionSet.id }, completionItem);
                    return delayedCompletionItem;
                });
                suggestionSetResults.push(unresolvedItems);
            }
            return [].concat(...suggestionSetResults);
        });
    }
    convertResult(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, notification, suggestion) {
        return this.makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, {
            completionText: suggestion.completion,
            defaultArgumentListString: suggestion.defaultArgumentListString,
            defaultArgumentListTextRanges: suggestion.defaultArgumentListTextRanges,
            displayText: suggestion.displayText,
            docComplete: suggestion.docComplete,
            elementKind: suggestion.element ? suggestion.element.kind : undefined,
            isDeprecated: suggestion.isDeprecated,
            kind: suggestion.kind,
            parameterNames: suggestion.parameterNames,
            parameterType: suggestion.parameterType,
            parameters: suggestion.element ? suggestion.element.parameters : undefined,
            relevance: suggestion.relevance,
            replacementLength: notification.replacementLength,
            replacementOffset: notification.replacementOffset,
            requiredParameterCount: suggestion.requiredParameterCount,
            returnType: suggestion.returnType || (suggestion.element ? suggestion.element.returnType : undefined),
            selectionLength: suggestion.selectionLength,
            selectionOffset: suggestion.selectionOffset,
        });
    }
    makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, suggestion) {
        const completionItemKind = suggestion.elementKind ? this.getElementKind(suggestion.elementKind) : undefined;
        let label = suggestion.displayText || suggestion.completionText;
        let detail;
        const completionText = new vscode_1.SnippetString();
        let triggerCompletion = false;
        const nextCharacterIsOpenParen = nextCharacter === "(";
        // If element has parameters (METHOD/CONSTRUCTOR/FUNCTION), show its parameters.
        if (suggestion.parameters && completionItemKind !== vscode_1.CompletionItemKind.Property && suggestion.kind !== "OVERRIDE"
            // Don't ever show if there is already a paren! (#969).
            && label.indexOf("(") === -1) {
            label += suggestion.parameters.length === 2 ? "()" : "(…)";
            detail = suggestion.parameters;
            const hasParams = (suggestion.parameterNames && suggestion.parameterNames.length > 0)
                || (insertArgumentPlaceholders && !!suggestion.defaultArgumentListString);
            // Add placeholders for params to the completion.
            if (insertArgumentPlaceholders && hasParams && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                completionText.appendText("(");
                if (suggestion.defaultArgumentListString) {
                    for (const arg of this.extractTabstopDataForNamedArgs(suggestion.defaultArgumentListString, suggestion.defaultArgumentListTextRanges || [])) {
                        const text = suggestion.defaultArgumentListString.substring(arg.start, arg.end);
                        if (arg.tabStop)
                            completionText.appendPlaceholder(text);
                        else
                            completionText.appendText(text);
                    }
                }
                else
                    completionText.appendTabstop(); // Put a tap stop between parens since there are optional args.
                completionText.appendText(")");
            }
            else if (insertArgumentPlaceholders && hasParams && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                const args = suggestion.parameterNames.slice(0, suggestion.requiredParameterCount);
                completionText.appendText("(");
                if (args.length) {
                    completionText.appendPlaceholder(args[0]);
                    for (const arg of args.slice(1)) {
                        completionText.appendText(", ");
                        completionText.appendPlaceholder(arg);
                    }
                }
                else
                    completionText.appendTabstop(0); // Put a tap stop between parens since there are optional args.
                completionText.appendText(")");
            }
            else if (insertArgumentPlaceholders && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                completionText.appendText("()");
            }
            else {
                completionText.appendText(suggestion.completionText);
            }
        }
        else if (suggestion.selectionOffset) {
            const before = suggestion.completionText.slice(0, suggestion.selectionOffset);
            const selection = suggestion.completionText.slice(suggestion.selectionOffset, suggestion.selectionOffset + (suggestion.selectionLength || 0));
            // If we have a selection offset (eg. a place to put the cursor) but not any text to pre-select then
            // pop open the completion to help the user type the value.
            // Only do this if it ends with a space (argument completion), see #730.
            if (!selection && suggestion.completionText.slice(suggestion.selectionOffset - 1, suggestion.selectionOffset) === " ")
                triggerCompletion = true;
            const after = suggestion.completionText.slice(suggestion.selectionOffset + (suggestion.selectionLength || 0));
            completionText.appendText(before);
            if (selection)
                completionText.appendPlaceholder(selection);
            else
                completionText.appendTabstop(0);
            completionText.appendText(after);
        }
        else {
            completionText.appendText(suggestion.completionText);
        }
        // If we're a property, work out the type.
        if (completionItemKind === vscode_1.CompletionItemKind.Property) {
            // Setters appear as methods with one arg (and cause getters to not appear),
            // so treat them both the same and just display with the properties type.
            detail = suggestion.elementKind === "GETTER"
                ? suggestion.returnType
                // See https://github.com/dart-lang/sdk/issues/27747
                : suggestion.parameters ? suggestion.parameters.substring(1, suggestion.parameters.lastIndexOf(" ")) : "";
            // Otherwise, get return type from method.
        }
        else if (suggestion.returnType) {
            detail =
                detail
                    ? detail + " → " + suggestion.returnType
                    : suggestion.returnType;
        }
        else if (suggestion.parameterType) {
            detail = suggestion.parameterType;
        }
        // If we have trailing commas (flutter) they look weird in the list, so trim the off (for display label only).
        if (label.endsWith(","))
            label = label.substr(0, label.length - 1).trim();
        // If we didnt have a CompletionItemKind from our element, base it on the CompletionSuggestionKind.
        // This covers things like Keywords that don't have elements.
        const kind = completionItemKind || (suggestion.kind ? this.getSuggestionKind(suggestion.kind, label) : undefined);
        const docs = extension_utils_1.cleanDartdoc(suggestion.docComplete);
        const completion = new vscode_1.CompletionItem(label, kind);
        completion.filterText = label.split("(")[0]; // Don't ever include anything after a ( in filtering.
        if (suggestion.isDeprecated)
            completion.tags = [vs.CompletionItemTag.Deprecated];
        completion.detail = detail;
        completion._documentation = docs ? new vscode_1.MarkdownString(docs) : undefined;
        completion.insertText = completionText;
        completion.keepWhitespace = true;
        completion.range = {
            inserting: new vscode_1.Range(document.positionAt(suggestion.replacementOffset), document.positionAt(Math.min(offset, suggestion.replacementOffset + suggestion.replacementLength))),
            replacing: new vscode_1.Range(document.positionAt(suggestion.replacementOffset), document.positionAt(suggestion.replacementOffset + suggestion.replacementLength)),
        };
        if (enableCommitCharacters)
            completion.commitCharacters = this.getCommitCharacters(suggestion.kind);
        const triggerCompletionsFor = ["import '';"];
        if (triggerCompletionsFor.indexOf(label) !== -1)
            triggerCompletion = true;
        // Handle folders in imports better.
        if (suggestion.kind === "IMPORT" && label.endsWith("/"))
            triggerCompletion = true;
        if (triggerCompletion) {
            completion.command = {
                command: "editor.action.triggerSuggest",
                title: "Suggest",
            };
        }
        // Relevance is a number, highest being best. Code sorts by text, so subtract from a large number so that
        // a text sort will result in the correct order.
        // 555 -> 999455
        //  10 -> 999990
        //   1 -> 999999
        completion.sortText = (1000000 - suggestion.relevance).toString();
        return completion;
    }
    /// Argument info comes through as a stringle string like "a: null, b: null"
    /// and an array of ints that are offset/length pairs. [3,4,12,4] means
    /// characters 3-7 and 12 - 16 are tabstops.
    ///
    /// To process this more easily, we first convert this into an array like:
    ///
    /// ```
    /// [
    ///   { start: 0, end: 3, tabStop: false },
    ///   { start: 3, end: 7, tabStop: true },
    ///   { start: 7, end: 12, tabStop: false },
    ///   { start: 12, end: 16, tabStop: true },
    /// ]
    /// ```
    extractTabstopDataForNamedArgs(argListString, argListTextRanges) {
        const ranges = [];
        let currentIndex = 0;
        // For each range, push anything that comes before it, and it.
        for (const range of this.extractOffsetLengthPairs(argListTextRanges)) {
            ranges.push({ start: currentIndex, end: range[0], tabStop: false });
            ranges.push({ start: range[0], end: range[1], tabStop: true });
            currentIndex = range[1];
        }
        // Then push anything left at the end.
        if (currentIndex < argListString.length)
            ranges.push({ start: currentIndex, end: argListString.length, tabStop: false });
        return ranges;
    }
    extractOffsetLengthPairs(numberPairs) {
        const pairs = [];
        for (let i = 0; i < numberPairs.length - 1; i += 2) {
            pairs.push([numberPairs[i], numberPairs[i] + numberPairs[i + 1]]);
        }
        return pairs;
    }
    getSuggestionKind(kind, label) {
        switch (kind) {
            case "ARGUMENT_LIST":
                return vscode_1.CompletionItemKind.Variable;
            case "IMPORT":
                return label.startsWith("dart:")
                    ? vscode_1.CompletionItemKind.Module
                    : path.extname(label.toLowerCase()) === ".dart"
                        ? vscode_1.CompletionItemKind.File
                        : vscode_1.CompletionItemKind.Folder;
            case "IDENTIFIER":
                return vscode_1.CompletionItemKind.Variable;
            case "INVOCATION":
                return vscode_1.CompletionItemKind.Method;
            case "KEYWORD":
                return vscode_1.CompletionItemKind.Keyword;
            case "NAMED_ARGUMENT":
                return vscode_1.CompletionItemKind.Variable;
            case "OPTIONAL_ARGUMENT":
                return vscode_1.CompletionItemKind.Variable;
            case "PARAMETER":
                return vscode_1.CompletionItemKind.Value;
        }
        return undefined;
    }
    getElementKind(kind) {
        switch (kind) {
            case "CLASS":
            case "CLASS_TYPE_ALIAS":
                return vscode_1.CompletionItemKind.Class;
            case "COMPILATION_UNIT":
                return vscode_1.CompletionItemKind.Module;
            case "CONSTRUCTOR":
            case "CONSTRUCTOR_INVOCATION":
                return vscode_1.CompletionItemKind.Constructor;
            case "ENUM":
                return vscode_1.CompletionItemKind.Enum;
            case "ENUM_CONSTANT":
                return vscode_1.CompletionItemKind.EnumMember;
            case "FIELD":
                return vscode_1.CompletionItemKind.Field;
            case "FILE":
                return vscode_1.CompletionItemKind.File;
            case "FUNCTION":
            case "FUNCTION_TYPE_ALIAS":
                return vscode_1.CompletionItemKind.Function;
            case "GETTER":
                return vscode_1.CompletionItemKind.Property;
            case "LABEL":
            case "LIBRARY":
                return vscode_1.CompletionItemKind.Module;
            case "LOCAL_VARIABLE":
                return vscode_1.CompletionItemKind.Variable;
            case "METHOD":
                return vscode_1.CompletionItemKind.Method;
            case "PARAMETER":
            case "PREFIX":
                return vscode_1.CompletionItemKind.Variable;
            case "SETTER":
                return vscode_1.CompletionItemKind.Property;
            case "TOP_LEVEL_VARIABLE":
            case "TYPE_PARAMETER":
                return vscode_1.CompletionItemKind.Variable;
            case "UNIT_TEST_GROUP":
                return vscode_1.CompletionItemKind.Module;
            case "UNIT_TEST_TEST":
                return vscode_1.CompletionItemKind.Method;
            case "UNKNOWN":
                return vscode_1.CompletionItemKind.Value;
        }
        return undefined;
    }
    getCommitCharacters(kind) {
        switch (kind) {
            case "IDENTIFIER":
            case "INVOCATION":
                return [".", ",", "(", "["];
        }
        return undefined;
    }
    appendAdditionalEdits(completionItem, document, change) {
        if (!change)
            return undefined;
        // VS Code expects offsets to be based on the original document, but the analysis server provides
        // them assuming all previous edits have already been made. This means if the server provides us a
        // set of edits where any edits offset is *equal to or greater than* a previous edit, it will do the wrong thing.
        // If this happens; we will fall back to sequential edits and write a warning.
        const hasProblematicEdits = edit_das_1.hasOverlappingEdits(change);
        if (hasProblematicEdits) {
            this.logger.error("Unable to insert imports because of overlapping edits from the server.");
            vs.window.showErrorMessage(`Unable to insert imports because of overlapping edits from the server`);
            return undefined;
        }
        const filePath = fs_1.fsPath(document.uri);
        const thisFilesEdits = change.edits.filter((e) => e.file === filePath);
        const otherFilesEdits = change.edits.filter((e) => e.file !== filePath);
        if (thisFilesEdits.length) {
            completionItem.additionalTextEdits = utils_1.flatMap(thisFilesEdits, (edit) => edit.edits.map((edit) => {
                const range = new vs.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length));
                return new vs.TextEdit(range, edit.replacement);
            }));
        }
        if (otherFilesEdits.length) {
            const filteredSourceChange = {
                edits: otherFilesEdits,
                id: change.id,
                linkedEditGroups: [],
                message: change.message,
                selection: change.selection,
            };
            completionItem.command = {
                arguments: [document, filteredSourceChange],
                command: "_dart.applySourceChange",
                title: "Automatically add imports",
            };
        }
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.DartCompletionItemProvider = DartCompletionItemProvider;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartDocumentSymbolProvider = void 0;
const vscode_1 = __webpack_require__(0);
const promises_1 = __webpack_require__(31);
const utils_1 = __webpack_require__(5);
const analyzer_das_1 = __webpack_require__(50);
class DartDocumentSymbolProvider {
    constructor(logger, fileTracker) {
        this.logger = logger;
        this.fileTracker = fileTracker;
    }
    provideDocumentSymbols(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const outline = yield promises_1.waitFor(() => this.fileTracker.getOutlineFor(document.uri), 500, 60000, token);
            if (token.isCancellationRequested || !outline || !outline.children || !outline.children.length)
                return;
            return outline.children.map((r) => this.convertResult(document, r));
        });
    }
    convertResult(document, outline) {
        const name = outline.element.name
            ? outline.element.name
            : (outline.element.kind === "EXTENSION" ? "<unnamed extension>" : "<unnamed>");
        const location = outline.element.location || outline;
        const symbol = new vscode_1.DocumentSymbol(name, this.getDetail(outline.element), analyzer_das_1.getSymbolKindForElementKind(this.logger, outline.element.kind), this.getCodeOffset(document, outline), utils_1.toRange(document, location.offset, location.length));
        // eslint-disable-next-line no-bitwise
        if (outline.element.flags & 0x20)
            symbol.tags = [vscode_1.SymbolTag.Deprecated];
        if (outline.children && outline.children.length) {
            symbol.children = outline.children.filter(this.shouldShow).map((r) => this.convertResult(document, r));
        }
        return symbol;
    }
    shouldShow(outline) {
        // Don't show these (#656).
        if (outline.element.kind === "CONSTRUCTOR_INVOCATION" || outline.element.kind === "FUNCTION_INVOCATION")
            return false;
        return true;
    }
    getDetail(element) {
        let label = "";
        if (element.parameters)
            label += element.parameters;
        if (element.returnType)
            label += " → " + element.returnType;
        return label.trim();
    }
    getCodeOffset(document, outline) {
        return utils_1.toRange(document, outline.codeOffset || outline.offset, outline.codeLength || outline.length);
    }
}
exports.DartDocumentSymbolProvider = DartDocumentSymbolProvider;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartFoldingProvider = void 0;
const vscode_1 = __webpack_require__(0);
class DartFoldingProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideFoldingRanges(document, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Wait for any current analysis to complete (eg. if we've just opened a project it
            // may take a while to get the results).
            yield this.analyzer.client.currentAnalysis;
            if (token && token.isCancellationRequested)
                return;
            // Wait up to another few seconds after analysis completed (it might be that we opened a new
            // file and there was no analysis, in which case we're just waiting for the server to process
            // the newly added subscription and send results).
            let foldingRegions;
            for (let i = 0; i < 5; i++) {
                foldingRegions = this.analyzer.fileTracker.getFoldingRegionsFor(document.uri);
                if (foldingRegions)
                    break;
                yield new Promise((resolve) => setTimeout(resolve, i * 1000).unref());
                if (token && token.isCancellationRequested)
                    return;
            }
            if (token.isCancellationRequested || !foldingRegions)
                return;
            return foldingRegions.map((f) => new vscode_1.FoldingRange(document.positionAt(f.offset).line, document.positionAt(f.offset + f.length).line, this.getKind(f.kind)));
        });
    }
    getKind(kind) {
        switch (kind) {
            case "FILE_HEADER":
            case "DOCUMENTATION_COMMENT":
                return vscode_1.FoldingRangeKind.Comment;
            case "DIRECTIVES":
                return vscode_1.FoldingRangeKind.Imports;
        }
    }
}
exports.DartFoldingProvider = DartFoldingProvider;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartFormattingEditProvider = void 0;
const minimatch = __webpack_require__(251);
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const config_1 = __webpack_require__(10);
class DartFormattingEditProvider {
    constructor(logger, analyzer, context) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.context = context;
        this.registeredFormatters = [];
        this.formatterRegisterFuncs = [];
        vscode_1.workspace.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration("dart.enableSdkFormatter")) {
                if (config_1.config.enableSdkFormatter)
                    this.registerAllFormatters();
                else
                    this.unregisterAllFormatters();
            }
        });
    }
    registerDocumentFormatter(filter) {
        this.registerFormatter(() => vscode_1.languages.registerDocumentFormattingEditProvider(filter, this));
    }
    registerTypingFormatter(filter, firstTriggerCharacter, ...moreTriggerCharacters) {
        this.registerFormatter(() => vscode_1.languages.registerOnTypeFormattingEditProvider(filter, this, firstTriggerCharacter, ...moreTriggerCharacters));
    }
    registerFormatter(reg) {
        const registerAndTrack = () => this.registeredFormatters.push(reg());
        // Register the formatter immediately if enabled.
        if (config_1.config.enableSdkFormatter)
            registerAndTrack();
        // Add it to our list so we can re-register later..
        this.formatterRegisterFuncs.push(registerAndTrack);
    }
    registerAllFormatters() {
        for (const formatterReg of this.formatterRegisterFuncs) {
            formatterReg();
        }
    }
    unregisterAllFormatters() {
        this.registeredFormatters.forEach((s) => s.dispose());
        this.registeredFormatters.length = 0;
    }
    provideDocumentFormattingEdits(document, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.doFormat(document, true); // await is important for catch to work.
            }
            catch (_a) {
                if (!this.context.hasWarnedAboutFormatterSyntaxLimitation) {
                    this.context.hasWarnedAboutFormatterSyntaxLimitation = true;
                    vscode_1.window.showInformationMessage("The Dart formatter will not run if the file has syntax errors");
                }
                return undefined;
            }
        });
    }
    provideOnTypeFormattingEdits(document, position, ch, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.doFormat(document, false);
            }
            catch (_a) {
                return undefined;
            }
        });
    }
    doFormat(document, doLogError = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.shouldFormat(document))
                return undefined;
            try {
                const resp = yield this.analyzer.editFormat({
                    file: fs_1.fsPath(document.uri),
                    lineLength: config_1.config.for(document.uri).lineLength,
                    selectionLength: 0,
                    selectionOffset: 0,
                });
                if (resp.edits.length === 0)
                    return undefined;
                else
                    return resp.edits.map((e) => this.convertData(document, e));
            }
            catch (e) {
                if (doLogError)
                    this.logger.error(e);
                throw e;
            }
        });
    }
    shouldFormat(document) {
        if (!document || !document.uri || document.uri.scheme !== "file")
            return false;
        const resourceConf = config_1.config.for(document.uri);
        const path = fs_1.fsPath(document.uri);
        return undefined === resourceConf.doNotFormat.find((p) => minimatch(path, p, { dot: true }));
    }
    convertData(document, edit) {
        return new vscode_1.TextEdit(new vscode_1.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length)), edit.replacement);
    }
    dispose() {
        this.unregisterAllFormatters();
    }
}
exports.DartFormattingEditProvider = DartFormattingEditProvider;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(2)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(252)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var concatMap = __webpack_require__(253);
var balanced = __webpack_require__(254);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),
/* 253 */
/***/ (function(module, exports) {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DartDocumentHighlightProvider = void 0;
const vscode_1 = __webpack_require__(0);
class DartDocumentHighlightProvider {
    constructor(fileTracker) {
        this.fileTracker = fileTracker;
    }
    provideDocumentHighlights(document, position, token) {
        const offset = document.offsetAt(position);
        const occurrences = this.fileTracker.getOccurrencesFor(document.uri);
        if (!occurrences)
            return;
        for (const occurrence of occurrences) {
            // If an occurence spans our position, then we don't need to look at any others.
            if (occurrence.offsets.find((o) => o <= offset && o + occurrence.length >= offset)) {
                return occurrence.offsets.map((o) => new vscode_1.DocumentHighlight(new vscode_1.Range(document.positionAt(o), document.positionAt(o + occurrence.length))));
            }
        }
    }
}
exports.DartDocumentHighlightProvider = DartDocumentHighlightProvider;


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartHoverProvider = void 0;
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const extension_utils_1 = __webpack_require__(20);
class DartHoverProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
    }
    provideHover(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield this.analyzer.analysisGetHover({
                    file: fs_1.fsPath(document.uri),
                    offset: document.offsetAt(position),
                });
                if (token.isCancellationRequested || resp.hovers.length === 0)
                    return;
                const hover = resp.hovers[0];
                const data = this.getHoverData(document.uri, hover);
                if (!data)
                    return;
                const range = new vscode_1.Range(document.positionAt(hover.offset), document.positionAt(hover.offset + hover.length));
                return new vscode_1.Hover([{ language: "dart", value: data.displayString }, data.documentation || undefined], range.isSingleLine ? range : undefined);
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    getHoverData(documentUri, hover) {
        if (!hover.elementDescription)
            return undefined;
        // Import prefix tooltips are not useful currently.
        // https://github.com/dart-lang/sdk/issues/32735
        if (hover.elementKind === "import prefix")
            return undefined;
        const elementDescription = hover.elementDescription;
        const dartdoc = hover.dartdoc;
        const propagatedType = hover.propagatedType;
        let displayString = "";
        if (elementDescription)
            displayString += (hover.isDeprecated ? "(deprecated) " : "") + `${elementDescription}\n`;
        if (propagatedType)
            displayString += `propogated type: ${propagatedType.trim()}`;
        let documentation = extension_utils_1.cleanDartdoc(dartdoc);
        const containingLibraryName = hover.containingLibraryName;
        if (containingLibraryName)
            documentation = `*${containingLibraryName}*\n\n` + documentation;
        return {
            displayString: displayString.trim(),
            documentation: documentation.trim(),
        };
    }
}
exports.DartHoverProvider = DartHoverProvider;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartImplementationProvider = void 0;
const vs = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const utils_2 = __webpack_require__(5);
const outline_1 = __webpack_require__(129);
class DartImplementationProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideImplementation(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Try to use the Outline data to snap our location to a node.
            // For example in:
            //
            //     void b();
            //
            // The search.getTypeHierarchy call will only work over "b" but by using outline we
            // can support the whole "void b();".
            const outlineNode = outline_1.findNearestOutlineNode(this.analyzer.fileTracker, document, position, true);
            const offset = outlineNode && outlineNode.element && outlineNode.element.location
                ? outlineNode.element.location.offset
                : document.offsetAt(position);
            const hierarchy = yield this.analyzer.client.searchGetTypeHierarchy({
                file: fs_1.fsPath(document.uri),
                offset,
            });
            if (token.isCancellationRequested || !hierarchy || !hierarchy.hierarchyItems || !hierarchy.hierarchyItems.length || hierarchy.hierarchyItems.length === 1)
                return;
            // Find the element we started with, since we only want implementations (not super classes).
            const currentItem = hierarchy.hierarchyItems.find((h) => {
                const elm = h.memberElement || h.classElement;
                return elm.location && elm.location.offset <= offset && elm.location.offset + elm.location.length >= offset;
            })
                // If we didn't find the element when we might have been at a call site, so we'll have to start
                // at the root.
                || hierarchy.hierarchyItems[0];
            const isClass = !currentItem.memberElement;
            function getDescendants(item) {
                return [
                    ...item.subclasses.map((i) => hierarchy.hierarchyItems[i]),
                    ...utils_1.flatMap(item.subclasses, (i) => getDescendants(hierarchy.hierarchyItems[i])),
                ];
            }
            const descendants = getDescendants(currentItem)
                .map((d) => isClass ? d.classElement : d.memberElement)
                .filter(utils_1.notUndefined);
            const locations = [];
            for (const element of descendants) {
                if (!element.location)
                    continue;
                const range = utils_2.toRange(yield vs.workspace.openTextDocument(element.location.file), element.location.offset, element.location.length);
                locations.push(new vs.Location(vs.Uri.file(element.location.file), range));
            }
            return locations;
        });
    }
}
exports.DartImplementationProvider = DartImplementationProvider;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DartLanguageConfiguration = void 0;
const vscode_1 = __webpack_require__(0);
class DartLanguageConfiguration {
    constructor() {
        this.onEnterRules = [
            {
                // Triple-slash with space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "/// " },
                beforeText: /^\s*\/\/\/ /,
            },
            {
                // Triple-slash without space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "///" },
                beforeText: /^\s*\/\/\//,
            },
            {
                // When between "/** | */" this puts a " * " in but also pushes the "*/" down to next line.
                action: { indentAction: vscode_1.IndentAction.IndentOutdent, appendText: " * " },
                afterText: /^\s*\*\/$/,
                beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
            },
            {
                // When after "/**" will put a " * " in (like above, but where there's no "*/" to push down).
                action: { indentAction: vscode_1.IndentAction.None, appendText: " * " },
                beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
            },
            {
                // Continue " * " when on a line already start with this.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "* " },
                beforeText: /^(\t|(\ \ ))*\ \*(\ ([^\*]|\*(?!\/))*)?$/,
            },
            {
                // After "*/" we need to remove the indent.
                action: { indentAction: vscode_1.IndentAction.None, removeText: 1 },
                beforeText: /^(\t|(\ \ ))*\ \*\/\s*$/,
            },
        ];
    }
}
exports.DartLanguageConfiguration = DartLanguageConfiguration;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartReferenceProvider = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const utils_2 = __webpack_require__(5);
class DartReferenceProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideReferences(document, position, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we want to include the decleration, kick off a request for that.
            const definitions = context.includeDeclaration
                ? yield this.provideDefinition(document, position, token)
                : undefined;
            const resp = yield this.analyzer.searchFindElementReferencesResults({
                file: fs_1.fsPath(document.uri),
                includePotential: true,
                offset: document.offsetAt(position),
            });
            if (token && token.isCancellationRequested)
                return;
            const locations = resp.results.map((result) => new vscode_1.Location(vscode_1.Uri.file(result.location.file), utils_2.toRangeOnLine(result.location)));
            return definitions
                ? locations.concat(definitions.map((dl) => new vscode_1.Location(dl.targetUri, dl.targetRange)))
                : locations;
        });
    }
    provideDefinition(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.analyzer.analysisGetNavigation({
                file: fs_1.fsPath(document.uri),
                length: 0,
                offset: document.offsetAt(position),
            });
            if (token && token.isCancellationRequested)
                return;
            const definitions = utils_1.flatMap(resp.regions, (region) => region.targets.map((targetIndex) => {
                const target = resp.targets[targetIndex];
                // HACK: We sometimes get a startColumn of 0 (should be 1-based). Just treat this as 1 for now.
                //     See https://github.com/Dart-Code/Dart-Code/issues/200
                if (target.startColumn === 0)
                    target.startColumn = 1;
                return {
                    originSelectionRange: utils_2.toRange(document, region.offset, region.length),
                    targetRange: utils_2.toRangeOnLine(target),
                    targetUri: vscode_1.Uri.file(resp.files[target.fileIndex]),
                };
            }));
            // For some locations (for example on the "var" keyword ), we'll get multiple results
            // where some of them are the location we invoked at, or the name of the variable. If
            // there are any results that are on a different line/different file to where we were
            // invoked, return only those. If the only results are on the same line of the same
            // file then just return them all.
            const definitionsOnOtherLines = definitions
                .filter((d) => fs_1.fsPath(d.targetUri) !== fs_1.fsPath(document.uri)
                || d.targetRange.start.line !== position.line);
            return definitionsOnOtherLines.length ? definitionsOnOtherLines : definitions;
        });
    }
}
exports.DartReferenceProvider = DartReferenceProvider;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartRenameProvider = void 0;
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(5);
const channels = __webpack_require__(108);
class DartRenameProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideRenameEdits(document, position, newName, token) {
        return this.doRename(document, position, newName, token);
    }
    prepareRename(document, position, token) {
        return this.getLocation(document, position, token);
    }
    doRename(document, position, newName, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const outputChannel = channels.getChannel("Refactorings");
            outputChannel.appendLine("");
            const resp = yield this.analyzer.editGetRefactoring({
                file: fs_1.fsPath(document.uri),
                kind: "RENAME",
                length: 1,
                offset: document.offsetAt(position),
                options: {
                    newName,
                },
                validateOnly: false,
            });
            if (token && token.isCancellationRequested) {
                outputChannel.appendLine("[INFO] Rename cancelled.");
                return;
            }
            const workspaceEdit = new vscode_1.WorkspaceEdit();
            if (resp.change && resp.change.message)
                outputChannel.appendLine(`[INFO] ${resp.change.message}…`);
            this.handleProblem(resp.initialProblems
                .concat(resp.optionsProblems)
                .concat(resp.finalProblems), outputChannel);
            const promises = [];
            if (resp.change) {
                resp.change.edits.forEach((changeEdit) => {
                    changeEdit.edits.forEach((fileEdit) => {
                        const uri = vscode_1.Uri.file(changeEdit.file);
                        const promise = vscode_1.workspace.openTextDocument(uri);
                        promises.push(promise.then((document) => workspaceEdit.replace(uri, new vscode_1.Range(document.positionAt(fileEdit.offset), document.positionAt(fileEdit.offset + fileEdit.length)), fileEdit.replacement)));
                    });
                });
            }
            // TODO: This class is inconsistent with other refactors (which are silent when they work, for ex).
            // We should review what we can extract share (though note that this method must return the edit whereas
            // the other refactors apply them).
            // Wait all openTextDocument to finish
            yield Promise.all(promises);
            if (token && token.isCancellationRequested) {
                outputChannel.appendLine("[INFO] Rename cancelled.");
                return;
            }
            outputChannel.appendLine("[INFO] Rename successful.");
            return workspaceEdit;
        });
    }
    handleProblem(problems, outputChannel) {
        // Log all in output channel.
        problems.forEach((problem) => outputChannel.appendLine(`[${problem.severity}] ${problem.message}`));
        const errors = problems
            .filter((p) => p.severity !== "INFO" && p.severity !== "WARNING")
            .sort((p1, p2) => p2.severity.localeCompare(p1.severity));
        if (errors.length !== 0) {
            outputChannel.appendLine("[INFO] Rename aborted.");
            throw errors[0].message;
        }
    }
    getLocation(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.analyzer.editGetRefactoring({
                file: fs_1.fsPath(document.uri),
                kind: "RENAME",
                length: 0,
                offset: document.offsetAt(position),
                validateOnly: true,
            });
            if (token && token.isCancellationRequested)
                return;
            if (!resp.feedback)
                throw new Error("You cannot rename this element.");
            const feedback = resp.feedback;
            // The dart server returns -1 when the old name doesn't exist (for ex. renaming an unprefixed import to add a prefix)
            // so we use a zero-character range at the requested position in this case.
            const range = feedback.offset === -1
                ? new vscode_1.Range(position, position)
                : utils_1.toRange(document, feedback.offset, feedback.length);
            if (feedback) {
                return {
                    placeholder: feedback.oldName,
                    range,
                };
            }
            else {
                const fatalProblems = resp.initialProblems
                    .concat(resp.optionsProblems)
                    .concat(resp.finalProblems)
                    .filter((p) => p.severity === "FATAL");
                if (fatalProblems && fatalProblems.length) {
                    throw new Error(fatalProblems[0].message);
                }
                else {
                    throw new Error("This rename is not supported.");
                }
            }
        });
    }
}
exports.DartRenameProvider = DartRenameProvider;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartSignatureHelpProvider = void 0;
const vs = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const extension_utils_1 = __webpack_require__(20);
class DartSignatureHelpProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideSignatureHelp(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield this.analyzer.analysisGetSignature({
                    file: fs_1.fsPath(document.uri),
                    offset: document.offsetAt(position),
                });
                if (token && token.isCancellationRequested)
                    return undefined;
                const sig = new vs.SignatureInformation(this.getSignatureLabel(resp), new vs.MarkdownString(extension_utils_1.cleanDartdoc(resp.dartdoc)));
                sig.parameters = resp.parameters.map((p) => new vs.ParameterInformation(this.getLabel(p)));
                const sigs = new vs.SignatureHelp();
                sigs.signatures = [sig];
                sigs.activeSignature = 0;
                // TODO: This isn't implemented in the server yet.
                sigs.activeParameter = -1; // resp.selectedParameterIndex;
                return sigs;
            }
            catch (_a) {
                return undefined;
            }
        });
    }
    getSignatureLabel(resp) {
        const req = resp.parameters.filter((p) => p.kind === "REQUIRED" || p.kind === "REQUIRED_POSITIONAL");
        const opt = resp.parameters.filter((p) => p.kind === "OPTIONAL" || p.kind === "OPTIONAL_POSITIONAL");
        const named = resp.parameters.filter((p) => p.kind === "NAMED" || p.kind === "OPTIONAL_NAMED" || p.kind === "REQUIRED_NAMED");
        const params = [];
        if (req.length)
            params.push(req.map(this.getLabel).join(", "));
        if (opt.length)
            params.push("[" + opt.map(this.getLabel).join(", ") + "]");
        if (named.length)
            params.push("{" + named.map(this.getLabel).join(", ") + "}");
        return `${resp.name}(${params.join(", ")})`;
    }
    getLabel(p) {
        const def = p.defaultValue
            ? ` = ${p.defaultValue}`
            : "";
        const prefix = p.kind === "REQUIRED_NAMED" ? "required " : "";
        return `${prefix}${p.type} ${p.name}${def}`;
    }
}
exports.DartSignatureHelpProvider = DartSignatureHelpProvider;


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartWorkspaceSymbolProvider = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(5);
const analyzer_das_1 = __webpack_require__(50);
class DartWorkspaceSymbolProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.badChars = new RegExp("[^0-9a-z\-]", "gi");
    }
    provideWorkspaceSymbols(query, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (query.length === 0)
                return undefined;
            // Turn query into a case-insensitive fuzzy search.
            const pattern = ".*" + query.replace(this.badChars, "").split("").map((c) => `[${c.toUpperCase()}${c.toLowerCase()}]`).join(".*") + ".*";
            const results = yield this.analyzer.searchGetElementDeclarations({ pattern, maxResults: 500 });
            if (token && token.isCancellationRequested)
                return;
            return results.declarations.map((d) => this.convertWorkspaceResult(d, results.files[d.fileIndex]));
        });
    }
    resolveWorkspaceSymbol(symbol, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(symbol instanceof PartialSymbolInformation))
                return undefined;
            const document = yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(symbol.locationData.file));
            symbol.location = new vscode_1.Location(document.uri, utils_1.toRange(document, symbol.locationData.offset, symbol.locationData.length));
            return symbol;
        });
    }
    convertWorkspaceResult(result, file) {
        const nameSuffix = result.parameters ? (result.parameters === "()" ? "()" : "(…)") : "";
        const symbol = new PartialSymbolInformation(result.name + nameSuffix, analyzer_das_1.getSymbolKindForElementKind(this.logger, result.kind), result.className || "", 
        // HACK: Work around the incorrect typing in VS Code with !
        // https://github.com/microsoft/vscode/issues/69558
        new vscode_1.Location(vscode_1.Uri.file(file), undefined), {
            file,
            length: result.codeLength,
            // Fall back to offset when the server gives us a bad codeOffset
            // https://github.com/dart-lang/sdk/issues/39192.
            offset: result.codeOffset || result.offset,
        });
        return symbol;
    }
}
exports.DartWorkspaceSymbolProvider = DartWorkspaceSymbolProvider;
class PartialSymbolInformation extends vscode_1.SymbolInformation {
    constructor(name, kind, containerName, location, locationData) {
        super(name, kind, containerName, location);
        this.locationData = locationData;
    }
}


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DartDebugAdapterDescriptorFactory = void 0;
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const debug_1 = __webpack_require__(264);
class DartDebugAdapterDescriptorFactory {
    constructor(logger, extensionContext) {
        this.logger = logger;
        this.extensionContext = extensionContext;
    }
    createDebugAdapterDescriptor(session, executable) {
        const debuggerName = debug_1.getDebugAdapterName(session.configuration.debuggerType);
        this.logger.info(`Using ${debuggerName} debugger for ${enums_1.DebuggerType[session.configuration.debuggerType]}`);
        if (process.env.DART_CODE_USE_DEBUG_SERVERS) {
            const port = debug_1.getDebugAdapterPort(debuggerName);
            this.logger.info(`Running debugger in server mode on port ${port} because DART_CODE_USE_DEBUG_SERVERS is set`);
            return new vscode_1.DebugAdapterServer(port);
        }
        const args = [this.extensionContext.asAbsolutePath(constants_1.debugAdapterPath), debuggerName];
        this.logger.info(`Running debugger via node with ${args.join("    ")}`);
        return new vscode_1.DebugAdapterExecutable("node", args);
    }
}
exports.DartDebugAdapterDescriptorFactory = DartDebugAdapterDescriptorFactory;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getDebugAdapterPort = exports.getDebugAdapterName = void 0;
const enums_1 = __webpack_require__(8);
function getDebugAdapterName(debugType) {
    let debuggerName;
    switch (debugType) {
        case enums_1.DebuggerType.Flutter:
            debuggerName = "flutter";
            break;
        case enums_1.DebuggerType.FlutterTest:
            debuggerName = "flutter_test";
            break;
        case enums_1.DebuggerType.Web:
            debuggerName = "web";
            break;
        case enums_1.DebuggerType.WebTest:
            debuggerName = "web_test";
            break;
        case enums_1.DebuggerType.Dart:
            debuggerName = "dart";
            break;
        case enums_1.DebuggerType.PubTest:
            debuggerName = "dart_test";
            break;
        default:
            throw new Error(`Unknown debugger type: ${debugType}`);
    }
    return debuggerName;
}
exports.getDebugAdapterName = getDebugAdapterName;
function getDebugAdapterPort(debuggerName) {
    const debugAdapterNames = [
        "flutter",
        "flutter_test",
        "web",
        "web_test",
        "dart",
        "dart_test",
    ];
    const index = debugAdapterNames.indexOf(debuggerName);
    if (index === -1)
        throw new Error(`Unknown debugger type: ${debuggerName}`);
    return 4711 + index;
}
exports.getDebugAdapterPort = getDebugAdapterPort;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamicDebugConfigProvider = exports.InitialLaunchJsonDebugConfigProvider = exports.DebugConfigProvider = void 0;
/* eslint-disable @typescript-eslint/tslint/config */
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const utils_1 = __webpack_require__(139);
const utils_2 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const utils_3 = __webpack_require__(5);
const debug_1 = __webpack_require__(106);
const logging_1 = __webpack_require__(130);
const config_1 = __webpack_require__(10);
const project_1 = __webpack_require__(51);
const webdev_1 = __webpack_require__(266);
const utils_4 = __webpack_require__(6);
const processes_1 = __webpack_require__(15);
class DebugConfigProvider {
    constructor(logger, wsContext, analytics, pubGlobal, testTreeModel, daemon, deviceManager, dartCapabilities, flutterCapabilities) {
        this.logger = logger;
        this.wsContext = wsContext;
        this.analytics = analytics;
        this.pubGlobal = pubGlobal;
        this.testTreeModel = testTreeModel;
        this.daemon = daemon;
        this.deviceManager = deviceManager;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
    }
    resolveDebugConfiguration(folder, debugConfig, token) {
        debugConfig.type = debugConfig.type || "dart";
        debugConfig.request = debugConfig.request || "launch";
        return debugConfig;
    }
    resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfig, token) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const logger = this.logger;
            const openFile = vscode_1.window.activeTextEditor && vscode_1.window.activeTextEditor.document && vscode_1.window.activeTextEditor.document.uri.scheme === "file"
                ? fs_1.fsPath(vscode_1.window.activeTextEditor.document.uri)
                : undefined;
            /** Gets the first unresolved variable from the given string. */
            function getUnresolvedVariable(input) {
                if (!input)
                    return undefined;
                const matches = /\${\w+}/.exec(input);
                return matches ? matches[0] : undefined;
            }
            function warnOnUnresolvedVariables(property, input) {
                if (!input)
                    return false;
                const v = getUnresolvedVariable(input);
                if (v) {
                    logger.error(`Launch config property '${property}' has unresolvable variable ${v}`);
                    vscode_1.window.showErrorMessage(`Launch config property '${property}' has unresolvable variable ${v}`);
                    return true;
                }
                return false;
            }
            logger.info(`Starting debug session...`);
            if (folder)
                logger.info(`    workspace: ${fs_1.fsPath(folder.uri)}`);
            if (debugConfig.program)
                logger.info(`    program  : ${debugConfig.program}`);
            if (debugConfig.cwd)
                logger.info(`    cwd      : ${debugConfig.cwd}`);
            if (warnOnUnresolvedVariables("program", debugConfig.program) || warnOnUnresolvedVariables("cwd", debugConfig.cwd)) {
                // Warning is shown from inside warnOnUnresolvedVariables.
                return null; // null means open launch.json.
            }
            if (openFile && !folder) {
                folder = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(openFile));
                if (folder)
                    logger.info(`Setting workspace based on open file: ${fs_1.fsPath(folder.uri)}`);
            }
            else if (!folder && vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length === 1) {
                folder = vs.workspace.workspaceFolders[0];
                if (folder)
                    logger.info(`Setting workspace based on single open workspace: ${fs_1.fsPath(folder.uri)}`);
            }
            // Convert to an absolute paths (if possible).
            if (debugConfig.cwd && !path.isAbsolute(debugConfig.cwd) && folder) {
                debugConfig.cwd = path.join(fs_1.fsPath(folder.uri), debugConfig.cwd);
                logger.info(`Converted cwd to absolute path: ${debugConfig.cwd}`);
            }
            if (debugConfig.program && !path.isAbsolute(debugConfig.program) && (debugConfig.cwd || folder)) {
                debugConfig.program = path.join(debugConfig.cwd || fs_1.fsPath(folder.uri), debugConfig.program);
                logger.info(`Converted program to absolute path: ${debugConfig.program}`);
            }
            const isAttachRequest = debugConfig.request === "attach";
            if (!isAttachRequest) {
                // If there's no program set, try to guess one.
                if (!debugConfig.program) {
                    const preferredFolder = debugConfig.cwd
                        ? debugConfig.cwd
                        : folder
                            ? fs_1.fsPath(folder.uri)
                            : undefined;
                    // If we have a folder specified, we should only consider open files if it's inside it.
                    const preferredFile = !preferredFolder || (!!openFile && fs_1.isWithinPath(openFile, preferredFolder)) ? openFile : undefined;
                    debugConfig.program = debugConfig.program || this.guessBestEntryPoint(preferredFile, preferredFolder);
                }
                // If we still don't have an entry point, the user will have to provide it.
                if (!debugConfig.program) {
                    logger.warn("No program was set in launch config");
                    const exampleEntryPoint = this.wsContext.hasAnyFlutterProjects ? "lib/main.dart" : "bin/main.dart";
                    vscode_1.window.showInformationMessage(`Set the 'program' value in your launch config (eg '${exampleEntryPoint}') then launch again`);
                    return null; // null means open launch.json.
                }
            }
            // If we don't have a cwd then find the best one from the project root.
            if (!debugConfig.cwd && folder) {
                debugConfig.cwd = fs_1.fsPath(folder.uri);
                logger.info(`Using workspace as cwd: ${debugConfig.cwd}`);
                // If we have an entry point, see if we can make this more specific by finding a .packages file
                if (debugConfig.program) {
                    const bestProjectRoot = project_1.locateBestProjectRoot(debugConfig.program);
                    if (bestProjectRoot && fs_1.isWithinPath(bestProjectRoot, fs_1.fsPath(folder.uri))) {
                        debugConfig.cwd = bestProjectRoot;
                        logger.info(`Found better project root to use as cwd: ${debugConfig.cwd}`);
                    }
                }
            }
            // Ensure we have a full path.
            if (debugConfig.program && debugConfig.cwd && !path.isAbsolute(debugConfig.program))
                debugConfig.program = path.join(debugConfig.cwd, debugConfig.program);
            if (debugConfig.program && path.isAbsolute(debugConfig.program) && !fs.existsSync(debugConfig.program)) {
                logger.warn(`Launch config references non-existant file ${debugConfig.program}`);
                vscode_1.window.showWarningMessage(`Your launch config references a program that does not exist. If you have problems launching, check the "program" field in your ".vscode/launch.json" file.`);
            }
            let debugType = enums_1.DebuggerType.Dart;
            if (debugConfig.cwd
                // TODO: This isInsideFolderNamed often fails when we found a better project root above.
                && !utils_4.isInsideFolderNamed(debugConfig.program, "bin")
                && !utils_4.isInsideFolderNamed(debugConfig.program, "tool")
                && !utils_4.isInsideFolderNamed(debugConfig.program, ".dart_tool")) {
                // Check if we're a Flutter or Web project.
                if (utils_4.isFlutterProjectFolder(debugConfig.cwd)) {
                    debugType = enums_1.DebuggerType.Flutter;
                }
                else if (utils_4.isInsideFolderNamed(debugConfig.program, "web") && !utils_4.isInsideFolderNamed(debugConfig.program, "test"))
                    debugType = enums_1.DebuggerType.Web;
                else
                    logger.info(`Project (${debugConfig.program}) not recognised as Flutter or Web, will use Dart debugger`);
            }
            logger.info(`Detected launch project as ${enums_1.DebuggerType[debugType]}`);
            // Some helpers for conditions below.
            const isAnyFlutter = debugType === enums_1.DebuggerType.Flutter || debugType === enums_1.DebuggerType.Web;
            const isStandardFlutter = debugType === enums_1.DebuggerType.Flutter;
            const isTest = debugConfig.program && utils_4.isTestFileOrFolder(debugConfig.program);
            const argsHaveTestNameFilter = isTest && debugConfig.args && (debugConfig.args.indexOf("--name") !== -1 || debugConfig.args.indexOf("--pname") !== -1);
            if (isTest)
                logger.info(`Detected launch project as a Test project`);
            const canPubRunTest = isTest && debugConfig.cwd && utils_4.projectShouldUsePubForTests(debugConfig.cwd, this.wsContext.config);
            if (isTest && !canPubRunTest)
                logger.info(`Project does not appear to support 'pub run test', will use VM directly`);
            if (isTest) {
                switch (debugType) {
                    case enums_1.DebuggerType.Dart:
                        if (canPubRunTest)
                            debugType = enums_1.DebuggerType.PubTest;
                        break;
                    case enums_1.DebuggerType.Flutter:
                        if (!debugConfig.runTestsOnDevice || argsHaveTestNameFilter) {
                            if (debugConfig.runTestsOnDevice && argsHaveTestNameFilter) {
                                vs.window.showWarningMessage("Running with 'flutter test' as 'runTestsOnDevice' is not supported for individual tests.");
                                logger.info(`runTestsOnDevice is set but args have test filter so will still use Flutter`);
                            }
                            debugType = enums_1.DebuggerType.FlutterTest;
                        }
                        else {
                            logger.info(`runTestsOnDevice is set, so will use Flutter instead of FlutterTest`);
                        }
                        break;
                    case enums_1.DebuggerType.Web:
                        debugType = enums_1.DebuggerType.WebTest;
                        break;
                    default:
                        logger.info("Unknown debugType, unable to switch to test debugger");
                }
            }
            logger.info(`Using ${enums_1.DebuggerType[debugType]} debug adapter for this session`);
            if (debugType === enums_1.DebuggerType.FlutterTest && utils_4.isInsideFolderNamed(debugConfig.program, "test_driver") && !((_a = debugConfig.env) === null || _a === void 0 ? void 0 : _a.VM_SERVICE_URL)) {
                const runningInstrumentedApps = debug_1.debugSessions.filter((s) => s.loadedServiceExtensions.indexOf(enums_1.VmServiceExtension.Driver) !== -1);
                if (runningInstrumentedApps.length === 0) {
                    return this.errorWithoutOpeningLaunchConfig("Could not find a running Flutter app that was instrumented with enableFlutterDriverExtension. Run your instrumented app before running driver tests.");
                }
                else if (runningInstrumentedApps.length > 1) {
                    return this.errorWithoutOpeningLaunchConfig("More than one Flutter app instrumented with enableFlutterDriverExtension is running. Please run only one app before running driver tests.");
                }
                else {
                    const app = runningInstrumentedApps[0];
                    // This shouldn't really be possible as we wouldn't find an instrumented app without having its VM Service connection.
                    if (!app.vmServiceUri)
                        return this.errorWithoutOpeningLaunchConfig("The Flutter app instrumented with enableFlutterDriverExtension is not fully initialised yet.");
                    // Restart the app for clean state before the test run.
                    yield app.session.customRequest("hotRestart");
                    debugConfig.env = debugConfig.env || {};
                    debugConfig.env.VM_SERVICE_URL = app.vmServiceUri;
                }
            }
            if (debugType === enums_1.DebuggerType.WebTest) {
                // TODO: IMPORTANT! When removing this if statement, add WebTest to
                // the call to TestResultsProvider.flagSuiteStart below!
                logger.error("Tests in web projects are not currently supported");
                vscode_1.window.showErrorMessage("Tests in web projects are not currently supported");
                return undefined; // undefined means silent (don't open launch.json).
            }
            if (debugType === enums_1.DebuggerType.FlutterTest && utils_4.isTestFolder(debugConfig.program) && !debugConfig.noDebug) {
                // When running `flutter test (folder)`, multiple debug sessions are created - one for each file. This is
                // different to how `pub run test (folder)` works (one debug session, which each file in an isolate). The
                // debugger does not currently support multiple VM service sessions so we have to downgrade this to noDebug.
                logger.warn("Setting noDebug=true for Flutter test run because it's a folder");
                debugConfig.noDebug = true;
            }
            // If we're attaching to Dart, ensure we get a VM service URI.
            if (isAttachRequest && !debugConfig.serviceInfoFile) {
                // For attaching, the VM service address must be specified. If it's not provided already, prompt for it.
                if (!isStandardFlutter) { // TEMP Condition because there's no point asking yet as the user doesn't know how to get this..
                    debugConfig.vmServiceUri = yield this.getFullVmServiceUri(debugConfig.vmServiceUri || debugConfig.observatoryUri);
                }
                if (!debugConfig.vmServiceUri && !isStandardFlutter) {
                    logger.warn("No VM service URI/port was provided");
                    vscode_1.window.showInformationMessage("You must provide a VM service URI/port to attach a debugger");
                    return undefined; // undefined means silent (don't open launch.json).
                }
            }
            if (token && token.isCancellationRequested)
                return;
            let deviceToLaunchOn = ((_b = this.deviceManager) === null || _b === void 0 ? void 0 : _b.getDevice(debugConfig.deviceId)) || ((_c = this.deviceManager) === null || _c === void 0 ? void 0 : _c.currentDevice);
            // Ensure we have a device if required.
            if (debugType === enums_1.DebuggerType.Flutter && this.deviceManager && this.daemon && debugConfig.deviceId !== "flutter-tester") {
                let supportedPlatforms = this.daemon.capabilities.providesPlatformTypes && debugConfig.cwd
                    ? (yield this.daemon.getSupportedPlatforms(debugConfig.cwd)).platforms
                    : [];
                // If the current device is not valid, prompt the user.
                if (!this.deviceManager.isSupported(supportedPlatforms, deviceToLaunchOn))
                    deviceToLaunchOn = yield this.deviceManager.showDevicePicker(supportedPlatforms);
                // Refresh the supported platforms, as the we may have enabled new platforms during
                // the call to showDevicePicker.
                supportedPlatforms = this.daemon.capabilities.providesPlatformTypes && debugConfig.cwd
                    ? (yield this.daemon.getSupportedPlatforms(debugConfig.cwd)).platforms
                    : [];
                // If we still don't have a valid device, show an error.
                if (!this.deviceManager.isSupported(supportedPlatforms, deviceToLaunchOn)) {
                    logger.warn("Unable to launch due to no active device");
                    vscode_1.window.showInformationMessage("Cannot launch without an active device");
                    return undefined; // undefined means silent (don't open launch.json).
                }
            }
            if (token && token.isCancellationRequested)
                return;
            // Ensure we have any require dependencies.
            if (!(yield this.installDependencies(debugType, this.pubGlobal))) {
                return undefined;
            }
            if (token && token.isCancellationRequested)
                return;
            // TODO: This cast feels nasty?
            this.setupDebugConfig(folder, debugConfig, isAnyFlutter, isAttachRequest, isTest, deviceToLaunchOn, this.deviceManager);
            // Debugger always uses uppercase drive letters to ensure our paths have them regardless of where they came from.
            debugConfig.program = fs_1.forceWindowsDriveLetterToUppercase(debugConfig.program);
            debugConfig.cwd = fs_1.forceWindowsDriveLetterToUppercase(debugConfig.cwd);
            // If we're launching (not attaching) then check there are no errors before we launch.
            if (!isAttachRequest && debugConfig.cwd && config_1.config.promptToRunIfErrors && !debugConfig.suppressPromptOnErrors) {
                logger.info("Checking for errors before launching");
                const isDartError = (d) => d.source === "dart" && d.severity === vs.DiagnosticSeverity.Error;
                const dartErrors = vs.languages
                    .getDiagnostics()
                    .filter((file) => file[1].find(isDartError));
                // Check if any are inside our CWD.
                const firstRelevantDiagnostic = dartErrors.find((fd) => {
                    const file = fs_1.fsPath(fd[0]);
                    return fs_1.isWithinPath(file, debugConfig.cwd)
                        // Ignore errors in test folder unless it's the file we're running.
                        && (!utils_4.isInsideFolderNamed(file, "test") || file === debugConfig.program);
                });
                if (firstRelevantDiagnostic) {
                    logger.warn("Project has errors, prompting user");
                    const firstRelevantError = firstRelevantDiagnostic[1].find(isDartError);
                    const range = firstRelevantError.range;
                    logger.warn(`    ${fs_1.fsPath(firstRelevantDiagnostic[0])}:${range.start.line}:${range.start.character}`);
                    logger.warn(`    ${firstRelevantError.message.split("\n")[0].trim()}`);
                    const action = yield vscode_1.window.showErrorMessage("Build errors exist in your project.", { modal: true }, constants_1.debugAnywayAction, constants_1.showErrorsAction);
                    if (action === constants_1.debugAnywayAction) {
                        logger.info("Debugging anyway!");
                        // Do nothing, we'll just carry on.
                    }
                    else {
                        logger.info("Aborting!");
                        if (action === constants_1.showErrorsAction)
                            vs.commands.executeCommand("workbench.action.showErrorsWarnings");
                        return undefined; // undefined means silent (don't open launch.json).
                    }
                }
            }
            if (token && token.isCancellationRequested)
                return;
            const didWarnAboutCwd = debugConfig.cwd && path.isAbsolute(debugConfig.cwd)
                ? utils_3.warnIfPathCaseMismatch(logger, debugConfig.cwd, "the launch script working directory", "check the 'cwd' field in your launch configuration file (.vscode/launch.json)")
                : false;
            if (!didWarnAboutCwd && debugConfig.program && path.isAbsolute(debugConfig.program))
                utils_3.warnIfPathCaseMismatch(logger, debugConfig.program, "the launch script", "check the 'program' field in your launch configuration file (.vscode/launch.json)");
            this.analytics.logDebuggerStart(folder && folder.uri, enums_1.DebuggerType[debugType], debugConfig.noDebug ? "Run" : "Debug");
            if (debugType === enums_1.DebuggerType.FlutterTest /* || debugType === DebuggerType.WebTest */ || debugType === enums_1.DebuggerType.PubTest) {
                this.testTreeModel.flagSuiteStart(debugConfig.program, !argsHaveTestNameFilter);
            }
            debugConfig.debuggerType = debugType;
            logger.info(`Debug session starting...\n    ${JSON.stringify(debugConfig, undefined, 4).replace(/\n/g, "\n    ")}`);
            // Stash the config to support the "rerun last debug session" command.
            debug_1.LastDebugSession.workspaceFolder = folder;
            debug_1.LastDebugSession.debugConfig = Object.assign({}, debugConfig);
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_DEBUG_CONFIG, true);
            // Stash the config to support the "rerun last test(s)" command.
            if (isTest) {
                debug_1.LastTestDebugSession.workspaceFolder = folder;
                debug_1.LastTestDebugSession.debugConfig = Object.assign({}, debugConfig);
                vs.commands.executeCommand("setContext", constants_1.HAS_LAST_TEST_DEBUG_CONFIG, true);
            }
            return debugConfig;
        });
    }
    errorWithoutOpeningLaunchConfig(message) {
        this.logger.error(message);
        vscode_1.window.showErrorMessage(message);
        return undefined; // undefined means silent (don't open launch.json).
    }
    installDependencies(debugType, pubGlobal) {
        return debugType === enums_1.DebuggerType.Web
            ? new webdev_1.WebDev(pubGlobal).promptToInstallIfRequired()
            : true;
    }
    guessBestEntryPoint(openFile, folder) {
        // For certain open files, assume the user wants to run them.
        if (utils_4.isValidEntryFile(openFile)) {
            this.logger.info(`Using open file as entry point: ${openFile}`);
            return openFile;
        }
        // Use the open file as a clue to find the best project root, then search from there.
        const projectRoot = (openFile && project_1.locateBestProjectRoot(openFile)) || folder;
        if (!projectRoot)
            return;
        const commonLaunchPaths = [
            path.join(projectRoot, "lib", "main.dart"),
            path.join(projectRoot, "bin", "main.dart"),
        ];
        for (const launchPath of commonLaunchPaths) {
            if (fs.existsSync(launchPath)) {
                this.logger.info(`Using found common entry point: ${launchPath}`);
                return launchPath;
            }
        }
        // If we don't have a bin folder, or a lib/main.dart, or a web folder, then
        // see if we have an example and try that.
        if (!fs.existsSync(path.join(projectRoot, "bin"))
            && !fs.existsSync(path.join(projectRoot, "web"))
            && fs.existsSync(path.join(projectRoot, "example")))
            return this.guessBestEntryPoint(undefined, path.join(projectRoot, "example"));
    }
    getFullVmServiceUri(vmServiceUriOrPort) {
        return __awaiter(this, void 0, void 0, function* () {
            vmServiceUriOrPort = vmServiceUriOrPort || (yield vs.commands.executeCommand("dart.promptForVmService"));
            vmServiceUriOrPort = vmServiceUriOrPort && vmServiceUriOrPort.trim();
            // If the input is just a number, treat is as a localhost port.
            if (vmServiceUriOrPort && /^[0-9]+$/.exec(vmServiceUriOrPort)) {
                vmServiceUriOrPort = `http://127.0.0.1:${vmServiceUriOrPort}`;
            }
            return vmServiceUriOrPort;
        });
    }
    setupDebugConfig(folder, debugConfig, isFlutter, isAttach, isTest, device, deviceManager) {
        const conf = config_1.config.for(folder && folder.uri);
        // Attach any properties that weren't explicitly set.
        if (!debugConfig.name) {
            if (isFlutter && debugConfig.deviceId) {
                debugConfig.name = `Flutter (${debugConfig.deviceId})`;
            }
            else if (isFlutter && device) {
                debugConfig.name = `Flutter (${deviceManager ? deviceManager.labelForDevice(device) : device.name})`;
            }
            else if (isFlutter) {
                debugConfig.name = "Flutter";
            }
            else {
                debugConfig.name = "Dart";
            }
        }
        debugConfig.toolEnv = processes_1.getToolEnv();
        debugConfig.sendLogsToClient = true;
        debugConfig.cwd = debugConfig.cwd || (folder && fs_1.fsPath(folder.uri));
        debugConfig.args = debugConfig.args || [];
        debugConfig.vmAdditionalArgs = debugConfig.vmAdditionalArgs || conf.vmAdditionalArgs;
        debugConfig.vmServicePort = debugConfig.vmServicePort || (constants_1.isChromeOS && config_1.config.useKnownChromeOSPorts ? constants_1.CHROME_OS_VM_SERVICE_PORT : 0);
        debugConfig.dartSdkPath = this.wsContext.sdks.dart;
        debugConfig.vmServiceLogFile = this.insertSessionName(debugConfig, debugConfig.vmServiceLogFile || conf.vmServiceLogFile);
        debugConfig.webDaemonLogFile = this.insertSessionName(debugConfig, debugConfig.webDaemonLogFile || conf.webDaemonLogFile);
        debugConfig.maxLogLineLength = debugConfig.maxLogLineLength || config_1.config.maxLogLineLength;
        debugConfig.pubTestLogFile = this.insertSessionName(debugConfig, debugConfig.pubTestLogFile || conf.pubTestLogFile);
        debugConfig.debugSdkLibraries = debugConfig.debugSdkLibraries !== undefined && debugConfig.debugSdkLibraries !== null
            ? debugConfig.debugSdkLibraries
            : !!config_1.config.debugSdkLibraries;
        debugConfig.debugExternalLibraries = debugConfig.debugExternalLibraries !== undefined && debugConfig.debugExternalLibraries !== null
            ? debugConfig.debugExternalLibraries
            : config_1.config.debugExternalLibraries;
        debugConfig.showDartDeveloperLogs = conf.showDartDeveloperLogs;
        debugConfig.evaluateGettersInDebugViews = debugConfig.evaluateGettersInDebugViews || conf.evaluateGettersInDebugViews;
        debugConfig.evaluateToStringInDebugViews = debugConfig.evaluateToStringInDebugViews || config_1.config.evaluateToStringInDebugViews;
        if (isFlutter && this.wsContext.sdks.flutter) {
            debugConfig.flutterSdkPath = this.wsContext.sdks.flutter;
            debugConfig.globalFlutterArgs = processes_1.getGlobalFlutterArgs();
            debugConfig.useFlutterStructuredErrors = conf.flutterStructuredErrors;
            debugConfig.debugExtensionBackendProtocol = config_1.config.debugExtensionBackendProtocol;
            const additionalArgs = isTest
                ? conf.flutterTestAdditionalArgs
                : isAttach
                    ? conf.flutterAttachAdditionalArgs
                    : conf.flutterRunAdditionalArgs;
            debugConfig.args = conf.flutterAdditionalArgs.concat(additionalArgs).concat(debugConfig.args);
            debugConfig.forceFlutterVerboseMode = logging_1.isLogging;
            debugConfig.flutterTrackWidgetCreation =
                // Use from the launch.json if configured.
                debugConfig.flutterTrackWidgetCreation !== undefined && debugConfig.flutterTrackWidgetCreation !== null
                    ? debugConfig.flutterTrackWidgetCreation :
                    // Otherwise use the config.
                    conf.flutterTrackWidgetCreation;
            debugConfig.flutterMode = debugConfig.flutterMode || "debug";
            debugConfig.flutterPlatform = debugConfig.flutterPlatform || "default";
            debugConfig.workspaceConfig = this.wsContext.config;
            debugConfig.flutterRunLogFile = this.insertSessionName(debugConfig, debugConfig.flutterRunLogFile || conf.flutterRunLogFile);
            debugConfig.flutterTestLogFile = this.insertSessionName(debugConfig, debugConfig.flutterTestLogFile || conf.flutterTestLogFile);
            if (!debugConfig.deviceId && device) {
                debugConfig.deviceId = device.id;
                debugConfig.deviceName = `${deviceManager ? deviceManager.labelForDevice(device) : device.name} (${device.platform})`;
            }
            if (!isTest && !isAttach && (device === null || device === void 0 ? void 0 : device.platformType) === "web") {
                const rendererArg = utils_1.getFutterWebRendererArg(this.flutterCapabilities, config_1.config.flutterWebRenderer, debugConfig.args);
                if (rendererArg)
                    debugConfig.args.push(rendererArg);
            }
            debugConfig.showMemoryUsage =
                debugConfig.showMemoryUsage || debugConfig.showMemoryUsage === false
                    ? debugConfig.showMemoryUsage
                    : debugConfig.flutterMode === "profile";
        }
    }
    insertSessionName(args, logPath) {
        return logPath
            ? logPath.replace(/\${name}/, utils_2.filenameSafe(args.name || "unnamed-session"))
            : logPath;
    }
}
exports.DebugConfigProvider = DebugConfigProvider;
class InitialLaunchJsonDebugConfigProvider {
    constructor(logger) {
        this.logger = logger;
    }
    provideDebugConfigurations(folder, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const rootFolder = folder ? fs_1.fsPath(folder.uri) : undefined;
            const projectFolders = rootFolder ? yield fs_1.findProjectFolders(this.logger, [rootFolder], utils_4.getExcludedFolders(folder), { requirePubspec: true }) : [];
            if (projectFolders.length) {
                return projectFolders.map((projectFolder) => {
                    // Compute cwd, using undefined instead of empty if rootFolder === projectFolder
                    const cwd = rootFolder ? path.relative(rootFolder, projectFolder) || undefined : undefined;
                    return {
                        name: path.basename(projectFolder),
                        cwd,
                        request: "launch",
                        type: "dart",
                    };
                });
            }
            else {
                return [{
                        name: "Dart & Flutter",
                        request: "launch",
                        type: "dart",
                    }];
            }
        });
    }
}
exports.InitialLaunchJsonDebugConfigProvider = InitialLaunchJsonDebugConfigProvider;
class DynamicDebugConfigProvider {
    constructor(logger) {
        this.logger = logger;
    }
    provideDebugConfigurations(folder, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const rootFolder = folder ? fs_1.fsPath(folder.uri) : undefined;
            const projectFolders = rootFolder ? yield fs_1.findProjectFolders(this.logger, [rootFolder], utils_4.getExcludedFolders(folder), { requirePubspec: true }) : [];
            for (const projectFolder of projectFolders) {
                const isFlutter = utils_4.isFlutterProjectFolder(projectFolder);
                const name = path.basename(projectFolder);
                const cwd = rootFolder ? path.relative(rootFolder, projectFolder) || undefined : undefined;
                const exists = (p) => folder && fs.existsSync(path.join(projectFolder, p));
                if (isFlutter && exists("lib/main.dart")) {
                    results.push({
                        name: `${name} (Flutter)`,
                        program: "lib/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (!isFlutter && exists("web")) {
                    results.push({
                        name: `${name} (Dart Web)`,
                        program: "web",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (exists("bin/main.dart")) {
                    results.push({
                        name: `${name} (Dart)`,
                        program: "bin/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (exists("test")) {
                    results.push({
                        name: `${name} (${isFlutter ? "Flutter" : "Dart"} Tests)`,
                        program: "test",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
            }
            return results;
        });
    }
}
exports.DynamicDebugConfigProvider = DynamicDebugConfigProvider;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WebDev = void 0;
const packageName = "webdev";
const packageID = "webdev";
class WebDev {
    constructor(pubGlobal) {
        this.pubGlobal = pubGlobal;
    }
    promptToInstallIfRequired() {
        return this.pubGlobal.promptToInstallIfRequired(packageName, packageID, undefined, "2.5.4");
    }
}
exports.WebDev = WebDev;


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(6);
const dart_diagnostic_provider_1 = __webpack_require__(110);
const ranking_code_action_provider_1 = __webpack_require__(109);
class FixCodeActionProvider {
    constructor(logger, selector, analyzer) {
        this.logger = logger;
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 1;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!utils_1.isAnalyzableAndInWorkspace(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // quickfix (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
                return undefined;
            try {
                const pos = "active" in range ? range.active : range.start;
                const result = yield this.analyzer.editGetFixes({
                    file: fs_1.fsPath(document.uri),
                    offset: document.offsetAt(pos),
                });
                if (token && token.isCancellationRequested)
                    return;
                // Because fixes may be the same for multiple errors, we'll de-dupe them based on their edit.
                const allActions = {};
                for (const errorFix of result.fixes) {
                    for (const fix of errorFix.fixes) {
                        allActions[JSON.stringify(fix.edits)] = this.convertResult(document, fix, errorFix.error);
                    }
                }
                const allFixes = Object.keys(allActions).map((a) => allActions[a]);
                return context.only
                    ? allFixes.filter((f) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(f.kind); })
                    : allFixes;
            }
            catch (e) {
                this.logger.error(e);
                throw e;
            }
        });
    }
    convertResult(document, change, error) {
        const title = change.message;
        const diagnostics = error ? [dart_diagnostic_provider_1.DartDiagnosticProvider.createDiagnostic(error)] : undefined;
        const kind = ranking_code_action_provider_1.getKindFor(change.id, vscode_1.CodeActionKind.QuickFix);
        const action = new vscode_1.CodeAction(title, kind);
        action.command = {
            arguments: [document, change],
            command: "_dart.applySourceChange",
            title,
        };
        action.diagnostics = diagnostics;
        return action;
    }
}
exports.FixCodeActionProvider = FixCodeActionProvider;


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IgnoreLintCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(0);
const config_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(6);
const dart_diagnostic_provider_1 = __webpack_require__(110);
class IgnoreLintCodeActionProvider {
    constructor(selector) {
        this.selector = selector;
        this.rank = 100;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
        };
    }
    provideCodeActions(document, range, context, token) {
        if (!utils_1.isAnalyzableAndInWorkspace(document))
            return;
        // If we were only asked for specific action types and that doesn't include
        // quickfix (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
            return;
        if (!config_1.config.showIgnoreQuickFixes || !context || !context.diagnostics || !context.diagnostics.length)
            return;
        const lintErrors = context.diagnostics.filter((d) => d.range.intersection(range)
            && (
            // Non-LSP:
            (d instanceof dart_diagnostic_provider_1.DartDiagnostic && (d.type === "LINT" || d.type === "HINT")
                // LSP:
                || (d.source === "dart" && d.severity === vscode_1.DiagnosticSeverity.Information))));
        if (!lintErrors.length)
            return;
        return lintErrors.map((diagnostic) => this.convertResult(document, diagnostic));
    }
    convertResult(document, diagnostic) {
        const type = diagnostic instanceof dart_diagnostic_provider_1.DartDiagnostic ? `${diagnostic.type.toLowerCase()} ` : "";
        const dCode = diagnostic.code || "";
        const code = typeof dCode === "string" ? dCode : dCode.value;
        const edit = new vscode_1.WorkspaceEdit();
        const line = document.lineAt(diagnostic.range.start.line);
        edit.insert(document.uri, line.range.start, `${" ".repeat(line.firstNonWhitespaceCharacterIndex)}// ignore: ${code}\n`);
        const title = `Ignore ${type}'${code}' for this line`;
        const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.QuickFix);
        action.edit = edit;
        return action;
    }
}
exports.IgnoreLintCodeActionProvider = IgnoreLintCodeActionProvider;


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LegacyDartWorkspaceSymbolProvider = void 0;
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const fs_1 = __webpack_require__(1);
const utils_1 = __webpack_require__(5);
const analyzer_das_1 = __webpack_require__(50);
const utils_2 = __webpack_require__(6);
class LegacyDartWorkspaceSymbolProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
    }
    provideWorkspaceSymbols(query, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (query.length === 0)
                return undefined;
            query = this.sanitizeUserQuery(query);
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const results = yield Promise.all([
                this.analyzer.searchFindTopLevelDeclarationsResults({ pattern }),
                this.analyzer.searchFindMemberDeclarationsResults({ name: pattern }),
            ]);
            return this.combineResults(results);
        });
    }
    combineResults(results) {
        return results[0].results.concat(results[1].results)
            .filter((r) => this.shouldIncludeResult(r))
            .map((r) => this.convertResult(r));
    }
    searchTopLevelSymbols(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const resp = yield this.analyzer.searchFindTopLevelDeclarationsResults({ pattern });
            return resp.results;
        });
    }
    searchMemberDeclarations(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const resp = yield this.analyzer.searchFindMemberDeclarationsResults({ name: pattern });
            return resp.results;
        });
    }
    sanitizeUserQuery(query) {
        let chars = Array.from(query);
        // Filter out special chars that will break regex.
        // searchFindTopLevelDeclarations supports regex, but we build the pattern with the output of this.
        // searchMemberDeclarations is not intended to support regex but does.
        chars = chars.filter((c) => "[](){}\\|./<>?+".indexOf(c) === -1);
        return chars.join("");
    }
    makeCaseInsensitiveFuzzyRegex(query) {
        let chars = Array.from(query);
        chars = chars.map((c) => {
            if (c.toUpperCase() === c.toLowerCase())
                return c;
            return `[${c.toUpperCase()}${c.toLowerCase()}]`;
        });
        const pattern = chars.join(".*");
        return `.*${pattern}.*`;
    }
    shouldIncludeResult(result) {
        // Must be either:
        //   1. Public (not start with an underscore).
        //   2. In our project.
        const isPrivate = result.path[0].name.startsWith("_") || result.path[1].name.startsWith("_");
        return utils_2.isWithinWorkspace(result.location.file) || !isPrivate;
    }
    convertResult(result) {
        // Rewrite the filename for best display.
        const containerName = this.createDisplayPath(result.location.file);
        // Remove the library and compilation unit parent elements; concatenate names.
        let elementPathDescription = result.path
            .slice(0, result.path.length - 2)
            .reverse()
            .map((e) => e.name)
            .join(".");
        // For properties, show if get/set.
        if (result.path[0].kind === "SETTER")
            elementPathDescription += " set";
        if (result.path[0].kind === "GETTER")
            elementPathDescription += " get";
        const parameters = result.path[0].parameters && result.path[0].kind !== "SETTER"
            ? result.path[0].parameters
            : "";
        return new vscode_1.SymbolInformation(elementPathDescription + parameters, analyzer_das_1.getSymbolKindForElementKind(this.logger, result.path[0].kind), containerName || "", new vscode_1.Location(vscode_1.Uri.file(result.location.file), utils_1.toRangeOnLine(result.location)));
    }
    createDisplayPath(inputPath) {
        if (!inputPath)
            return undefined;
        // HACK: The AS returns paths to the PUB_CACHE folder, which Code can't
        // convert to relative paths (so they look terrible). If the file exists in
        // workspace.rootPath we rewrite the path to there which gives us a nice
        // relative path.
        // Currently I only do this for "hosted\pub.dartlang.org" as I'm not sure of the
        // rules for these paths!
        const pubCachePath = "hosted" + path.sep + "pub.dartlang.org";
        const pubCachePathIndex = inputPath.indexOf(pubCachePath);
        if (pubCachePathIndex > -1) {
            const relativePath = inputPath.substring(pubCachePathIndex + pubCachePath.length + 1);
            // Packages in pubcache are versioned so trim the "-x.x.x" off the end of the foldername.
            const pathComponents = relativePath.split(path.sep);
            pathComponents[0] = pathComponents[0].split("-")[0];
            // Symlink goes into the lib folder, so strip that out of the path.
            if (pathComponents[1] === "lib")
                pathComponents.splice(1, 1);
            // Return 'package:foo/bar.dart'.
            inputPath = `package:${pathComponents[0]}/${pathComponents.slice(1).join("/")}`;
        }
        else {
            const root = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(inputPath));
            inputPath = root && path.relative(fs_1.fsPath(root.uri), inputPath);
        }
        return inputPath;
    }
}
exports.LegacyDartWorkspaceSymbolProvider = LegacyDartWorkspaceSymbolProvider;


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RefactorCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const utils_2 = __webpack_require__(6);
const supportedRefactors = {
    CONVERT_METHOD_TO_GETTER: "Convert Method to Getter",
    EXTRACT_LOCAL_VARIABLE: "Extract Local Variable",
    EXTRACT_METHOD: "Extract Method",
    EXTRACT_WIDGET: "Extract Widget",
};
class RefactorCodeActionProvider {
    constructor(selector, analyzer) {
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 50;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.Refactor],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!utils_2.isAnalyzableAndInWorkspace(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // refactor (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.Refactor.contains(context.only))
                return undefined;
            try {
                const startOffset = document.offsetAt(range.start);
                const endOffset = document.offsetAt(range.end);
                const result = yield this.analyzer.editGetAvailableRefactorings({
                    file: fs_1.fsPath(document.uri),
                    length: endOffset - startOffset,
                    offset: startOffset,
                });
                if (token && token.isCancellationRequested)
                    return;
                const allRefactors = result.kinds.map((k) => this.getSupportedRefactorForKind(document, range, k)).filter(utils_1.notUndefined);
                return context.only
                    ? allRefactors.filter((r) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(r.kind); })
                    : allRefactors;
            }
            catch (e) {
                // TODO: Swap this back to logError/throw when https://github.com/dart-lang/sdk/issues/33471 is fixed.
                return [];
                // logError(e);
                // reject();
            }
        });
    }
    getSupportedRefactorForKind(document, range, k) {
        if (!supportedRefactors[k])
            return;
        const title = supportedRefactors[k];
        const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.Refactor);
        action.command = {
            arguments: [document, range, k],
            command: "_dart.performRefactor",
            title,
        };
        return action;
    }
}
exports.RefactorCodeActionProvider = RefactorCodeActionProvider;


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SnippetCompletionItemProvider = void 0;
const path = __webpack_require__(2);
const vscode_1 = __webpack_require__(0);
const extension_utils_1 = __webpack_require__(20);
const config_1 = __webpack_require__(10);
class SnippetCompletionItemProvider {
    constructor(filename, shouldRender) {
        this.completions = new vscode_1.CompletionList();
        this.shouldRender = shouldRender;
        const snippets = extension_utils_1.readJson(path.join(extension_utils_1.extensionPath, filename));
        for (const snippetType of Object.keys(snippets)) {
            for (const snippetName of Object.keys(snippets[snippetType])) {
                const snippet = snippets[snippetType][snippetName];
                const completionItem = new vscode_1.CompletionItem(snippetName, vscode_1.CompletionItemKind.Snippet);
                completionItem.filterText = snippet.prefix;
                completionItem.insertText = new vscode_1.SnippetString(Array.isArray(snippet.body)
                    ? snippet.body.join("\n")
                    : snippet.body);
                completionItem.detail = snippet.description;
                completionItem.documentation = new vscode_1.MarkdownString().appendCodeblock(completionItem.insertText.value);
                completionItem.sortText = "zzzzzzzzzzzzzzzzzzzzzz";
                this.completions.items.push(completionItem);
            }
        }
    }
    provideCompletionItems(document, position, token, context) {
        if (!config_1.config.enableSnippets)
            return;
        const line = document.lineAt(position.line).text.slice(0, position.character);
        if (!this.shouldAllowCompletion(line, context))
            return;
        if (!this.shouldRender(document.uri))
            return;
        return this.completions;
    }
    shouldAllowCompletion(line, context) {
        line = line.trim();
        // Don't provide completions after comment markers. This isn't perfect since it'll
        // suppress them for ex if // appears inside strings, but it's a reasonable
        // approximation given we don't have a reliable way to tell that.
        if (line.indexOf("//") !== -1)
            return false;
        // Otherwise, allow through.
        return true;
    }
}
exports.SnippetCompletionItemProvider = SnippetCompletionItemProvider;


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(0);
const utils_1 = __webpack_require__(5);
const utils_2 = __webpack_require__(6);
class SourceCodeActionProvider {
    provideCodeActions(document, range, context, token) {
        if (!utils_2.isAnalyzableAndInWorkspace(document))
            return undefined;
        const actions = [];
        if (!context
            || !context.only
            || context.only.contains(vscode_1.CodeActionKind.Source)
            || context.only.contains(vscode_1.CodeActionKind.SourceOrganizeImports)) {
            actions.push({
                command: {
                    arguments: [document],
                    command: "_dart.organizeImports",
                    title: "Organize Imports",
                },
                kind: vscode_1.CodeActionKind.SourceOrganizeImports,
                title: "Organize Imports",
            });
        }
        if (!context
            || !context.only
            || context.only.contains(vscode_1.CodeActionKind.Source)
            || context.only.contains(utils_1.SourceSortMembersCodeActionKind)) {
            actions.push({
                command: {
                    arguments: [document],
                    command: "dart.sortMembers",
                    title: "Sort Members",
                },
                kind: utils_1.SourceSortMembersCodeActionKind,
                title: "Sort Members",
            });
        }
        return actions;
    }
}
exports.SourceCodeActionProvider = SourceCodeActionProvider;
SourceCodeActionProvider.metadata = {
    providedCodeActionKinds: [vscode_1.CodeActionKind.Source, vscode_1.CodeActionKind.SourceOrganizeImports, utils_1.SourceSortMembersCodeActionKind],
};


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubGlobal = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const logging_1 = __webpack_require__(13);
const utils_1 = __webpack_require__(3);
const utils_2 = __webpack_require__(5);
const processes_1 = __webpack_require__(15);
class PubGlobal {
    constructor(logger, context, sdks, pubApi) {
        this.logger = logger;
        this.context = context;
        this.sdks = sdks;
        this.pubApi = pubApi;
    }
    promptToInstallIfRequired(packageName, packageID, moreInfoLink = constants_1.pubGlobalDocsUrl, requiredVersion, customActivateScript, autoUpdate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let installedVersion = yield this.getInstalledVersion(packageName, packageID);
            const versionStatus = customActivateScript
                ? enums_1.VersionStatus.UpdateRequired
                : yield this.checkVersionStatus(packageID, installedVersion, requiredVersion);
            if (versionStatus === enums_1.VersionStatus.Valid)
                return installedVersion;
            // Custom activation scripts always auto run without prompt since we
            // are unable to check whether they are required.
            if (customActivateScript)
                autoUpdate = true;
            const activateForMe = versionStatus === enums_1.VersionStatus.NotInstalled ? `Activate ${packageName}` : `Update ${packageName}`;
            const message = versionStatus === enums_1.VersionStatus.NotInstalled
                ? `${packageName} needs to be installed with 'pub global activate ${packageID}' to use this feature.`
                : (versionStatus === enums_1.VersionStatus.UpdateRequired
                    ? `${packageName} needs to be updated with 'pub global activate ${packageID}' to use this feature.`
                    : `A new version of ${packageName} is available and can be installed with 'pub global activate ${packageID}'.`);
            let action = 
            // If we need an update and we're allowed to auto-update, to the same as if the user
            // clicked the activate button, otherwise prompt them.
            autoUpdate && (versionStatus === enums_1.VersionStatus.UpdateRequired || versionStatus === enums_1.VersionStatus.UpdateAvailable)
                ? activateForMe
                : yield vs.window.showWarningMessage(message, activateForMe, constants_1.moreInfoAction);
            if (action === constants_1.moreInfoAction) {
                yield utils_2.envUtils.openInBrowser(moreInfoLink);
                return undefined;
            }
            else if (action === activateForMe) {
                const actionName = versionStatus === enums_1.VersionStatus.NotInstalled ? `Activating ${packageName}` : `Updating ${packageName}`;
                const args = ["global", "activate", packageID];
                yield this.runCommandWithProgress(packageName, `${actionName}...`, args, customActivateScript);
                installedVersion = yield this.getInstalledVersion(packageName, packageID);
                if ((yield this.checkVersionStatus(packageID, installedVersion)) === enums_1.VersionStatus.Valid) {
                    return installedVersion;
                }
                else {
                    action = yield vs.window.showErrorMessage(`${actionName} failed. Please try running 'pub global activate ${packageID}' manually.`, constants_1.moreInfoAction);
                    if (action === constants_1.moreInfoAction) {
                        yield utils_2.envUtils.openInBrowser(moreInfoLink);
                    }
                    return undefined;
                }
            }
            return undefined;
        });
    }
    backgroundActivate(packageName, packageID, silent, customActivateScript) {
        return __awaiter(this, void 0, void 0, function* () {
            const actionName = `Activating ${packageName}`;
            const args = ["global", "activate", packageID];
            if (silent)
                yield this.runCommand(packageName, args, customActivateScript);
            else
                yield this.runCommandWithProgress(packageName, `${actionName}...`, args, customActivateScript);
        });
    }
    uninstall(packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["global", "deactivate", packageID];
            yield this.runCommand(packageID, args);
        });
    }
    checkVersionStatus(packageID, installedVersion, requiredVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!installedVersion)
                return enums_1.VersionStatus.NotInstalled;
            // If we need a specific version, check it here.
            if (requiredVersion && !utils_1.pubVersionIsAtLeast(installedVersion, requiredVersion))
                return enums_1.VersionStatus.UpdateRequired;
            // If we haven't checked in the last 24 hours, check if there's an update available.
            const lastChecked = this.context.getPackageLastCheckedForUpdates(packageID);
            if (!lastChecked || lastChecked <= Date.now() - constants_1.noRepeatPromptThreshold) {
                this.context.setPackageLastCheckedForUpdates(packageID, Date.now());
                try {
                    const pubPackage = yield this.pubApi.getPackage(packageID);
                    if (!utils_1.pubVersionIsAtLeast(installedVersion, pubPackage.latest.version))
                        return enums_1.VersionStatus.UpdateAvailable;
                }
                catch (e) {
                    // If we fail to call the API to check for a new version, then we can run
                    // with what we have.
                    this.logger.warn(`Failed to check for new version of ${packageID}: ${e}`, enums_1.LogCategory.CommandProcesses);
                    return enums_1.VersionStatus.Valid;
                }
            }
            // Otherwise, we're installed and have a new enough version.
            return enums_1.VersionStatus.Valid;
        });
    }
    getInstalledVersion(packageName, packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield this.runCommand(packageName, ["global", "list"]);
            const versionMatch = new RegExp(`^${packageID} (\\d+\\.\\d+\\.\\d+[\\w.\\-+]*)(?: |$)`, "m");
            const match = versionMatch.exec(output);
            const installedVersion = match ? match[1] : undefined;
            return installedVersion;
        });
    }
    runCommandWithProgress(packageName, title, args, customScript) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(packageName, args, customScript));
    }
    runCommand(packageName, args, customScript) {
        const { binPath, binArgs } = utils_1.usingCustomScript(path.join(this.sdks.dart, constants_1.pubPath), args, customScript);
        return new Promise((resolve, reject) => {
            this.logger.info(`Spawning ${binPath} with args ${JSON.stringify(binArgs)}`);
            const proc = processes_1.safeToolSpawn(undefined, binPath, binArgs);
            logging_1.logProcess(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`${packageName} exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.PubGlobal = PubGlobal;


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusBarVersionTracker = void 0;
const vs = __webpack_require__(0);
const config_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(6);
class StatusBarVersionTracker {
    constructor(workspaceContext, isLsp) {
        this.subscriptions = [];
        const dartIsFromFlutter = workspaceContext.sdks.dartSdkIsFromFlutter;
        // Which switcher we show is based on whether we're in a Flutter project or not.
        const switchSdkCommand = workspaceContext.hasAnyFlutterProjects
            ? (config_1.config.flutterSdkPaths && config_1.config.flutterSdkPaths.length > 0 ? "dart.changeFlutterSdk" : undefined)
            : (config_1.config.sdkPaths && config_1.config.sdkPaths.length > 0 ? "dart.changeSdk" : undefined);
        // Render an approprite label for what we're calling this SDK.
        const label = workspaceContext.hasAnyFlutterProjects
            ? "Flutter"
            : (dartIsFromFlutter ? "Dart from Flutter" : "Dart");
        const versionLabel = (workspaceContext.hasAnyFlutterProjects || dartIsFromFlutter)
            ? workspaceContext.sdks.flutterVersion
            : workspaceContext.sdks.dartVersion;
        if (versionLabel) {
            this.addStatusBarItem(`${label}: ` + (versionLabel.length > 20 ? versionLabel.substr(0, 17) + "…" : versionLabel), `${label} SDK (${isLsp ? "LSP" : "DAS"}): ${versionLabel}`, switchSdkCommand);
        }
    }
    addStatusBarItem(text, tooltip, command) {
        const statusBarItem = vs.window.createStatusBarItem(vs.StatusBarAlignment.Right, 2);
        statusBarItem.text = text;
        statusBarItem.tooltip = tooltip;
        statusBarItem.command = command;
        this.subscriptions.push(statusBarItem);
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            // Show the Dart-specific label if the document is analyzable but it isn't HTML.
            if (e && e.document && utils_1.isAnalyzable(e.document) && e.document.languageId !== "html")
                statusBarItem.show();
            else
                statusBarItem.hide();
        }));
        if (vs.window.activeTextEditor && vs.window.activeTextEditor.document && utils_1.isAnalyzable(vs.window.activeTextEditor.document))
            statusBarItem.show();
    }
    dispose() {
        this.subscriptions.forEach((s) => s.dispose());
    }
}
exports.StatusBarVersionTracker = StatusBarVersionTracker;


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkForStandardDartSdkUpdates = void 0;
const vscode_1 = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const utils_1 = __webpack_require__(3);
const utils_2 = __webpack_require__(5);
const config_1 = __webpack_require__(10);
const utils_3 = __webpack_require__(6);
function checkForStandardDartSdkUpdates(logger, workspaceContext) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!config_1.config.checkForSdkUpdates || workspaceContext.config.disableSdkUpdateChecks)
            return;
        // Someties people use the Dart SDK inside Flutter for non-Flutter projects. Since we'll never want
        // to do SDK update checks in that situation (esp. as it's VERSION file is bad!) we should skip in
        // that case.
        if (workspaceContext.sdks.dartSdkIsFromFlutter)
            return;
        const dartSdkVersion = workspaceContext.sdks.dartVersion;
        try {
            const version = yield utils_3.getLatestSdkVersion();
            if (!dartSdkVersion || utils_1.versionIsAtLeast(dartSdkVersion, version))
                return;
            const goToDownloadsAction = "Go to Dart Downloads";
            const dontShowAgainAction = "Disable Update Checks";
            const message = `Version ${version} of the Dart SDK is available (you have ${dartSdkVersion}). Some features of Dart Code may not work correctly with an old SDK.`;
            const action = yield vscode_1.window.showWarningMessage(message, goToDownloadsAction, dontShowAgainAction);
            if (action === goToDownloadsAction)
                yield utils_2.envUtils.openInBrowser(constants_1.DART_DOWNLOAD_URL);
            else if (action === dontShowAgainAction)
                config_1.config.setCheckForSdkUpdates(false);
        }
        catch (e) {
            logger.error(e);
        }
    });
}
exports.checkForStandardDartSdkUpdates = checkForStandardDartSdkUpdates;


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DartTerminalLinkProvider = void 0;
const vs = __webpack_require__(0);
const package_map_1 = __webpack_require__(52);
const utils_1 = __webpack_require__(3);
const fs_1 = __webpack_require__(1);
const utils_2 = __webpack_require__(5);
const utils_3 = __webpack_require__(6);
const packageUriPattern = new RegExp("(?<uri>package:\\S+[\\/]\\S+\\.dart)(?:[: ](?<line>\\d+):(?<col>\\d+))?", "mg");
class DartTerminalLinkProvider {
    constructor(logger, context) {
        this.logger = logger;
        this.context = context;
        context.events.onPackageMapChange.listen(() => {
            this.packageMaps = undefined;
            this.packageMapDiscovery = undefined;
        });
    }
    discoverPackageMaps() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.packageMapDiscovery) {
                return this.packageMapDiscovery;
            }
            this.packageMapDiscovery = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const workspaceFolders = utils_2.getDartWorkspaceFolders();
                const topLevelFolders = workspaceFolders.map((w) => fs_1.fsPath(w.uri));
                const allExcludedFolders = utils_1.flatMap(workspaceFolders, utils_3.getExcludedFolders);
                const projectFolders = yield fs_1.findProjectFolders(this.logger, topLevelFolders, allExcludedFolders, { requirePubspec: true });
                this.packageMaps = {};
                for (const projectFolder of projectFolders) {
                    this.packageMaps[projectFolder] = package_map_1.PackageMap.loadForProject(this.logger, projectFolder);
                }
                resolve();
            }));
            return this.packageMapDiscovery;
        });
    }
    isKnownPackage(packageName) {
        return this.packageMaps && !!Object.values(this.packageMaps).find((m) => m.packages[packageName]);
    }
    resolvePackageUri(uri) {
        if (!this.packageMaps)
            return undefined;
        for (const packageMap of Object.values(this.packageMaps)) {
            const filePath = packageMap.resolvePackageUri(uri);
            if (filePath)
                return filePath;
        }
        return undefined;
    }
    provideTerminalLinks(context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.packageMaps)
                yield this.discoverPackageMaps();
            const results = [];
            packageUriPattern.lastIndex = -1;
            let result;
            // tslint:disable-next-line: no-conditional-assignment
            while ((result = packageUriPattern.exec(context.line)) && result.groups) {
                let uri;
                try {
                    uri = vs.Uri.parse(result.groups.uri, true);
                }
                catch (e) {
                    this.logger.error(e);
                    continue;
                }
                if (!uri)
                    continue;
                const packageName = uri.path.split("/")[0];
                if (!this.isKnownPackage(packageName))
                    continue;
                const line = result.groups.line ? parseInt(result.groups.line) : undefined;
                const col = result.groups.col ? parseInt(result.groups.col) : undefined;
                const startIndex = result.index;
                // TODO: This should be "result[0].length" but including the line/col can cause
                // the tooltip not to render correctly, so we only highlight the uri for now.
                // https://github.com/microsoft/vscode/issues/108301
                const length = result.groups.uri.length;
                results.push({
                    col,
                    length,
                    line,
                    packageName,
                    startIndex,
                    tooltip: "Open file in editor",
                    uri: result.groups.uri,
                });
            }
            return results;
        });
    }
    handleTerminalLink(link) {
        const filePath = this.resolvePackageUri(link.uri);
        if (!filePath) {
            vs.window.showErrorMessage(`Unable to find root for package ${link.packageName}`);
            return;
        }
        vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(filePath), link.line, link.col);
    }
}
exports.DartTerminalLinkProvider = DartTerminalLinkProvider;


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleNewProjects = exports.showUserPrompts = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const fs_1 = __webpack_require__(1);
const extension_utils_1 = __webpack_require__(20);
const user_prompts_1 = __webpack_require__(126);
const utils_1 = __webpack_require__(5);
const sdk_1 = __webpack_require__(132);
const utils_2 = __webpack_require__(6);
function showUserPrompts(logger, context, webClient, workspaceContext) {
    return __awaiter(this, void 0, void 0, function* () {
        function shouldSuppress(key) {
            const stateKey = `${constants_1.userPromptContextPrefix}${key}`;
            return context.get(stateKey) === true;
        }
        /// Shows a prompt and stores the return value. Prompt should return `true` to mark
        /// this extension as seen-forever and it won't be shown again. Returning anything
        /// else will allow the prompt to appear again next time.
        function showPrompt(key, prompt) {
            const stateKey = `${constants_1.userPromptContextPrefix}${key}`;
            prompt().then((res) => context.update(stateKey, res), error);
        }
        if (workspaceContext.hasAnyFlutterProjects && !extension_utils_1.hasFlutterExtension && !shouldSuppress(constants_1.installFlutterExtensionPromptKey)) {
            // It's possible that we got here when the user installed the Flutter extension, because it causes Dart to install
            // first and activate. So, before showing this prompt we'll wait 30 seconds and then check if we still don't
            // have the Flutter extension, and then show the prompt.
            yield new Promise((resolve) => setTimeout(resolve, 20000));
            if (!extension_utils_1.checkHasFlutterExtension())
                return showPrompt(constants_1.installFlutterExtensionPromptKey, promptToInstallFlutterExtension);
        }
        // Check the user hasn't installed Flutter in a forbidden location that will cause issues.
        if (workspaceContext.hasAnyFlutterProjects && workspaceContext.sdks.flutter) {
            if (constants_1.isWin) {
                const forbiddenLocations = [
                    process.env.COMMONPROGRAMFILES,
                    process.env["COMMONPROGRAMFILES(x86)"],
                    process.env.CommonProgramW6432,
                    process.env.PROGRAMFILES,
                    process.env.ProgramW6432,
                    process.env["PROGRAMFILES(X86)"],
                ];
                const installedForbiddenLocation = forbiddenLocations.find((fl) => { var _a; return fl && ((_a = workspaceContext.sdks.flutter) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith(fl.toLowerCase())); });
                if (installedForbiddenLocation) {
                    logger.error(`Flutter is installed in protected folder: ${installedForbiddenLocation}`);
                    vs.window.showErrorMessage("The Flutter SDK is installed in a protected folder and may not function correctly. Please move the SDK to a location that is user-writable without Administration permissions and restart.");
                }
            }
        }
        const lastSeenVersionNotification = context.lastSeenVersion;
        if (!lastSeenVersionNotification) {
            // If we've not got a stored version, this is the first install, so just
            // stash the current version and don't show anything.
            context.lastSeenVersion = extension_utils_1.extensionVersion;
        }
        else if (false) {}
        if (workspaceContext.hasAnyFlutterProjects) {
            if (yield user_prompts_1.showFlutterSurveyNotificationIfAppropriate(context, webClient, utils_1.envUtils.openInBrowser, Date.now(), logger))
                return; // Bail if we showed it, so we won't show any other notifications.
        }
        if (!shouldSuppress(constants_1.useRecommendedSettingsPromptKey)) {
            showPrompt(constants_1.useRecommendedSettingsPromptKey, promptToUseRecommendedSettings);
            return;
        }
        // (though, there are no other notifications right now...)
    });
}
exports.showUserPrompts = showUserPrompts;
function promptToUseRecommendedSettings() {
    return __awaiter(this, void 0, void 0, function* () {
        const action = yield vs.window.showInformationMessage("Would you like to use recommended VS Code settings for Dart & Flutter?", constants_1.yesAction, constants_1.noAction, constants_1.showRecommendedSettingsAction);
        if (action === constants_1.yesAction) {
            yield vs.commands.executeCommand("dart.writeRecommendedSettings");
        }
        else if (action === constants_1.showRecommendedSettingsAction) {
            yield utils_1.envUtils.openInBrowser(constants_1.recommendedSettingsUrl);
        }
        return true;
    });
}
function promptToInstallFlutterExtension() {
    return __awaiter(this, void 0, void 0, function* () {
        const installExtension = "Install Flutter Extension";
        const res = yield vs.window.showInformationMessage("The Flutter extension is required to work with Flutter projects.", installExtension);
        if (res === installExtension) {
            yield vs.window.withProgress({ location: vs.ProgressLocation.Notification }, (progress) => {
                progress.report({ message: "Installing Flutter extension" });
                return new Promise((resolve) => {
                    vs.extensions.onDidChange((e) => resolve());
                    vs.commands.executeCommand("workbench.extensions.installExtension", constants_1.flutterExtensionIdentifier);
                });
            });
            // tslint:disable-next-line: no-floating-promises
            utils_2.promptToReloadExtension();
        }
        return false;
    });
}
function promptToShowReleaseNotes(versionDisplay, versionLink) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield vs.window.showInformationMessage(`Dart Code has been updated to v${versionDisplay}`, `Show Release Notes`);
        if (res) {
            yield utils_1.envUtils.openInBrowser(`https://dartcode.org/releases/v${versionLink}/`);
        }
        return true; // Always mark this as done; we don't want to prompt the user multiple times.
    });
}
function error(err) {
    vs.window.showErrorMessage(err.message);
}
function handleNewProjects(logger, context) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(utils_1.getDartWorkspaceFolders().map((wf) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield handleStagehandTrigger(logger, wf, constants_1.DART_STAGEHAND_PROJECT_TRIGGER_FILE);
                yield handleFlutterCreateTrigger(wf);
            }
            catch (e) {
                logger.error("Failed to create project");
                logger.error(e);
                vs.window.showErrorMessage("Failed to create project");
            }
        })));
    });
}
exports.handleNewProjects = handleNewProjects;
function handleStagehandTrigger(logger, wf, triggerFilename) {
    return __awaiter(this, void 0, void 0, function* () {
        const triggerFile = path.join(fs_1.fsPath(wf.uri), triggerFilename);
        if (!fs.existsSync(triggerFile))
            return;
        const templateJson = fs.readFileSync(triggerFile).toString().trim();
        let template;
        try {
            template = JSON.parse(templateJson);
        }
        catch (e) {
            logger.error("Failed to get Stagehand templates");
            logger.error(e);
            vs.window.showErrorMessage("Failed to run Stagehand to create project");
            return;
        }
        fs.unlinkSync(triggerFile);
        logger.info(`Creating Dart project for ${fs_1.fsPath(wf.uri)}`, enums_1.LogCategory.CommandProcesses);
        try {
            sdk_1.markProjectCreationStarted();
            const success = yield createDartProject(fs_1.fsPath(wf.uri), template.name);
            if (success) {
                logger.info(`Fetching packages for newly-created project`, enums_1.LogCategory.CommandProcesses);
                yield vs.commands.executeCommand("dart.getPackages", wf.uri);
                handleDartWelcome(wf, template);
                logger.info(`Finished creating new project!`, enums_1.LogCategory.CommandProcesses);
            }
            else {
                logger.info(`Failed to create new project`, enums_1.LogCategory.CommandProcesses);
            }
        }
        finally {
            sdk_1.markProjectCreationEnded();
        }
    });
}
function handleFlutterCreateTrigger(wf) {
    return __awaiter(this, void 0, void 0, function* () {
        const flutterTriggerFile = path.join(fs_1.fsPath(wf.uri), constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE);
        if (!fs.existsSync(flutterTriggerFile))
            return;
        const jsonString = fs.readFileSync(flutterTriggerFile).toString().trim();
        const json = jsonString ? JSON.parse(jsonString) : undefined;
        fs.unlinkSync(flutterTriggerFile);
        try {
            sdk_1.markProjectCreationStarted();
            const success = yield createFlutterProject(fs_1.fsPath(wf.uri), json);
            if (success)
                handleFlutterWelcome(wf, json);
        }
        finally {
            sdk_1.markProjectCreationEnded();
        }
    });
}
function createDartProject(projectPath, templateName) {
    return __awaiter(this, void 0, void 0, function* () {
        const code = yield vs.commands.executeCommand("_dart.create", projectPath, templateName);
        return code === 0;
    });
}
function createFlutterProject(projectPath, triggerData) {
    return __awaiter(this, void 0, void 0, function* () {
        const projectName = (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample) ? "sample" : undefined;
        const code = yield vs.commands.executeCommand("_flutter.create", projectPath, projectName, triggerData);
        return code === 0;
    });
}
function handleFlutterWelcome(workspaceFolder, triggerData) {
    const entryFile = path.join(fs_1.fsPath(workspaceFolder.uri), "lib/main.dart");
    openFile(entryFile);
    if (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample)
        vs.window.showInformationMessage(`${triggerData.sample} sample ready! Connect a device and press F5 to run.`);
    else
        vs.window.showInformationMessage("Your Flutter project is ready! Connect a device and press F5 to start running.");
}
function handleDartWelcome(workspaceFolder, template) {
    const workspacePath = fs_1.fsPath(workspaceFolder.uri);
    const projectName = path.basename(workspacePath);
    const entryFile = path.join(workspacePath, template.entrypoint.replace("__projectName__", projectName));
    openFile(entryFile);
    vs.window.showInformationMessage(`${template.label} project ready!`);
}
/// Opens a file, but does it in a setTimeout to work around VS Code reveal bug
/// https://github.com/Microsoft/vscode/issues/71588#event-2252962973
function openFile(entryFile) {
    if (!fs.existsSync(entryFile))
        return;
    // TODO: Remove this setTimeout when it's no longer required.
    setTimeout(() => {
        vs.commands.executeCommand("vscode.open", vs.Uri.file(entryFile));
    }, 100);
}


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageDepPackage = exports.PackageDepProject = exports.PackageDepFolder = exports.PackageDepFile = exports.PackageDep = exports.DartPackagesProvider = void 0;
const fs = __webpack_require__(7);
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const package_map_1 = __webpack_require__(52);
const utils_1 = __webpack_require__(3);
const array_1 = __webpack_require__(19);
const fs_1 = __webpack_require__(1);
const utils_2 = __webpack_require__(5);
const utils_3 = __webpack_require__(6);
class DartPackagesProvider {
    constructor(logger, context) {
        this.logger = logger;
        this.context = context;
        this.onDidChangeTreeDataEmitter = new vs.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
        context.events.onPackageMapChange.listen(() => {
            this.onDidChangeTreeDataEmitter.fire(undefined);
        });
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!element) {
                const workspaceFolders = utils_2.getDartWorkspaceFolders();
                const topLevelFolders = workspaceFolders.map((w) => fs_1.fsPath(w.uri));
                const allExcludedFolders = utils_1.flatMap(workspaceFolders, utils_3.getExcludedFolders);
                const allProjects = yield fs_1.findProjectFolders(this.logger, topLevelFolders, allExcludedFolders, { requirePubspec: true });
                const nodes = allProjects.map((folder) => new PackageDepProject(vs.Uri.file(folder)));
                // If there's only one, just skip over to the deps.
                return nodes.length === 1
                    ? this.getChildren(nodes[0])
                    : nodes;
            }
            else if (element instanceof PackageDepProject) {
                return this.getPackages(element);
            }
            else if (element instanceof PackageDepPackage) {
                return this.getFilesAndFolders(element);
            }
            else if (element instanceof PackageDepFolder) {
                return this.getFilesAndFolders(element);
            }
            else if (element instanceof PackageDepFile) {
                return [];
            }
            else {
                this.logger.warn(`Don't know how to show children of ${element.label}/${element.resourceUri}`);
                return [];
            }
        });
    }
    getPackages(project) {
        const projectFolder = fs_1.fsPath(project.resourceUri);
        const map = package_map_1.PackageMap.loadForProject(this.logger, projectFolder);
        const packages = map.packages;
        const packageNames = array_1.sortBy(Object.keys(packages), (s) => s.toLowerCase());
        const packageDepNodes = packageNames
            .filter((name) => packages[name] && !fs_1.areSameFolder(packages[name], path.join(projectFolder, "lib")))
            .map((name) => {
            let packagePath = packages[name];
            if (path.basename(packagePath) === "lib")
                packagePath = path.normalize(path.join(packagePath, ".."));
            return new PackageDepPackage(`${name}`, vs.Uri.file(packagePath));
        });
        return packageDepNodes;
    }
    getFilesAndFolders(folder) {
        const children = array_1.sortBy(fs.readdirSync(fs_1.fsPath(folder.resourceUri), { withFileTypes: true }), (s) => s.name.toLowerCase());
        const folders = [];
        const files = [];
        if (!folder.resourceUri)
            return [];
        const folderPath = fs_1.fsPath(folder.resourceUri);
        children.forEach((child) => {
            const filePath = path.join(folderPath, child.name);
            if (child.isFile()) {
                files.push(new PackageDepFile(vs.Uri.file(filePath)));
            }
            else if (child.isDirectory()) {
                folders.push(new PackageDepFolder(vs.Uri.file(filePath)));
            }
        });
        return [...folders, ...files];
    }
}
exports.DartPackagesProvider = DartPackagesProvider;
class PackageDep extends vs.TreeItem {
    constructor(label, resourceUri, collapsibleState) {
        if (label) {
            super(label, collapsibleState);
            this.resourceUri = resourceUri;
        }
        else {
            super(resourceUri, collapsibleState);
        }
    }
}
exports.PackageDep = PackageDep;
class PackageDepFile extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.None);
        this.contextValue = constants_1.DART_DEP_FILE_NODE_CONTEXT;
        this.command = {
            arguments: [resourceUri],
            command: "dart.package.openFile",
            title: "Open File",
        };
    }
}
exports.PackageDepFile = PackageDepFile;
class PackageDepFolder extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.contextValue = constants_1.DART_DEP_FOLDER_NODE_CONTEXT;
    }
}
exports.PackageDepFolder = PackageDepFolder;
class PackageDepProject extends PackageDep {
    constructor(resourceUri) {
        const projectFolder = fs_1.fsPath(resourceUri);
        super(path.basename(projectFolder), resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.contextValue = constants_1.DART_DEP_PROJECT_NODE_CONTEXT;
        // Calculate relative path to the folder for the description.
        const wf = vs.workspace.getWorkspaceFolder(resourceUri);
        if (wf) {
            const workspaceFolder = fs_1.fsPath(wf.uri);
            this.description = path.relative(path.dirname(workspaceFolder), path.dirname(projectFolder));
        }
    }
}
exports.PackageDepProject = PackageDepProject;
class PackageDepPackage extends PackageDep {
    constructor(label, resourceUri) {
        super(label, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.contextValue = constants_1.DART_DEP_PACKAGE_NODE_CONTEXT;
    }
}
exports.PackageDepPackage = PackageDepPackage;


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestResultsProvider = void 0;
const path = __webpack_require__(2);
const vs = __webpack_require__(0);
const constants_1 = __webpack_require__(4);
const enums_1 = __webpack_require__(8);
const test_model_1 = __webpack_require__(61);
const utils_1 = __webpack_require__(3);
const colors_1 = __webpack_require__(67);
const fs_1 = __webpack_require__(1);
const test_1 = __webpack_require__(57);
const extension_utils_1 = __webpack_require__(20);
const terminals_1 = __webpack_require__(127);
class TestResultsProvider {
    constructor(data, coordindator) {
        this.data = data;
        this.coordindator = coordindator;
        this.disposables = [];
        this.onDidChangeTreeDataEmitter = new vs.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
        this.disposables.push(data.onDidChangeTreeData.listen((node) => this.onDidChangeTreeDataEmitter.fire(node)));
        this.disposables.push(vs.debug.onDidReceiveDebugSessionCustomEvent((e) => this.handleDebugSessionCustomEvent(e)));
        this.disposables.push(vs.debug.onDidTerminateDebugSession((session) => this.handleDebugSessionEnd(session)));
        this.disposables.push(vs.commands.registerCommand("dart.startDebuggingTest", (treeNode) => this.runTests(treeNode, this.getTestNames(treeNode, false), true, false)));
        this.disposables.push(vs.commands.registerCommand("dart.startWithoutDebuggingTest", (treeNode) => this.runTests(treeNode, this.getTestNames(treeNode, false), false, false)));
        this.disposables.push(vs.commands.registerCommand("dart.startDebuggingFailedTests", (treeNode) => this.runTests(treeNode, this.getTestNames(treeNode, true), true, false)));
        this.disposables.push(vs.commands.registerCommand("dart.startWithoutDebuggingFailedTests", (treeNode) => this.runTests(treeNode, this.getTestNames(treeNode, true), false, false)));
        this.disposables.push(vs.commands.registerCommand("dart.runAllFailedTestsWithoutDebugging", () => this.runAllFailedTests()));
        this.disposables.push(vs.commands.registerCommand("_dart.displaySuite", (treeNode) => vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(treeNode.suiteData.path))));
        this.disposables.push(vs.commands.registerCommand("_dart.displayGroup", (treeNode) => {
            if (!treeNode.path)
                return;
            return vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(treeNode.path), treeNode.line, treeNode.column);
        }));
        this.disposables.push(vs.commands.registerCommand("_dart.displayTest", (treeNode) => {
            this.writeTestOutput(treeNode);
            if (!treeNode.path)
                return;
            return vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(treeNode.path), treeNode.line, treeNode.column);
        }));
    }
    handleDebugSessionCustomEvent(e) {
        this.coordindator.handleDebugSessionCustomEvent(e);
    }
    handleDebugSessionEnd(session) {
        this.coordindator.handleDebugSessionEnd(session.id);
    }
    runAllFailedTests() {
        return __awaiter(this, void 0, void 0, function* () {
            const topLevelNodes = this.getChildren() || [];
            const suitesWithFailures = topLevelNodes
                .filter((node) => node instanceof test_model_1.SuiteNode && node.hasFailures)
                .map((m) => [m, this.getTestNames(m, true)]);
            if (suitesWithFailures.length === 0)
                return;
            const percentProgressPerTest = 99 / suitesWithFailures.map((swf) => swf[1].length).reduce((a, b) => a + b);
            yield vs.window.withProgress({
                cancellable: true,
                location: vs.ProgressLocation.Notification,
                title: "Re-running failed tests",
            }, (progress, token) => __awaiter(this, void 0, void 0, function* () {
                progress.report({ increment: 1 });
                for (const suite of suitesWithFailures) {
                    const node = suite[0];
                    const failedTestNames = suite[1];
                    if (token.isCancellationRequested)
                        break;
                    const suiteName = path.basename(node.suiteData.path);
                    progress.report({ message: suiteName });
                    yield this.runTests(node, failedTestNames, false, true, token);
                    progress.report({ message: suiteName, increment: failedTestNames.length * percentProgressPerTest });
                }
            }));
        });
    }
    runTests(treeNode, testNames, debug, suppressPromptOnErrors, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const subs = [];
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                // Construct a unique ID for this session so we can track when it completes.
                const dartCodeDebugSessionID = `session-${fs_1.getRandomInt(0x1000, 0x10000).toString(16)}`;
                if (token) {
                    subs.push(vs.debug.onDidStartDebugSession((e) => {
                        if (e.configuration.dartCodeDebugSessionID === dartCodeDebugSessionID)
                            subs.push(token.onCancellationRequested(() => e.customRequest("disconnect")));
                    }));
                }
                subs.push(vs.debug.onDidTerminateDebugSession((e) => {
                    if (e.configuration.dartCodeDebugSessionID === dartCodeDebugSessionID)
                        resolve();
                }));
                const programPath = fs_1.fsPath(treeNode.suiteData.path);
                const didStart = yield vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(vs.Uri.file(treeNode.suiteData.path)), Object.assign(Object.assign({ dartCodeDebugSessionID,
                    suppressPromptOnErrors }, test_1.getLaunchConfig(!debug, programPath, testNames, treeNode instanceof test_model_1.GroupNode)), { name: `Tests ${path.basename(programPath)}` }));
                if (!didStart)
                    reject();
            })).finally(() => utils_1.disposeAll(subs));
        });
    }
    getTestNames(treeNode, failedOnly) {
        // If we're not running failed only, we can just use the test name/group name (or undefined for suite)
        // directly.
        if (!failedOnly) {
            if ((treeNode instanceof test_model_1.TestNode || treeNode instanceof test_model_1.GroupNode) && treeNode.name !== undefined)
                return [treeNode.name];
            return undefined;
        }
        // Otherwise, collect all descendants tests that are failed.
        let names = [];
        if (treeNode instanceof test_model_1.SuiteNode || treeNode instanceof test_model_1.GroupNode) {
            for (const child of treeNode.children) {
                const childNames = this.getTestNames(child, failedOnly);
                if (childNames)
                    names = names.concat(childNames);
            }
        }
        else if (treeNode instanceof test_model_1.TestNode && treeNode.hasFailures) {
            if (treeNode.name !== undefined)
                names.push(treeNode.name);
        }
        return names;
    }
    writeTestOutput(treeNode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentTestTerminal) {
                this.currentTestTerminal[0].dispose();
                this.currentTestTerminal = undefined;
            }
            const messages = [];
            messages.push(`Output for ${treeNode.name}\r\n`);
            if (!treeNode.outputEvents.length)
                messages.push(`(no output)\r\n`);
            for (const o of treeNode.outputEvents) {
                messages.push(this.getColoredTestOutput(o));
            }
            this.currentTestTerminal = terminals_1.writeToPseudoTerminal(messages);
        });
    }
    getColoredTestOutput(event) {
        let output;
        if (event.type === "error") {
            event = event;
            output = colors_1.brightRed(`${event.error}\n${event.stackTrace}\n`);
        }
        else if (event.type === "print") {
            event = event;
            output = `${event.message}\n`;
        }
        else {
            output = colors_1.yellow(`Unknown message type '${event.type}'.\n`);
        }
        return output;
    }
    getTreeItem(element) {
        if (element instanceof test_model_1.SuiteNode) {
            return treeItemBuilder.createSuiteNode(element);
        }
        else if (element instanceof test_model_1.GroupNode) {
            return treeItemBuilder.createGroupNode(element);
        }
        else if (element instanceof test_model_1.TestNode) {
            return treeItemBuilder.createTestNode(element);
        }
        else {
            throw new Error(`Unrecognised tree node type: ${element}`);
        }
    }
    getChildren(element) {
        // Nodes with children.
        if (element instanceof test_model_1.SuiteNode || element instanceof test_model_1.GroupNode)
            return element.children;
        // Notes without children (TestNode, or other unknown).
        if (element)
            return [];
        // All top-level suites.
        return Object.values(this.data.suites)
            .map((suite) => suite.node)
            .sort((a, b) => {
            // Sort by .sort first.
            if (a.sort > b.sort)
                return 1;
            if (a.sort < b.sort)
                return -1;
            // If they're the same, sort by label.
            const aLabel = a.label || (a.suiteData.path || "");
            const bLabel = b.label || (b.suiteData.path || "");
            if (aLabel > bLabel)
                return 1;
            if (aLabel < bLabel)
                return -1;
            return 0;
        });
    }
    getParent(element) {
        if (element instanceof test_model_1.TestNode || element instanceof test_model_1.GroupNode)
            return element.parent;
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
}
exports.TestResultsProvider = TestResultsProvider;
function getIconPath(status, isStale) {
    let file;
    // TODO: Should we have faded icons for stale versions?
    switch (status) {
        case enums_1.TestStatus.Running:
            file = "running";
            break;
        case enums_1.TestStatus.Passed:
            file = isStale ? "pass_stale" : "pass";
            break;
        case enums_1.TestStatus.Failed:
        case enums_1.TestStatus.Errored:
            file = isStale ? "fail_stale" : "fail";
            break;
        case enums_1.TestStatus.Skipped:
            file = isStale ? "skip_stale" : "skip";
            break;
        case enums_1.TestStatus.Unknown:
            file = "unknown";
            break;
        case enums_1.TestStatus.Waiting:
            file = "loading";
            break;
        default:
            file = undefined;
    }
    return file && extension_utils_1.extensionPath
        ? vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/tests/${file}.svg`))
        : undefined;
}
class TreeItemBuilder {
    createSuiteNode(node) {
        var _a;
        // TODO: children is quite expensive, we should add a faster way.
        const collapseState = ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) || 0 > 0 ? vs.TreeItemCollapsibleState.Collapsed : vs.TreeItemCollapsibleState.None;
        const treeItem = new vs.TreeItem(vs.Uri.file(node.suiteData.path), collapseState);
        treeItem.contextValue = node.hasFailures
            ? constants_1.DART_TEST_SUITE_NODE_WITH_FAILURES_CONTEXT
            : constants_1.DART_TEST_SUITE_NODE_CONTEXT;
        treeItem.iconPath = getIconPath(node.status, node.isStale);
        treeItem.description = node.description;
        treeItem.command = { command: "_dart.displaySuite", arguments: [node], title: "" };
        return treeItem;
    }
    createGroupNode(node) {
        var _a;
        const collapseState = ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) || 0 > 0 ? vs.TreeItemCollapsibleState.Collapsed : vs.TreeItemCollapsibleState.None;
        const treeItem = new vs.TreeItem(node.label || "<unnamed>", collapseState);
        treeItem.contextValue = constants_1.DART_TEST_GROUP_NODE_CONTEXT;
        treeItem.resourceUri = vs.Uri.file(node.suiteData.path);
        treeItem.iconPath = getIconPath(node.status, node.isStale);
        treeItem.description = node.description;
        treeItem.command = { command: "_dart.displayGroup", arguments: [node], title: "" };
        return treeItem;
    }
    createTestNode(node) {
        const treeItem = new vs.TreeItem(node.label || "<unnamed>", vs.TreeItemCollapsibleState.None);
        treeItem.contextValue = constants_1.DART_TEST_TEST_NODE_CONTEXT;
        treeItem.resourceUri = vs.Uri.file(node.suiteData.path);
        treeItem.iconPath = getIconPath(node.status, node.isStale);
        treeItem.description = node.description;
        treeItem.command = { command: "_dart.displayTest", arguments: [node], title: "" };
        return treeItem;
    }
}
const treeItemBuilder = new TreeItemBuilder();


/***/ })
/******/ ]);
//# sourceMappingURL=extension.js.map