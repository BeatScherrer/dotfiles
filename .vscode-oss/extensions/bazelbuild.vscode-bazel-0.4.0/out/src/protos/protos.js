"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function (global, factory) {
    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));
})(this, function ($protobuf) {
    "use strict";
    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.build_event_stream = (function () {
        /**
         * Namespace build_event_stream.
         * @exports build_event_stream
         * @namespace
         */
        var build_event_stream = {};
        build_event_stream.BuildEventId = (function () {
            /**
             * Properties of a BuildEventId.
             * @memberof build_event_stream
             * @interface IBuildEventId
             * @property {build_event_stream.BuildEventId.IUnknownBuildEventId|null} [unknown] BuildEventId unknown
             * @property {build_event_stream.BuildEventId.IProgressId|null} [progress] BuildEventId progress
             * @property {build_event_stream.BuildEventId.IBuildStartedId|null} [started] BuildEventId started
             * @property {build_event_stream.BuildEventId.IUnstructuredCommandLineId|null} [unstructuredCommandLine] BuildEventId unstructuredCommandLine
             * @property {build_event_stream.BuildEventId.IStructuredCommandLineId|null} [structuredCommandLine] BuildEventId structuredCommandLine
             * @property {build_event_stream.BuildEventId.IWorkspaceStatusId|null} [workspaceStatus] BuildEventId workspaceStatus
             * @property {build_event_stream.BuildEventId.IOptionsParsedId|null} [optionsParsed] BuildEventId optionsParsed
             * @property {build_event_stream.BuildEventId.IFetchId|null} [fetch] BuildEventId fetch
             * @property {build_event_stream.BuildEventId.IConfigurationId|null} [configuration] BuildEventId configuration
             * @property {build_event_stream.BuildEventId.ITargetConfiguredId|null} [targetConfigured] BuildEventId targetConfigured
             * @property {build_event_stream.BuildEventId.IPatternExpandedId|null} [pattern] BuildEventId pattern
             * @property {build_event_stream.BuildEventId.IPatternExpandedId|null} [patternSkipped] BuildEventId patternSkipped
             * @property {build_event_stream.BuildEventId.INamedSetOfFilesId|null} [namedSet] BuildEventId namedSet
             * @property {build_event_stream.BuildEventId.ITargetCompletedId|null} [targetCompleted] BuildEventId targetCompleted
             * @property {build_event_stream.BuildEventId.IActionCompletedId|null} [actionCompleted] BuildEventId actionCompleted
             * @property {build_event_stream.BuildEventId.IUnconfiguredLabelId|null} [unconfiguredLabel] BuildEventId unconfiguredLabel
             * @property {build_event_stream.BuildEventId.IConfiguredLabelId|null} [configuredLabel] BuildEventId configuredLabel
             * @property {build_event_stream.BuildEventId.ITestResultId|null} [testResult] BuildEventId testResult
             * @property {build_event_stream.BuildEventId.ITestSummaryId|null} [testSummary] BuildEventId testSummary
             * @property {build_event_stream.BuildEventId.IBuildFinishedId|null} [buildFinished] BuildEventId buildFinished
             * @property {build_event_stream.BuildEventId.IBuildToolLogsId|null} [buildToolLogs] BuildEventId buildToolLogs
             * @property {build_event_stream.BuildEventId.IBuildMetricsId|null} [buildMetrics] BuildEventId buildMetrics
             */
            /**
             * Constructs a new BuildEventId.
             * @memberof build_event_stream
             * @classdesc Represents a BuildEventId.
             * @implements IBuildEventId
             * @constructor
             * @param {build_event_stream.IBuildEventId=} [properties] Properties to set
             */
            function BuildEventId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * BuildEventId unknown.
             * @member {build_event_stream.BuildEventId.IUnknownBuildEventId|null|undefined} unknown
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.unknown = null;
            /**
             * BuildEventId progress.
             * @member {build_event_stream.BuildEventId.IProgressId|null|undefined} progress
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.progress = null;
            /**
             * BuildEventId started.
             * @member {build_event_stream.BuildEventId.IBuildStartedId|null|undefined} started
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.started = null;
            /**
             * BuildEventId unstructuredCommandLine.
             * @member {build_event_stream.BuildEventId.IUnstructuredCommandLineId|null|undefined} unstructuredCommandLine
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.unstructuredCommandLine = null;
            /**
             * BuildEventId structuredCommandLine.
             * @member {build_event_stream.BuildEventId.IStructuredCommandLineId|null|undefined} structuredCommandLine
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.structuredCommandLine = null;
            /**
             * BuildEventId workspaceStatus.
             * @member {build_event_stream.BuildEventId.IWorkspaceStatusId|null|undefined} workspaceStatus
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.workspaceStatus = null;
            /**
             * BuildEventId optionsParsed.
             * @member {build_event_stream.BuildEventId.IOptionsParsedId|null|undefined} optionsParsed
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.optionsParsed = null;
            /**
             * BuildEventId fetch.
             * @member {build_event_stream.BuildEventId.IFetchId|null|undefined} fetch
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.fetch = null;
            /**
             * BuildEventId configuration.
             * @member {build_event_stream.BuildEventId.IConfigurationId|null|undefined} configuration
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.configuration = null;
            /**
             * BuildEventId targetConfigured.
             * @member {build_event_stream.BuildEventId.ITargetConfiguredId|null|undefined} targetConfigured
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.targetConfigured = null;
            /**
             * BuildEventId pattern.
             * @member {build_event_stream.BuildEventId.IPatternExpandedId|null|undefined} pattern
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.pattern = null;
            /**
             * BuildEventId patternSkipped.
             * @member {build_event_stream.BuildEventId.IPatternExpandedId|null|undefined} patternSkipped
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.patternSkipped = null;
            /**
             * BuildEventId namedSet.
             * @member {build_event_stream.BuildEventId.INamedSetOfFilesId|null|undefined} namedSet
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.namedSet = null;
            /**
             * BuildEventId targetCompleted.
             * @member {build_event_stream.BuildEventId.ITargetCompletedId|null|undefined} targetCompleted
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.targetCompleted = null;
            /**
             * BuildEventId actionCompleted.
             * @member {build_event_stream.BuildEventId.IActionCompletedId|null|undefined} actionCompleted
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.actionCompleted = null;
            /**
             * BuildEventId unconfiguredLabel.
             * @member {build_event_stream.BuildEventId.IUnconfiguredLabelId|null|undefined} unconfiguredLabel
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.unconfiguredLabel = null;
            /**
             * BuildEventId configuredLabel.
             * @member {build_event_stream.BuildEventId.IConfiguredLabelId|null|undefined} configuredLabel
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.configuredLabel = null;
            /**
             * BuildEventId testResult.
             * @member {build_event_stream.BuildEventId.ITestResultId|null|undefined} testResult
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.testResult = null;
            /**
             * BuildEventId testSummary.
             * @member {build_event_stream.BuildEventId.ITestSummaryId|null|undefined} testSummary
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.testSummary = null;
            /**
             * BuildEventId buildFinished.
             * @member {build_event_stream.BuildEventId.IBuildFinishedId|null|undefined} buildFinished
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.buildFinished = null;
            /**
             * BuildEventId buildToolLogs.
             * @member {build_event_stream.BuildEventId.IBuildToolLogsId|null|undefined} buildToolLogs
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.buildToolLogs = null;
            /**
             * BuildEventId buildMetrics.
             * @member {build_event_stream.BuildEventId.IBuildMetricsId|null|undefined} buildMetrics
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            BuildEventId.prototype.buildMetrics = null;
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
            /**
             * BuildEventId id.
             * @member {"unknown"|"progress"|"started"|"unstructuredCommandLine"|"structuredCommandLine"|"workspaceStatus"|"optionsParsed"|"fetch"|"configuration"|"targetConfigured"|"pattern"|"patternSkipped"|"namedSet"|"targetCompleted"|"actionCompleted"|"unconfiguredLabel"|"configuredLabel"|"testResult"|"testSummary"|"buildFinished"|"buildToolLogs"|"buildMetrics"|undefined} id
             * @memberof build_event_stream.BuildEventId
             * @instance
             */
            Object.defineProperty(BuildEventId.prototype, "id", {
                get: $util.oneOfGetter($oneOfFields = ["unknown", "progress", "started", "unstructuredCommandLine", "structuredCommandLine", "workspaceStatus", "optionsParsed", "fetch", "configuration", "targetConfigured", "pattern", "patternSkipped", "namedSet", "targetCompleted", "actionCompleted", "unconfiguredLabel", "configuredLabel", "testResult", "testSummary", "buildFinished", "buildToolLogs", "buildMetrics"]),
                set: $util.oneOfSetter($oneOfFields)
            });
            /**
             * Creates a new BuildEventId instance using the specified properties.
             * @function create
             * @memberof build_event_stream.BuildEventId
             * @static
             * @param {build_event_stream.IBuildEventId=} [properties] Properties to set
             * @returns {build_event_stream.BuildEventId} BuildEventId instance
             */
            BuildEventId.create = function create(properties) {
                return new BuildEventId(properties);
            };
            /**
             * Encodes the specified BuildEventId message. Does not implicitly {@link build_event_stream.BuildEventId.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.BuildEventId
             * @static
             * @param {build_event_stream.IBuildEventId} message BuildEventId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildEventId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.unknown != null && message.hasOwnProperty("unknown"))
                    $root.build_event_stream.BuildEventId.UnknownBuildEventId.encode(message.unknown, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                if (message.progress != null && message.hasOwnProperty("progress"))
                    $root.build_event_stream.BuildEventId.ProgressId.encode(message.progress, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.started != null && message.hasOwnProperty("started"))
                    $root.build_event_stream.BuildEventId.BuildStartedId.encode(message.started, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                if (message.pattern != null && message.hasOwnProperty("pattern"))
                    $root.build_event_stream.BuildEventId.PatternExpandedId.encode(message.pattern, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.targetCompleted != null && message.hasOwnProperty("targetCompleted"))
                    $root.build_event_stream.BuildEventId.TargetCompletedId.encode(message.targetCompleted, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                if (message.actionCompleted != null && message.hasOwnProperty("actionCompleted"))
                    $root.build_event_stream.BuildEventId.ActionCompletedId.encode(message.actionCompleted, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
                if (message.testSummary != null && message.hasOwnProperty("testSummary"))
                    $root.build_event_stream.BuildEventId.TestSummaryId.encode(message.testSummary, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
                if (message.testResult != null && message.hasOwnProperty("testResult"))
                    $root.build_event_stream.BuildEventId.TestResultId.encode(message.testResult, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                if (message.buildFinished != null && message.hasOwnProperty("buildFinished"))
                    $root.build_event_stream.BuildEventId.BuildFinishedId.encode(message.buildFinished, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
                if (message.patternSkipped != null && message.hasOwnProperty("patternSkipped"))
                    $root.build_event_stream.BuildEventId.PatternExpandedId.encode(message.patternSkipped, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
                if (message.unstructuredCommandLine != null && message.hasOwnProperty("unstructuredCommandLine"))
                    $root.build_event_stream.BuildEventId.UnstructuredCommandLineId.encode(message.unstructuredCommandLine, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
                if (message.optionsParsed != null && message.hasOwnProperty("optionsParsed"))
                    $root.build_event_stream.BuildEventId.OptionsParsedId.encode(message.optionsParsed, writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
                if (message.namedSet != null && message.hasOwnProperty("namedSet"))
                    $root.build_event_stream.BuildEventId.NamedSetOfFilesId.encode(message.namedSet, writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
                if (message.workspaceStatus != null && message.hasOwnProperty("workspaceStatus"))
                    $root.build_event_stream.BuildEventId.WorkspaceStatusId.encode(message.workspaceStatus, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
                if (message.configuration != null && message.hasOwnProperty("configuration"))
                    $root.build_event_stream.BuildEventId.ConfigurationId.encode(message.configuration, writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
                if (message.targetConfigured != null && message.hasOwnProperty("targetConfigured"))
                    $root.build_event_stream.BuildEventId.TargetConfiguredId.encode(message.targetConfigured, writer.uint32(/* id 16, wireType 2 =*/ 130).fork()).ldelim();
                if (message.fetch != null && message.hasOwnProperty("fetch"))
                    $root.build_event_stream.BuildEventId.FetchId.encode(message.fetch, writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
                if (message.structuredCommandLine != null && message.hasOwnProperty("structuredCommandLine"))
                    $root.build_event_stream.BuildEventId.StructuredCommandLineId.encode(message.structuredCommandLine, writer.uint32(/* id 18, wireType 2 =*/ 146).fork()).ldelim();
                if (message.unconfiguredLabel != null && message.hasOwnProperty("unconfiguredLabel"))
                    $root.build_event_stream.BuildEventId.UnconfiguredLabelId.encode(message.unconfiguredLabel, writer.uint32(/* id 19, wireType 2 =*/ 154).fork()).ldelim();
                if (message.buildToolLogs != null && message.hasOwnProperty("buildToolLogs"))
                    $root.build_event_stream.BuildEventId.BuildToolLogsId.encode(message.buildToolLogs, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
                if (message.configuredLabel != null && message.hasOwnProperty("configuredLabel"))
                    $root.build_event_stream.BuildEventId.ConfiguredLabelId.encode(message.configuredLabel, writer.uint32(/* id 21, wireType 2 =*/ 170).fork()).ldelim();
                if (message.buildMetrics != null && message.hasOwnProperty("buildMetrics"))
                    $root.build_event_stream.BuildEventId.BuildMetricsId.encode(message.buildMetrics, writer.uint32(/* id 22, wireType 2 =*/ 178).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified BuildEventId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.BuildEventId
             * @static
             * @param {build_event_stream.IBuildEventId} message BuildEventId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildEventId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a BuildEventId message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.BuildEventId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.BuildEventId} BuildEventId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildEventId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.unknown = $root.build_event_stream.BuildEventId.UnknownBuildEventId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.progress = $root.build_event_stream.BuildEventId.ProgressId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.started = $root.build_event_stream.BuildEventId.BuildStartedId.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.unstructuredCommandLine = $root.build_event_stream.BuildEventId.UnstructuredCommandLineId.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.structuredCommandLine = $root.build_event_stream.BuildEventId.StructuredCommandLineId.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.workspaceStatus = $root.build_event_stream.BuildEventId.WorkspaceStatusId.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.optionsParsed = $root.build_event_stream.BuildEventId.OptionsParsedId.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.fetch = $root.build_event_stream.BuildEventId.FetchId.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.targetConfigured = $root.build_event_stream.BuildEventId.TargetConfiguredId.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.pattern = $root.build_event_stream.BuildEventId.PatternExpandedId.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.patternSkipped = $root.build_event_stream.BuildEventId.PatternExpandedId.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.namedSet = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.targetCompleted = $root.build_event_stream.BuildEventId.TargetCompletedId.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.actionCompleted = $root.build_event_stream.BuildEventId.ActionCompletedId.decode(reader, reader.uint32());
                            break;
                        case 19:
                            message.unconfiguredLabel = $root.build_event_stream.BuildEventId.UnconfiguredLabelId.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.configuredLabel = $root.build_event_stream.BuildEventId.ConfiguredLabelId.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.testResult = $root.build_event_stream.BuildEventId.TestResultId.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.testSummary = $root.build_event_stream.BuildEventId.TestSummaryId.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.buildFinished = $root.build_event_stream.BuildEventId.BuildFinishedId.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.buildToolLogs = $root.build_event_stream.BuildEventId.BuildToolLogsId.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.buildMetrics = $root.build_event_stream.BuildEventId.BuildMetricsId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a BuildEventId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.BuildEventId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.BuildEventId} BuildEventId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildEventId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a BuildEventId message.
             * @function verify
             * @memberof build_event_stream.BuildEventId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BuildEventId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.unknown != null && message.hasOwnProperty("unknown")) {
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.UnknownBuildEventId.verify(message.unknown);
                        if (error)
                            return "unknown." + error;
                    }
                }
                if (message.progress != null && message.hasOwnProperty("progress")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.ProgressId.verify(message.progress);
                        if (error)
                            return "progress." + error;
                    }
                }
                if (message.started != null && message.hasOwnProperty("started")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.BuildStartedId.verify(message.started);
                        if (error)
                            return "started." + error;
                    }
                }
                if (message.unstructuredCommandLine != null && message.hasOwnProperty("unstructuredCommandLine")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.UnstructuredCommandLineId.verify(message.unstructuredCommandLine);
                        if (error)
                            return "unstructuredCommandLine." + error;
                    }
                }
                if (message.structuredCommandLine != null && message.hasOwnProperty("structuredCommandLine")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.StructuredCommandLineId.verify(message.structuredCommandLine);
                        if (error)
                            return "structuredCommandLine." + error;
                    }
                }
                if (message.workspaceStatus != null && message.hasOwnProperty("workspaceStatus")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.WorkspaceStatusId.verify(message.workspaceStatus);
                        if (error)
                            return "workspaceStatus." + error;
                    }
                }
                if (message.optionsParsed != null && message.hasOwnProperty("optionsParsed")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.OptionsParsedId.verify(message.optionsParsed);
                        if (error)
                            return "optionsParsed." + error;
                    }
                }
                if (message.fetch != null && message.hasOwnProperty("fetch")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.FetchId.verify(message.fetch);
                        if (error)
                            return "fetch." + error;
                    }
                }
                if (message.configuration != null && message.hasOwnProperty("configuration")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.ConfigurationId.verify(message.configuration);
                        if (error)
                            return "configuration." + error;
                    }
                }
                if (message.targetConfigured != null && message.hasOwnProperty("targetConfigured")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.TargetConfiguredId.verify(message.targetConfigured);
                        if (error)
                            return "targetConfigured." + error;
                    }
                }
                if (message.pattern != null && message.hasOwnProperty("pattern")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.PatternExpandedId.verify(message.pattern);
                        if (error)
                            return "pattern." + error;
                    }
                }
                if (message.patternSkipped != null && message.hasOwnProperty("patternSkipped")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.PatternExpandedId.verify(message.patternSkipped);
                        if (error)
                            return "patternSkipped." + error;
                    }
                }
                if (message.namedSet != null && message.hasOwnProperty("namedSet")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.verify(message.namedSet);
                        if (error)
                            return "namedSet." + error;
                    }
                }
                if (message.targetCompleted != null && message.hasOwnProperty("targetCompleted")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.TargetCompletedId.verify(message.targetCompleted);
                        if (error)
                            return "targetCompleted." + error;
                    }
                }
                if (message.actionCompleted != null && message.hasOwnProperty("actionCompleted")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.ActionCompletedId.verify(message.actionCompleted);
                        if (error)
                            return "actionCompleted." + error;
                    }
                }
                if (message.unconfiguredLabel != null && message.hasOwnProperty("unconfiguredLabel")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.UnconfiguredLabelId.verify(message.unconfiguredLabel);
                        if (error)
                            return "unconfiguredLabel." + error;
                    }
                }
                if (message.configuredLabel != null && message.hasOwnProperty("configuredLabel")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.ConfiguredLabelId.verify(message.configuredLabel);
                        if (error)
                            return "configuredLabel." + error;
                    }
                }
                if (message.testResult != null && message.hasOwnProperty("testResult")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.TestResultId.verify(message.testResult);
                        if (error)
                            return "testResult." + error;
                    }
                }
                if (message.testSummary != null && message.hasOwnProperty("testSummary")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.TestSummaryId.verify(message.testSummary);
                        if (error)
                            return "testSummary." + error;
                    }
                }
                if (message.buildFinished != null && message.hasOwnProperty("buildFinished")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.BuildFinishedId.verify(message.buildFinished);
                        if (error)
                            return "buildFinished." + error;
                    }
                }
                if (message.buildToolLogs != null && message.hasOwnProperty("buildToolLogs")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.BuildToolLogsId.verify(message.buildToolLogs);
                        if (error)
                            return "buildToolLogs." + error;
                    }
                }
                if (message.buildMetrics != null && message.hasOwnProperty("buildMetrics")) {
                    if (properties.id === 1)
                        return "id: multiple values";
                    properties.id = 1;
                    {
                        var error = $root.build_event_stream.BuildEventId.BuildMetricsId.verify(message.buildMetrics);
                        if (error)
                            return "buildMetrics." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a BuildEventId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.BuildEventId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.BuildEventId} BuildEventId
             */
            BuildEventId.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.BuildEventId)
                    return object;
                var message = new $root.build_event_stream.BuildEventId();
                if (object.unknown != null) {
                    if (typeof object.unknown !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.unknown: object expected");
                    message.unknown = $root.build_event_stream.BuildEventId.UnknownBuildEventId.fromObject(object.unknown);
                }
                if (object.progress != null) {
                    if (typeof object.progress !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.progress: object expected");
                    message.progress = $root.build_event_stream.BuildEventId.ProgressId.fromObject(object.progress);
                }
                if (object.started != null) {
                    if (typeof object.started !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.started: object expected");
                    message.started = $root.build_event_stream.BuildEventId.BuildStartedId.fromObject(object.started);
                }
                if (object.unstructuredCommandLine != null) {
                    if (typeof object.unstructuredCommandLine !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.unstructuredCommandLine: object expected");
                    message.unstructuredCommandLine = $root.build_event_stream.BuildEventId.UnstructuredCommandLineId.fromObject(object.unstructuredCommandLine);
                }
                if (object.structuredCommandLine != null) {
                    if (typeof object.structuredCommandLine !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.structuredCommandLine: object expected");
                    message.structuredCommandLine = $root.build_event_stream.BuildEventId.StructuredCommandLineId.fromObject(object.structuredCommandLine);
                }
                if (object.workspaceStatus != null) {
                    if (typeof object.workspaceStatus !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.workspaceStatus: object expected");
                    message.workspaceStatus = $root.build_event_stream.BuildEventId.WorkspaceStatusId.fromObject(object.workspaceStatus);
                }
                if (object.optionsParsed != null) {
                    if (typeof object.optionsParsed !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.optionsParsed: object expected");
                    message.optionsParsed = $root.build_event_stream.BuildEventId.OptionsParsedId.fromObject(object.optionsParsed);
                }
                if (object.fetch != null) {
                    if (typeof object.fetch !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.fetch: object expected");
                    message.fetch = $root.build_event_stream.BuildEventId.FetchId.fromObject(object.fetch);
                }
                if (object.configuration != null) {
                    if (typeof object.configuration !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.configuration: object expected");
                    message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.fromObject(object.configuration);
                }
                if (object.targetConfigured != null) {
                    if (typeof object.targetConfigured !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.targetConfigured: object expected");
                    message.targetConfigured = $root.build_event_stream.BuildEventId.TargetConfiguredId.fromObject(object.targetConfigured);
                }
                if (object.pattern != null) {
                    if (typeof object.pattern !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.pattern: object expected");
                    message.pattern = $root.build_event_stream.BuildEventId.PatternExpandedId.fromObject(object.pattern);
                }
                if (object.patternSkipped != null) {
                    if (typeof object.patternSkipped !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.patternSkipped: object expected");
                    message.patternSkipped = $root.build_event_stream.BuildEventId.PatternExpandedId.fromObject(object.patternSkipped);
                }
                if (object.namedSet != null) {
                    if (typeof object.namedSet !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.namedSet: object expected");
                    message.namedSet = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.fromObject(object.namedSet);
                }
                if (object.targetCompleted != null) {
                    if (typeof object.targetCompleted !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.targetCompleted: object expected");
                    message.targetCompleted = $root.build_event_stream.BuildEventId.TargetCompletedId.fromObject(object.targetCompleted);
                }
                if (object.actionCompleted != null) {
                    if (typeof object.actionCompleted !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.actionCompleted: object expected");
                    message.actionCompleted = $root.build_event_stream.BuildEventId.ActionCompletedId.fromObject(object.actionCompleted);
                }
                if (object.unconfiguredLabel != null) {
                    if (typeof object.unconfiguredLabel !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.unconfiguredLabel: object expected");
                    message.unconfiguredLabel = $root.build_event_stream.BuildEventId.UnconfiguredLabelId.fromObject(object.unconfiguredLabel);
                }
                if (object.configuredLabel != null) {
                    if (typeof object.configuredLabel !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.configuredLabel: object expected");
                    message.configuredLabel = $root.build_event_stream.BuildEventId.ConfiguredLabelId.fromObject(object.configuredLabel);
                }
                if (object.testResult != null) {
                    if (typeof object.testResult !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.testResult: object expected");
                    message.testResult = $root.build_event_stream.BuildEventId.TestResultId.fromObject(object.testResult);
                }
                if (object.testSummary != null) {
                    if (typeof object.testSummary !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.testSummary: object expected");
                    message.testSummary = $root.build_event_stream.BuildEventId.TestSummaryId.fromObject(object.testSummary);
                }
                if (object.buildFinished != null) {
                    if (typeof object.buildFinished !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.buildFinished: object expected");
                    message.buildFinished = $root.build_event_stream.BuildEventId.BuildFinishedId.fromObject(object.buildFinished);
                }
                if (object.buildToolLogs != null) {
                    if (typeof object.buildToolLogs !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.buildToolLogs: object expected");
                    message.buildToolLogs = $root.build_event_stream.BuildEventId.BuildToolLogsId.fromObject(object.buildToolLogs);
                }
                if (object.buildMetrics != null) {
                    if (typeof object.buildMetrics !== "object")
                        throw TypeError(".build_event_stream.BuildEventId.buildMetrics: object expected");
                    message.buildMetrics = $root.build_event_stream.BuildEventId.BuildMetricsId.fromObject(object.buildMetrics);
                }
                return message;
            };
            /**
             * Creates a plain object from a BuildEventId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.BuildEventId
             * @static
             * @param {build_event_stream.BuildEventId} message BuildEventId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BuildEventId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.unknown != null && message.hasOwnProperty("unknown")) {
                    object.unknown = $root.build_event_stream.BuildEventId.UnknownBuildEventId.toObject(message.unknown, options);
                    if (options.oneofs)
                        object.id = "unknown";
                }
                if (message.progress != null && message.hasOwnProperty("progress")) {
                    object.progress = $root.build_event_stream.BuildEventId.ProgressId.toObject(message.progress, options);
                    if (options.oneofs)
                        object.id = "progress";
                }
                if (message.started != null && message.hasOwnProperty("started")) {
                    object.started = $root.build_event_stream.BuildEventId.BuildStartedId.toObject(message.started, options);
                    if (options.oneofs)
                        object.id = "started";
                }
                if (message.pattern != null && message.hasOwnProperty("pattern")) {
                    object.pattern = $root.build_event_stream.BuildEventId.PatternExpandedId.toObject(message.pattern, options);
                    if (options.oneofs)
                        object.id = "pattern";
                }
                if (message.targetCompleted != null && message.hasOwnProperty("targetCompleted")) {
                    object.targetCompleted = $root.build_event_stream.BuildEventId.TargetCompletedId.toObject(message.targetCompleted, options);
                    if (options.oneofs)
                        object.id = "targetCompleted";
                }
                if (message.actionCompleted != null && message.hasOwnProperty("actionCompleted")) {
                    object.actionCompleted = $root.build_event_stream.BuildEventId.ActionCompletedId.toObject(message.actionCompleted, options);
                    if (options.oneofs)
                        object.id = "actionCompleted";
                }
                if (message.testSummary != null && message.hasOwnProperty("testSummary")) {
                    object.testSummary = $root.build_event_stream.BuildEventId.TestSummaryId.toObject(message.testSummary, options);
                    if (options.oneofs)
                        object.id = "testSummary";
                }
                if (message.testResult != null && message.hasOwnProperty("testResult")) {
                    object.testResult = $root.build_event_stream.BuildEventId.TestResultId.toObject(message.testResult, options);
                    if (options.oneofs)
                        object.id = "testResult";
                }
                if (message.buildFinished != null && message.hasOwnProperty("buildFinished")) {
                    object.buildFinished = $root.build_event_stream.BuildEventId.BuildFinishedId.toObject(message.buildFinished, options);
                    if (options.oneofs)
                        object.id = "buildFinished";
                }
                if (message.patternSkipped != null && message.hasOwnProperty("patternSkipped")) {
                    object.patternSkipped = $root.build_event_stream.BuildEventId.PatternExpandedId.toObject(message.patternSkipped, options);
                    if (options.oneofs)
                        object.id = "patternSkipped";
                }
                if (message.unstructuredCommandLine != null && message.hasOwnProperty("unstructuredCommandLine")) {
                    object.unstructuredCommandLine = $root.build_event_stream.BuildEventId.UnstructuredCommandLineId.toObject(message.unstructuredCommandLine, options);
                    if (options.oneofs)
                        object.id = "unstructuredCommandLine";
                }
                if (message.optionsParsed != null && message.hasOwnProperty("optionsParsed")) {
                    object.optionsParsed = $root.build_event_stream.BuildEventId.OptionsParsedId.toObject(message.optionsParsed, options);
                    if (options.oneofs)
                        object.id = "optionsParsed";
                }
                if (message.namedSet != null && message.hasOwnProperty("namedSet")) {
                    object.namedSet = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.toObject(message.namedSet, options);
                    if (options.oneofs)
                        object.id = "namedSet";
                }
                if (message.workspaceStatus != null && message.hasOwnProperty("workspaceStatus")) {
                    object.workspaceStatus = $root.build_event_stream.BuildEventId.WorkspaceStatusId.toObject(message.workspaceStatus, options);
                    if (options.oneofs)
                        object.id = "workspaceStatus";
                }
                if (message.configuration != null && message.hasOwnProperty("configuration")) {
                    object.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.toObject(message.configuration, options);
                    if (options.oneofs)
                        object.id = "configuration";
                }
                if (message.targetConfigured != null && message.hasOwnProperty("targetConfigured")) {
                    object.targetConfigured = $root.build_event_stream.BuildEventId.TargetConfiguredId.toObject(message.targetConfigured, options);
                    if (options.oneofs)
                        object.id = "targetConfigured";
                }
                if (message.fetch != null && message.hasOwnProperty("fetch")) {
                    object.fetch = $root.build_event_stream.BuildEventId.FetchId.toObject(message.fetch, options);
                    if (options.oneofs)
                        object.id = "fetch";
                }
                if (message.structuredCommandLine != null && message.hasOwnProperty("structuredCommandLine")) {
                    object.structuredCommandLine = $root.build_event_stream.BuildEventId.StructuredCommandLineId.toObject(message.structuredCommandLine, options);
                    if (options.oneofs)
                        object.id = "structuredCommandLine";
                }
                if (message.unconfiguredLabel != null && message.hasOwnProperty("unconfiguredLabel")) {
                    object.unconfiguredLabel = $root.build_event_stream.BuildEventId.UnconfiguredLabelId.toObject(message.unconfiguredLabel, options);
                    if (options.oneofs)
                        object.id = "unconfiguredLabel";
                }
                if (message.buildToolLogs != null && message.hasOwnProperty("buildToolLogs")) {
                    object.buildToolLogs = $root.build_event_stream.BuildEventId.BuildToolLogsId.toObject(message.buildToolLogs, options);
                    if (options.oneofs)
                        object.id = "buildToolLogs";
                }
                if (message.configuredLabel != null && message.hasOwnProperty("configuredLabel")) {
                    object.configuredLabel = $root.build_event_stream.BuildEventId.ConfiguredLabelId.toObject(message.configuredLabel, options);
                    if (options.oneofs)
                        object.id = "configuredLabel";
                }
                if (message.buildMetrics != null && message.hasOwnProperty("buildMetrics")) {
                    object.buildMetrics = $root.build_event_stream.BuildEventId.BuildMetricsId.toObject(message.buildMetrics, options);
                    if (options.oneofs)
                        object.id = "buildMetrics";
                }
                return object;
            };
            /**
             * Converts this BuildEventId to JSON.
             * @function toJSON
             * @memberof build_event_stream.BuildEventId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BuildEventId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            BuildEventId.UnknownBuildEventId = (function () {
                /**
                 * Properties of an UnknownBuildEventId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IUnknownBuildEventId
                 * @property {string|null} [details] UnknownBuildEventId details
                 */
                /**
                 * Constructs a new UnknownBuildEventId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents an UnknownBuildEventId.
                 * @implements IUnknownBuildEventId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IUnknownBuildEventId=} [properties] Properties to set
                 */
                function UnknownBuildEventId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * UnknownBuildEventId details.
                 * @member {string} details
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @instance
                 */
                UnknownBuildEventId.prototype.details = "";
                /**
                 * Creates a new UnknownBuildEventId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnknownBuildEventId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.UnknownBuildEventId} UnknownBuildEventId instance
                 */
                UnknownBuildEventId.create = function create(properties) {
                    return new UnknownBuildEventId(properties);
                };
                /**
                 * Encodes the specified UnknownBuildEventId message. Does not implicitly {@link build_event_stream.BuildEventId.UnknownBuildEventId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnknownBuildEventId} message UnknownBuildEventId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnknownBuildEventId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.details != null && message.hasOwnProperty("details"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.details);
                    return writer;
                };
                /**
                 * Encodes the specified UnknownBuildEventId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.UnknownBuildEventId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnknownBuildEventId} message UnknownBuildEventId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnknownBuildEventId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an UnknownBuildEventId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.UnknownBuildEventId} UnknownBuildEventId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnknownBuildEventId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.UnknownBuildEventId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.details = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an UnknownBuildEventId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.UnknownBuildEventId} UnknownBuildEventId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnknownBuildEventId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an UnknownBuildEventId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnknownBuildEventId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.details != null && message.hasOwnProperty("details"))
                        if (!$util.isString(message.details))
                            return "details: string expected";
                    return null;
                };
                /**
                 * Creates an UnknownBuildEventId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.UnknownBuildEventId} UnknownBuildEventId
                 */
                UnknownBuildEventId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.UnknownBuildEventId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.UnknownBuildEventId();
                    if (object.details != null)
                        message.details = String(object.details);
                    return message;
                };
                /**
                 * Creates a plain object from an UnknownBuildEventId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @static
                 * @param {build_event_stream.BuildEventId.UnknownBuildEventId} message UnknownBuildEventId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnknownBuildEventId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.details = "";
                    if (message.details != null && message.hasOwnProperty("details"))
                        object.details = message.details;
                    return object;
                };
                /**
                 * Converts this UnknownBuildEventId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.UnknownBuildEventId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnknownBuildEventId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return UnknownBuildEventId;
            })();
            BuildEventId.ProgressId = (function () {
                /**
                 * Properties of a ProgressId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IProgressId
                 * @property {number|null} [opaqueCount] ProgressId opaqueCount
                 */
                /**
                 * Constructs a new ProgressId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a ProgressId.
                 * @implements IProgressId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IProgressId=} [properties] Properties to set
                 */
                function ProgressId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ProgressId opaqueCount.
                 * @member {number} opaqueCount
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @instance
                 */
                ProgressId.prototype.opaqueCount = 0;
                /**
                 * Creates a new ProgressId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @static
                 * @param {build_event_stream.BuildEventId.IProgressId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.ProgressId} ProgressId instance
                 */
                ProgressId.create = function create(properties) {
                    return new ProgressId(properties);
                };
                /**
                 * Encodes the specified ProgressId message. Does not implicitly {@link build_event_stream.BuildEventId.ProgressId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @static
                 * @param {build_event_stream.BuildEventId.IProgressId} message ProgressId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProgressId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.opaqueCount != null && message.hasOwnProperty("opaqueCount"))
                        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.opaqueCount);
                    return writer;
                };
                /**
                 * Encodes the specified ProgressId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.ProgressId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @static
                 * @param {build_event_stream.BuildEventId.IProgressId} message ProgressId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProgressId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a ProgressId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.ProgressId} ProgressId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProgressId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.ProgressId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.opaqueCount = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a ProgressId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.ProgressId} ProgressId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProgressId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a ProgressId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProgressId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.opaqueCount != null && message.hasOwnProperty("opaqueCount"))
                        if (!$util.isInteger(message.opaqueCount))
                            return "opaqueCount: integer expected";
                    return null;
                };
                /**
                 * Creates a ProgressId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.ProgressId} ProgressId
                 */
                ProgressId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.ProgressId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.ProgressId();
                    if (object.opaqueCount != null)
                        message.opaqueCount = object.opaqueCount | 0;
                    return message;
                };
                /**
                 * Creates a plain object from a ProgressId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @static
                 * @param {build_event_stream.BuildEventId.ProgressId} message ProgressId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProgressId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.opaqueCount = 0;
                    if (message.opaqueCount != null && message.hasOwnProperty("opaqueCount"))
                        object.opaqueCount = message.opaqueCount;
                    return object;
                };
                /**
                 * Converts this ProgressId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.ProgressId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProgressId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return ProgressId;
            })();
            BuildEventId.BuildStartedId = (function () {
                /**
                 * Properties of a BuildStartedId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IBuildStartedId
                 */
                /**
                 * Constructs a new BuildStartedId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a BuildStartedId.
                 * @implements IBuildStartedId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IBuildStartedId=} [properties] Properties to set
                 */
                function BuildStartedId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Creates a new BuildStartedId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildStartedId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.BuildStartedId} BuildStartedId instance
                 */
                BuildStartedId.create = function create(properties) {
                    return new BuildStartedId(properties);
                };
                /**
                 * Encodes the specified BuildStartedId message. Does not implicitly {@link build_event_stream.BuildEventId.BuildStartedId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildStartedId} message BuildStartedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildStartedId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
                /**
                 * Encodes the specified BuildStartedId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.BuildStartedId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildStartedId} message BuildStartedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildStartedId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a BuildStartedId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.BuildStartedId} BuildStartedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildStartedId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.BuildStartedId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a BuildStartedId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.BuildStartedId} BuildStartedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildStartedId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a BuildStartedId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BuildStartedId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
                /**
                 * Creates a BuildStartedId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.BuildStartedId} BuildStartedId
                 */
                BuildStartedId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.BuildStartedId)
                        return object;
                    return new $root.build_event_stream.BuildEventId.BuildStartedId();
                };
                /**
                 * Creates a plain object from a BuildStartedId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @static
                 * @param {build_event_stream.BuildEventId.BuildStartedId} message BuildStartedId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BuildStartedId.toObject = function toObject() {
                    return {};
                };
                /**
                 * Converts this BuildStartedId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.BuildStartedId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BuildStartedId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return BuildStartedId;
            })();
            BuildEventId.UnstructuredCommandLineId = (function () {
                /**
                 * Properties of an UnstructuredCommandLineId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IUnstructuredCommandLineId
                 */
                /**
                 * Constructs a new UnstructuredCommandLineId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents an UnstructuredCommandLineId.
                 * @implements IUnstructuredCommandLineId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IUnstructuredCommandLineId=} [properties] Properties to set
                 */
                function UnstructuredCommandLineId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Creates a new UnstructuredCommandLineId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnstructuredCommandLineId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.UnstructuredCommandLineId} UnstructuredCommandLineId instance
                 */
                UnstructuredCommandLineId.create = function create(properties) {
                    return new UnstructuredCommandLineId(properties);
                };
                /**
                 * Encodes the specified UnstructuredCommandLineId message. Does not implicitly {@link build_event_stream.BuildEventId.UnstructuredCommandLineId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnstructuredCommandLineId} message UnstructuredCommandLineId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnstructuredCommandLineId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
                /**
                 * Encodes the specified UnstructuredCommandLineId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.UnstructuredCommandLineId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnstructuredCommandLineId} message UnstructuredCommandLineId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnstructuredCommandLineId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an UnstructuredCommandLineId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.UnstructuredCommandLineId} UnstructuredCommandLineId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnstructuredCommandLineId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.UnstructuredCommandLineId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an UnstructuredCommandLineId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.UnstructuredCommandLineId} UnstructuredCommandLineId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnstructuredCommandLineId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an UnstructuredCommandLineId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnstructuredCommandLineId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
                /**
                 * Creates an UnstructuredCommandLineId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.UnstructuredCommandLineId} UnstructuredCommandLineId
                 */
                UnstructuredCommandLineId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.UnstructuredCommandLineId)
                        return object;
                    return new $root.build_event_stream.BuildEventId.UnstructuredCommandLineId();
                };
                /**
                 * Creates a plain object from an UnstructuredCommandLineId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @static
                 * @param {build_event_stream.BuildEventId.UnstructuredCommandLineId} message UnstructuredCommandLineId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnstructuredCommandLineId.toObject = function toObject() {
                    return {};
                };
                /**
                 * Converts this UnstructuredCommandLineId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.UnstructuredCommandLineId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnstructuredCommandLineId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return UnstructuredCommandLineId;
            })();
            BuildEventId.StructuredCommandLineId = (function () {
                /**
                 * Properties of a StructuredCommandLineId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IStructuredCommandLineId
                 * @property {string|null} [commandLineLabel] StructuredCommandLineId commandLineLabel
                 */
                /**
                 * Constructs a new StructuredCommandLineId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a StructuredCommandLineId.
                 * @implements IStructuredCommandLineId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IStructuredCommandLineId=} [properties] Properties to set
                 */
                function StructuredCommandLineId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * StructuredCommandLineId commandLineLabel.
                 * @member {string} commandLineLabel
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @instance
                 */
                StructuredCommandLineId.prototype.commandLineLabel = "";
                /**
                 * Creates a new StructuredCommandLineId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @static
                 * @param {build_event_stream.BuildEventId.IStructuredCommandLineId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.StructuredCommandLineId} StructuredCommandLineId instance
                 */
                StructuredCommandLineId.create = function create(properties) {
                    return new StructuredCommandLineId(properties);
                };
                /**
                 * Encodes the specified StructuredCommandLineId message. Does not implicitly {@link build_event_stream.BuildEventId.StructuredCommandLineId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @static
                 * @param {build_event_stream.BuildEventId.IStructuredCommandLineId} message StructuredCommandLineId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StructuredCommandLineId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.commandLineLabel != null && message.hasOwnProperty("commandLineLabel"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.commandLineLabel);
                    return writer;
                };
                /**
                 * Encodes the specified StructuredCommandLineId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.StructuredCommandLineId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @static
                 * @param {build_event_stream.BuildEventId.IStructuredCommandLineId} message StructuredCommandLineId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StructuredCommandLineId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a StructuredCommandLineId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.StructuredCommandLineId} StructuredCommandLineId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StructuredCommandLineId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.StructuredCommandLineId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.commandLineLabel = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a StructuredCommandLineId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.StructuredCommandLineId} StructuredCommandLineId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StructuredCommandLineId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a StructuredCommandLineId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StructuredCommandLineId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.commandLineLabel != null && message.hasOwnProperty("commandLineLabel"))
                        if (!$util.isString(message.commandLineLabel))
                            return "commandLineLabel: string expected";
                    return null;
                };
                /**
                 * Creates a StructuredCommandLineId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.StructuredCommandLineId} StructuredCommandLineId
                 */
                StructuredCommandLineId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.StructuredCommandLineId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.StructuredCommandLineId();
                    if (object.commandLineLabel != null)
                        message.commandLineLabel = String(object.commandLineLabel);
                    return message;
                };
                /**
                 * Creates a plain object from a StructuredCommandLineId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @static
                 * @param {build_event_stream.BuildEventId.StructuredCommandLineId} message StructuredCommandLineId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StructuredCommandLineId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.commandLineLabel = "";
                    if (message.commandLineLabel != null && message.hasOwnProperty("commandLineLabel"))
                        object.commandLineLabel = message.commandLineLabel;
                    return object;
                };
                /**
                 * Converts this StructuredCommandLineId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.StructuredCommandLineId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StructuredCommandLineId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return StructuredCommandLineId;
            })();
            BuildEventId.WorkspaceStatusId = (function () {
                /**
                 * Properties of a WorkspaceStatusId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IWorkspaceStatusId
                 */
                /**
                 * Constructs a new WorkspaceStatusId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a WorkspaceStatusId.
                 * @implements IWorkspaceStatusId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IWorkspaceStatusId=} [properties] Properties to set
                 */
                function WorkspaceStatusId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Creates a new WorkspaceStatusId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @static
                 * @param {build_event_stream.BuildEventId.IWorkspaceStatusId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.WorkspaceStatusId} WorkspaceStatusId instance
                 */
                WorkspaceStatusId.create = function create(properties) {
                    return new WorkspaceStatusId(properties);
                };
                /**
                 * Encodes the specified WorkspaceStatusId message. Does not implicitly {@link build_event_stream.BuildEventId.WorkspaceStatusId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @static
                 * @param {build_event_stream.BuildEventId.IWorkspaceStatusId} message WorkspaceStatusId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkspaceStatusId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
                /**
                 * Encodes the specified WorkspaceStatusId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.WorkspaceStatusId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @static
                 * @param {build_event_stream.BuildEventId.IWorkspaceStatusId} message WorkspaceStatusId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WorkspaceStatusId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a WorkspaceStatusId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.WorkspaceStatusId} WorkspaceStatusId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkspaceStatusId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.WorkspaceStatusId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a WorkspaceStatusId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.WorkspaceStatusId} WorkspaceStatusId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WorkspaceStatusId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a WorkspaceStatusId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WorkspaceStatusId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
                /**
                 * Creates a WorkspaceStatusId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.WorkspaceStatusId} WorkspaceStatusId
                 */
                WorkspaceStatusId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.WorkspaceStatusId)
                        return object;
                    return new $root.build_event_stream.BuildEventId.WorkspaceStatusId();
                };
                /**
                 * Creates a plain object from a WorkspaceStatusId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @static
                 * @param {build_event_stream.BuildEventId.WorkspaceStatusId} message WorkspaceStatusId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WorkspaceStatusId.toObject = function toObject() {
                    return {};
                };
                /**
                 * Converts this WorkspaceStatusId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.WorkspaceStatusId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WorkspaceStatusId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return WorkspaceStatusId;
            })();
            BuildEventId.OptionsParsedId = (function () {
                /**
                 * Properties of an OptionsParsedId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IOptionsParsedId
                 */
                /**
                 * Constructs a new OptionsParsedId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents an OptionsParsedId.
                 * @implements IOptionsParsedId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IOptionsParsedId=} [properties] Properties to set
                 */
                function OptionsParsedId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Creates a new OptionsParsedId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IOptionsParsedId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.OptionsParsedId} OptionsParsedId instance
                 */
                OptionsParsedId.create = function create(properties) {
                    return new OptionsParsedId(properties);
                };
                /**
                 * Encodes the specified OptionsParsedId message. Does not implicitly {@link build_event_stream.BuildEventId.OptionsParsedId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IOptionsParsedId} message OptionsParsedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptionsParsedId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
                /**
                 * Encodes the specified OptionsParsedId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.OptionsParsedId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IOptionsParsedId} message OptionsParsedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptionsParsedId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an OptionsParsedId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.OptionsParsedId} OptionsParsedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptionsParsedId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.OptionsParsedId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an OptionsParsedId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.OptionsParsedId} OptionsParsedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptionsParsedId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an OptionsParsedId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OptionsParsedId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
                /**
                 * Creates an OptionsParsedId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.OptionsParsedId} OptionsParsedId
                 */
                OptionsParsedId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.OptionsParsedId)
                        return object;
                    return new $root.build_event_stream.BuildEventId.OptionsParsedId();
                };
                /**
                 * Creates a plain object from an OptionsParsedId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @static
                 * @param {build_event_stream.BuildEventId.OptionsParsedId} message OptionsParsedId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptionsParsedId.toObject = function toObject() {
                    return {};
                };
                /**
                 * Converts this OptionsParsedId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.OptionsParsedId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OptionsParsedId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return OptionsParsedId;
            })();
            BuildEventId.FetchId = (function () {
                /**
                 * Properties of a FetchId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IFetchId
                 * @property {string|null} [url] FetchId url
                 */
                /**
                 * Constructs a new FetchId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a FetchId.
                 * @implements IFetchId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IFetchId=} [properties] Properties to set
                 */
                function FetchId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * FetchId url.
                 * @member {string} url
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @instance
                 */
                FetchId.prototype.url = "";
                /**
                 * Creates a new FetchId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @static
                 * @param {build_event_stream.BuildEventId.IFetchId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.FetchId} FetchId instance
                 */
                FetchId.create = function create(properties) {
                    return new FetchId(properties);
                };
                /**
                 * Encodes the specified FetchId message. Does not implicitly {@link build_event_stream.BuildEventId.FetchId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @static
                 * @param {build_event_stream.BuildEventId.IFetchId} message FetchId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FetchId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.url != null && message.hasOwnProperty("url"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.url);
                    return writer;
                };
                /**
                 * Encodes the specified FetchId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.FetchId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @static
                 * @param {build_event_stream.BuildEventId.IFetchId} message FetchId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FetchId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a FetchId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.FetchId} FetchId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FetchId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.FetchId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.url = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a FetchId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.FetchId} FetchId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FetchId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a FetchId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FetchId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    return null;
                };
                /**
                 * Creates a FetchId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.FetchId} FetchId
                 */
                FetchId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.FetchId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.FetchId();
                    if (object.url != null)
                        message.url = String(object.url);
                    return message;
                };
                /**
                 * Creates a plain object from a FetchId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @static
                 * @param {build_event_stream.BuildEventId.FetchId} message FetchId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FetchId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.url = "";
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    return object;
                };
                /**
                 * Converts this FetchId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.FetchId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FetchId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return FetchId;
            })();
            BuildEventId.PatternExpandedId = (function () {
                /**
                 * Properties of a PatternExpandedId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IPatternExpandedId
                 * @property {Array.<string>|null} [pattern] PatternExpandedId pattern
                 */
                /**
                 * Constructs a new PatternExpandedId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a PatternExpandedId.
                 * @implements IPatternExpandedId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IPatternExpandedId=} [properties] Properties to set
                 */
                function PatternExpandedId(properties) {
                    this.pattern = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * PatternExpandedId pattern.
                 * @member {Array.<string>} pattern
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @instance
                 */
                PatternExpandedId.prototype.pattern = $util.emptyArray;
                /**
                 * Creates a new PatternExpandedId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IPatternExpandedId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.PatternExpandedId} PatternExpandedId instance
                 */
                PatternExpandedId.create = function create(properties) {
                    return new PatternExpandedId(properties);
                };
                /**
                 * Encodes the specified PatternExpandedId message. Does not implicitly {@link build_event_stream.BuildEventId.PatternExpandedId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IPatternExpandedId} message PatternExpandedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PatternExpandedId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pattern != null && message.pattern.length)
                        for (var i = 0; i < message.pattern.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.pattern[i]);
                    return writer;
                };
                /**
                 * Encodes the specified PatternExpandedId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.PatternExpandedId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IPatternExpandedId} message PatternExpandedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PatternExpandedId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a PatternExpandedId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.PatternExpandedId} PatternExpandedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PatternExpandedId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.PatternExpandedId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.pattern && message.pattern.length))
                                    message.pattern = [];
                                message.pattern.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a PatternExpandedId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.PatternExpandedId} PatternExpandedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PatternExpandedId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a PatternExpandedId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PatternExpandedId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pattern != null && message.hasOwnProperty("pattern")) {
                        if (!Array.isArray(message.pattern))
                            return "pattern: array expected";
                        for (var i = 0; i < message.pattern.length; ++i)
                            if (!$util.isString(message.pattern[i]))
                                return "pattern: string[] expected";
                    }
                    return null;
                };
                /**
                 * Creates a PatternExpandedId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.PatternExpandedId} PatternExpandedId
                 */
                PatternExpandedId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.PatternExpandedId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.PatternExpandedId();
                    if (object.pattern) {
                        if (!Array.isArray(object.pattern))
                            throw TypeError(".build_event_stream.BuildEventId.PatternExpandedId.pattern: array expected");
                        message.pattern = [];
                        for (var i = 0; i < object.pattern.length; ++i)
                            message.pattern[i] = String(object.pattern[i]);
                    }
                    return message;
                };
                /**
                 * Creates a plain object from a PatternExpandedId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @static
                 * @param {build_event_stream.BuildEventId.PatternExpandedId} message PatternExpandedId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PatternExpandedId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.pattern = [];
                    if (message.pattern && message.pattern.length) {
                        object.pattern = [];
                        for (var j = 0; j < message.pattern.length; ++j)
                            object.pattern[j] = message.pattern[j];
                    }
                    return object;
                };
                /**
                 * Converts this PatternExpandedId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.PatternExpandedId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PatternExpandedId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return PatternExpandedId;
            })();
            BuildEventId.TargetConfiguredId = (function () {
                /**
                 * Properties of a TargetConfiguredId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface ITargetConfiguredId
                 * @property {string|null} [label] TargetConfiguredId label
                 * @property {string|null} [aspect] TargetConfiguredId aspect
                 */
                /**
                 * Constructs a new TargetConfiguredId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a TargetConfiguredId.
                 * @implements ITargetConfiguredId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.ITargetConfiguredId=} [properties] Properties to set
                 */
                function TargetConfiguredId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * TargetConfiguredId label.
                 * @member {string} label
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @instance
                 */
                TargetConfiguredId.prototype.label = "";
                /**
                 * TargetConfiguredId aspect.
                 * @member {string} aspect
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @instance
                 */
                TargetConfiguredId.prototype.aspect = "";
                /**
                 * Creates a new TargetConfiguredId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITargetConfiguredId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.TargetConfiguredId} TargetConfiguredId instance
                 */
                TargetConfiguredId.create = function create(properties) {
                    return new TargetConfiguredId(properties);
                };
                /**
                 * Encodes the specified TargetConfiguredId message. Does not implicitly {@link build_event_stream.BuildEventId.TargetConfiguredId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITargetConfiguredId} message TargetConfiguredId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TargetConfiguredId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.label);
                    if (message.aspect != null && message.hasOwnProperty("aspect"))
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.aspect);
                    return writer;
                };
                /**
                 * Encodes the specified TargetConfiguredId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.TargetConfiguredId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITargetConfiguredId} message TargetConfiguredId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TargetConfiguredId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a TargetConfiguredId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.TargetConfiguredId} TargetConfiguredId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TargetConfiguredId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.TargetConfiguredId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.label = reader.string();
                                break;
                            case 2:
                                message.aspect = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a TargetConfiguredId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.TargetConfiguredId} TargetConfiguredId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TargetConfiguredId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a TargetConfiguredId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TargetConfiguredId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.aspect != null && message.hasOwnProperty("aspect"))
                        if (!$util.isString(message.aspect))
                            return "aspect: string expected";
                    return null;
                };
                /**
                 * Creates a TargetConfiguredId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.TargetConfiguredId} TargetConfiguredId
                 */
                TargetConfiguredId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.TargetConfiguredId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.TargetConfiguredId();
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.aspect != null)
                        message.aspect = String(object.aspect);
                    return message;
                };
                /**
                 * Creates a plain object from a TargetConfiguredId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @static
                 * @param {build_event_stream.BuildEventId.TargetConfiguredId} message TargetConfiguredId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TargetConfiguredId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.label = "";
                        object.aspect = "";
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.aspect != null && message.hasOwnProperty("aspect"))
                        object.aspect = message.aspect;
                    return object;
                };
                /**
                 * Converts this TargetConfiguredId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.TargetConfiguredId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TargetConfiguredId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return TargetConfiguredId;
            })();
            BuildEventId.NamedSetOfFilesId = (function () {
                /**
                 * Properties of a NamedSetOfFilesId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface INamedSetOfFilesId
                 * @property {string|null} [id] NamedSetOfFilesId id
                 */
                /**
                 * Constructs a new NamedSetOfFilesId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a NamedSetOfFilesId.
                 * @implements INamedSetOfFilesId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.INamedSetOfFilesId=} [properties] Properties to set
                 */
                function NamedSetOfFilesId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * NamedSetOfFilesId id.
                 * @member {string} id
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @instance
                 */
                NamedSetOfFilesId.prototype.id = "";
                /**
                 * Creates a new NamedSetOfFilesId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @static
                 * @param {build_event_stream.BuildEventId.INamedSetOfFilesId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.NamedSetOfFilesId} NamedSetOfFilesId instance
                 */
                NamedSetOfFilesId.create = function create(properties) {
                    return new NamedSetOfFilesId(properties);
                };
                /**
                 * Encodes the specified NamedSetOfFilesId message. Does not implicitly {@link build_event_stream.BuildEventId.NamedSetOfFilesId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @static
                 * @param {build_event_stream.BuildEventId.INamedSetOfFilesId} message NamedSetOfFilesId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedSetOfFilesId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
                    return writer;
                };
                /**
                 * Encodes the specified NamedSetOfFilesId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.NamedSetOfFilesId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @static
                 * @param {build_event_stream.BuildEventId.INamedSetOfFilesId} message NamedSetOfFilesId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedSetOfFilesId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a NamedSetOfFilesId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.NamedSetOfFilesId} NamedSetOfFilesId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedSetOfFilesId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.NamedSetOfFilesId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a NamedSetOfFilesId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.NamedSetOfFilesId} NamedSetOfFilesId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedSetOfFilesId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a NamedSetOfFilesId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedSetOfFilesId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    return null;
                };
                /**
                 * Creates a NamedSetOfFilesId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.NamedSetOfFilesId} NamedSetOfFilesId
                 */
                NamedSetOfFilesId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.NamedSetOfFilesId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.NamedSetOfFilesId();
                    if (object.id != null)
                        message.id = String(object.id);
                    return message;
                };
                /**
                 * Creates a plain object from a NamedSetOfFilesId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @static
                 * @param {build_event_stream.BuildEventId.NamedSetOfFilesId} message NamedSetOfFilesId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamedSetOfFilesId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.id = "";
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    return object;
                };
                /**
                 * Converts this NamedSetOfFilesId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.NamedSetOfFilesId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamedSetOfFilesId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return NamedSetOfFilesId;
            })();
            BuildEventId.ConfigurationId = (function () {
                /**
                 * Properties of a ConfigurationId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IConfigurationId
                 * @property {string|null} [id] ConfigurationId id
                 */
                /**
                 * Constructs a new ConfigurationId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a ConfigurationId.
                 * @implements IConfigurationId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IConfigurationId=} [properties] Properties to set
                 */
                function ConfigurationId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ConfigurationId id.
                 * @member {string} id
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @instance
                 */
                ConfigurationId.prototype.id = "";
                /**
                 * Creates a new ConfigurationId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @static
                 * @param {build_event_stream.BuildEventId.IConfigurationId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.ConfigurationId} ConfigurationId instance
                 */
                ConfigurationId.create = function create(properties) {
                    return new ConfigurationId(properties);
                };
                /**
                 * Encodes the specified ConfigurationId message. Does not implicitly {@link build_event_stream.BuildEventId.ConfigurationId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @static
                 * @param {build_event_stream.BuildEventId.IConfigurationId} message ConfigurationId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConfigurationId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
                    return writer;
                };
                /**
                 * Encodes the specified ConfigurationId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.ConfigurationId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @static
                 * @param {build_event_stream.BuildEventId.IConfigurationId} message ConfigurationId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConfigurationId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a ConfigurationId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.ConfigurationId} ConfigurationId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConfigurationId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.ConfigurationId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a ConfigurationId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.ConfigurationId} ConfigurationId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConfigurationId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a ConfigurationId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConfigurationId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    return null;
                };
                /**
                 * Creates a ConfigurationId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.ConfigurationId} ConfigurationId
                 */
                ConfigurationId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.ConfigurationId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.ConfigurationId();
                    if (object.id != null)
                        message.id = String(object.id);
                    return message;
                };
                /**
                 * Creates a plain object from a ConfigurationId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @static
                 * @param {build_event_stream.BuildEventId.ConfigurationId} message ConfigurationId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConfigurationId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.id = "";
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    return object;
                };
                /**
                 * Converts this ConfigurationId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.ConfigurationId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConfigurationId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return ConfigurationId;
            })();
            BuildEventId.TargetCompletedId = (function () {
                /**
                 * Properties of a TargetCompletedId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface ITargetCompletedId
                 * @property {string|null} [label] TargetCompletedId label
                 * @property {build_event_stream.BuildEventId.IConfigurationId|null} [configuration] TargetCompletedId configuration
                 * @property {string|null} [aspect] TargetCompletedId aspect
                 */
                /**
                 * Constructs a new TargetCompletedId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a TargetCompletedId.
                 * @implements ITargetCompletedId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.ITargetCompletedId=} [properties] Properties to set
                 */
                function TargetCompletedId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * TargetCompletedId label.
                 * @member {string} label
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @instance
                 */
                TargetCompletedId.prototype.label = "";
                /**
                 * TargetCompletedId configuration.
                 * @member {build_event_stream.BuildEventId.IConfigurationId|null|undefined} configuration
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @instance
                 */
                TargetCompletedId.prototype.configuration = null;
                /**
                 * TargetCompletedId aspect.
                 * @member {string} aspect
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @instance
                 */
                TargetCompletedId.prototype.aspect = "";
                /**
                 * Creates a new TargetCompletedId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITargetCompletedId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.TargetCompletedId} TargetCompletedId instance
                 */
                TargetCompletedId.create = function create(properties) {
                    return new TargetCompletedId(properties);
                };
                /**
                 * Encodes the specified TargetCompletedId message. Does not implicitly {@link build_event_stream.BuildEventId.TargetCompletedId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITargetCompletedId} message TargetCompletedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TargetCompletedId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.label);
                    if (message.aspect != null && message.hasOwnProperty("aspect"))
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.aspect);
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        $root.build_event_stream.BuildEventId.ConfigurationId.encode(message.configuration, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified TargetCompletedId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.TargetCompletedId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITargetCompletedId} message TargetCompletedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TargetCompletedId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a TargetCompletedId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.TargetCompletedId} TargetCompletedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TargetCompletedId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.TargetCompletedId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.label = reader.string();
                                break;
                            case 3:
                                message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.aspect = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a TargetCompletedId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.TargetCompletedId} TargetCompletedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TargetCompletedId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a TargetCompletedId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TargetCompletedId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.configuration != null && message.hasOwnProperty("configuration")) {
                        var error = $root.build_event_stream.BuildEventId.ConfigurationId.verify(message.configuration);
                        if (error)
                            return "configuration." + error;
                    }
                    if (message.aspect != null && message.hasOwnProperty("aspect"))
                        if (!$util.isString(message.aspect))
                            return "aspect: string expected";
                    return null;
                };
                /**
                 * Creates a TargetCompletedId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.TargetCompletedId} TargetCompletedId
                 */
                TargetCompletedId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.TargetCompletedId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.TargetCompletedId();
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.configuration != null) {
                        if (typeof object.configuration !== "object")
                            throw TypeError(".build_event_stream.BuildEventId.TargetCompletedId.configuration: object expected");
                        message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.fromObject(object.configuration);
                    }
                    if (object.aspect != null)
                        message.aspect = String(object.aspect);
                    return message;
                };
                /**
                 * Creates a plain object from a TargetCompletedId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @static
                 * @param {build_event_stream.BuildEventId.TargetCompletedId} message TargetCompletedId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TargetCompletedId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.label = "";
                        object.aspect = "";
                        object.configuration = null;
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.aspect != null && message.hasOwnProperty("aspect"))
                        object.aspect = message.aspect;
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        object.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.toObject(message.configuration, options);
                    return object;
                };
                /**
                 * Converts this TargetCompletedId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.TargetCompletedId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TargetCompletedId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return TargetCompletedId;
            })();
            BuildEventId.ActionCompletedId = (function () {
                /**
                 * Properties of an ActionCompletedId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IActionCompletedId
                 * @property {string|null} [primaryOutput] ActionCompletedId primaryOutput
                 * @property {string|null} [label] ActionCompletedId label
                 * @property {build_event_stream.BuildEventId.IConfigurationId|null} [configuration] ActionCompletedId configuration
                 */
                /**
                 * Constructs a new ActionCompletedId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents an ActionCompletedId.
                 * @implements IActionCompletedId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IActionCompletedId=} [properties] Properties to set
                 */
                function ActionCompletedId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ActionCompletedId primaryOutput.
                 * @member {string} primaryOutput
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @instance
                 */
                ActionCompletedId.prototype.primaryOutput = "";
                /**
                 * ActionCompletedId label.
                 * @member {string} label
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @instance
                 */
                ActionCompletedId.prototype.label = "";
                /**
                 * ActionCompletedId configuration.
                 * @member {build_event_stream.BuildEventId.IConfigurationId|null|undefined} configuration
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @instance
                 */
                ActionCompletedId.prototype.configuration = null;
                /**
                 * Creates a new ActionCompletedId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IActionCompletedId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.ActionCompletedId} ActionCompletedId instance
                 */
                ActionCompletedId.create = function create(properties) {
                    return new ActionCompletedId(properties);
                };
                /**
                 * Encodes the specified ActionCompletedId message. Does not implicitly {@link build_event_stream.BuildEventId.ActionCompletedId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IActionCompletedId} message ActionCompletedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionCompletedId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.primaryOutput != null && message.hasOwnProperty("primaryOutput"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.primaryOutput);
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.label);
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        $root.build_event_stream.BuildEventId.ConfigurationId.encode(message.configuration, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified ActionCompletedId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.ActionCompletedId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IActionCompletedId} message ActionCompletedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionCompletedId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an ActionCompletedId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.ActionCompletedId} ActionCompletedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionCompletedId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.ActionCompletedId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.primaryOutput = reader.string();
                                break;
                            case 2:
                                message.label = reader.string();
                                break;
                            case 3:
                                message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an ActionCompletedId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.ActionCompletedId} ActionCompletedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionCompletedId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an ActionCompletedId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActionCompletedId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.primaryOutput != null && message.hasOwnProperty("primaryOutput"))
                        if (!$util.isString(message.primaryOutput))
                            return "primaryOutput: string expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.configuration != null && message.hasOwnProperty("configuration")) {
                        var error = $root.build_event_stream.BuildEventId.ConfigurationId.verify(message.configuration);
                        if (error)
                            return "configuration." + error;
                    }
                    return null;
                };
                /**
                 * Creates an ActionCompletedId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.ActionCompletedId} ActionCompletedId
                 */
                ActionCompletedId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.ActionCompletedId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.ActionCompletedId();
                    if (object.primaryOutput != null)
                        message.primaryOutput = String(object.primaryOutput);
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.configuration != null) {
                        if (typeof object.configuration !== "object")
                            throw TypeError(".build_event_stream.BuildEventId.ActionCompletedId.configuration: object expected");
                        message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.fromObject(object.configuration);
                    }
                    return message;
                };
                /**
                 * Creates a plain object from an ActionCompletedId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @static
                 * @param {build_event_stream.BuildEventId.ActionCompletedId} message ActionCompletedId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActionCompletedId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.primaryOutput = "";
                        object.label = "";
                        object.configuration = null;
                    }
                    if (message.primaryOutput != null && message.hasOwnProperty("primaryOutput"))
                        object.primaryOutput = message.primaryOutput;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        object.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.toObject(message.configuration, options);
                    return object;
                };
                /**
                 * Converts this ActionCompletedId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.ActionCompletedId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActionCompletedId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return ActionCompletedId;
            })();
            BuildEventId.UnconfiguredLabelId = (function () {
                /**
                 * Properties of an UnconfiguredLabelId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IUnconfiguredLabelId
                 * @property {string|null} [label] UnconfiguredLabelId label
                 */
                /**
                 * Constructs a new UnconfiguredLabelId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents an UnconfiguredLabelId.
                 * @implements IUnconfiguredLabelId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IUnconfiguredLabelId=} [properties] Properties to set
                 */
                function UnconfiguredLabelId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * UnconfiguredLabelId label.
                 * @member {string} label
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @instance
                 */
                UnconfiguredLabelId.prototype.label = "";
                /**
                 * Creates a new UnconfiguredLabelId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnconfiguredLabelId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.UnconfiguredLabelId} UnconfiguredLabelId instance
                 */
                UnconfiguredLabelId.create = function create(properties) {
                    return new UnconfiguredLabelId(properties);
                };
                /**
                 * Encodes the specified UnconfiguredLabelId message. Does not implicitly {@link build_event_stream.BuildEventId.UnconfiguredLabelId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnconfiguredLabelId} message UnconfiguredLabelId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnconfiguredLabelId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.label);
                    return writer;
                };
                /**
                 * Encodes the specified UnconfiguredLabelId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.UnconfiguredLabelId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @static
                 * @param {build_event_stream.BuildEventId.IUnconfiguredLabelId} message UnconfiguredLabelId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnconfiguredLabelId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an UnconfiguredLabelId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.UnconfiguredLabelId} UnconfiguredLabelId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnconfiguredLabelId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.UnconfiguredLabelId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.label = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an UnconfiguredLabelId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.UnconfiguredLabelId} UnconfiguredLabelId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnconfiguredLabelId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an UnconfiguredLabelId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnconfiguredLabelId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    return null;
                };
                /**
                 * Creates an UnconfiguredLabelId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.UnconfiguredLabelId} UnconfiguredLabelId
                 */
                UnconfiguredLabelId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.UnconfiguredLabelId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.UnconfiguredLabelId();
                    if (object.label != null)
                        message.label = String(object.label);
                    return message;
                };
                /**
                 * Creates a plain object from an UnconfiguredLabelId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @static
                 * @param {build_event_stream.BuildEventId.UnconfiguredLabelId} message UnconfiguredLabelId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnconfiguredLabelId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.label = "";
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    return object;
                };
                /**
                 * Converts this UnconfiguredLabelId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.UnconfiguredLabelId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnconfiguredLabelId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return UnconfiguredLabelId;
            })();
            BuildEventId.ConfiguredLabelId = (function () {
                /**
                 * Properties of a ConfiguredLabelId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IConfiguredLabelId
                 * @property {string|null} [label] ConfiguredLabelId label
                 * @property {build_event_stream.BuildEventId.IConfigurationId|null} [configuration] ConfiguredLabelId configuration
                 */
                /**
                 * Constructs a new ConfiguredLabelId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a ConfiguredLabelId.
                 * @implements IConfiguredLabelId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IConfiguredLabelId=} [properties] Properties to set
                 */
                function ConfiguredLabelId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ConfiguredLabelId label.
                 * @member {string} label
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @instance
                 */
                ConfiguredLabelId.prototype.label = "";
                /**
                 * ConfiguredLabelId configuration.
                 * @member {build_event_stream.BuildEventId.IConfigurationId|null|undefined} configuration
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @instance
                 */
                ConfiguredLabelId.prototype.configuration = null;
                /**
                 * Creates a new ConfiguredLabelId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @static
                 * @param {build_event_stream.BuildEventId.IConfiguredLabelId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.ConfiguredLabelId} ConfiguredLabelId instance
                 */
                ConfiguredLabelId.create = function create(properties) {
                    return new ConfiguredLabelId(properties);
                };
                /**
                 * Encodes the specified ConfiguredLabelId message. Does not implicitly {@link build_event_stream.BuildEventId.ConfiguredLabelId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @static
                 * @param {build_event_stream.BuildEventId.IConfiguredLabelId} message ConfiguredLabelId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConfiguredLabelId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.label);
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        $root.build_event_stream.BuildEventId.ConfigurationId.encode(message.configuration, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified ConfiguredLabelId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.ConfiguredLabelId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @static
                 * @param {build_event_stream.BuildEventId.IConfiguredLabelId} message ConfiguredLabelId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConfiguredLabelId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a ConfiguredLabelId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.ConfiguredLabelId} ConfiguredLabelId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConfiguredLabelId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.ConfiguredLabelId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.label = reader.string();
                                break;
                            case 2:
                                message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a ConfiguredLabelId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.ConfiguredLabelId} ConfiguredLabelId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConfiguredLabelId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a ConfiguredLabelId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConfiguredLabelId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.configuration != null && message.hasOwnProperty("configuration")) {
                        var error = $root.build_event_stream.BuildEventId.ConfigurationId.verify(message.configuration);
                        if (error)
                            return "configuration." + error;
                    }
                    return null;
                };
                /**
                 * Creates a ConfiguredLabelId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.ConfiguredLabelId} ConfiguredLabelId
                 */
                ConfiguredLabelId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.ConfiguredLabelId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.ConfiguredLabelId();
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.configuration != null) {
                        if (typeof object.configuration !== "object")
                            throw TypeError(".build_event_stream.BuildEventId.ConfiguredLabelId.configuration: object expected");
                        message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.fromObject(object.configuration);
                    }
                    return message;
                };
                /**
                 * Creates a plain object from a ConfiguredLabelId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @static
                 * @param {build_event_stream.BuildEventId.ConfiguredLabelId} message ConfiguredLabelId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConfiguredLabelId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.label = "";
                        object.configuration = null;
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        object.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.toObject(message.configuration, options);
                    return object;
                };
                /**
                 * Converts this ConfiguredLabelId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.ConfiguredLabelId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConfiguredLabelId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return ConfiguredLabelId;
            })();
            BuildEventId.TestResultId = (function () {
                /**
                 * Properties of a TestResultId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface ITestResultId
                 * @property {string|null} [label] TestResultId label
                 * @property {build_event_stream.BuildEventId.IConfigurationId|null} [configuration] TestResultId configuration
                 * @property {number|null} [run] TestResultId run
                 * @property {number|null} [shard] TestResultId shard
                 * @property {number|null} [attempt] TestResultId attempt
                 */
                /**
                 * Constructs a new TestResultId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a TestResultId.
                 * @implements ITestResultId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.ITestResultId=} [properties] Properties to set
                 */
                function TestResultId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * TestResultId label.
                 * @member {string} label
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @instance
                 */
                TestResultId.prototype.label = "";
                /**
                 * TestResultId configuration.
                 * @member {build_event_stream.BuildEventId.IConfigurationId|null|undefined} configuration
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @instance
                 */
                TestResultId.prototype.configuration = null;
                /**
                 * TestResultId run.
                 * @member {number} run
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @instance
                 */
                TestResultId.prototype.run = 0;
                /**
                 * TestResultId shard.
                 * @member {number} shard
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @instance
                 */
                TestResultId.prototype.shard = 0;
                /**
                 * TestResultId attempt.
                 * @member {number} attempt
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @instance
                 */
                TestResultId.prototype.attempt = 0;
                /**
                 * Creates a new TestResultId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITestResultId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.TestResultId} TestResultId instance
                 */
                TestResultId.create = function create(properties) {
                    return new TestResultId(properties);
                };
                /**
                 * Encodes the specified TestResultId message. Does not implicitly {@link build_event_stream.BuildEventId.TestResultId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITestResultId} message TestResultId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestResultId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.label);
                    if (message.run != null && message.hasOwnProperty("run"))
                        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.run);
                    if (message.shard != null && message.hasOwnProperty("shard"))
                        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.shard);
                    if (message.attempt != null && message.hasOwnProperty("attempt"))
                        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.attempt);
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        $root.build_event_stream.BuildEventId.ConfigurationId.encode(message.configuration, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified TestResultId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.TestResultId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITestResultId} message TestResultId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestResultId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a TestResultId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.TestResultId} TestResultId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestResultId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.TestResultId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.label = reader.string();
                                break;
                            case 5:
                                message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.run = reader.int32();
                                break;
                            case 3:
                                message.shard = reader.int32();
                                break;
                            case 4:
                                message.attempt = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a TestResultId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.TestResultId} TestResultId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestResultId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a TestResultId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestResultId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.configuration != null && message.hasOwnProperty("configuration")) {
                        var error = $root.build_event_stream.BuildEventId.ConfigurationId.verify(message.configuration);
                        if (error)
                            return "configuration." + error;
                    }
                    if (message.run != null && message.hasOwnProperty("run"))
                        if (!$util.isInteger(message.run))
                            return "run: integer expected";
                    if (message.shard != null && message.hasOwnProperty("shard"))
                        if (!$util.isInteger(message.shard))
                            return "shard: integer expected";
                    if (message.attempt != null && message.hasOwnProperty("attempt"))
                        if (!$util.isInteger(message.attempt))
                            return "attempt: integer expected";
                    return null;
                };
                /**
                 * Creates a TestResultId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.TestResultId} TestResultId
                 */
                TestResultId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.TestResultId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.TestResultId();
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.configuration != null) {
                        if (typeof object.configuration !== "object")
                            throw TypeError(".build_event_stream.BuildEventId.TestResultId.configuration: object expected");
                        message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.fromObject(object.configuration);
                    }
                    if (object.run != null)
                        message.run = object.run | 0;
                    if (object.shard != null)
                        message.shard = object.shard | 0;
                    if (object.attempt != null)
                        message.attempt = object.attempt | 0;
                    return message;
                };
                /**
                 * Creates a plain object from a TestResultId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @static
                 * @param {build_event_stream.BuildEventId.TestResultId} message TestResultId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestResultId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.label = "";
                        object.run = 0;
                        object.shard = 0;
                        object.attempt = 0;
                        object.configuration = null;
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.run != null && message.hasOwnProperty("run"))
                        object.run = message.run;
                    if (message.shard != null && message.hasOwnProperty("shard"))
                        object.shard = message.shard;
                    if (message.attempt != null && message.hasOwnProperty("attempt"))
                        object.attempt = message.attempt;
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        object.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.toObject(message.configuration, options);
                    return object;
                };
                /**
                 * Converts this TestResultId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.TestResultId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestResultId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return TestResultId;
            })();
            BuildEventId.TestSummaryId = (function () {
                /**
                 * Properties of a TestSummaryId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface ITestSummaryId
                 * @property {string|null} [label] TestSummaryId label
                 * @property {build_event_stream.BuildEventId.IConfigurationId|null} [configuration] TestSummaryId configuration
                 */
                /**
                 * Constructs a new TestSummaryId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a TestSummaryId.
                 * @implements ITestSummaryId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.ITestSummaryId=} [properties] Properties to set
                 */
                function TestSummaryId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * TestSummaryId label.
                 * @member {string} label
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @instance
                 */
                TestSummaryId.prototype.label = "";
                /**
                 * TestSummaryId configuration.
                 * @member {build_event_stream.BuildEventId.IConfigurationId|null|undefined} configuration
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @instance
                 */
                TestSummaryId.prototype.configuration = null;
                /**
                 * Creates a new TestSummaryId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITestSummaryId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.TestSummaryId} TestSummaryId instance
                 */
                TestSummaryId.create = function create(properties) {
                    return new TestSummaryId(properties);
                };
                /**
                 * Encodes the specified TestSummaryId message. Does not implicitly {@link build_event_stream.BuildEventId.TestSummaryId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITestSummaryId} message TestSummaryId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestSummaryId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.label);
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        $root.build_event_stream.BuildEventId.ConfigurationId.encode(message.configuration, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified TestSummaryId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.TestSummaryId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @static
                 * @param {build_event_stream.BuildEventId.ITestSummaryId} message TestSummaryId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestSummaryId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a TestSummaryId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.TestSummaryId} TestSummaryId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestSummaryId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.TestSummaryId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.label = reader.string();
                                break;
                            case 2:
                                message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a TestSummaryId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.TestSummaryId} TestSummaryId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestSummaryId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a TestSummaryId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestSummaryId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.configuration != null && message.hasOwnProperty("configuration")) {
                        var error = $root.build_event_stream.BuildEventId.ConfigurationId.verify(message.configuration);
                        if (error)
                            return "configuration." + error;
                    }
                    return null;
                };
                /**
                 * Creates a TestSummaryId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.TestSummaryId} TestSummaryId
                 */
                TestSummaryId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.TestSummaryId)
                        return object;
                    var message = new $root.build_event_stream.BuildEventId.TestSummaryId();
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.configuration != null) {
                        if (typeof object.configuration !== "object")
                            throw TypeError(".build_event_stream.BuildEventId.TestSummaryId.configuration: object expected");
                        message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.fromObject(object.configuration);
                    }
                    return message;
                };
                /**
                 * Creates a plain object from a TestSummaryId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @static
                 * @param {build_event_stream.BuildEventId.TestSummaryId} message TestSummaryId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestSummaryId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.label = "";
                        object.configuration = null;
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.configuration != null && message.hasOwnProperty("configuration"))
                        object.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.toObject(message.configuration, options);
                    return object;
                };
                /**
                 * Converts this TestSummaryId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.TestSummaryId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestSummaryId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return TestSummaryId;
            })();
            BuildEventId.BuildFinishedId = (function () {
                /**
                 * Properties of a BuildFinishedId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IBuildFinishedId
                 */
                /**
                 * Constructs a new BuildFinishedId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a BuildFinishedId.
                 * @implements IBuildFinishedId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IBuildFinishedId=} [properties] Properties to set
                 */
                function BuildFinishedId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Creates a new BuildFinishedId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildFinishedId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.BuildFinishedId} BuildFinishedId instance
                 */
                BuildFinishedId.create = function create(properties) {
                    return new BuildFinishedId(properties);
                };
                /**
                 * Encodes the specified BuildFinishedId message. Does not implicitly {@link build_event_stream.BuildEventId.BuildFinishedId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildFinishedId} message BuildFinishedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildFinishedId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
                /**
                 * Encodes the specified BuildFinishedId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.BuildFinishedId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildFinishedId} message BuildFinishedId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildFinishedId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a BuildFinishedId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.BuildFinishedId} BuildFinishedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildFinishedId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.BuildFinishedId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a BuildFinishedId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.BuildFinishedId} BuildFinishedId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildFinishedId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a BuildFinishedId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BuildFinishedId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
                /**
                 * Creates a BuildFinishedId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.BuildFinishedId} BuildFinishedId
                 */
                BuildFinishedId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.BuildFinishedId)
                        return object;
                    return new $root.build_event_stream.BuildEventId.BuildFinishedId();
                };
                /**
                 * Creates a plain object from a BuildFinishedId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @static
                 * @param {build_event_stream.BuildEventId.BuildFinishedId} message BuildFinishedId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BuildFinishedId.toObject = function toObject() {
                    return {};
                };
                /**
                 * Converts this BuildFinishedId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.BuildFinishedId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BuildFinishedId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return BuildFinishedId;
            })();
            BuildEventId.BuildToolLogsId = (function () {
                /**
                 * Properties of a BuildToolLogsId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IBuildToolLogsId
                 */
                /**
                 * Constructs a new BuildToolLogsId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a BuildToolLogsId.
                 * @implements IBuildToolLogsId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IBuildToolLogsId=} [properties] Properties to set
                 */
                function BuildToolLogsId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Creates a new BuildToolLogsId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildToolLogsId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.BuildToolLogsId} BuildToolLogsId instance
                 */
                BuildToolLogsId.create = function create(properties) {
                    return new BuildToolLogsId(properties);
                };
                /**
                 * Encodes the specified BuildToolLogsId message. Does not implicitly {@link build_event_stream.BuildEventId.BuildToolLogsId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildToolLogsId} message BuildToolLogsId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildToolLogsId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
                /**
                 * Encodes the specified BuildToolLogsId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.BuildToolLogsId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildToolLogsId} message BuildToolLogsId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildToolLogsId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a BuildToolLogsId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.BuildToolLogsId} BuildToolLogsId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildToolLogsId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.BuildToolLogsId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a BuildToolLogsId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.BuildToolLogsId} BuildToolLogsId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildToolLogsId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a BuildToolLogsId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BuildToolLogsId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
                /**
                 * Creates a BuildToolLogsId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.BuildToolLogsId} BuildToolLogsId
                 */
                BuildToolLogsId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.BuildToolLogsId)
                        return object;
                    return new $root.build_event_stream.BuildEventId.BuildToolLogsId();
                };
                /**
                 * Creates a plain object from a BuildToolLogsId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @static
                 * @param {build_event_stream.BuildEventId.BuildToolLogsId} message BuildToolLogsId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BuildToolLogsId.toObject = function toObject() {
                    return {};
                };
                /**
                 * Converts this BuildToolLogsId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.BuildToolLogsId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BuildToolLogsId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return BuildToolLogsId;
            })();
            BuildEventId.BuildMetricsId = (function () {
                /**
                 * Properties of a BuildMetricsId.
                 * @memberof build_event_stream.BuildEventId
                 * @interface IBuildMetricsId
                 */
                /**
                 * Constructs a new BuildMetricsId.
                 * @memberof build_event_stream.BuildEventId
                 * @classdesc Represents a BuildMetricsId.
                 * @implements IBuildMetricsId
                 * @constructor
                 * @param {build_event_stream.BuildEventId.IBuildMetricsId=} [properties] Properties to set
                 */
                function BuildMetricsId(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Creates a new BuildMetricsId instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildMetricsId=} [properties] Properties to set
                 * @returns {build_event_stream.BuildEventId.BuildMetricsId} BuildMetricsId instance
                 */
                BuildMetricsId.create = function create(properties) {
                    return new BuildMetricsId(properties);
                };
                /**
                 * Encodes the specified BuildMetricsId message. Does not implicitly {@link build_event_stream.BuildEventId.BuildMetricsId.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildMetricsId} message BuildMetricsId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildMetricsId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
                /**
                 * Encodes the specified BuildMetricsId message, length delimited. Does not implicitly {@link build_event_stream.BuildEventId.BuildMetricsId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @static
                 * @param {build_event_stream.BuildEventId.IBuildMetricsId} message BuildMetricsId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BuildMetricsId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a BuildMetricsId message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildEventId.BuildMetricsId} BuildMetricsId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildMetricsId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEventId.BuildMetricsId();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a BuildMetricsId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildEventId.BuildMetricsId} BuildMetricsId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BuildMetricsId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a BuildMetricsId message.
                 * @function verify
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BuildMetricsId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
                /**
                 * Creates a BuildMetricsId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildEventId.BuildMetricsId} BuildMetricsId
                 */
                BuildMetricsId.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildEventId.BuildMetricsId)
                        return object;
                    return new $root.build_event_stream.BuildEventId.BuildMetricsId();
                };
                /**
                 * Creates a plain object from a BuildMetricsId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @static
                 * @param {build_event_stream.BuildEventId.BuildMetricsId} message BuildMetricsId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BuildMetricsId.toObject = function toObject() {
                    return {};
                };
                /**
                 * Converts this BuildMetricsId to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildEventId.BuildMetricsId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BuildMetricsId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return BuildMetricsId;
            })();
            return BuildEventId;
        })();
        build_event_stream.Progress = (function () {
            /**
             * Properties of a Progress.
             * @memberof build_event_stream
             * @interface IProgress
             * @property {string|null} [stdout] Progress stdout
             * @property {string|null} [stderr] Progress stderr
             */
            /**
             * Constructs a new Progress.
             * @memberof build_event_stream
             * @classdesc Represents a Progress.
             * @implements IProgress
             * @constructor
             * @param {build_event_stream.IProgress=} [properties] Properties to set
             */
            function Progress(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Progress stdout.
             * @member {string} stdout
             * @memberof build_event_stream.Progress
             * @instance
             */
            Progress.prototype.stdout = "";
            /**
             * Progress stderr.
             * @member {string} stderr
             * @memberof build_event_stream.Progress
             * @instance
             */
            Progress.prototype.stderr = "";
            /**
             * Creates a new Progress instance using the specified properties.
             * @function create
             * @memberof build_event_stream.Progress
             * @static
             * @param {build_event_stream.IProgress=} [properties] Properties to set
             * @returns {build_event_stream.Progress} Progress instance
             */
            Progress.create = function create(properties) {
                return new Progress(properties);
            };
            /**
             * Encodes the specified Progress message. Does not implicitly {@link build_event_stream.Progress.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.Progress
             * @static
             * @param {build_event_stream.IProgress} message Progress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Progress.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.stdout);
                if (message.stderr != null && message.hasOwnProperty("stderr"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.stderr);
                return writer;
            };
            /**
             * Encodes the specified Progress message, length delimited. Does not implicitly {@link build_event_stream.Progress.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.Progress
             * @static
             * @param {build_event_stream.IProgress} message Progress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Progress.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Progress message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.Progress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.Progress} Progress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Progress.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.Progress();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.stdout = reader.string();
                            break;
                        case 2:
                            message.stderr = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Progress message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.Progress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.Progress} Progress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Progress.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Progress message.
             * @function verify
             * @memberof build_event_stream.Progress
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Progress.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    if (!$util.isString(message.stdout))
                        return "stdout: string expected";
                if (message.stderr != null && message.hasOwnProperty("stderr"))
                    if (!$util.isString(message.stderr))
                        return "stderr: string expected";
                return null;
            };
            /**
             * Creates a Progress message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.Progress
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.Progress} Progress
             */
            Progress.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.Progress)
                    return object;
                var message = new $root.build_event_stream.Progress();
                if (object.stdout != null)
                    message.stdout = String(object.stdout);
                if (object.stderr != null)
                    message.stderr = String(object.stderr);
                return message;
            };
            /**
             * Creates a plain object from a Progress message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.Progress
             * @static
             * @param {build_event_stream.Progress} message Progress
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Progress.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stdout = "";
                    object.stderr = "";
                }
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    object.stdout = message.stdout;
                if (message.stderr != null && message.hasOwnProperty("stderr"))
                    object.stderr = message.stderr;
                return object;
            };
            /**
             * Converts this Progress to JSON.
             * @function toJSON
             * @memberof build_event_stream.Progress
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Progress.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Progress;
        })();
        build_event_stream.Aborted = (function () {
            /**
             * Properties of an Aborted.
             * @memberof build_event_stream
             * @interface IAborted
             * @property {build_event_stream.Aborted.AbortReason|null} [reason] Aborted reason
             * @property {string|null} [description] Aborted description
             */
            /**
             * Constructs a new Aborted.
             * @memberof build_event_stream
             * @classdesc Represents an Aborted.
             * @implements IAborted
             * @constructor
             * @param {build_event_stream.IAborted=} [properties] Properties to set
             */
            function Aborted(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Aborted reason.
             * @member {build_event_stream.Aborted.AbortReason} reason
             * @memberof build_event_stream.Aborted
             * @instance
             */
            Aborted.prototype.reason = 0;
            /**
             * Aborted description.
             * @member {string} description
             * @memberof build_event_stream.Aborted
             * @instance
             */
            Aborted.prototype.description = "";
            /**
             * Creates a new Aborted instance using the specified properties.
             * @function create
             * @memberof build_event_stream.Aborted
             * @static
             * @param {build_event_stream.IAborted=} [properties] Properties to set
             * @returns {build_event_stream.Aborted} Aborted instance
             */
            Aborted.create = function create(properties) {
                return new Aborted(properties);
            };
            /**
             * Encodes the specified Aborted message. Does not implicitly {@link build_event_stream.Aborted.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.Aborted
             * @static
             * @param {build_event_stream.IAborted} message Aborted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Aborted.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.reason != null && message.hasOwnProperty("reason"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.reason);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.description);
                return writer;
            };
            /**
             * Encodes the specified Aborted message, length delimited. Does not implicitly {@link build_event_stream.Aborted.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.Aborted
             * @static
             * @param {build_event_stream.IAborted} message Aborted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Aborted.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Aborted message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.Aborted
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.Aborted} Aborted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Aborted.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.Aborted();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.reason = reader.int32();
                            break;
                        case 2:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Aborted message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.Aborted
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.Aborted} Aborted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Aborted.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Aborted message.
             * @function verify
             * @memberof build_event_stream.Aborted
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Aborted.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.reason != null && message.hasOwnProperty("reason"))
                    switch (message.reason) {
                        default:
                            return "reason: enum value expected";
                        case 0:
                        case 1:
                        case 8:
                        case 9:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                    }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };
            /**
             * Creates an Aborted message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.Aborted
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.Aborted} Aborted
             */
            Aborted.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.Aborted)
                    return object;
                var message = new $root.build_event_stream.Aborted();
                switch (object.reason) {
                    case "UNKNOWN":
                    case 0:
                        message.reason = 0;
                        break;
                    case "USER_INTERRUPTED":
                    case 1:
                        message.reason = 1;
                        break;
                    case "NO_ANALYZE":
                    case 8:
                        message.reason = 8;
                        break;
                    case "NO_BUILD":
                    case 9:
                        message.reason = 9;
                        break;
                    case "TIME_OUT":
                    case 2:
                        message.reason = 2;
                        break;
                    case "REMOTE_ENVIRONMENT_FAILURE":
                    case 3:
                        message.reason = 3;
                        break;
                    case "INTERNAL":
                    case 4:
                        message.reason = 4;
                        break;
                    case "LOADING_FAILURE":
                    case 5:
                        message.reason = 5;
                        break;
                    case "ANALYSIS_FAILURE":
                    case 6:
                        message.reason = 6;
                        break;
                    case "SKIPPED":
                    case 7:
                        message.reason = 7;
                        break;
                }
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };
            /**
             * Creates a plain object from an Aborted message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.Aborted
             * @static
             * @param {build_event_stream.Aborted} message Aborted
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Aborted.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.reason = options.enums === String ? "UNKNOWN" : 0;
                    object.description = "";
                }
                if (message.reason != null && message.hasOwnProperty("reason"))
                    object.reason = options.enums === String ? $root.build_event_stream.Aborted.AbortReason[message.reason] : message.reason;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };
            /**
             * Converts this Aborted to JSON.
             * @function toJSON
             * @memberof build_event_stream.Aborted
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Aborted.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * AbortReason enum.
             * @name build_event_stream.Aborted.AbortReason
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} USER_INTERRUPTED=1 USER_INTERRUPTED value
             * @property {number} NO_ANALYZE=8 NO_ANALYZE value
             * @property {number} NO_BUILD=9 NO_BUILD value
             * @property {number} TIME_OUT=2 TIME_OUT value
             * @property {number} REMOTE_ENVIRONMENT_FAILURE=3 REMOTE_ENVIRONMENT_FAILURE value
             * @property {number} INTERNAL=4 INTERNAL value
             * @property {number} LOADING_FAILURE=5 LOADING_FAILURE value
             * @property {number} ANALYSIS_FAILURE=6 ANALYSIS_FAILURE value
             * @property {number} SKIPPED=7 SKIPPED value
             */
            Aborted.AbortReason = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "USER_INTERRUPTED"] = 1;
                values[valuesById[8] = "NO_ANALYZE"] = 8;
                values[valuesById[9] = "NO_BUILD"] = 9;
                values[valuesById[2] = "TIME_OUT"] = 2;
                values[valuesById[3] = "REMOTE_ENVIRONMENT_FAILURE"] = 3;
                values[valuesById[4] = "INTERNAL"] = 4;
                values[valuesById[5] = "LOADING_FAILURE"] = 5;
                values[valuesById[6] = "ANALYSIS_FAILURE"] = 6;
                values[valuesById[7] = "SKIPPED"] = 7;
                return values;
            })();
            return Aborted;
        })();
        build_event_stream.BuildStarted = (function () {
            /**
             * Properties of a BuildStarted.
             * @memberof build_event_stream
             * @interface IBuildStarted
             * @property {string|null} [uuid] BuildStarted uuid
             * @property {number|Long|null} [startTimeMillis] BuildStarted startTimeMillis
             * @property {string|null} [buildToolVersion] BuildStarted buildToolVersion
             * @property {string|null} [optionsDescription] BuildStarted optionsDescription
             * @property {string|null} [command] BuildStarted command
             * @property {string|null} [workingDirectory] BuildStarted workingDirectory
             * @property {string|null} [workspaceDirectory] BuildStarted workspaceDirectory
             * @property {number|Long|null} [serverPid] BuildStarted serverPid
             */
            /**
             * Constructs a new BuildStarted.
             * @memberof build_event_stream
             * @classdesc Represents a BuildStarted.
             * @implements IBuildStarted
             * @constructor
             * @param {build_event_stream.IBuildStarted=} [properties] Properties to set
             */
            function BuildStarted(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * BuildStarted uuid.
             * @member {string} uuid
             * @memberof build_event_stream.BuildStarted
             * @instance
             */
            BuildStarted.prototype.uuid = "";
            /**
             * BuildStarted startTimeMillis.
             * @member {number|Long} startTimeMillis
             * @memberof build_event_stream.BuildStarted
             * @instance
             */
            BuildStarted.prototype.startTimeMillis = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * BuildStarted buildToolVersion.
             * @member {string} buildToolVersion
             * @memberof build_event_stream.BuildStarted
             * @instance
             */
            BuildStarted.prototype.buildToolVersion = "";
            /**
             * BuildStarted optionsDescription.
             * @member {string} optionsDescription
             * @memberof build_event_stream.BuildStarted
             * @instance
             */
            BuildStarted.prototype.optionsDescription = "";
            /**
             * BuildStarted command.
             * @member {string} command
             * @memberof build_event_stream.BuildStarted
             * @instance
             */
            BuildStarted.prototype.command = "";
            /**
             * BuildStarted workingDirectory.
             * @member {string} workingDirectory
             * @memberof build_event_stream.BuildStarted
             * @instance
             */
            BuildStarted.prototype.workingDirectory = "";
            /**
             * BuildStarted workspaceDirectory.
             * @member {string} workspaceDirectory
             * @memberof build_event_stream.BuildStarted
             * @instance
             */
            BuildStarted.prototype.workspaceDirectory = "";
            /**
             * BuildStarted serverPid.
             * @member {number|Long} serverPid
             * @memberof build_event_stream.BuildStarted
             * @instance
             */
            BuildStarted.prototype.serverPid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new BuildStarted instance using the specified properties.
             * @function create
             * @memberof build_event_stream.BuildStarted
             * @static
             * @param {build_event_stream.IBuildStarted=} [properties] Properties to set
             * @returns {build_event_stream.BuildStarted} BuildStarted instance
             */
            BuildStarted.create = function create(properties) {
                return new BuildStarted(properties);
            };
            /**
             * Encodes the specified BuildStarted message. Does not implicitly {@link build_event_stream.BuildStarted.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.BuildStarted
             * @static
             * @param {build_event_stream.IBuildStarted} message BuildStarted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildStarted.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.uuid);
                if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.startTimeMillis);
                if (message.buildToolVersion != null && message.hasOwnProperty("buildToolVersion"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.buildToolVersion);
                if (message.optionsDescription != null && message.hasOwnProperty("optionsDescription"))
                    writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.optionsDescription);
                if (message.command != null && message.hasOwnProperty("command"))
                    writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.command);
                if (message.workingDirectory != null && message.hasOwnProperty("workingDirectory"))
                    writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.workingDirectory);
                if (message.workspaceDirectory != null && message.hasOwnProperty("workspaceDirectory"))
                    writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.workspaceDirectory);
                if (message.serverPid != null && message.hasOwnProperty("serverPid"))
                    writer.uint32(/* id 8, wireType 0 =*/ 64).int64(message.serverPid);
                return writer;
            };
            /**
             * Encodes the specified BuildStarted message, length delimited. Does not implicitly {@link build_event_stream.BuildStarted.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.BuildStarted
             * @static
             * @param {build_event_stream.IBuildStarted} message BuildStarted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildStarted.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a BuildStarted message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.BuildStarted
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.BuildStarted} BuildStarted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildStarted.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildStarted();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.uuid = reader.string();
                            break;
                        case 2:
                            message.startTimeMillis = reader.int64();
                            break;
                        case 3:
                            message.buildToolVersion = reader.string();
                            break;
                        case 4:
                            message.optionsDescription = reader.string();
                            break;
                        case 5:
                            message.command = reader.string();
                            break;
                        case 6:
                            message.workingDirectory = reader.string();
                            break;
                        case 7:
                            message.workspaceDirectory = reader.string();
                            break;
                        case 8:
                            message.serverPid = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a BuildStarted message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.BuildStarted
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.BuildStarted} BuildStarted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildStarted.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a BuildStarted message.
             * @function verify
             * @memberof build_event_stream.BuildStarted
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BuildStarted.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    if (!$util.isString(message.uuid))
                        return "uuid: string expected";
                if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                    if (!$util.isInteger(message.startTimeMillis) && !(message.startTimeMillis && $util.isInteger(message.startTimeMillis.low) && $util.isInteger(message.startTimeMillis.high)))
                        return "startTimeMillis: integer|Long expected";
                if (message.buildToolVersion != null && message.hasOwnProperty("buildToolVersion"))
                    if (!$util.isString(message.buildToolVersion))
                        return "buildToolVersion: string expected";
                if (message.optionsDescription != null && message.hasOwnProperty("optionsDescription"))
                    if (!$util.isString(message.optionsDescription))
                        return "optionsDescription: string expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.workingDirectory != null && message.hasOwnProperty("workingDirectory"))
                    if (!$util.isString(message.workingDirectory))
                        return "workingDirectory: string expected";
                if (message.workspaceDirectory != null && message.hasOwnProperty("workspaceDirectory"))
                    if (!$util.isString(message.workspaceDirectory))
                        return "workspaceDirectory: string expected";
                if (message.serverPid != null && message.hasOwnProperty("serverPid"))
                    if (!$util.isInteger(message.serverPid) && !(message.serverPid && $util.isInteger(message.serverPid.low) && $util.isInteger(message.serverPid.high)))
                        return "serverPid: integer|Long expected";
                return null;
            };
            /**
             * Creates a BuildStarted message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.BuildStarted
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.BuildStarted} BuildStarted
             */
            BuildStarted.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.BuildStarted)
                    return object;
                var message = new $root.build_event_stream.BuildStarted();
                if (object.uuid != null)
                    message.uuid = String(object.uuid);
                if (object.startTimeMillis != null)
                    if ($util.Long)
                        (message.startTimeMillis = $util.Long.fromValue(object.startTimeMillis)).unsigned = false;
                    else if (typeof object.startTimeMillis === "string")
                        message.startTimeMillis = parseInt(object.startTimeMillis, 10);
                    else if (typeof object.startTimeMillis === "number")
                        message.startTimeMillis = object.startTimeMillis;
                    else if (typeof object.startTimeMillis === "object")
                        message.startTimeMillis = new $util.LongBits(object.startTimeMillis.low >>> 0, object.startTimeMillis.high >>> 0).toNumber();
                if (object.buildToolVersion != null)
                    message.buildToolVersion = String(object.buildToolVersion);
                if (object.optionsDescription != null)
                    message.optionsDescription = String(object.optionsDescription);
                if (object.command != null)
                    message.command = String(object.command);
                if (object.workingDirectory != null)
                    message.workingDirectory = String(object.workingDirectory);
                if (object.workspaceDirectory != null)
                    message.workspaceDirectory = String(object.workspaceDirectory);
                if (object.serverPid != null)
                    if ($util.Long)
                        (message.serverPid = $util.Long.fromValue(object.serverPid)).unsigned = false;
                    else if (typeof object.serverPid === "string")
                        message.serverPid = parseInt(object.serverPid, 10);
                    else if (typeof object.serverPid === "number")
                        message.serverPid = object.serverPid;
                    else if (typeof object.serverPid === "object")
                        message.serverPid = new $util.LongBits(object.serverPid.low >>> 0, object.serverPid.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from a BuildStarted message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.BuildStarted
             * @static
             * @param {build_event_stream.BuildStarted} message BuildStarted
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BuildStarted.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.uuid = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.startTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.startTimeMillis = options.longs === String ? "0" : 0;
                    object.buildToolVersion = "";
                    object.optionsDescription = "";
                    object.command = "";
                    object.workingDirectory = "";
                    object.workspaceDirectory = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.serverPid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.serverPid = options.longs === String ? "0" : 0;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = message.uuid;
                if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                    if (typeof message.startTimeMillis === "number")
                        object.startTimeMillis = options.longs === String ? String(message.startTimeMillis) : message.startTimeMillis;
                    else
                        object.startTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeMillis) : options.longs === Number ? new $util.LongBits(message.startTimeMillis.low >>> 0, message.startTimeMillis.high >>> 0).toNumber() : message.startTimeMillis;
                if (message.buildToolVersion != null && message.hasOwnProperty("buildToolVersion"))
                    object.buildToolVersion = message.buildToolVersion;
                if (message.optionsDescription != null && message.hasOwnProperty("optionsDescription"))
                    object.optionsDescription = message.optionsDescription;
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.workingDirectory != null && message.hasOwnProperty("workingDirectory"))
                    object.workingDirectory = message.workingDirectory;
                if (message.workspaceDirectory != null && message.hasOwnProperty("workspaceDirectory"))
                    object.workspaceDirectory = message.workspaceDirectory;
                if (message.serverPid != null && message.hasOwnProperty("serverPid"))
                    if (typeof message.serverPid === "number")
                        object.serverPid = options.longs === String ? String(message.serverPid) : message.serverPid;
                    else
                        object.serverPid = options.longs === String ? $util.Long.prototype.toString.call(message.serverPid) : options.longs === Number ? new $util.LongBits(message.serverPid.low >>> 0, message.serverPid.high >>> 0).toNumber() : message.serverPid;
                return object;
            };
            /**
             * Converts this BuildStarted to JSON.
             * @function toJSON
             * @memberof build_event_stream.BuildStarted
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BuildStarted.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return BuildStarted;
        })();
        build_event_stream.UnstructuredCommandLine = (function () {
            /**
             * Properties of an UnstructuredCommandLine.
             * @memberof build_event_stream
             * @interface IUnstructuredCommandLine
             * @property {Array.<string>|null} [args] UnstructuredCommandLine args
             */
            /**
             * Constructs a new UnstructuredCommandLine.
             * @memberof build_event_stream
             * @classdesc Represents an UnstructuredCommandLine.
             * @implements IUnstructuredCommandLine
             * @constructor
             * @param {build_event_stream.IUnstructuredCommandLine=} [properties] Properties to set
             */
            function UnstructuredCommandLine(properties) {
                this.args = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * UnstructuredCommandLine args.
             * @member {Array.<string>} args
             * @memberof build_event_stream.UnstructuredCommandLine
             * @instance
             */
            UnstructuredCommandLine.prototype.args = $util.emptyArray;
            /**
             * Creates a new UnstructuredCommandLine instance using the specified properties.
             * @function create
             * @memberof build_event_stream.UnstructuredCommandLine
             * @static
             * @param {build_event_stream.IUnstructuredCommandLine=} [properties] Properties to set
             * @returns {build_event_stream.UnstructuredCommandLine} UnstructuredCommandLine instance
             */
            UnstructuredCommandLine.create = function create(properties) {
                return new UnstructuredCommandLine(properties);
            };
            /**
             * Encodes the specified UnstructuredCommandLine message. Does not implicitly {@link build_event_stream.UnstructuredCommandLine.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.UnstructuredCommandLine
             * @static
             * @param {build_event_stream.IUnstructuredCommandLine} message UnstructuredCommandLine message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnstructuredCommandLine.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.args != null && message.args.length)
                    for (var i = 0; i < message.args.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.args[i]);
                return writer;
            };
            /**
             * Encodes the specified UnstructuredCommandLine message, length delimited. Does not implicitly {@link build_event_stream.UnstructuredCommandLine.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.UnstructuredCommandLine
             * @static
             * @param {build_event_stream.IUnstructuredCommandLine} message UnstructuredCommandLine message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnstructuredCommandLine.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an UnstructuredCommandLine message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.UnstructuredCommandLine
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.UnstructuredCommandLine} UnstructuredCommandLine
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnstructuredCommandLine.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.UnstructuredCommandLine();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an UnstructuredCommandLine message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.UnstructuredCommandLine
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.UnstructuredCommandLine} UnstructuredCommandLine
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnstructuredCommandLine.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an UnstructuredCommandLine message.
             * @function verify
             * @memberof build_event_stream.UnstructuredCommandLine
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnstructuredCommandLine.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.args != null && message.hasOwnProperty("args")) {
                    if (!Array.isArray(message.args))
                        return "args: array expected";
                    for (var i = 0; i < message.args.length; ++i)
                        if (!$util.isString(message.args[i]))
                            return "args: string[] expected";
                }
                return null;
            };
            /**
             * Creates an UnstructuredCommandLine message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.UnstructuredCommandLine
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.UnstructuredCommandLine} UnstructuredCommandLine
             */
            UnstructuredCommandLine.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.UnstructuredCommandLine)
                    return object;
                var message = new $root.build_event_stream.UnstructuredCommandLine();
                if (object.args) {
                    if (!Array.isArray(object.args))
                        throw TypeError(".build_event_stream.UnstructuredCommandLine.args: array expected");
                    message.args = [];
                    for (var i = 0; i < object.args.length; ++i)
                        message.args[i] = String(object.args[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from an UnstructuredCommandLine message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.UnstructuredCommandLine
             * @static
             * @param {build_event_stream.UnstructuredCommandLine} message UnstructuredCommandLine
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnstructuredCommandLine.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.args = [];
                if (message.args && message.args.length) {
                    object.args = [];
                    for (var j = 0; j < message.args.length; ++j)
                        object.args[j] = message.args[j];
                }
                return object;
            };
            /**
             * Converts this UnstructuredCommandLine to JSON.
             * @function toJSON
             * @memberof build_event_stream.UnstructuredCommandLine
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnstructuredCommandLine.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return UnstructuredCommandLine;
        })();
        build_event_stream.OptionsParsed = (function () {
            /**
             * Properties of an OptionsParsed.
             * @memberof build_event_stream
             * @interface IOptionsParsed
             * @property {Array.<string>|null} [startupOptions] OptionsParsed startupOptions
             * @property {Array.<string>|null} [explicitStartupOptions] OptionsParsed explicitStartupOptions
             * @property {Array.<string>|null} [cmdLine] OptionsParsed cmdLine
             * @property {Array.<string>|null} [explicitCmdLine] OptionsParsed explicitCmdLine
             * @property {blaze.invocation_policy.IInvocationPolicy|null} [invocationPolicy] OptionsParsed invocationPolicy
             * @property {string|null} [toolTag] OptionsParsed toolTag
             */
            /**
             * Constructs a new OptionsParsed.
             * @memberof build_event_stream
             * @classdesc Represents an OptionsParsed.
             * @implements IOptionsParsed
             * @constructor
             * @param {build_event_stream.IOptionsParsed=} [properties] Properties to set
             */
            function OptionsParsed(properties) {
                this.startupOptions = [];
                this.explicitStartupOptions = [];
                this.cmdLine = [];
                this.explicitCmdLine = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OptionsParsed startupOptions.
             * @member {Array.<string>} startupOptions
             * @memberof build_event_stream.OptionsParsed
             * @instance
             */
            OptionsParsed.prototype.startupOptions = $util.emptyArray;
            /**
             * OptionsParsed explicitStartupOptions.
             * @member {Array.<string>} explicitStartupOptions
             * @memberof build_event_stream.OptionsParsed
             * @instance
             */
            OptionsParsed.prototype.explicitStartupOptions = $util.emptyArray;
            /**
             * OptionsParsed cmdLine.
             * @member {Array.<string>} cmdLine
             * @memberof build_event_stream.OptionsParsed
             * @instance
             */
            OptionsParsed.prototype.cmdLine = $util.emptyArray;
            /**
             * OptionsParsed explicitCmdLine.
             * @member {Array.<string>} explicitCmdLine
             * @memberof build_event_stream.OptionsParsed
             * @instance
             */
            OptionsParsed.prototype.explicitCmdLine = $util.emptyArray;
            /**
             * OptionsParsed invocationPolicy.
             * @member {blaze.invocation_policy.IInvocationPolicy|null|undefined} invocationPolicy
             * @memberof build_event_stream.OptionsParsed
             * @instance
             */
            OptionsParsed.prototype.invocationPolicy = null;
            /**
             * OptionsParsed toolTag.
             * @member {string} toolTag
             * @memberof build_event_stream.OptionsParsed
             * @instance
             */
            OptionsParsed.prototype.toolTag = "";
            /**
             * Creates a new OptionsParsed instance using the specified properties.
             * @function create
             * @memberof build_event_stream.OptionsParsed
             * @static
             * @param {build_event_stream.IOptionsParsed=} [properties] Properties to set
             * @returns {build_event_stream.OptionsParsed} OptionsParsed instance
             */
            OptionsParsed.create = function create(properties) {
                return new OptionsParsed(properties);
            };
            /**
             * Encodes the specified OptionsParsed message. Does not implicitly {@link build_event_stream.OptionsParsed.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.OptionsParsed
             * @static
             * @param {build_event_stream.IOptionsParsed} message OptionsParsed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OptionsParsed.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startupOptions != null && message.startupOptions.length)
                    for (var i = 0; i < message.startupOptions.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.startupOptions[i]);
                if (message.explicitStartupOptions != null && message.explicitStartupOptions.length)
                    for (var i = 0; i < message.explicitStartupOptions.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.explicitStartupOptions[i]);
                if (message.cmdLine != null && message.cmdLine.length)
                    for (var i = 0; i < message.cmdLine.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.cmdLine[i]);
                if (message.explicitCmdLine != null && message.explicitCmdLine.length)
                    for (var i = 0; i < message.explicitCmdLine.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.explicitCmdLine[i]);
                if (message.invocationPolicy != null && message.hasOwnProperty("invocationPolicy"))
                    $root.blaze.invocation_policy.InvocationPolicy.encode(message.invocationPolicy, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                if (message.toolTag != null && message.hasOwnProperty("toolTag"))
                    writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.toolTag);
                return writer;
            };
            /**
             * Encodes the specified OptionsParsed message, length delimited. Does not implicitly {@link build_event_stream.OptionsParsed.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.OptionsParsed
             * @static
             * @param {build_event_stream.IOptionsParsed} message OptionsParsed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OptionsParsed.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an OptionsParsed message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.OptionsParsed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.OptionsParsed} OptionsParsed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OptionsParsed.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.OptionsParsed();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.startupOptions && message.startupOptions.length))
                                message.startupOptions = [];
                            message.startupOptions.push(reader.string());
                            break;
                        case 2:
                            if (!(message.explicitStartupOptions && message.explicitStartupOptions.length))
                                message.explicitStartupOptions = [];
                            message.explicitStartupOptions.push(reader.string());
                            break;
                        case 3:
                            if (!(message.cmdLine && message.cmdLine.length))
                                message.cmdLine = [];
                            message.cmdLine.push(reader.string());
                            break;
                        case 4:
                            if (!(message.explicitCmdLine && message.explicitCmdLine.length))
                                message.explicitCmdLine = [];
                            message.explicitCmdLine.push(reader.string());
                            break;
                        case 5:
                            message.invocationPolicy = $root.blaze.invocation_policy.InvocationPolicy.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.toolTag = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an OptionsParsed message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.OptionsParsed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.OptionsParsed} OptionsParsed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OptionsParsed.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an OptionsParsed message.
             * @function verify
             * @memberof build_event_stream.OptionsParsed
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OptionsParsed.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startupOptions != null && message.hasOwnProperty("startupOptions")) {
                    if (!Array.isArray(message.startupOptions))
                        return "startupOptions: array expected";
                    for (var i = 0; i < message.startupOptions.length; ++i)
                        if (!$util.isString(message.startupOptions[i]))
                            return "startupOptions: string[] expected";
                }
                if (message.explicitStartupOptions != null && message.hasOwnProperty("explicitStartupOptions")) {
                    if (!Array.isArray(message.explicitStartupOptions))
                        return "explicitStartupOptions: array expected";
                    for (var i = 0; i < message.explicitStartupOptions.length; ++i)
                        if (!$util.isString(message.explicitStartupOptions[i]))
                            return "explicitStartupOptions: string[] expected";
                }
                if (message.cmdLine != null && message.hasOwnProperty("cmdLine")) {
                    if (!Array.isArray(message.cmdLine))
                        return "cmdLine: array expected";
                    for (var i = 0; i < message.cmdLine.length; ++i)
                        if (!$util.isString(message.cmdLine[i]))
                            return "cmdLine: string[] expected";
                }
                if (message.explicitCmdLine != null && message.hasOwnProperty("explicitCmdLine")) {
                    if (!Array.isArray(message.explicitCmdLine))
                        return "explicitCmdLine: array expected";
                    for (var i = 0; i < message.explicitCmdLine.length; ++i)
                        if (!$util.isString(message.explicitCmdLine[i]))
                            return "explicitCmdLine: string[] expected";
                }
                if (message.invocationPolicy != null && message.hasOwnProperty("invocationPolicy")) {
                    var error = $root.blaze.invocation_policy.InvocationPolicy.verify(message.invocationPolicy);
                    if (error)
                        return "invocationPolicy." + error;
                }
                if (message.toolTag != null && message.hasOwnProperty("toolTag"))
                    if (!$util.isString(message.toolTag))
                        return "toolTag: string expected";
                return null;
            };
            /**
             * Creates an OptionsParsed message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.OptionsParsed
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.OptionsParsed} OptionsParsed
             */
            OptionsParsed.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.OptionsParsed)
                    return object;
                var message = new $root.build_event_stream.OptionsParsed();
                if (object.startupOptions) {
                    if (!Array.isArray(object.startupOptions))
                        throw TypeError(".build_event_stream.OptionsParsed.startupOptions: array expected");
                    message.startupOptions = [];
                    for (var i = 0; i < object.startupOptions.length; ++i)
                        message.startupOptions[i] = String(object.startupOptions[i]);
                }
                if (object.explicitStartupOptions) {
                    if (!Array.isArray(object.explicitStartupOptions))
                        throw TypeError(".build_event_stream.OptionsParsed.explicitStartupOptions: array expected");
                    message.explicitStartupOptions = [];
                    for (var i = 0; i < object.explicitStartupOptions.length; ++i)
                        message.explicitStartupOptions[i] = String(object.explicitStartupOptions[i]);
                }
                if (object.cmdLine) {
                    if (!Array.isArray(object.cmdLine))
                        throw TypeError(".build_event_stream.OptionsParsed.cmdLine: array expected");
                    message.cmdLine = [];
                    for (var i = 0; i < object.cmdLine.length; ++i)
                        message.cmdLine[i] = String(object.cmdLine[i]);
                }
                if (object.explicitCmdLine) {
                    if (!Array.isArray(object.explicitCmdLine))
                        throw TypeError(".build_event_stream.OptionsParsed.explicitCmdLine: array expected");
                    message.explicitCmdLine = [];
                    for (var i = 0; i < object.explicitCmdLine.length; ++i)
                        message.explicitCmdLine[i] = String(object.explicitCmdLine[i]);
                }
                if (object.invocationPolicy != null) {
                    if (typeof object.invocationPolicy !== "object")
                        throw TypeError(".build_event_stream.OptionsParsed.invocationPolicy: object expected");
                    message.invocationPolicy = $root.blaze.invocation_policy.InvocationPolicy.fromObject(object.invocationPolicy);
                }
                if (object.toolTag != null)
                    message.toolTag = String(object.toolTag);
                return message;
            };
            /**
             * Creates a plain object from an OptionsParsed message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.OptionsParsed
             * @static
             * @param {build_event_stream.OptionsParsed} message OptionsParsed
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OptionsParsed.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.startupOptions = [];
                    object.explicitStartupOptions = [];
                    object.cmdLine = [];
                    object.explicitCmdLine = [];
                }
                if (options.defaults) {
                    object.invocationPolicy = null;
                    object.toolTag = "";
                }
                if (message.startupOptions && message.startupOptions.length) {
                    object.startupOptions = [];
                    for (var j = 0; j < message.startupOptions.length; ++j)
                        object.startupOptions[j] = message.startupOptions[j];
                }
                if (message.explicitStartupOptions && message.explicitStartupOptions.length) {
                    object.explicitStartupOptions = [];
                    for (var j = 0; j < message.explicitStartupOptions.length; ++j)
                        object.explicitStartupOptions[j] = message.explicitStartupOptions[j];
                }
                if (message.cmdLine && message.cmdLine.length) {
                    object.cmdLine = [];
                    for (var j = 0; j < message.cmdLine.length; ++j)
                        object.cmdLine[j] = message.cmdLine[j];
                }
                if (message.explicitCmdLine && message.explicitCmdLine.length) {
                    object.explicitCmdLine = [];
                    for (var j = 0; j < message.explicitCmdLine.length; ++j)
                        object.explicitCmdLine[j] = message.explicitCmdLine[j];
                }
                if (message.invocationPolicy != null && message.hasOwnProperty("invocationPolicy"))
                    object.invocationPolicy = $root.blaze.invocation_policy.InvocationPolicy.toObject(message.invocationPolicy, options);
                if (message.toolTag != null && message.hasOwnProperty("toolTag"))
                    object.toolTag = message.toolTag;
                return object;
            };
            /**
             * Converts this OptionsParsed to JSON.
             * @function toJSON
             * @memberof build_event_stream.OptionsParsed
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OptionsParsed.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return OptionsParsed;
        })();
        build_event_stream.Fetch = (function () {
            /**
             * Properties of a Fetch.
             * @memberof build_event_stream
             * @interface IFetch
             * @property {boolean|null} [success] Fetch success
             */
            /**
             * Constructs a new Fetch.
             * @memberof build_event_stream
             * @classdesc Represents a Fetch.
             * @implements IFetch
             * @constructor
             * @param {build_event_stream.IFetch=} [properties] Properties to set
             */
            function Fetch(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Fetch success.
             * @member {boolean} success
             * @memberof build_event_stream.Fetch
             * @instance
             */
            Fetch.prototype.success = false;
            /**
             * Creates a new Fetch instance using the specified properties.
             * @function create
             * @memberof build_event_stream.Fetch
             * @static
             * @param {build_event_stream.IFetch=} [properties] Properties to set
             * @returns {build_event_stream.Fetch} Fetch instance
             */
            Fetch.create = function create(properties) {
                return new Fetch(properties);
            };
            /**
             * Encodes the specified Fetch message. Does not implicitly {@link build_event_stream.Fetch.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.Fetch
             * @static
             * @param {build_event_stream.IFetch} message Fetch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Fetch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.success != null && message.hasOwnProperty("success"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.success);
                return writer;
            };
            /**
             * Encodes the specified Fetch message, length delimited. Does not implicitly {@link build_event_stream.Fetch.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.Fetch
             * @static
             * @param {build_event_stream.IFetch} message Fetch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Fetch.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Fetch message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.Fetch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.Fetch} Fetch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Fetch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.Fetch();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.success = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Fetch message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.Fetch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.Fetch} Fetch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Fetch.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Fetch message.
             * @function verify
             * @memberof build_event_stream.Fetch
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Fetch.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.success != null && message.hasOwnProperty("success"))
                    if (typeof message.success !== "boolean")
                        return "success: boolean expected";
                return null;
            };
            /**
             * Creates a Fetch message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.Fetch
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.Fetch} Fetch
             */
            Fetch.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.Fetch)
                    return object;
                var message = new $root.build_event_stream.Fetch();
                if (object.success != null)
                    message.success = Boolean(object.success);
                return message;
            };
            /**
             * Creates a plain object from a Fetch message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.Fetch
             * @static
             * @param {build_event_stream.Fetch} message Fetch
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Fetch.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.success = false;
                if (message.success != null && message.hasOwnProperty("success"))
                    object.success = message.success;
                return object;
            };
            /**
             * Converts this Fetch to JSON.
             * @function toJSON
             * @memberof build_event_stream.Fetch
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Fetch.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Fetch;
        })();
        build_event_stream.WorkspaceStatus = (function () {
            /**
             * Properties of a WorkspaceStatus.
             * @memberof build_event_stream
             * @interface IWorkspaceStatus
             * @property {Array.<build_event_stream.WorkspaceStatus.IItem>|null} [item] WorkspaceStatus item
             */
            /**
             * Constructs a new WorkspaceStatus.
             * @memberof build_event_stream
             * @classdesc Represents a WorkspaceStatus.
             * @implements IWorkspaceStatus
             * @constructor
             * @param {build_event_stream.IWorkspaceStatus=} [properties] Properties to set
             */
            function WorkspaceStatus(properties) {
                this.item = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * WorkspaceStatus item.
             * @member {Array.<build_event_stream.WorkspaceStatus.IItem>} item
             * @memberof build_event_stream.WorkspaceStatus
             * @instance
             */
            WorkspaceStatus.prototype.item = $util.emptyArray;
            /**
             * Creates a new WorkspaceStatus instance using the specified properties.
             * @function create
             * @memberof build_event_stream.WorkspaceStatus
             * @static
             * @param {build_event_stream.IWorkspaceStatus=} [properties] Properties to set
             * @returns {build_event_stream.WorkspaceStatus} WorkspaceStatus instance
             */
            WorkspaceStatus.create = function create(properties) {
                return new WorkspaceStatus(properties);
            };
            /**
             * Encodes the specified WorkspaceStatus message. Does not implicitly {@link build_event_stream.WorkspaceStatus.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.WorkspaceStatus
             * @static
             * @param {build_event_stream.IWorkspaceStatus} message WorkspaceStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkspaceStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.item != null && message.item.length)
                    for (var i = 0; i < message.item.length; ++i)
                        $root.build_event_stream.WorkspaceStatus.Item.encode(message.item[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified WorkspaceStatus message, length delimited. Does not implicitly {@link build_event_stream.WorkspaceStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.WorkspaceStatus
             * @static
             * @param {build_event_stream.IWorkspaceStatus} message WorkspaceStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorkspaceStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a WorkspaceStatus message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.WorkspaceStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.WorkspaceStatus} WorkspaceStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkspaceStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.WorkspaceStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.item && message.item.length))
                                message.item = [];
                            message.item.push($root.build_event_stream.WorkspaceStatus.Item.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a WorkspaceStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.WorkspaceStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.WorkspaceStatus} WorkspaceStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorkspaceStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a WorkspaceStatus message.
             * @function verify
             * @memberof build_event_stream.WorkspaceStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorkspaceStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.item != null && message.hasOwnProperty("item")) {
                    if (!Array.isArray(message.item))
                        return "item: array expected";
                    for (var i = 0; i < message.item.length; ++i) {
                        var error = $root.build_event_stream.WorkspaceStatus.Item.verify(message.item[i]);
                        if (error)
                            return "item." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a WorkspaceStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.WorkspaceStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.WorkspaceStatus} WorkspaceStatus
             */
            WorkspaceStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.WorkspaceStatus)
                    return object;
                var message = new $root.build_event_stream.WorkspaceStatus();
                if (object.item) {
                    if (!Array.isArray(object.item))
                        throw TypeError(".build_event_stream.WorkspaceStatus.item: array expected");
                    message.item = [];
                    for (var i = 0; i < object.item.length; ++i) {
                        if (typeof object.item[i] !== "object")
                            throw TypeError(".build_event_stream.WorkspaceStatus.item: object expected");
                        message.item[i] = $root.build_event_stream.WorkspaceStatus.Item.fromObject(object.item[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a WorkspaceStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.WorkspaceStatus
             * @static
             * @param {build_event_stream.WorkspaceStatus} message WorkspaceStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WorkspaceStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.item = [];
                if (message.item && message.item.length) {
                    object.item = [];
                    for (var j = 0; j < message.item.length; ++j)
                        object.item[j] = $root.build_event_stream.WorkspaceStatus.Item.toObject(message.item[j], options);
                }
                return object;
            };
            /**
             * Converts this WorkspaceStatus to JSON.
             * @function toJSON
             * @memberof build_event_stream.WorkspaceStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WorkspaceStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            WorkspaceStatus.Item = (function () {
                /**
                 * Properties of an Item.
                 * @memberof build_event_stream.WorkspaceStatus
                 * @interface IItem
                 * @property {string|null} [key] Item key
                 * @property {string|null} [value] Item value
                 */
                /**
                 * Constructs a new Item.
                 * @memberof build_event_stream.WorkspaceStatus
                 * @classdesc Represents an Item.
                 * @implements IItem
                 * @constructor
                 * @param {build_event_stream.WorkspaceStatus.IItem=} [properties] Properties to set
                 */
                function Item(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Item key.
                 * @member {string} key
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @instance
                 */
                Item.prototype.key = "";
                /**
                 * Item value.
                 * @member {string} value
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @instance
                 */
                Item.prototype.value = "";
                /**
                 * Creates a new Item instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @static
                 * @param {build_event_stream.WorkspaceStatus.IItem=} [properties] Properties to set
                 * @returns {build_event_stream.WorkspaceStatus.Item} Item instance
                 */
                Item.create = function create(properties) {
                    return new Item(properties);
                };
                /**
                 * Encodes the specified Item message. Does not implicitly {@link build_event_stream.WorkspaceStatus.Item.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @static
                 * @param {build_event_stream.WorkspaceStatus.IItem} message Item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Item.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && message.hasOwnProperty("key"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
                    return writer;
                };
                /**
                 * Encodes the specified Item message, length delimited. Does not implicitly {@link build_event_stream.WorkspaceStatus.Item.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @static
                 * @param {build_event_stream.WorkspaceStatus.IItem} message Item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Item.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an Item message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.WorkspaceStatus.Item} Item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Item.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.WorkspaceStatus.Item();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.key = reader.string();
                                break;
                            case 2:
                                message.value = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an Item message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.WorkspaceStatus.Item} Item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Item.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an Item message.
                 * @function verify
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Item.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };
                /**
                 * Creates an Item message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.WorkspaceStatus.Item} Item
                 */
                Item.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.WorkspaceStatus.Item)
                        return object;
                    var message = new $root.build_event_stream.WorkspaceStatus.Item();
                    if (object.key != null)
                        message.key = String(object.key);
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };
                /**
                 * Creates a plain object from an Item message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @static
                 * @param {build_event_stream.WorkspaceStatus.Item} message Item
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Item.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.key = "";
                        object.value = "";
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
                /**
                 * Converts this Item to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.WorkspaceStatus.Item
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Item.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return Item;
            })();
            return WorkspaceStatus;
        })();
        build_event_stream.Configuration = (function () {
            /**
             * Properties of a Configuration.
             * @memberof build_event_stream
             * @interface IConfiguration
             * @property {string|null} [mnemonic] Configuration mnemonic
             * @property {string|null} [platformName] Configuration platformName
             * @property {string|null} [cpu] Configuration cpu
             * @property {Object.<string,string>|null} [makeVariable] Configuration makeVariable
             */
            /**
             * Constructs a new Configuration.
             * @memberof build_event_stream
             * @classdesc Represents a Configuration.
             * @implements IConfiguration
             * @constructor
             * @param {build_event_stream.IConfiguration=} [properties] Properties to set
             */
            function Configuration(properties) {
                this.makeVariable = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Configuration mnemonic.
             * @member {string} mnemonic
             * @memberof build_event_stream.Configuration
             * @instance
             */
            Configuration.prototype.mnemonic = "";
            /**
             * Configuration platformName.
             * @member {string} platformName
             * @memberof build_event_stream.Configuration
             * @instance
             */
            Configuration.prototype.platformName = "";
            /**
             * Configuration cpu.
             * @member {string} cpu
             * @memberof build_event_stream.Configuration
             * @instance
             */
            Configuration.prototype.cpu = "";
            /**
             * Configuration makeVariable.
             * @member {Object.<string,string>} makeVariable
             * @memberof build_event_stream.Configuration
             * @instance
             */
            Configuration.prototype.makeVariable = $util.emptyObject;
            /**
             * Creates a new Configuration instance using the specified properties.
             * @function create
             * @memberof build_event_stream.Configuration
             * @static
             * @param {build_event_stream.IConfiguration=} [properties] Properties to set
             * @returns {build_event_stream.Configuration} Configuration instance
             */
            Configuration.create = function create(properties) {
                return new Configuration(properties);
            };
            /**
             * Encodes the specified Configuration message. Does not implicitly {@link build_event_stream.Configuration.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.Configuration
             * @static
             * @param {build_event_stream.IConfiguration} message Configuration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Configuration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.mnemonic);
                if (message.platformName != null && message.hasOwnProperty("platformName"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.platformName);
                if (message.cpu != null && message.hasOwnProperty("cpu"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.cpu);
                if (message.makeVariable != null && message.hasOwnProperty("makeVariable"))
                    for (var keys = Object.keys(message.makeVariable), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/ 34).fork().uint32(/* id 1, wireType 2 =*/ 10).string(keys[i]).uint32(/* id 2, wireType 2 =*/ 18).string(message.makeVariable[keys[i]]).ldelim();
                return writer;
            };
            /**
             * Encodes the specified Configuration message, length delimited. Does not implicitly {@link build_event_stream.Configuration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.Configuration
             * @static
             * @param {build_event_stream.IConfiguration} message Configuration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Configuration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Configuration message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.Configuration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.Configuration} Configuration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Configuration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.Configuration(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.mnemonic = reader.string();
                            break;
                        case 2:
                            message.platformName = reader.string();
                            break;
                        case 3:
                            message.cpu = reader.string();
                            break;
                        case 4:
                            reader.skip().pos++;
                            if (message.makeVariable === $util.emptyObject)
                                message.makeVariable = {};
                            key = reader.string();
                            reader.pos++;
                            message.makeVariable[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Configuration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.Configuration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.Configuration} Configuration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Configuration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Configuration message.
             * @function verify
             * @memberof build_event_stream.Configuration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Configuration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                    if (!$util.isString(message.mnemonic))
                        return "mnemonic: string expected";
                if (message.platformName != null && message.hasOwnProperty("platformName"))
                    if (!$util.isString(message.platformName))
                        return "platformName: string expected";
                if (message.cpu != null && message.hasOwnProperty("cpu"))
                    if (!$util.isString(message.cpu))
                        return "cpu: string expected";
                if (message.makeVariable != null && message.hasOwnProperty("makeVariable")) {
                    if (!$util.isObject(message.makeVariable))
                        return "makeVariable: object expected";
                    var key = Object.keys(message.makeVariable);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.makeVariable[key[i]]))
                            return "makeVariable: string{k:string} expected";
                }
                return null;
            };
            /**
             * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.Configuration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.Configuration} Configuration
             */
            Configuration.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.Configuration)
                    return object;
                var message = new $root.build_event_stream.Configuration();
                if (object.mnemonic != null)
                    message.mnemonic = String(object.mnemonic);
                if (object.platformName != null)
                    message.platformName = String(object.platformName);
                if (object.cpu != null)
                    message.cpu = String(object.cpu);
                if (object.makeVariable) {
                    if (typeof object.makeVariable !== "object")
                        throw TypeError(".build_event_stream.Configuration.makeVariable: object expected");
                    message.makeVariable = {};
                    for (var keys = Object.keys(object.makeVariable), i = 0; i < keys.length; ++i)
                        message.makeVariable[keys[i]] = String(object.makeVariable[keys[i]]);
                }
                return message;
            };
            /**
             * Creates a plain object from a Configuration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.Configuration
             * @static
             * @param {build_event_stream.Configuration} message Configuration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Configuration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.makeVariable = {};
                if (options.defaults) {
                    object.mnemonic = "";
                    object.platformName = "";
                    object.cpu = "";
                }
                if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                    object.mnemonic = message.mnemonic;
                if (message.platformName != null && message.hasOwnProperty("platformName"))
                    object.platformName = message.platformName;
                if (message.cpu != null && message.hasOwnProperty("cpu"))
                    object.cpu = message.cpu;
                var keys2;
                if (message.makeVariable && (keys2 = Object.keys(message.makeVariable)).length) {
                    object.makeVariable = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.makeVariable[keys2[j]] = message.makeVariable[keys2[j]];
                }
                return object;
            };
            /**
             * Converts this Configuration to JSON.
             * @function toJSON
             * @memberof build_event_stream.Configuration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Configuration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Configuration;
        })();
        build_event_stream.PatternExpanded = (function () {
            /**
             * Properties of a PatternExpanded.
             * @memberof build_event_stream
             * @interface IPatternExpanded
             */
            /**
             * Constructs a new PatternExpanded.
             * @memberof build_event_stream
             * @classdesc Represents a PatternExpanded.
             * @implements IPatternExpanded
             * @constructor
             * @param {build_event_stream.IPatternExpanded=} [properties] Properties to set
             */
            function PatternExpanded(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new PatternExpanded instance using the specified properties.
             * @function create
             * @memberof build_event_stream.PatternExpanded
             * @static
             * @param {build_event_stream.IPatternExpanded=} [properties] Properties to set
             * @returns {build_event_stream.PatternExpanded} PatternExpanded instance
             */
            PatternExpanded.create = function create(properties) {
                return new PatternExpanded(properties);
            };
            /**
             * Encodes the specified PatternExpanded message. Does not implicitly {@link build_event_stream.PatternExpanded.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.PatternExpanded
             * @static
             * @param {build_event_stream.IPatternExpanded} message PatternExpanded message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PatternExpanded.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified PatternExpanded message, length delimited. Does not implicitly {@link build_event_stream.PatternExpanded.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.PatternExpanded
             * @static
             * @param {build_event_stream.IPatternExpanded} message PatternExpanded message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PatternExpanded.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PatternExpanded message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.PatternExpanded
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.PatternExpanded} PatternExpanded
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PatternExpanded.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.PatternExpanded();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a PatternExpanded message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.PatternExpanded
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.PatternExpanded} PatternExpanded
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PatternExpanded.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PatternExpanded message.
             * @function verify
             * @memberof build_event_stream.PatternExpanded
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PatternExpanded.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates a PatternExpanded message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.PatternExpanded
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.PatternExpanded} PatternExpanded
             */
            PatternExpanded.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.PatternExpanded)
                    return object;
                return new $root.build_event_stream.PatternExpanded();
            };
            /**
             * Creates a plain object from a PatternExpanded message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.PatternExpanded
             * @static
             * @param {build_event_stream.PatternExpanded} message PatternExpanded
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PatternExpanded.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this PatternExpanded to JSON.
             * @function toJSON
             * @memberof build_event_stream.PatternExpanded
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PatternExpanded.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PatternExpanded;
        })();
        /**
         * TestSize enum.
         * @name build_event_stream.TestSize
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SMALL=1 SMALL value
         * @property {number} MEDIUM=2 MEDIUM value
         * @property {number} LARGE=3 LARGE value
         * @property {number} ENORMOUS=4 ENORMOUS value
         */
        build_event_stream.TestSize = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "SMALL"] = 1;
            values[valuesById[2] = "MEDIUM"] = 2;
            values[valuesById[3] = "LARGE"] = 3;
            values[valuesById[4] = "ENORMOUS"] = 4;
            return values;
        })();
        build_event_stream.TargetConfigured = (function () {
            /**
             * Properties of a TargetConfigured.
             * @memberof build_event_stream
             * @interface ITargetConfigured
             * @property {string|null} [targetKind] TargetConfigured targetKind
             * @property {build_event_stream.TestSize|null} [testSize] TargetConfigured testSize
             * @property {Array.<string>|null} [tag] TargetConfigured tag
             */
            /**
             * Constructs a new TargetConfigured.
             * @memberof build_event_stream
             * @classdesc Represents a TargetConfigured.
             * @implements ITargetConfigured
             * @constructor
             * @param {build_event_stream.ITargetConfigured=} [properties] Properties to set
             */
            function TargetConfigured(properties) {
                this.tag = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * TargetConfigured targetKind.
             * @member {string} targetKind
             * @memberof build_event_stream.TargetConfigured
             * @instance
             */
            TargetConfigured.prototype.targetKind = "";
            /**
             * TargetConfigured testSize.
             * @member {build_event_stream.TestSize} testSize
             * @memberof build_event_stream.TargetConfigured
             * @instance
             */
            TargetConfigured.prototype.testSize = 0;
            /**
             * TargetConfigured tag.
             * @member {Array.<string>} tag
             * @memberof build_event_stream.TargetConfigured
             * @instance
             */
            TargetConfigured.prototype.tag = $util.emptyArray;
            /**
             * Creates a new TargetConfigured instance using the specified properties.
             * @function create
             * @memberof build_event_stream.TargetConfigured
             * @static
             * @param {build_event_stream.ITargetConfigured=} [properties] Properties to set
             * @returns {build_event_stream.TargetConfigured} TargetConfigured instance
             */
            TargetConfigured.create = function create(properties) {
                return new TargetConfigured(properties);
            };
            /**
             * Encodes the specified TargetConfigured message. Does not implicitly {@link build_event_stream.TargetConfigured.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.TargetConfigured
             * @static
             * @param {build_event_stream.ITargetConfigured} message TargetConfigured message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TargetConfigured.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetKind != null && message.hasOwnProperty("targetKind"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.targetKind);
                if (message.testSize != null && message.hasOwnProperty("testSize"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.testSize);
                if (message.tag != null && message.tag.length)
                    for (var i = 0; i < message.tag.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.tag[i]);
                return writer;
            };
            /**
             * Encodes the specified TargetConfigured message, length delimited. Does not implicitly {@link build_event_stream.TargetConfigured.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.TargetConfigured
             * @static
             * @param {build_event_stream.ITargetConfigured} message TargetConfigured message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TargetConfigured.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a TargetConfigured message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.TargetConfigured
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.TargetConfigured} TargetConfigured
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TargetConfigured.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.TargetConfigured();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.targetKind = reader.string();
                            break;
                        case 2:
                            message.testSize = reader.int32();
                            break;
                        case 3:
                            if (!(message.tag && message.tag.length))
                                message.tag = [];
                            message.tag.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a TargetConfigured message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.TargetConfigured
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.TargetConfigured} TargetConfigured
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TargetConfigured.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a TargetConfigured message.
             * @function verify
             * @memberof build_event_stream.TargetConfigured
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TargetConfigured.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetKind != null && message.hasOwnProperty("targetKind"))
                    if (!$util.isString(message.targetKind))
                        return "targetKind: string expected";
                if (message.testSize != null && message.hasOwnProperty("testSize"))
                    switch (message.testSize) {
                        default:
                            return "testSize: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                    }
                if (message.tag != null && message.hasOwnProperty("tag")) {
                    if (!Array.isArray(message.tag))
                        return "tag: array expected";
                    for (var i = 0; i < message.tag.length; ++i)
                        if (!$util.isString(message.tag[i]))
                            return "tag: string[] expected";
                }
                return null;
            };
            /**
             * Creates a TargetConfigured message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.TargetConfigured
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.TargetConfigured} TargetConfigured
             */
            TargetConfigured.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.TargetConfigured)
                    return object;
                var message = new $root.build_event_stream.TargetConfigured();
                if (object.targetKind != null)
                    message.targetKind = String(object.targetKind);
                switch (object.testSize) {
                    case "UNKNOWN":
                    case 0:
                        message.testSize = 0;
                        break;
                    case "SMALL":
                    case 1:
                        message.testSize = 1;
                        break;
                    case "MEDIUM":
                    case 2:
                        message.testSize = 2;
                        break;
                    case "LARGE":
                    case 3:
                        message.testSize = 3;
                        break;
                    case "ENORMOUS":
                    case 4:
                        message.testSize = 4;
                        break;
                }
                if (object.tag) {
                    if (!Array.isArray(object.tag))
                        throw TypeError(".build_event_stream.TargetConfigured.tag: array expected");
                    message.tag = [];
                    for (var i = 0; i < object.tag.length; ++i)
                        message.tag[i] = String(object.tag[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from a TargetConfigured message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.TargetConfigured
             * @static
             * @param {build_event_stream.TargetConfigured} message TargetConfigured
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TargetConfigured.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tag = [];
                if (options.defaults) {
                    object.targetKind = "";
                    object.testSize = options.enums === String ? "UNKNOWN" : 0;
                }
                if (message.targetKind != null && message.hasOwnProperty("targetKind"))
                    object.targetKind = message.targetKind;
                if (message.testSize != null && message.hasOwnProperty("testSize"))
                    object.testSize = options.enums === String ? $root.build_event_stream.TestSize[message.testSize] : message.testSize;
                if (message.tag && message.tag.length) {
                    object.tag = [];
                    for (var j = 0; j < message.tag.length; ++j)
                        object.tag[j] = message.tag[j];
                }
                return object;
            };
            /**
             * Converts this TargetConfigured to JSON.
             * @function toJSON
             * @memberof build_event_stream.TargetConfigured
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TargetConfigured.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return TargetConfigured;
        })();
        build_event_stream.File = (function () {
            /**
             * Properties of a File.
             * @memberof build_event_stream
             * @interface IFile
             * @property {string|null} [name] File name
             * @property {string|null} [uri] File uri
             * @property {Uint8Array|null} [contents] File contents
             */
            /**
             * Constructs a new File.
             * @memberof build_event_stream
             * @classdesc Represents a File.
             * @implements IFile
             * @constructor
             * @param {build_event_stream.IFile=} [properties] Properties to set
             */
            function File(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * File name.
             * @member {string} name
             * @memberof build_event_stream.File
             * @instance
             */
            File.prototype.name = "";
            /**
             * File uri.
             * @member {string} uri
             * @memberof build_event_stream.File
             * @instance
             */
            File.prototype.uri = "";
            /**
             * File contents.
             * @member {Uint8Array} contents
             * @memberof build_event_stream.File
             * @instance
             */
            File.prototype.contents = $util.newBuffer([]);
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
            /**
             * File file.
             * @member {"uri"|"contents"|undefined} file
             * @memberof build_event_stream.File
             * @instance
             */
            Object.defineProperty(File.prototype, "file", {
                get: $util.oneOfGetter($oneOfFields = ["uri", "contents"]),
                set: $util.oneOfSetter($oneOfFields)
            });
            /**
             * Creates a new File instance using the specified properties.
             * @function create
             * @memberof build_event_stream.File
             * @static
             * @param {build_event_stream.IFile=} [properties] Properties to set
             * @returns {build_event_stream.File} File instance
             */
            File.create = function create(properties) {
                return new File(properties);
            };
            /**
             * Encodes the specified File message. Does not implicitly {@link build_event_stream.File.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.File
             * @static
             * @param {build_event_stream.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                if (message.uri != null && message.hasOwnProperty("uri"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.uri);
                if (message.contents != null && message.hasOwnProperty("contents"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.contents);
                return writer;
            };
            /**
             * Encodes the specified File message, length delimited. Does not implicitly {@link build_event_stream.File.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.File
             * @static
             * @param {build_event_stream.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a File message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.File();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.uri = reader.string();
                            break;
                        case 3:
                            message.contents = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a File message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a File message.
             * @function verify
             * @memberof build_event_stream.File
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            File.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.uri != null && message.hasOwnProperty("uri")) {
                    properties.file = 1;
                    if (!$util.isString(message.uri))
                        return "uri: string expected";
                }
                if (message.contents != null && message.hasOwnProperty("contents")) {
                    if (properties.file === 1)
                        return "file: multiple values";
                    properties.file = 1;
                    if (!(message.contents && typeof message.contents.length === "number" || $util.isString(message.contents)))
                        return "contents: buffer expected";
                }
                return null;
            };
            /**
             * Creates a File message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.File
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.File} File
             */
            File.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.File)
                    return object;
                var message = new $root.build_event_stream.File();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.uri != null)
                    message.uri = String(object.uri);
                if (object.contents != null)
                    if (typeof object.contents === "string")
                        $util.base64.decode(object.contents, message.contents = $util.newBuffer($util.base64.length(object.contents)), 0);
                    else if (object.contents.length)
                        message.contents = object.contents;
                return message;
            };
            /**
             * Creates a plain object from a File message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.File
             * @static
             * @param {build_event_stream.File} message File
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            File.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.uri != null && message.hasOwnProperty("uri")) {
                    object.uri = message.uri;
                    if (options.oneofs)
                        object.file = "uri";
                }
                if (message.contents != null && message.hasOwnProperty("contents")) {
                    object.contents = options.bytes === String ? $util.base64.encode(message.contents, 0, message.contents.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents) : message.contents;
                    if (options.oneofs)
                        object.file = "contents";
                }
                return object;
            };
            /**
             * Converts this File to JSON.
             * @function toJSON
             * @memberof build_event_stream.File
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            File.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return File;
        })();
        build_event_stream.NamedSetOfFiles = (function () {
            /**
             * Properties of a NamedSetOfFiles.
             * @memberof build_event_stream
             * @interface INamedSetOfFiles
             * @property {Array.<build_event_stream.IFile>|null} [files] NamedSetOfFiles files
             * @property {Array.<build_event_stream.BuildEventId.INamedSetOfFilesId>|null} [fileSets] NamedSetOfFiles fileSets
             */
            /**
             * Constructs a new NamedSetOfFiles.
             * @memberof build_event_stream
             * @classdesc Represents a NamedSetOfFiles.
             * @implements INamedSetOfFiles
             * @constructor
             * @param {build_event_stream.INamedSetOfFiles=} [properties] Properties to set
             */
            function NamedSetOfFiles(properties) {
                this.files = [];
                this.fileSets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * NamedSetOfFiles files.
             * @member {Array.<build_event_stream.IFile>} files
             * @memberof build_event_stream.NamedSetOfFiles
             * @instance
             */
            NamedSetOfFiles.prototype.files = $util.emptyArray;
            /**
             * NamedSetOfFiles fileSets.
             * @member {Array.<build_event_stream.BuildEventId.INamedSetOfFilesId>} fileSets
             * @memberof build_event_stream.NamedSetOfFiles
             * @instance
             */
            NamedSetOfFiles.prototype.fileSets = $util.emptyArray;
            /**
             * Creates a new NamedSetOfFiles instance using the specified properties.
             * @function create
             * @memberof build_event_stream.NamedSetOfFiles
             * @static
             * @param {build_event_stream.INamedSetOfFiles=} [properties] Properties to set
             * @returns {build_event_stream.NamedSetOfFiles} NamedSetOfFiles instance
             */
            NamedSetOfFiles.create = function create(properties) {
                return new NamedSetOfFiles(properties);
            };
            /**
             * Encodes the specified NamedSetOfFiles message. Does not implicitly {@link build_event_stream.NamedSetOfFiles.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.NamedSetOfFiles
             * @static
             * @param {build_event_stream.INamedSetOfFiles} message NamedSetOfFiles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedSetOfFiles.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (var i = 0; i < message.files.length; ++i)
                        $root.build_event_stream.File.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                if (message.fileSets != null && message.fileSets.length)
                    for (var i = 0; i < message.fileSets.length; ++i)
                        $root.build_event_stream.BuildEventId.NamedSetOfFilesId.encode(message.fileSets[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified NamedSetOfFiles message, length delimited. Does not implicitly {@link build_event_stream.NamedSetOfFiles.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.NamedSetOfFiles
             * @static
             * @param {build_event_stream.INamedSetOfFiles} message NamedSetOfFiles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedSetOfFiles.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a NamedSetOfFiles message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.NamedSetOfFiles
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.NamedSetOfFiles} NamedSetOfFiles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedSetOfFiles.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.NamedSetOfFiles();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push($root.build_event_stream.File.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.fileSets && message.fileSets.length))
                                message.fileSets = [];
                            message.fileSets.push($root.build_event_stream.BuildEventId.NamedSetOfFilesId.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a NamedSetOfFiles message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.NamedSetOfFiles
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.NamedSetOfFiles} NamedSetOfFiles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedSetOfFiles.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a NamedSetOfFiles message.
             * @function verify
             * @memberof build_event_stream.NamedSetOfFiles
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedSetOfFiles.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (var i = 0; i < message.files.length; ++i) {
                        var error = $root.build_event_stream.File.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                if (message.fileSets != null && message.hasOwnProperty("fileSets")) {
                    if (!Array.isArray(message.fileSets))
                        return "fileSets: array expected";
                    for (var i = 0; i < message.fileSets.length; ++i) {
                        var error = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.verify(message.fileSets[i]);
                        if (error)
                            return "fileSets." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a NamedSetOfFiles message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.NamedSetOfFiles
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.NamedSetOfFiles} NamedSetOfFiles
             */
            NamedSetOfFiles.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.NamedSetOfFiles)
                    return object;
                var message = new $root.build_event_stream.NamedSetOfFiles();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".build_event_stream.NamedSetOfFiles.files: array expected");
                    message.files = [];
                    for (var i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".build_event_stream.NamedSetOfFiles.files: object expected");
                        message.files[i] = $root.build_event_stream.File.fromObject(object.files[i]);
                    }
                }
                if (object.fileSets) {
                    if (!Array.isArray(object.fileSets))
                        throw TypeError(".build_event_stream.NamedSetOfFiles.fileSets: array expected");
                    message.fileSets = [];
                    for (var i = 0; i < object.fileSets.length; ++i) {
                        if (typeof object.fileSets[i] !== "object")
                            throw TypeError(".build_event_stream.NamedSetOfFiles.fileSets: object expected");
                        message.fileSets[i] = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.fromObject(object.fileSets[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a NamedSetOfFiles message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.NamedSetOfFiles
             * @static
             * @param {build_event_stream.NamedSetOfFiles} message NamedSetOfFiles
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NamedSetOfFiles.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.files = [];
                    object.fileSets = [];
                }
                if (message.files && message.files.length) {
                    object.files = [];
                    for (var j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.build_event_stream.File.toObject(message.files[j], options);
                }
                if (message.fileSets && message.fileSets.length) {
                    object.fileSets = [];
                    for (var j = 0; j < message.fileSets.length; ++j)
                        object.fileSets[j] = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.toObject(message.fileSets[j], options);
                }
                return object;
            };
            /**
             * Converts this NamedSetOfFiles to JSON.
             * @function toJSON
             * @memberof build_event_stream.NamedSetOfFiles
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NamedSetOfFiles.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return NamedSetOfFiles;
        })();
        build_event_stream.ActionExecuted = (function () {
            /**
             * Properties of an ActionExecuted.
             * @memberof build_event_stream
             * @interface IActionExecuted
             * @property {boolean|null} [success] ActionExecuted success
             * @property {string|null} [type] ActionExecuted type
             * @property {number|null} [exitCode] ActionExecuted exitCode
             * @property {build_event_stream.IFile|null} [stdout] ActionExecuted stdout
             * @property {build_event_stream.IFile|null} [stderr] ActionExecuted stderr
             * @property {string|null} [label] ActionExecuted label
             * @property {build_event_stream.BuildEventId.IConfigurationId|null} [configuration] ActionExecuted configuration
             * @property {build_event_stream.IFile|null} [primaryOutput] ActionExecuted primaryOutput
             * @property {Array.<string>|null} [commandLine] ActionExecuted commandLine
             */
            /**
             * Constructs a new ActionExecuted.
             * @memberof build_event_stream
             * @classdesc Represents an ActionExecuted.
             * @implements IActionExecuted
             * @constructor
             * @param {build_event_stream.IActionExecuted=} [properties] Properties to set
             */
            function ActionExecuted(properties) {
                this.commandLine = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ActionExecuted success.
             * @member {boolean} success
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.success = false;
            /**
             * ActionExecuted type.
             * @member {string} type
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.type = "";
            /**
             * ActionExecuted exitCode.
             * @member {number} exitCode
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.exitCode = 0;
            /**
             * ActionExecuted stdout.
             * @member {build_event_stream.IFile|null|undefined} stdout
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.stdout = null;
            /**
             * ActionExecuted stderr.
             * @member {build_event_stream.IFile|null|undefined} stderr
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.stderr = null;
            /**
             * ActionExecuted label.
             * @member {string} label
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.label = "";
            /**
             * ActionExecuted configuration.
             * @member {build_event_stream.BuildEventId.IConfigurationId|null|undefined} configuration
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.configuration = null;
            /**
             * ActionExecuted primaryOutput.
             * @member {build_event_stream.IFile|null|undefined} primaryOutput
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.primaryOutput = null;
            /**
             * ActionExecuted commandLine.
             * @member {Array.<string>} commandLine
             * @memberof build_event_stream.ActionExecuted
             * @instance
             */
            ActionExecuted.prototype.commandLine = $util.emptyArray;
            /**
             * Creates a new ActionExecuted instance using the specified properties.
             * @function create
             * @memberof build_event_stream.ActionExecuted
             * @static
             * @param {build_event_stream.IActionExecuted=} [properties] Properties to set
             * @returns {build_event_stream.ActionExecuted} ActionExecuted instance
             */
            ActionExecuted.create = function create(properties) {
                return new ActionExecuted(properties);
            };
            /**
             * Encodes the specified ActionExecuted message. Does not implicitly {@link build_event_stream.ActionExecuted.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.ActionExecuted
             * @static
             * @param {build_event_stream.IActionExecuted} message ActionExecuted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActionExecuted.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.success != null && message.hasOwnProperty("success"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.success);
                if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.exitCode);
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    $root.build_event_stream.File.encode(message.stdout, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                if (message.stderr != null && message.hasOwnProperty("stderr"))
                    $root.build_event_stream.File.encode(message.stderr, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.label);
                if (message.primaryOutput != null && message.hasOwnProperty("primaryOutput"))
                    $root.build_event_stream.File.encode(message.primaryOutput, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
                if (message.configuration != null && message.hasOwnProperty("configuration"))
                    $root.build_event_stream.BuildEventId.ConfigurationId.encode(message.configuration, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.type);
                if (message.commandLine != null && message.commandLine.length)
                    for (var i = 0; i < message.commandLine.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.commandLine[i]);
                return writer;
            };
            /**
             * Encodes the specified ActionExecuted message, length delimited. Does not implicitly {@link build_event_stream.ActionExecuted.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.ActionExecuted
             * @static
             * @param {build_event_stream.IActionExecuted} message ActionExecuted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActionExecuted.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an ActionExecuted message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.ActionExecuted
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.ActionExecuted} ActionExecuted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActionExecuted.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.ActionExecuted();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.success = reader.bool();
                            break;
                        case 8:
                            message.type = reader.string();
                            break;
                        case 2:
                            message.exitCode = reader.int32();
                            break;
                        case 3:
                            message.stdout = $root.build_event_stream.File.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.stderr = $root.build_event_stream.File.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.label = reader.string();
                            break;
                        case 7:
                            message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.primaryOutput = $root.build_event_stream.File.decode(reader, reader.uint32());
                            break;
                        case 9:
                            if (!(message.commandLine && message.commandLine.length))
                                message.commandLine = [];
                            message.commandLine.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an ActionExecuted message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.ActionExecuted
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.ActionExecuted} ActionExecuted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActionExecuted.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an ActionExecuted message.
             * @function verify
             * @memberof build_event_stream.ActionExecuted
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActionExecuted.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.success != null && message.hasOwnProperty("success"))
                    if (typeof message.success !== "boolean")
                        return "success: boolean expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                    if (!$util.isInteger(message.exitCode))
                        return "exitCode: integer expected";
                if (message.stdout != null && message.hasOwnProperty("stdout")) {
                    var error = $root.build_event_stream.File.verify(message.stdout);
                    if (error)
                        return "stdout." + error;
                }
                if (message.stderr != null && message.hasOwnProperty("stderr")) {
                    var error = $root.build_event_stream.File.verify(message.stderr);
                    if (error)
                        return "stderr." + error;
                }
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.configuration != null && message.hasOwnProperty("configuration")) {
                    var error = $root.build_event_stream.BuildEventId.ConfigurationId.verify(message.configuration);
                    if (error)
                        return "configuration." + error;
                }
                if (message.primaryOutput != null && message.hasOwnProperty("primaryOutput")) {
                    var error = $root.build_event_stream.File.verify(message.primaryOutput);
                    if (error)
                        return "primaryOutput." + error;
                }
                if (message.commandLine != null && message.hasOwnProperty("commandLine")) {
                    if (!Array.isArray(message.commandLine))
                        return "commandLine: array expected";
                    for (var i = 0; i < message.commandLine.length; ++i)
                        if (!$util.isString(message.commandLine[i]))
                            return "commandLine: string[] expected";
                }
                return null;
            };
            /**
             * Creates an ActionExecuted message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.ActionExecuted
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.ActionExecuted} ActionExecuted
             */
            ActionExecuted.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.ActionExecuted)
                    return object;
                var message = new $root.build_event_stream.ActionExecuted();
                if (object.success != null)
                    message.success = Boolean(object.success);
                if (object.type != null)
                    message.type = String(object.type);
                if (object.exitCode != null)
                    message.exitCode = object.exitCode | 0;
                if (object.stdout != null) {
                    if (typeof object.stdout !== "object")
                        throw TypeError(".build_event_stream.ActionExecuted.stdout: object expected");
                    message.stdout = $root.build_event_stream.File.fromObject(object.stdout);
                }
                if (object.stderr != null) {
                    if (typeof object.stderr !== "object")
                        throw TypeError(".build_event_stream.ActionExecuted.stderr: object expected");
                    message.stderr = $root.build_event_stream.File.fromObject(object.stderr);
                }
                if (object.label != null)
                    message.label = String(object.label);
                if (object.configuration != null) {
                    if (typeof object.configuration !== "object")
                        throw TypeError(".build_event_stream.ActionExecuted.configuration: object expected");
                    message.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.fromObject(object.configuration);
                }
                if (object.primaryOutput != null) {
                    if (typeof object.primaryOutput !== "object")
                        throw TypeError(".build_event_stream.ActionExecuted.primaryOutput: object expected");
                    message.primaryOutput = $root.build_event_stream.File.fromObject(object.primaryOutput);
                }
                if (object.commandLine) {
                    if (!Array.isArray(object.commandLine))
                        throw TypeError(".build_event_stream.ActionExecuted.commandLine: array expected");
                    message.commandLine = [];
                    for (var i = 0; i < object.commandLine.length; ++i)
                        message.commandLine[i] = String(object.commandLine[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from an ActionExecuted message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.ActionExecuted
             * @static
             * @param {build_event_stream.ActionExecuted} message ActionExecuted
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActionExecuted.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.commandLine = [];
                if (options.defaults) {
                    object.success = false;
                    object.exitCode = 0;
                    object.stdout = null;
                    object.stderr = null;
                    object.label = "";
                    object.primaryOutput = null;
                    object.configuration = null;
                    object.type = "";
                }
                if (message.success != null && message.hasOwnProperty("success"))
                    object.success = message.success;
                if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                    object.exitCode = message.exitCode;
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    object.stdout = $root.build_event_stream.File.toObject(message.stdout, options);
                if (message.stderr != null && message.hasOwnProperty("stderr"))
                    object.stderr = $root.build_event_stream.File.toObject(message.stderr, options);
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.primaryOutput != null && message.hasOwnProperty("primaryOutput"))
                    object.primaryOutput = $root.build_event_stream.File.toObject(message.primaryOutput, options);
                if (message.configuration != null && message.hasOwnProperty("configuration"))
                    object.configuration = $root.build_event_stream.BuildEventId.ConfigurationId.toObject(message.configuration, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.commandLine && message.commandLine.length) {
                    object.commandLine = [];
                    for (var j = 0; j < message.commandLine.length; ++j)
                        object.commandLine[j] = message.commandLine[j];
                }
                return object;
            };
            /**
             * Converts this ActionExecuted to JSON.
             * @function toJSON
             * @memberof build_event_stream.ActionExecuted
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActionExecuted.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ActionExecuted;
        })();
        build_event_stream.OutputGroup = (function () {
            /**
             * Properties of an OutputGroup.
             * @memberof build_event_stream
             * @interface IOutputGroup
             * @property {string|null} [name] OutputGroup name
             * @property {Array.<build_event_stream.BuildEventId.INamedSetOfFilesId>|null} [fileSets] OutputGroup fileSets
             */
            /**
             * Constructs a new OutputGroup.
             * @memberof build_event_stream
             * @classdesc Represents an OutputGroup.
             * @implements IOutputGroup
             * @constructor
             * @param {build_event_stream.IOutputGroup=} [properties] Properties to set
             */
            function OutputGroup(properties) {
                this.fileSets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OutputGroup name.
             * @member {string} name
             * @memberof build_event_stream.OutputGroup
             * @instance
             */
            OutputGroup.prototype.name = "";
            /**
             * OutputGroup fileSets.
             * @member {Array.<build_event_stream.BuildEventId.INamedSetOfFilesId>} fileSets
             * @memberof build_event_stream.OutputGroup
             * @instance
             */
            OutputGroup.prototype.fileSets = $util.emptyArray;
            /**
             * Creates a new OutputGroup instance using the specified properties.
             * @function create
             * @memberof build_event_stream.OutputGroup
             * @static
             * @param {build_event_stream.IOutputGroup=} [properties] Properties to set
             * @returns {build_event_stream.OutputGroup} OutputGroup instance
             */
            OutputGroup.create = function create(properties) {
                return new OutputGroup(properties);
            };
            /**
             * Encodes the specified OutputGroup message. Does not implicitly {@link build_event_stream.OutputGroup.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.OutputGroup
             * @static
             * @param {build_event_stream.IOutputGroup} message OutputGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutputGroup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                if (message.fileSets != null && message.fileSets.length)
                    for (var i = 0; i < message.fileSets.length; ++i)
                        $root.build_event_stream.BuildEventId.NamedSetOfFilesId.encode(message.fileSets[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified OutputGroup message, length delimited. Does not implicitly {@link build_event_stream.OutputGroup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.OutputGroup
             * @static
             * @param {build_event_stream.IOutputGroup} message OutputGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutputGroup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an OutputGroup message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.OutputGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.OutputGroup} OutputGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutputGroup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.OutputGroup();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            if (!(message.fileSets && message.fileSets.length))
                                message.fileSets = [];
                            message.fileSets.push($root.build_event_stream.BuildEventId.NamedSetOfFilesId.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an OutputGroup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.OutputGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.OutputGroup} OutputGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutputGroup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an OutputGroup message.
             * @function verify
             * @memberof build_event_stream.OutputGroup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OutputGroup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.fileSets != null && message.hasOwnProperty("fileSets")) {
                    if (!Array.isArray(message.fileSets))
                        return "fileSets: array expected";
                    for (var i = 0; i < message.fileSets.length; ++i) {
                        var error = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.verify(message.fileSets[i]);
                        if (error)
                            return "fileSets." + error;
                    }
                }
                return null;
            };
            /**
             * Creates an OutputGroup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.OutputGroup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.OutputGroup} OutputGroup
             */
            OutputGroup.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.OutputGroup)
                    return object;
                var message = new $root.build_event_stream.OutputGroup();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.fileSets) {
                    if (!Array.isArray(object.fileSets))
                        throw TypeError(".build_event_stream.OutputGroup.fileSets: array expected");
                    message.fileSets = [];
                    for (var i = 0; i < object.fileSets.length; ++i) {
                        if (typeof object.fileSets[i] !== "object")
                            throw TypeError(".build_event_stream.OutputGroup.fileSets: object expected");
                        message.fileSets[i] = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.fromObject(object.fileSets[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from an OutputGroup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.OutputGroup
             * @static
             * @param {build_event_stream.OutputGroup} message OutputGroup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OutputGroup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fileSets = [];
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.fileSets && message.fileSets.length) {
                    object.fileSets = [];
                    for (var j = 0; j < message.fileSets.length; ++j)
                        object.fileSets[j] = $root.build_event_stream.BuildEventId.NamedSetOfFilesId.toObject(message.fileSets[j], options);
                }
                return object;
            };
            /**
             * Converts this OutputGroup to JSON.
             * @function toJSON
             * @memberof build_event_stream.OutputGroup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OutputGroup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return OutputGroup;
        })();
        build_event_stream.TargetComplete = (function () {
            /**
             * Properties of a TargetComplete.
             * @memberof build_event_stream
             * @interface ITargetComplete
             * @property {boolean|null} [success] TargetComplete success
             * @property {string|null} [targetKind] TargetComplete targetKind
             * @property {build_event_stream.TestSize|null} [testSize] TargetComplete testSize
             * @property {Array.<build_event_stream.IOutputGroup>|null} [outputGroup] TargetComplete outputGroup
             * @property {Array.<build_event_stream.IFile>|null} [importantOutput] TargetComplete importantOutput
             * @property {Array.<string>|null} [tag] TargetComplete tag
             * @property {number|Long|null} [testTimeoutSeconds] TargetComplete testTimeoutSeconds
             */
            /**
             * Constructs a new TargetComplete.
             * @memberof build_event_stream
             * @classdesc Represents a TargetComplete.
             * @implements ITargetComplete
             * @constructor
             * @param {build_event_stream.ITargetComplete=} [properties] Properties to set
             */
            function TargetComplete(properties) {
                this.outputGroup = [];
                this.importantOutput = [];
                this.tag = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * TargetComplete success.
             * @member {boolean} success
             * @memberof build_event_stream.TargetComplete
             * @instance
             */
            TargetComplete.prototype.success = false;
            /**
             * TargetComplete targetKind.
             * @member {string} targetKind
             * @memberof build_event_stream.TargetComplete
             * @instance
             */
            TargetComplete.prototype.targetKind = "";
            /**
             * TargetComplete testSize.
             * @member {build_event_stream.TestSize} testSize
             * @memberof build_event_stream.TargetComplete
             * @instance
             */
            TargetComplete.prototype.testSize = 0;
            /**
             * TargetComplete outputGroup.
             * @member {Array.<build_event_stream.IOutputGroup>} outputGroup
             * @memberof build_event_stream.TargetComplete
             * @instance
             */
            TargetComplete.prototype.outputGroup = $util.emptyArray;
            /**
             * TargetComplete importantOutput.
             * @member {Array.<build_event_stream.IFile>} importantOutput
             * @memberof build_event_stream.TargetComplete
             * @instance
             */
            TargetComplete.prototype.importantOutput = $util.emptyArray;
            /**
             * TargetComplete tag.
             * @member {Array.<string>} tag
             * @memberof build_event_stream.TargetComplete
             * @instance
             */
            TargetComplete.prototype.tag = $util.emptyArray;
            /**
             * TargetComplete testTimeoutSeconds.
             * @member {number|Long} testTimeoutSeconds
             * @memberof build_event_stream.TargetComplete
             * @instance
             */
            TargetComplete.prototype.testTimeoutSeconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new TargetComplete instance using the specified properties.
             * @function create
             * @memberof build_event_stream.TargetComplete
             * @static
             * @param {build_event_stream.ITargetComplete=} [properties] Properties to set
             * @returns {build_event_stream.TargetComplete} TargetComplete instance
             */
            TargetComplete.create = function create(properties) {
                return new TargetComplete(properties);
            };
            /**
             * Encodes the specified TargetComplete message. Does not implicitly {@link build_event_stream.TargetComplete.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.TargetComplete
             * @static
             * @param {build_event_stream.ITargetComplete} message TargetComplete message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TargetComplete.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.success != null && message.hasOwnProperty("success"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.success);
                if (message.outputGroup != null && message.outputGroup.length)
                    for (var i = 0; i < message.outputGroup.length; ++i)
                        $root.build_event_stream.OutputGroup.encode(message.outputGroup[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.tag != null && message.tag.length)
                    for (var i = 0; i < message.tag.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.tag[i]);
                if (message.importantOutput != null && message.importantOutput.length)
                    for (var i = 0; i < message.importantOutput.length; ++i)
                        $root.build_event_stream.File.encode(message.importantOutput[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.targetKind != null && message.hasOwnProperty("targetKind"))
                    writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.targetKind);
                if (message.testSize != null && message.hasOwnProperty("testSize"))
                    writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.testSize);
                if (message.testTimeoutSeconds != null && message.hasOwnProperty("testTimeoutSeconds"))
                    writer.uint32(/* id 7, wireType 0 =*/ 56).int64(message.testTimeoutSeconds);
                return writer;
            };
            /**
             * Encodes the specified TargetComplete message, length delimited. Does not implicitly {@link build_event_stream.TargetComplete.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.TargetComplete
             * @static
             * @param {build_event_stream.ITargetComplete} message TargetComplete message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TargetComplete.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a TargetComplete message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.TargetComplete
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.TargetComplete} TargetComplete
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TargetComplete.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.TargetComplete();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.success = reader.bool();
                            break;
                        case 5:
                            message.targetKind = reader.string();
                            break;
                        case 6:
                            message.testSize = reader.int32();
                            break;
                        case 2:
                            if (!(message.outputGroup && message.outputGroup.length))
                                message.outputGroup = [];
                            message.outputGroup.push($root.build_event_stream.OutputGroup.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.importantOutput && message.importantOutput.length))
                                message.importantOutput = [];
                            message.importantOutput.push($root.build_event_stream.File.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.tag && message.tag.length))
                                message.tag = [];
                            message.tag.push(reader.string());
                            break;
                        case 7:
                            message.testTimeoutSeconds = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a TargetComplete message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.TargetComplete
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.TargetComplete} TargetComplete
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TargetComplete.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a TargetComplete message.
             * @function verify
             * @memberof build_event_stream.TargetComplete
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TargetComplete.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.success != null && message.hasOwnProperty("success"))
                    if (typeof message.success !== "boolean")
                        return "success: boolean expected";
                if (message.targetKind != null && message.hasOwnProperty("targetKind"))
                    if (!$util.isString(message.targetKind))
                        return "targetKind: string expected";
                if (message.testSize != null && message.hasOwnProperty("testSize"))
                    switch (message.testSize) {
                        default:
                            return "testSize: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                    }
                if (message.outputGroup != null && message.hasOwnProperty("outputGroup")) {
                    if (!Array.isArray(message.outputGroup))
                        return "outputGroup: array expected";
                    for (var i = 0; i < message.outputGroup.length; ++i) {
                        var error = $root.build_event_stream.OutputGroup.verify(message.outputGroup[i]);
                        if (error)
                            return "outputGroup." + error;
                    }
                }
                if (message.importantOutput != null && message.hasOwnProperty("importantOutput")) {
                    if (!Array.isArray(message.importantOutput))
                        return "importantOutput: array expected";
                    for (var i = 0; i < message.importantOutput.length; ++i) {
                        var error = $root.build_event_stream.File.verify(message.importantOutput[i]);
                        if (error)
                            return "importantOutput." + error;
                    }
                }
                if (message.tag != null && message.hasOwnProperty("tag")) {
                    if (!Array.isArray(message.tag))
                        return "tag: array expected";
                    for (var i = 0; i < message.tag.length; ++i)
                        if (!$util.isString(message.tag[i]))
                            return "tag: string[] expected";
                }
                if (message.testTimeoutSeconds != null && message.hasOwnProperty("testTimeoutSeconds"))
                    if (!$util.isInteger(message.testTimeoutSeconds) && !(message.testTimeoutSeconds && $util.isInteger(message.testTimeoutSeconds.low) && $util.isInteger(message.testTimeoutSeconds.high)))
                        return "testTimeoutSeconds: integer|Long expected";
                return null;
            };
            /**
             * Creates a TargetComplete message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.TargetComplete
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.TargetComplete} TargetComplete
             */
            TargetComplete.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.TargetComplete)
                    return object;
                var message = new $root.build_event_stream.TargetComplete();
                if (object.success != null)
                    message.success = Boolean(object.success);
                if (object.targetKind != null)
                    message.targetKind = String(object.targetKind);
                switch (object.testSize) {
                    case "UNKNOWN":
                    case 0:
                        message.testSize = 0;
                        break;
                    case "SMALL":
                    case 1:
                        message.testSize = 1;
                        break;
                    case "MEDIUM":
                    case 2:
                        message.testSize = 2;
                        break;
                    case "LARGE":
                    case 3:
                        message.testSize = 3;
                        break;
                    case "ENORMOUS":
                    case 4:
                        message.testSize = 4;
                        break;
                }
                if (object.outputGroup) {
                    if (!Array.isArray(object.outputGroup))
                        throw TypeError(".build_event_stream.TargetComplete.outputGroup: array expected");
                    message.outputGroup = [];
                    for (var i = 0; i < object.outputGroup.length; ++i) {
                        if (typeof object.outputGroup[i] !== "object")
                            throw TypeError(".build_event_stream.TargetComplete.outputGroup: object expected");
                        message.outputGroup[i] = $root.build_event_stream.OutputGroup.fromObject(object.outputGroup[i]);
                    }
                }
                if (object.importantOutput) {
                    if (!Array.isArray(object.importantOutput))
                        throw TypeError(".build_event_stream.TargetComplete.importantOutput: array expected");
                    message.importantOutput = [];
                    for (var i = 0; i < object.importantOutput.length; ++i) {
                        if (typeof object.importantOutput[i] !== "object")
                            throw TypeError(".build_event_stream.TargetComplete.importantOutput: object expected");
                        message.importantOutput[i] = $root.build_event_stream.File.fromObject(object.importantOutput[i]);
                    }
                }
                if (object.tag) {
                    if (!Array.isArray(object.tag))
                        throw TypeError(".build_event_stream.TargetComplete.tag: array expected");
                    message.tag = [];
                    for (var i = 0; i < object.tag.length; ++i)
                        message.tag[i] = String(object.tag[i]);
                }
                if (object.testTimeoutSeconds != null)
                    if ($util.Long)
                        (message.testTimeoutSeconds = $util.Long.fromValue(object.testTimeoutSeconds)).unsigned = false;
                    else if (typeof object.testTimeoutSeconds === "string")
                        message.testTimeoutSeconds = parseInt(object.testTimeoutSeconds, 10);
                    else if (typeof object.testTimeoutSeconds === "number")
                        message.testTimeoutSeconds = object.testTimeoutSeconds;
                    else if (typeof object.testTimeoutSeconds === "object")
                        message.testTimeoutSeconds = new $util.LongBits(object.testTimeoutSeconds.low >>> 0, object.testTimeoutSeconds.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from a TargetComplete message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.TargetComplete
             * @static
             * @param {build_event_stream.TargetComplete} message TargetComplete
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TargetComplete.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.outputGroup = [];
                    object.tag = [];
                    object.importantOutput = [];
                }
                if (options.defaults) {
                    object.success = false;
                    object.targetKind = "";
                    object.testSize = options.enums === String ? "UNKNOWN" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.testTimeoutSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.testTimeoutSeconds = options.longs === String ? "0" : 0;
                }
                if (message.success != null && message.hasOwnProperty("success"))
                    object.success = message.success;
                if (message.outputGroup && message.outputGroup.length) {
                    object.outputGroup = [];
                    for (var j = 0; j < message.outputGroup.length; ++j)
                        object.outputGroup[j] = $root.build_event_stream.OutputGroup.toObject(message.outputGroup[j], options);
                }
                if (message.tag && message.tag.length) {
                    object.tag = [];
                    for (var j = 0; j < message.tag.length; ++j)
                        object.tag[j] = message.tag[j];
                }
                if (message.importantOutput && message.importantOutput.length) {
                    object.importantOutput = [];
                    for (var j = 0; j < message.importantOutput.length; ++j)
                        object.importantOutput[j] = $root.build_event_stream.File.toObject(message.importantOutput[j], options);
                }
                if (message.targetKind != null && message.hasOwnProperty("targetKind"))
                    object.targetKind = message.targetKind;
                if (message.testSize != null && message.hasOwnProperty("testSize"))
                    object.testSize = options.enums === String ? $root.build_event_stream.TestSize[message.testSize] : message.testSize;
                if (message.testTimeoutSeconds != null && message.hasOwnProperty("testTimeoutSeconds"))
                    if (typeof message.testTimeoutSeconds === "number")
                        object.testTimeoutSeconds = options.longs === String ? String(message.testTimeoutSeconds) : message.testTimeoutSeconds;
                    else
                        object.testTimeoutSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.testTimeoutSeconds) : options.longs === Number ? new $util.LongBits(message.testTimeoutSeconds.low >>> 0, message.testTimeoutSeconds.high >>> 0).toNumber() : message.testTimeoutSeconds;
                return object;
            };
            /**
             * Converts this TargetComplete to JSON.
             * @function toJSON
             * @memberof build_event_stream.TargetComplete
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TargetComplete.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return TargetComplete;
        })();
        /**
         * TestStatus enum.
         * @name build_event_stream.TestStatus
         * @enum {string}
         * @property {number} NO_STATUS=0 NO_STATUS value
         * @property {number} PASSED=1 PASSED value
         * @property {number} FLAKY=2 FLAKY value
         * @property {number} TIMEOUT=3 TIMEOUT value
         * @property {number} FAILED=4 FAILED value
         * @property {number} INCOMPLETE=5 INCOMPLETE value
         * @property {number} REMOTE_FAILURE=6 REMOTE_FAILURE value
         * @property {number} FAILED_TO_BUILD=7 FAILED_TO_BUILD value
         * @property {number} TOOL_HALTED_BEFORE_TESTING=8 TOOL_HALTED_BEFORE_TESTING value
         */
        build_event_stream.TestStatus = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NO_STATUS"] = 0;
            values[valuesById[1] = "PASSED"] = 1;
            values[valuesById[2] = "FLAKY"] = 2;
            values[valuesById[3] = "TIMEOUT"] = 3;
            values[valuesById[4] = "FAILED"] = 4;
            values[valuesById[5] = "INCOMPLETE"] = 5;
            values[valuesById[6] = "REMOTE_FAILURE"] = 6;
            values[valuesById[7] = "FAILED_TO_BUILD"] = 7;
            values[valuesById[8] = "TOOL_HALTED_BEFORE_TESTING"] = 8;
            return values;
        })();
        build_event_stream.TestResult = (function () {
            /**
             * Properties of a TestResult.
             * @memberof build_event_stream
             * @interface ITestResult
             * @property {build_event_stream.TestStatus|null} [status] TestResult status
             * @property {string|null} [statusDetails] TestResult statusDetails
             * @property {boolean|null} [cachedLocally] TestResult cachedLocally
             * @property {number|Long|null} [testAttemptStartMillisEpoch] TestResult testAttemptStartMillisEpoch
             * @property {number|Long|null} [testAttemptDurationMillis] TestResult testAttemptDurationMillis
             * @property {Array.<build_event_stream.IFile>|null} [testActionOutput] TestResult testActionOutput
             * @property {Array.<string>|null} [warning] TestResult warning
             * @property {build_event_stream.TestResult.IExecutionInfo|null} [executionInfo] TestResult executionInfo
             */
            /**
             * Constructs a new TestResult.
             * @memberof build_event_stream
             * @classdesc Represents a TestResult.
             * @implements ITestResult
             * @constructor
             * @param {build_event_stream.ITestResult=} [properties] Properties to set
             */
            function TestResult(properties) {
                this.testActionOutput = [];
                this.warning = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * TestResult status.
             * @member {build_event_stream.TestStatus} status
             * @memberof build_event_stream.TestResult
             * @instance
             */
            TestResult.prototype.status = 0;
            /**
             * TestResult statusDetails.
             * @member {string} statusDetails
             * @memberof build_event_stream.TestResult
             * @instance
             */
            TestResult.prototype.statusDetails = "";
            /**
             * TestResult cachedLocally.
             * @member {boolean} cachedLocally
             * @memberof build_event_stream.TestResult
             * @instance
             */
            TestResult.prototype.cachedLocally = false;
            /**
             * TestResult testAttemptStartMillisEpoch.
             * @member {number|Long} testAttemptStartMillisEpoch
             * @memberof build_event_stream.TestResult
             * @instance
             */
            TestResult.prototype.testAttemptStartMillisEpoch = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * TestResult testAttemptDurationMillis.
             * @member {number|Long} testAttemptDurationMillis
             * @memberof build_event_stream.TestResult
             * @instance
             */
            TestResult.prototype.testAttemptDurationMillis = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * TestResult testActionOutput.
             * @member {Array.<build_event_stream.IFile>} testActionOutput
             * @memberof build_event_stream.TestResult
             * @instance
             */
            TestResult.prototype.testActionOutput = $util.emptyArray;
            /**
             * TestResult warning.
             * @member {Array.<string>} warning
             * @memberof build_event_stream.TestResult
             * @instance
             */
            TestResult.prototype.warning = $util.emptyArray;
            /**
             * TestResult executionInfo.
             * @member {build_event_stream.TestResult.IExecutionInfo|null|undefined} executionInfo
             * @memberof build_event_stream.TestResult
             * @instance
             */
            TestResult.prototype.executionInfo = null;
            /**
             * Creates a new TestResult instance using the specified properties.
             * @function create
             * @memberof build_event_stream.TestResult
             * @static
             * @param {build_event_stream.ITestResult=} [properties] Properties to set
             * @returns {build_event_stream.TestResult} TestResult instance
             */
            TestResult.create = function create(properties) {
                return new TestResult(properties);
            };
            /**
             * Encodes the specified TestResult message. Does not implicitly {@link build_event_stream.TestResult.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.TestResult
             * @static
             * @param {build_event_stream.ITestResult} message TestResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.testActionOutput != null && message.testActionOutput.length)
                    for (var i = 0; i < message.testActionOutput.length; ++i)
                        $root.build_event_stream.File.encode(message.testActionOutput[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.testAttemptDurationMillis != null && message.hasOwnProperty("testAttemptDurationMillis"))
                    writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.testAttemptDurationMillis);
                if (message.cachedLocally != null && message.hasOwnProperty("cachedLocally"))
                    writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.cachedLocally);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.status);
                if (message.testAttemptStartMillisEpoch != null && message.hasOwnProperty("testAttemptStartMillisEpoch"))
                    writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.testAttemptStartMillisEpoch);
                if (message.warning != null && message.warning.length)
                    for (var i = 0; i < message.warning.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.warning[i]);
                if (message.executionInfo != null && message.hasOwnProperty("executionInfo"))
                    $root.build_event_stream.TestResult.ExecutionInfo.encode(message.executionInfo, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                if (message.statusDetails != null && message.hasOwnProperty("statusDetails"))
                    writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.statusDetails);
                return writer;
            };
            /**
             * Encodes the specified TestResult message, length delimited. Does not implicitly {@link build_event_stream.TestResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.TestResult
             * @static
             * @param {build_event_stream.ITestResult} message TestResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a TestResult message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.TestResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.TestResult} TestResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.TestResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 5:
                            message.status = reader.int32();
                            break;
                        case 9:
                            message.statusDetails = reader.string();
                            break;
                        case 4:
                            message.cachedLocally = reader.bool();
                            break;
                        case 6:
                            message.testAttemptStartMillisEpoch = reader.int64();
                            break;
                        case 3:
                            message.testAttemptDurationMillis = reader.int64();
                            break;
                        case 2:
                            if (!(message.testActionOutput && message.testActionOutput.length))
                                message.testActionOutput = [];
                            message.testActionOutput.push($root.build_event_stream.File.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.warning && message.warning.length))
                                message.warning = [];
                            message.warning.push(reader.string());
                            break;
                        case 8:
                            message.executionInfo = $root.build_event_stream.TestResult.ExecutionInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a TestResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.TestResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.TestResult} TestResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a TestResult message.
             * @function verify
             * @memberof build_event_stream.TestResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            break;
                    }
                if (message.statusDetails != null && message.hasOwnProperty("statusDetails"))
                    if (!$util.isString(message.statusDetails))
                        return "statusDetails: string expected";
                if (message.cachedLocally != null && message.hasOwnProperty("cachedLocally"))
                    if (typeof message.cachedLocally !== "boolean")
                        return "cachedLocally: boolean expected";
                if (message.testAttemptStartMillisEpoch != null && message.hasOwnProperty("testAttemptStartMillisEpoch"))
                    if (!$util.isInteger(message.testAttemptStartMillisEpoch) && !(message.testAttemptStartMillisEpoch && $util.isInteger(message.testAttemptStartMillisEpoch.low) && $util.isInteger(message.testAttemptStartMillisEpoch.high)))
                        return "testAttemptStartMillisEpoch: integer|Long expected";
                if (message.testAttemptDurationMillis != null && message.hasOwnProperty("testAttemptDurationMillis"))
                    if (!$util.isInteger(message.testAttemptDurationMillis) && !(message.testAttemptDurationMillis && $util.isInteger(message.testAttemptDurationMillis.low) && $util.isInteger(message.testAttemptDurationMillis.high)))
                        return "testAttemptDurationMillis: integer|Long expected";
                if (message.testActionOutput != null && message.hasOwnProperty("testActionOutput")) {
                    if (!Array.isArray(message.testActionOutput))
                        return "testActionOutput: array expected";
                    for (var i = 0; i < message.testActionOutput.length; ++i) {
                        var error = $root.build_event_stream.File.verify(message.testActionOutput[i]);
                        if (error)
                            return "testActionOutput." + error;
                    }
                }
                if (message.warning != null && message.hasOwnProperty("warning")) {
                    if (!Array.isArray(message.warning))
                        return "warning: array expected";
                    for (var i = 0; i < message.warning.length; ++i)
                        if (!$util.isString(message.warning[i]))
                            return "warning: string[] expected";
                }
                if (message.executionInfo != null && message.hasOwnProperty("executionInfo")) {
                    var error = $root.build_event_stream.TestResult.ExecutionInfo.verify(message.executionInfo);
                    if (error)
                        return "executionInfo." + error;
                }
                return null;
            };
            /**
             * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.TestResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.TestResult} TestResult
             */
            TestResult.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.TestResult)
                    return object;
                var message = new $root.build_event_stream.TestResult();
                switch (object.status) {
                    case "NO_STATUS":
                    case 0:
                        message.status = 0;
                        break;
                    case "PASSED":
                    case 1:
                        message.status = 1;
                        break;
                    case "FLAKY":
                    case 2:
                        message.status = 2;
                        break;
                    case "TIMEOUT":
                    case 3:
                        message.status = 3;
                        break;
                    case "FAILED":
                    case 4:
                        message.status = 4;
                        break;
                    case "INCOMPLETE":
                    case 5:
                        message.status = 5;
                        break;
                    case "REMOTE_FAILURE":
                    case 6:
                        message.status = 6;
                        break;
                    case "FAILED_TO_BUILD":
                    case 7:
                        message.status = 7;
                        break;
                    case "TOOL_HALTED_BEFORE_TESTING":
                    case 8:
                        message.status = 8;
                        break;
                }
                if (object.statusDetails != null)
                    message.statusDetails = String(object.statusDetails);
                if (object.cachedLocally != null)
                    message.cachedLocally = Boolean(object.cachedLocally);
                if (object.testAttemptStartMillisEpoch != null)
                    if ($util.Long)
                        (message.testAttemptStartMillisEpoch = $util.Long.fromValue(object.testAttemptStartMillisEpoch)).unsigned = false;
                    else if (typeof object.testAttemptStartMillisEpoch === "string")
                        message.testAttemptStartMillisEpoch = parseInt(object.testAttemptStartMillisEpoch, 10);
                    else if (typeof object.testAttemptStartMillisEpoch === "number")
                        message.testAttemptStartMillisEpoch = object.testAttemptStartMillisEpoch;
                    else if (typeof object.testAttemptStartMillisEpoch === "object")
                        message.testAttemptStartMillisEpoch = new $util.LongBits(object.testAttemptStartMillisEpoch.low >>> 0, object.testAttemptStartMillisEpoch.high >>> 0).toNumber();
                if (object.testAttemptDurationMillis != null)
                    if ($util.Long)
                        (message.testAttemptDurationMillis = $util.Long.fromValue(object.testAttemptDurationMillis)).unsigned = false;
                    else if (typeof object.testAttemptDurationMillis === "string")
                        message.testAttemptDurationMillis = parseInt(object.testAttemptDurationMillis, 10);
                    else if (typeof object.testAttemptDurationMillis === "number")
                        message.testAttemptDurationMillis = object.testAttemptDurationMillis;
                    else if (typeof object.testAttemptDurationMillis === "object")
                        message.testAttemptDurationMillis = new $util.LongBits(object.testAttemptDurationMillis.low >>> 0, object.testAttemptDurationMillis.high >>> 0).toNumber();
                if (object.testActionOutput) {
                    if (!Array.isArray(object.testActionOutput))
                        throw TypeError(".build_event_stream.TestResult.testActionOutput: array expected");
                    message.testActionOutput = [];
                    for (var i = 0; i < object.testActionOutput.length; ++i) {
                        if (typeof object.testActionOutput[i] !== "object")
                            throw TypeError(".build_event_stream.TestResult.testActionOutput: object expected");
                        message.testActionOutput[i] = $root.build_event_stream.File.fromObject(object.testActionOutput[i]);
                    }
                }
                if (object.warning) {
                    if (!Array.isArray(object.warning))
                        throw TypeError(".build_event_stream.TestResult.warning: array expected");
                    message.warning = [];
                    for (var i = 0; i < object.warning.length; ++i)
                        message.warning[i] = String(object.warning[i]);
                }
                if (object.executionInfo != null) {
                    if (typeof object.executionInfo !== "object")
                        throw TypeError(".build_event_stream.TestResult.executionInfo: object expected");
                    message.executionInfo = $root.build_event_stream.TestResult.ExecutionInfo.fromObject(object.executionInfo);
                }
                return message;
            };
            /**
             * Creates a plain object from a TestResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.TestResult
             * @static
             * @param {build_event_stream.TestResult} message TestResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.testActionOutput = [];
                    object.warning = [];
                }
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.testAttemptDurationMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.testAttemptDurationMillis = options.longs === String ? "0" : 0;
                    object.cachedLocally = false;
                    object.status = options.enums === String ? "NO_STATUS" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.testAttemptStartMillisEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.testAttemptStartMillisEpoch = options.longs === String ? "0" : 0;
                    object.executionInfo = null;
                    object.statusDetails = "";
                }
                if (message.testActionOutput && message.testActionOutput.length) {
                    object.testActionOutput = [];
                    for (var j = 0; j < message.testActionOutput.length; ++j)
                        object.testActionOutput[j] = $root.build_event_stream.File.toObject(message.testActionOutput[j], options);
                }
                if (message.testAttemptDurationMillis != null && message.hasOwnProperty("testAttemptDurationMillis"))
                    if (typeof message.testAttemptDurationMillis === "number")
                        object.testAttemptDurationMillis = options.longs === String ? String(message.testAttemptDurationMillis) : message.testAttemptDurationMillis;
                    else
                        object.testAttemptDurationMillis = options.longs === String ? $util.Long.prototype.toString.call(message.testAttemptDurationMillis) : options.longs === Number ? new $util.LongBits(message.testAttemptDurationMillis.low >>> 0, message.testAttemptDurationMillis.high >>> 0).toNumber() : message.testAttemptDurationMillis;
                if (message.cachedLocally != null && message.hasOwnProperty("cachedLocally"))
                    object.cachedLocally = message.cachedLocally;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.build_event_stream.TestStatus[message.status] : message.status;
                if (message.testAttemptStartMillisEpoch != null && message.hasOwnProperty("testAttemptStartMillisEpoch"))
                    if (typeof message.testAttemptStartMillisEpoch === "number")
                        object.testAttemptStartMillisEpoch = options.longs === String ? String(message.testAttemptStartMillisEpoch) : message.testAttemptStartMillisEpoch;
                    else
                        object.testAttemptStartMillisEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.testAttemptStartMillisEpoch) : options.longs === Number ? new $util.LongBits(message.testAttemptStartMillisEpoch.low >>> 0, message.testAttemptStartMillisEpoch.high >>> 0).toNumber() : message.testAttemptStartMillisEpoch;
                if (message.warning && message.warning.length) {
                    object.warning = [];
                    for (var j = 0; j < message.warning.length; ++j)
                        object.warning[j] = message.warning[j];
                }
                if (message.executionInfo != null && message.hasOwnProperty("executionInfo"))
                    object.executionInfo = $root.build_event_stream.TestResult.ExecutionInfo.toObject(message.executionInfo, options);
                if (message.statusDetails != null && message.hasOwnProperty("statusDetails"))
                    object.statusDetails = message.statusDetails;
                return object;
            };
            /**
             * Converts this TestResult to JSON.
             * @function toJSON
             * @memberof build_event_stream.TestResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            TestResult.ExecutionInfo = (function () {
                /**
                 * Properties of an ExecutionInfo.
                 * @memberof build_event_stream.TestResult
                 * @interface IExecutionInfo
                 * @property {number|null} [timeoutSeconds] ExecutionInfo timeoutSeconds
                 * @property {string|null} [strategy] ExecutionInfo strategy
                 * @property {boolean|null} [cachedRemotely] ExecutionInfo cachedRemotely
                 * @property {number|null} [exitCode] ExecutionInfo exitCode
                 * @property {string|null} [hostname] ExecutionInfo hostname
                 * @property {build_event_stream.TestResult.ExecutionInfo.ITimingBreakdown|null} [timingBreakdown] ExecutionInfo timingBreakdown
                 * @property {Array.<build_event_stream.TestResult.ExecutionInfo.IResourceUsage>|null} [resourceUsage] ExecutionInfo resourceUsage
                 */
                /**
                 * Constructs a new ExecutionInfo.
                 * @memberof build_event_stream.TestResult
                 * @classdesc Represents an ExecutionInfo.
                 * @implements IExecutionInfo
                 * @constructor
                 * @param {build_event_stream.TestResult.IExecutionInfo=} [properties] Properties to set
                 */
                function ExecutionInfo(properties) {
                    this.resourceUsage = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ExecutionInfo timeoutSeconds.
                 * @member {number} timeoutSeconds
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @instance
                 */
                ExecutionInfo.prototype.timeoutSeconds = 0;
                /**
                 * ExecutionInfo strategy.
                 * @member {string} strategy
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @instance
                 */
                ExecutionInfo.prototype.strategy = "";
                /**
                 * ExecutionInfo cachedRemotely.
                 * @member {boolean} cachedRemotely
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @instance
                 */
                ExecutionInfo.prototype.cachedRemotely = false;
                /**
                 * ExecutionInfo exitCode.
                 * @member {number} exitCode
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @instance
                 */
                ExecutionInfo.prototype.exitCode = 0;
                /**
                 * ExecutionInfo hostname.
                 * @member {string} hostname
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @instance
                 */
                ExecutionInfo.prototype.hostname = "";
                /**
                 * ExecutionInfo timingBreakdown.
                 * @member {build_event_stream.TestResult.ExecutionInfo.ITimingBreakdown|null|undefined} timingBreakdown
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @instance
                 */
                ExecutionInfo.prototype.timingBreakdown = null;
                /**
                 * ExecutionInfo resourceUsage.
                 * @member {Array.<build_event_stream.TestResult.ExecutionInfo.IResourceUsage>} resourceUsage
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @instance
                 */
                ExecutionInfo.prototype.resourceUsage = $util.emptyArray;
                /**
                 * Creates a new ExecutionInfo instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @static
                 * @param {build_event_stream.TestResult.IExecutionInfo=} [properties] Properties to set
                 * @returns {build_event_stream.TestResult.ExecutionInfo} ExecutionInfo instance
                 */
                ExecutionInfo.create = function create(properties) {
                    return new ExecutionInfo(properties);
                };
                /**
                 * Encodes the specified ExecutionInfo message. Does not implicitly {@link build_event_stream.TestResult.ExecutionInfo.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @static
                 * @param {build_event_stream.TestResult.IExecutionInfo} message ExecutionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.timeoutSeconds);
                    if (message.strategy != null && message.hasOwnProperty("strategy"))
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.strategy);
                    if (message.hostname != null && message.hasOwnProperty("hostname"))
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.hostname);
                    if (message.timingBreakdown != null && message.hasOwnProperty("timingBreakdown"))
                        $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.encode(message.timingBreakdown, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                    if (message.resourceUsage != null && message.resourceUsage.length)
                        for (var i = 0; i < message.resourceUsage.length; ++i)
                            $root.build_event_stream.TestResult.ExecutionInfo.ResourceUsage.encode(message.resourceUsage[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                    if (message.cachedRemotely != null && message.hasOwnProperty("cachedRemotely"))
                        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.cachedRemotely);
                    if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                        writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.exitCode);
                    return writer;
                };
                /**
                 * Encodes the specified ExecutionInfo message, length delimited. Does not implicitly {@link build_event_stream.TestResult.ExecutionInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @static
                 * @param {build_event_stream.TestResult.IExecutionInfo} message ExecutionInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecutionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an ExecutionInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.TestResult.ExecutionInfo} ExecutionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.TestResult.ExecutionInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.timeoutSeconds = reader.int32();
                                break;
                            case 2:
                                message.strategy = reader.string();
                                break;
                            case 6:
                                message.cachedRemotely = reader.bool();
                                break;
                            case 7:
                                message.exitCode = reader.int32();
                                break;
                            case 3:
                                message.hostname = reader.string();
                                break;
                            case 4:
                                message.timingBreakdown = $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.decode(reader, reader.uint32());
                                break;
                            case 5:
                                if (!(message.resourceUsage && message.resourceUsage.length))
                                    message.resourceUsage = [];
                                message.resourceUsage.push($root.build_event_stream.TestResult.ExecutionInfo.ResourceUsage.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an ExecutionInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.TestResult.ExecutionInfo} ExecutionInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecutionInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an ExecutionInfo message.
                 * @function verify
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecutionInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                        if (!$util.isInteger(message.timeoutSeconds))
                            return "timeoutSeconds: integer expected";
                    if (message.strategy != null && message.hasOwnProperty("strategy"))
                        if (!$util.isString(message.strategy))
                            return "strategy: string expected";
                    if (message.cachedRemotely != null && message.hasOwnProperty("cachedRemotely"))
                        if (typeof message.cachedRemotely !== "boolean")
                            return "cachedRemotely: boolean expected";
                    if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                        if (!$util.isInteger(message.exitCode))
                            return "exitCode: integer expected";
                    if (message.hostname != null && message.hasOwnProperty("hostname"))
                        if (!$util.isString(message.hostname))
                            return "hostname: string expected";
                    if (message.timingBreakdown != null && message.hasOwnProperty("timingBreakdown")) {
                        var error = $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.verify(message.timingBreakdown);
                        if (error)
                            return "timingBreakdown." + error;
                    }
                    if (message.resourceUsage != null && message.hasOwnProperty("resourceUsage")) {
                        if (!Array.isArray(message.resourceUsage))
                            return "resourceUsage: array expected";
                        for (var i = 0; i < message.resourceUsage.length; ++i) {
                            var error = $root.build_event_stream.TestResult.ExecutionInfo.ResourceUsage.verify(message.resourceUsage[i]);
                            if (error)
                                return "resourceUsage." + error;
                        }
                    }
                    return null;
                };
                /**
                 * Creates an ExecutionInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.TestResult.ExecutionInfo} ExecutionInfo
                 */
                ExecutionInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.TestResult.ExecutionInfo)
                        return object;
                    var message = new $root.build_event_stream.TestResult.ExecutionInfo();
                    if (object.timeoutSeconds != null)
                        message.timeoutSeconds = object.timeoutSeconds | 0;
                    if (object.strategy != null)
                        message.strategy = String(object.strategy);
                    if (object.cachedRemotely != null)
                        message.cachedRemotely = Boolean(object.cachedRemotely);
                    if (object.exitCode != null)
                        message.exitCode = object.exitCode | 0;
                    if (object.hostname != null)
                        message.hostname = String(object.hostname);
                    if (object.timingBreakdown != null) {
                        if (typeof object.timingBreakdown !== "object")
                            throw TypeError(".build_event_stream.TestResult.ExecutionInfo.timingBreakdown: object expected");
                        message.timingBreakdown = $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.fromObject(object.timingBreakdown);
                    }
                    if (object.resourceUsage) {
                        if (!Array.isArray(object.resourceUsage))
                            throw TypeError(".build_event_stream.TestResult.ExecutionInfo.resourceUsage: array expected");
                        message.resourceUsage = [];
                        for (var i = 0; i < object.resourceUsage.length; ++i) {
                            if (typeof object.resourceUsage[i] !== "object")
                                throw TypeError(".build_event_stream.TestResult.ExecutionInfo.resourceUsage: object expected");
                            message.resourceUsage[i] = $root.build_event_stream.TestResult.ExecutionInfo.ResourceUsage.fromObject(object.resourceUsage[i]);
                        }
                    }
                    return message;
                };
                /**
                 * Creates a plain object from an ExecutionInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @static
                 * @param {build_event_stream.TestResult.ExecutionInfo} message ExecutionInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExecutionInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.resourceUsage = [];
                    if (options.defaults) {
                        object.timeoutSeconds = 0;
                        object.strategy = "";
                        object.hostname = "";
                        object.timingBreakdown = null;
                        object.cachedRemotely = false;
                        object.exitCode = 0;
                    }
                    if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                        object.timeoutSeconds = message.timeoutSeconds;
                    if (message.strategy != null && message.hasOwnProperty("strategy"))
                        object.strategy = message.strategy;
                    if (message.hostname != null && message.hasOwnProperty("hostname"))
                        object.hostname = message.hostname;
                    if (message.timingBreakdown != null && message.hasOwnProperty("timingBreakdown"))
                        object.timingBreakdown = $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.toObject(message.timingBreakdown, options);
                    if (message.resourceUsage && message.resourceUsage.length) {
                        object.resourceUsage = [];
                        for (var j = 0; j < message.resourceUsage.length; ++j)
                            object.resourceUsage[j] = $root.build_event_stream.TestResult.ExecutionInfo.ResourceUsage.toObject(message.resourceUsage[j], options);
                    }
                    if (message.cachedRemotely != null && message.hasOwnProperty("cachedRemotely"))
                        object.cachedRemotely = message.cachedRemotely;
                    if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                        object.exitCode = message.exitCode;
                    return object;
                };
                /**
                 * Converts this ExecutionInfo to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.TestResult.ExecutionInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExecutionInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExecutionInfo.TimingBreakdown = (function () {
                    /**
                     * Properties of a TimingBreakdown.
                     * @memberof build_event_stream.TestResult.ExecutionInfo
                     * @interface ITimingBreakdown
                     * @property {Array.<build_event_stream.TestResult.ExecutionInfo.ITimingBreakdown>|null} [child] TimingBreakdown child
                     * @property {string|null} [name] TimingBreakdown name
                     * @property {number|Long|null} [timeMillis] TimingBreakdown timeMillis
                     */
                    /**
                     * Constructs a new TimingBreakdown.
                     * @memberof build_event_stream.TestResult.ExecutionInfo
                     * @classdesc Represents a TimingBreakdown.
                     * @implements ITimingBreakdown
                     * @constructor
                     * @param {build_event_stream.TestResult.ExecutionInfo.ITimingBreakdown=} [properties] Properties to set
                     */
                    function TimingBreakdown(properties) {
                        this.child = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
                    /**
                     * TimingBreakdown child.
                     * @member {Array.<build_event_stream.TestResult.ExecutionInfo.ITimingBreakdown>} child
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @instance
                     */
                    TimingBreakdown.prototype.child = $util.emptyArray;
                    /**
                     * TimingBreakdown name.
                     * @member {string} name
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @instance
                     */
                    TimingBreakdown.prototype.name = "";
                    /**
                     * TimingBreakdown timeMillis.
                     * @member {number|Long} timeMillis
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @instance
                     */
                    TimingBreakdown.prototype.timeMillis = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                    /**
                     * Creates a new TimingBreakdown instance using the specified properties.
                     * @function create
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @static
                     * @param {build_event_stream.TestResult.ExecutionInfo.ITimingBreakdown=} [properties] Properties to set
                     * @returns {build_event_stream.TestResult.ExecutionInfo.TimingBreakdown} TimingBreakdown instance
                     */
                    TimingBreakdown.create = function create(properties) {
                        return new TimingBreakdown(properties);
                    };
                    /**
                     * Encodes the specified TimingBreakdown message. Does not implicitly {@link build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.verify|verify} messages.
                     * @function encode
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @static
                     * @param {build_event_stream.TestResult.ExecutionInfo.ITimingBreakdown} message TimingBreakdown message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimingBreakdown.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.child != null && message.child.length)
                            for (var i = 0; i < message.child.length; ++i)
                                $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.encode(message.child[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
                        if (message.timeMillis != null && message.hasOwnProperty("timeMillis"))
                            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.timeMillis);
                        return writer;
                    };
                    /**
                     * Encodes the specified TimingBreakdown message, length delimited. Does not implicitly {@link build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @static
                     * @param {build_event_stream.TestResult.ExecutionInfo.ITimingBreakdown} message TimingBreakdown message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimingBreakdown.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
                    /**
                     * Decodes a TimingBreakdown message from the specified reader or buffer.
                     * @function decode
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {build_event_stream.TestResult.ExecutionInfo.TimingBreakdown} TimingBreakdown
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimingBreakdown.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                                case 1:
                                    if (!(message.child && message.child.length))
                                        message.child = [];
                                    message.child.push($root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.decode(reader, reader.uint32()));
                                    break;
                                case 2:
                                    message.name = reader.string();
                                    break;
                                case 3:
                                    message.timeMillis = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                            }
                        }
                        return message;
                    };
                    /**
                     * Decodes a TimingBreakdown message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {build_event_stream.TestResult.ExecutionInfo.TimingBreakdown} TimingBreakdown
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimingBreakdown.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
                    /**
                     * Verifies a TimingBreakdown message.
                     * @function verify
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TimingBreakdown.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.child != null && message.hasOwnProperty("child")) {
                            if (!Array.isArray(message.child))
                                return "child: array expected";
                            for (var i = 0; i < message.child.length; ++i) {
                                var error = $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.verify(message.child[i]);
                                if (error)
                                    return "child." + error;
                            }
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.timeMillis != null && message.hasOwnProperty("timeMillis"))
                            if (!$util.isInteger(message.timeMillis) && !(message.timeMillis && $util.isInteger(message.timeMillis.low) && $util.isInteger(message.timeMillis.high)))
                                return "timeMillis: integer|Long expected";
                        return null;
                    };
                    /**
                     * Creates a TimingBreakdown message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {build_event_stream.TestResult.ExecutionInfo.TimingBreakdown} TimingBreakdown
                     */
                    TimingBreakdown.fromObject = function fromObject(object) {
                        if (object instanceof $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown)
                            return object;
                        var message = new $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown();
                        if (object.child) {
                            if (!Array.isArray(object.child))
                                throw TypeError(".build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.child: array expected");
                            message.child = [];
                            for (var i = 0; i < object.child.length; ++i) {
                                if (typeof object.child[i] !== "object")
                                    throw TypeError(".build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.child: object expected");
                                message.child[i] = $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.fromObject(object.child[i]);
                            }
                        }
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.timeMillis != null)
                            if ($util.Long)
                                (message.timeMillis = $util.Long.fromValue(object.timeMillis)).unsigned = false;
                            else if (typeof object.timeMillis === "string")
                                message.timeMillis = parseInt(object.timeMillis, 10);
                            else if (typeof object.timeMillis === "number")
                                message.timeMillis = object.timeMillis;
                            else if (typeof object.timeMillis === "object")
                                message.timeMillis = new $util.LongBits(object.timeMillis.low >>> 0, object.timeMillis.high >>> 0).toNumber();
                        return message;
                    };
                    /**
                     * Creates a plain object from a TimingBreakdown message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @static
                     * @param {build_event_stream.TestResult.ExecutionInfo.TimingBreakdown} message TimingBreakdown
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TimingBreakdown.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.child = [];
                        if (options.defaults) {
                            object.name = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            }
                            else
                                object.timeMillis = options.longs === String ? "0" : 0;
                        }
                        if (message.child && message.child.length) {
                            object.child = [];
                            for (var j = 0; j < message.child.length; ++j)
                                object.child[j] = $root.build_event_stream.TestResult.ExecutionInfo.TimingBreakdown.toObject(message.child[j], options);
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.timeMillis != null && message.hasOwnProperty("timeMillis"))
                            if (typeof message.timeMillis === "number")
                                object.timeMillis = options.longs === String ? String(message.timeMillis) : message.timeMillis;
                            else
                                object.timeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.timeMillis) : options.longs === Number ? new $util.LongBits(message.timeMillis.low >>> 0, message.timeMillis.high >>> 0).toNumber() : message.timeMillis;
                        return object;
                    };
                    /**
                     * Converts this TimingBreakdown to JSON.
                     * @function toJSON
                     * @memberof build_event_stream.TestResult.ExecutionInfo.TimingBreakdown
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TimingBreakdown.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
                    return TimingBreakdown;
                })();
                ExecutionInfo.ResourceUsage = (function () {
                    /**
                     * Properties of a ResourceUsage.
                     * @memberof build_event_stream.TestResult.ExecutionInfo
                     * @interface IResourceUsage
                     * @property {string|null} [name] ResourceUsage name
                     * @property {number|Long|null} [value] ResourceUsage value
                     */
                    /**
                     * Constructs a new ResourceUsage.
                     * @memberof build_event_stream.TestResult.ExecutionInfo
                     * @classdesc Represents a ResourceUsage.
                     * @implements IResourceUsage
                     * @constructor
                     * @param {build_event_stream.TestResult.ExecutionInfo.IResourceUsage=} [properties] Properties to set
                     */
                    function ResourceUsage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
                    /**
                     * ResourceUsage name.
                     * @member {string} name
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @instance
                     */
                    ResourceUsage.prototype.name = "";
                    /**
                     * ResourceUsage value.
                     * @member {number|Long} value
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @instance
                     */
                    ResourceUsage.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                    /**
                     * Creates a new ResourceUsage instance using the specified properties.
                     * @function create
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @static
                     * @param {build_event_stream.TestResult.ExecutionInfo.IResourceUsage=} [properties] Properties to set
                     * @returns {build_event_stream.TestResult.ExecutionInfo.ResourceUsage} ResourceUsage instance
                     */
                    ResourceUsage.create = function create(properties) {
                        return new ResourceUsage(properties);
                    };
                    /**
                     * Encodes the specified ResourceUsage message. Does not implicitly {@link build_event_stream.TestResult.ExecutionInfo.ResourceUsage.verify|verify} messages.
                     * @function encode
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @static
                     * @param {build_event_stream.TestResult.ExecutionInfo.IResourceUsage} message ResourceUsage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ResourceUsage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.value);
                        return writer;
                    };
                    /**
                     * Encodes the specified ResourceUsage message, length delimited. Does not implicitly {@link build_event_stream.TestResult.ExecutionInfo.ResourceUsage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @static
                     * @param {build_event_stream.TestResult.ExecutionInfo.IResourceUsage} message ResourceUsage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ResourceUsage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
                    /**
                     * Decodes a ResourceUsage message from the specified reader or buffer.
                     * @function decode
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {build_event_stream.TestResult.ExecutionInfo.ResourceUsage} ResourceUsage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ResourceUsage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.TestResult.ExecutionInfo.ResourceUsage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                                case 1:
                                    message.name = reader.string();
                                    break;
                                case 2:
                                    message.value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                            }
                        }
                        return message;
                    };
                    /**
                     * Decodes a ResourceUsage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {build_event_stream.TestResult.ExecutionInfo.ResourceUsage} ResourceUsage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ResourceUsage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
                    /**
                     * Verifies a ResourceUsage message.
                     * @function verify
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ResourceUsage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
                    /**
                     * Creates a ResourceUsage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {build_event_stream.TestResult.ExecutionInfo.ResourceUsage} ResourceUsage
                     */
                    ResourceUsage.fromObject = function fromObject(object) {
                        if (object instanceof $root.build_event_stream.TestResult.ExecutionInfo.ResourceUsage)
                            return object;
                        var message = new $root.build_event_stream.TestResult.ExecutionInfo.ResourceUsage();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                        return message;
                    };
                    /**
                     * Creates a plain object from a ResourceUsage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @static
                     * @param {build_event_stream.TestResult.ExecutionInfo.ResourceUsage} message ResourceUsage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ResourceUsage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            }
                            else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                        return object;
                    };
                    /**
                     * Converts this ResourceUsage to JSON.
                     * @function toJSON
                     * @memberof build_event_stream.TestResult.ExecutionInfo.ResourceUsage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ResourceUsage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
                    return ResourceUsage;
                })();
                return ExecutionInfo;
            })();
            return TestResult;
        })();
        build_event_stream.TestSummary = (function () {
            /**
             * Properties of a TestSummary.
             * @memberof build_event_stream
             * @interface ITestSummary
             * @property {build_event_stream.TestStatus|null} [overallStatus] TestSummary overallStatus
             * @property {number|null} [totalRunCount] TestSummary totalRunCount
             * @property {Array.<build_event_stream.IFile>|null} [passed] TestSummary passed
             * @property {Array.<build_event_stream.IFile>|null} [failed] TestSummary failed
             * @property {number|null} [totalNumCached] TestSummary totalNumCached
             */
            /**
             * Constructs a new TestSummary.
             * @memberof build_event_stream
             * @classdesc Represents a TestSummary.
             * @implements ITestSummary
             * @constructor
             * @param {build_event_stream.ITestSummary=} [properties] Properties to set
             */
            function TestSummary(properties) {
                this.passed = [];
                this.failed = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * TestSummary overallStatus.
             * @member {build_event_stream.TestStatus} overallStatus
             * @memberof build_event_stream.TestSummary
             * @instance
             */
            TestSummary.prototype.overallStatus = 0;
            /**
             * TestSummary totalRunCount.
             * @member {number} totalRunCount
             * @memberof build_event_stream.TestSummary
             * @instance
             */
            TestSummary.prototype.totalRunCount = 0;
            /**
             * TestSummary passed.
             * @member {Array.<build_event_stream.IFile>} passed
             * @memberof build_event_stream.TestSummary
             * @instance
             */
            TestSummary.prototype.passed = $util.emptyArray;
            /**
             * TestSummary failed.
             * @member {Array.<build_event_stream.IFile>} failed
             * @memberof build_event_stream.TestSummary
             * @instance
             */
            TestSummary.prototype.failed = $util.emptyArray;
            /**
             * TestSummary totalNumCached.
             * @member {number} totalNumCached
             * @memberof build_event_stream.TestSummary
             * @instance
             */
            TestSummary.prototype.totalNumCached = 0;
            /**
             * Creates a new TestSummary instance using the specified properties.
             * @function create
             * @memberof build_event_stream.TestSummary
             * @static
             * @param {build_event_stream.ITestSummary=} [properties] Properties to set
             * @returns {build_event_stream.TestSummary} TestSummary instance
             */
            TestSummary.create = function create(properties) {
                return new TestSummary(properties);
            };
            /**
             * Encodes the specified TestSummary message. Does not implicitly {@link build_event_stream.TestSummary.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.TestSummary
             * @static
             * @param {build_event_stream.ITestSummary} message TestSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestSummary.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.totalRunCount != null && message.hasOwnProperty("totalRunCount"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.totalRunCount);
                if (message.passed != null && message.passed.length)
                    for (var i = 0; i < message.passed.length; ++i)
                        $root.build_event_stream.File.encode(message.passed[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                if (message.failed != null && message.failed.length)
                    for (var i = 0; i < message.failed.length; ++i)
                        $root.build_event_stream.File.encode(message.failed[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.overallStatus != null && message.hasOwnProperty("overallStatus"))
                    writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.overallStatus);
                if (message.totalNumCached != null && message.hasOwnProperty("totalNumCached"))
                    writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.totalNumCached);
                return writer;
            };
            /**
             * Encodes the specified TestSummary message, length delimited. Does not implicitly {@link build_event_stream.TestSummary.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.TestSummary
             * @static
             * @param {build_event_stream.ITestSummary} message TestSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestSummary.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a TestSummary message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.TestSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.TestSummary} TestSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestSummary.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.TestSummary();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 5:
                            message.overallStatus = reader.int32();
                            break;
                        case 1:
                            message.totalRunCount = reader.int32();
                            break;
                        case 3:
                            if (!(message.passed && message.passed.length))
                                message.passed = [];
                            message.passed.push($root.build_event_stream.File.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.failed && message.failed.length))
                                message.failed = [];
                            message.failed.push($root.build_event_stream.File.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.totalNumCached = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a TestSummary message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.TestSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.TestSummary} TestSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestSummary.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a TestSummary message.
             * @function verify
             * @memberof build_event_stream.TestSummary
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestSummary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.overallStatus != null && message.hasOwnProperty("overallStatus"))
                    switch (message.overallStatus) {
                        default:
                            return "overallStatus: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            break;
                    }
                if (message.totalRunCount != null && message.hasOwnProperty("totalRunCount"))
                    if (!$util.isInteger(message.totalRunCount))
                        return "totalRunCount: integer expected";
                if (message.passed != null && message.hasOwnProperty("passed")) {
                    if (!Array.isArray(message.passed))
                        return "passed: array expected";
                    for (var i = 0; i < message.passed.length; ++i) {
                        var error = $root.build_event_stream.File.verify(message.passed[i]);
                        if (error)
                            return "passed." + error;
                    }
                }
                if (message.failed != null && message.hasOwnProperty("failed")) {
                    if (!Array.isArray(message.failed))
                        return "failed: array expected";
                    for (var i = 0; i < message.failed.length; ++i) {
                        var error = $root.build_event_stream.File.verify(message.failed[i]);
                        if (error)
                            return "failed." + error;
                    }
                }
                if (message.totalNumCached != null && message.hasOwnProperty("totalNumCached"))
                    if (!$util.isInteger(message.totalNumCached))
                        return "totalNumCached: integer expected";
                return null;
            };
            /**
             * Creates a TestSummary message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.TestSummary
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.TestSummary} TestSummary
             */
            TestSummary.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.TestSummary)
                    return object;
                var message = new $root.build_event_stream.TestSummary();
                switch (object.overallStatus) {
                    case "NO_STATUS":
                    case 0:
                        message.overallStatus = 0;
                        break;
                    case "PASSED":
                    case 1:
                        message.overallStatus = 1;
                        break;
                    case "FLAKY":
                    case 2:
                        message.overallStatus = 2;
                        break;
                    case "TIMEOUT":
                    case 3:
                        message.overallStatus = 3;
                        break;
                    case "FAILED":
                    case 4:
                        message.overallStatus = 4;
                        break;
                    case "INCOMPLETE":
                    case 5:
                        message.overallStatus = 5;
                        break;
                    case "REMOTE_FAILURE":
                    case 6:
                        message.overallStatus = 6;
                        break;
                    case "FAILED_TO_BUILD":
                    case 7:
                        message.overallStatus = 7;
                        break;
                    case "TOOL_HALTED_BEFORE_TESTING":
                    case 8:
                        message.overallStatus = 8;
                        break;
                }
                if (object.totalRunCount != null)
                    message.totalRunCount = object.totalRunCount | 0;
                if (object.passed) {
                    if (!Array.isArray(object.passed))
                        throw TypeError(".build_event_stream.TestSummary.passed: array expected");
                    message.passed = [];
                    for (var i = 0; i < object.passed.length; ++i) {
                        if (typeof object.passed[i] !== "object")
                            throw TypeError(".build_event_stream.TestSummary.passed: object expected");
                        message.passed[i] = $root.build_event_stream.File.fromObject(object.passed[i]);
                    }
                }
                if (object.failed) {
                    if (!Array.isArray(object.failed))
                        throw TypeError(".build_event_stream.TestSummary.failed: array expected");
                    message.failed = [];
                    for (var i = 0; i < object.failed.length; ++i) {
                        if (typeof object.failed[i] !== "object")
                            throw TypeError(".build_event_stream.TestSummary.failed: object expected");
                        message.failed[i] = $root.build_event_stream.File.fromObject(object.failed[i]);
                    }
                }
                if (object.totalNumCached != null)
                    message.totalNumCached = object.totalNumCached | 0;
                return message;
            };
            /**
             * Creates a plain object from a TestSummary message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.TestSummary
             * @static
             * @param {build_event_stream.TestSummary} message TestSummary
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestSummary.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.passed = [];
                    object.failed = [];
                }
                if (options.defaults) {
                    object.totalRunCount = 0;
                    object.overallStatus = options.enums === String ? "NO_STATUS" : 0;
                    object.totalNumCached = 0;
                }
                if (message.totalRunCount != null && message.hasOwnProperty("totalRunCount"))
                    object.totalRunCount = message.totalRunCount;
                if (message.passed && message.passed.length) {
                    object.passed = [];
                    for (var j = 0; j < message.passed.length; ++j)
                        object.passed[j] = $root.build_event_stream.File.toObject(message.passed[j], options);
                }
                if (message.failed && message.failed.length) {
                    object.failed = [];
                    for (var j = 0; j < message.failed.length; ++j)
                        object.failed[j] = $root.build_event_stream.File.toObject(message.failed[j], options);
                }
                if (message.overallStatus != null && message.hasOwnProperty("overallStatus"))
                    object.overallStatus = options.enums === String ? $root.build_event_stream.TestStatus[message.overallStatus] : message.overallStatus;
                if (message.totalNumCached != null && message.hasOwnProperty("totalNumCached"))
                    object.totalNumCached = message.totalNumCached;
                return object;
            };
            /**
             * Converts this TestSummary to JSON.
             * @function toJSON
             * @memberof build_event_stream.TestSummary
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestSummary.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return TestSummary;
        })();
        build_event_stream.BuildFinished = (function () {
            /**
             * Properties of a BuildFinished.
             * @memberof build_event_stream
             * @interface IBuildFinished
             * @property {boolean|null} [overallSuccess] BuildFinished overallSuccess
             * @property {build_event_stream.BuildFinished.IExitCode|null} [exitCode] BuildFinished exitCode
             * @property {number|Long|null} [finishTimeMillis] BuildFinished finishTimeMillis
             */
            /**
             * Constructs a new BuildFinished.
             * @memberof build_event_stream
             * @classdesc Represents a BuildFinished.
             * @implements IBuildFinished
             * @constructor
             * @param {build_event_stream.IBuildFinished=} [properties] Properties to set
             */
            function BuildFinished(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * BuildFinished overallSuccess.
             * @member {boolean} overallSuccess
             * @memberof build_event_stream.BuildFinished
             * @instance
             */
            BuildFinished.prototype.overallSuccess = false;
            /**
             * BuildFinished exitCode.
             * @member {build_event_stream.BuildFinished.IExitCode|null|undefined} exitCode
             * @memberof build_event_stream.BuildFinished
             * @instance
             */
            BuildFinished.prototype.exitCode = null;
            /**
             * BuildFinished finishTimeMillis.
             * @member {number|Long} finishTimeMillis
             * @memberof build_event_stream.BuildFinished
             * @instance
             */
            BuildFinished.prototype.finishTimeMillis = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new BuildFinished instance using the specified properties.
             * @function create
             * @memberof build_event_stream.BuildFinished
             * @static
             * @param {build_event_stream.IBuildFinished=} [properties] Properties to set
             * @returns {build_event_stream.BuildFinished} BuildFinished instance
             */
            BuildFinished.create = function create(properties) {
                return new BuildFinished(properties);
            };
            /**
             * Encodes the specified BuildFinished message. Does not implicitly {@link build_event_stream.BuildFinished.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.BuildFinished
             * @static
             * @param {build_event_stream.IBuildFinished} message BuildFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildFinished.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.overallSuccess != null && message.hasOwnProperty("overallSuccess"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.overallSuccess);
                if (message.finishTimeMillis != null && message.hasOwnProperty("finishTimeMillis"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.finishTimeMillis);
                if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                    $root.build_event_stream.BuildFinished.ExitCode.encode(message.exitCode, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified BuildFinished message, length delimited. Does not implicitly {@link build_event_stream.BuildFinished.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.BuildFinished
             * @static
             * @param {build_event_stream.IBuildFinished} message BuildFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildFinished.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a BuildFinished message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.BuildFinished
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.BuildFinished} BuildFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildFinished.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildFinished();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.overallSuccess = reader.bool();
                            break;
                        case 3:
                            message.exitCode = $root.build_event_stream.BuildFinished.ExitCode.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.finishTimeMillis = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a BuildFinished message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.BuildFinished
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.BuildFinished} BuildFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildFinished.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a BuildFinished message.
             * @function verify
             * @memberof build_event_stream.BuildFinished
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BuildFinished.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.overallSuccess != null && message.hasOwnProperty("overallSuccess"))
                    if (typeof message.overallSuccess !== "boolean")
                        return "overallSuccess: boolean expected";
                if (message.exitCode != null && message.hasOwnProperty("exitCode")) {
                    var error = $root.build_event_stream.BuildFinished.ExitCode.verify(message.exitCode);
                    if (error)
                        return "exitCode." + error;
                }
                if (message.finishTimeMillis != null && message.hasOwnProperty("finishTimeMillis"))
                    if (!$util.isInteger(message.finishTimeMillis) && !(message.finishTimeMillis && $util.isInteger(message.finishTimeMillis.low) && $util.isInteger(message.finishTimeMillis.high)))
                        return "finishTimeMillis: integer|Long expected";
                return null;
            };
            /**
             * Creates a BuildFinished message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.BuildFinished
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.BuildFinished} BuildFinished
             */
            BuildFinished.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.BuildFinished)
                    return object;
                var message = new $root.build_event_stream.BuildFinished();
                if (object.overallSuccess != null)
                    message.overallSuccess = Boolean(object.overallSuccess);
                if (object.exitCode != null) {
                    if (typeof object.exitCode !== "object")
                        throw TypeError(".build_event_stream.BuildFinished.exitCode: object expected");
                    message.exitCode = $root.build_event_stream.BuildFinished.ExitCode.fromObject(object.exitCode);
                }
                if (object.finishTimeMillis != null)
                    if ($util.Long)
                        (message.finishTimeMillis = $util.Long.fromValue(object.finishTimeMillis)).unsigned = false;
                    else if (typeof object.finishTimeMillis === "string")
                        message.finishTimeMillis = parseInt(object.finishTimeMillis, 10);
                    else if (typeof object.finishTimeMillis === "number")
                        message.finishTimeMillis = object.finishTimeMillis;
                    else if (typeof object.finishTimeMillis === "object")
                        message.finishTimeMillis = new $util.LongBits(object.finishTimeMillis.low >>> 0, object.finishTimeMillis.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from a BuildFinished message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.BuildFinished
             * @static
             * @param {build_event_stream.BuildFinished} message BuildFinished
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BuildFinished.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.overallSuccess = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.finishTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.finishTimeMillis = options.longs === String ? "0" : 0;
                    object.exitCode = null;
                }
                if (message.overallSuccess != null && message.hasOwnProperty("overallSuccess"))
                    object.overallSuccess = message.overallSuccess;
                if (message.finishTimeMillis != null && message.hasOwnProperty("finishTimeMillis"))
                    if (typeof message.finishTimeMillis === "number")
                        object.finishTimeMillis = options.longs === String ? String(message.finishTimeMillis) : message.finishTimeMillis;
                    else
                        object.finishTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.finishTimeMillis) : options.longs === Number ? new $util.LongBits(message.finishTimeMillis.low >>> 0, message.finishTimeMillis.high >>> 0).toNumber() : message.finishTimeMillis;
                if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                    object.exitCode = $root.build_event_stream.BuildFinished.ExitCode.toObject(message.exitCode, options);
                return object;
            };
            /**
             * Converts this BuildFinished to JSON.
             * @function toJSON
             * @memberof build_event_stream.BuildFinished
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BuildFinished.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            BuildFinished.ExitCode = (function () {
                /**
                 * Properties of an ExitCode.
                 * @memberof build_event_stream.BuildFinished
                 * @interface IExitCode
                 * @property {string|null} [name] ExitCode name
                 * @property {number|null} [code] ExitCode code
                 */
                /**
                 * Constructs a new ExitCode.
                 * @memberof build_event_stream.BuildFinished
                 * @classdesc Represents an ExitCode.
                 * @implements IExitCode
                 * @constructor
                 * @param {build_event_stream.BuildFinished.IExitCode=} [properties] Properties to set
                 */
                function ExitCode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ExitCode name.
                 * @member {string} name
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @instance
                 */
                ExitCode.prototype.name = "";
                /**
                 * ExitCode code.
                 * @member {number} code
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @instance
                 */
                ExitCode.prototype.code = 0;
                /**
                 * Creates a new ExitCode instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @static
                 * @param {build_event_stream.BuildFinished.IExitCode=} [properties] Properties to set
                 * @returns {build_event_stream.BuildFinished.ExitCode} ExitCode instance
                 */
                ExitCode.create = function create(properties) {
                    return new ExitCode(properties);
                };
                /**
                 * Encodes the specified ExitCode message. Does not implicitly {@link build_event_stream.BuildFinished.ExitCode.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @static
                 * @param {build_event_stream.BuildFinished.IExitCode} message ExitCode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExitCode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                    if (message.code != null && message.hasOwnProperty("code"))
                        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.code);
                    return writer;
                };
                /**
                 * Encodes the specified ExitCode message, length delimited. Does not implicitly {@link build_event_stream.BuildFinished.ExitCode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @static
                 * @param {build_event_stream.BuildFinished.IExitCode} message ExitCode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExitCode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an ExitCode message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildFinished.ExitCode} ExitCode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExitCode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildFinished.ExitCode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.code = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an ExitCode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildFinished.ExitCode} ExitCode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExitCode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an ExitCode message.
                 * @function verify
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExitCode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isInteger(message.code))
                            return "code: integer expected";
                    return null;
                };
                /**
                 * Creates an ExitCode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildFinished.ExitCode} ExitCode
                 */
                ExitCode.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildFinished.ExitCode)
                        return object;
                    var message = new $root.build_event_stream.BuildFinished.ExitCode();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.code != null)
                        message.code = object.code | 0;
                    return message;
                };
                /**
                 * Creates a plain object from an ExitCode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @static
                 * @param {build_event_stream.BuildFinished.ExitCode} message ExitCode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExitCode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.code = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    return object;
                };
                /**
                 * Converts this ExitCode to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildFinished.ExitCode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExitCode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return ExitCode;
            })();
            return BuildFinished;
        })();
        build_event_stream.BuildMetrics = (function () {
            /**
             * Properties of a BuildMetrics.
             * @memberof build_event_stream
             * @interface IBuildMetrics
             * @property {build_event_stream.BuildMetrics.IActionSummary|null} [actionSummary] BuildMetrics actionSummary
             * @property {build_event_stream.BuildMetrics.IMemoryMetrics|null} [memoryMetrics] BuildMetrics memoryMetrics
             * @property {build_event_stream.BuildMetrics.ITargetMetrics|null} [targetMetrics] BuildMetrics targetMetrics
             * @property {build_event_stream.BuildMetrics.IPackageMetrics|null} [packageMetrics] BuildMetrics packageMetrics
             */
            /**
             * Constructs a new BuildMetrics.
             * @memberof build_event_stream
             * @classdesc Represents a BuildMetrics.
             * @implements IBuildMetrics
             * @constructor
             * @param {build_event_stream.IBuildMetrics=} [properties] Properties to set
             */
            function BuildMetrics(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * BuildMetrics actionSummary.
             * @member {build_event_stream.BuildMetrics.IActionSummary|null|undefined} actionSummary
             * @memberof build_event_stream.BuildMetrics
             * @instance
             */
            BuildMetrics.prototype.actionSummary = null;
            /**
             * BuildMetrics memoryMetrics.
             * @member {build_event_stream.BuildMetrics.IMemoryMetrics|null|undefined} memoryMetrics
             * @memberof build_event_stream.BuildMetrics
             * @instance
             */
            BuildMetrics.prototype.memoryMetrics = null;
            /**
             * BuildMetrics targetMetrics.
             * @member {build_event_stream.BuildMetrics.ITargetMetrics|null|undefined} targetMetrics
             * @memberof build_event_stream.BuildMetrics
             * @instance
             */
            BuildMetrics.prototype.targetMetrics = null;
            /**
             * BuildMetrics packageMetrics.
             * @member {build_event_stream.BuildMetrics.IPackageMetrics|null|undefined} packageMetrics
             * @memberof build_event_stream.BuildMetrics
             * @instance
             */
            BuildMetrics.prototype.packageMetrics = null;
            /**
             * Creates a new BuildMetrics instance using the specified properties.
             * @function create
             * @memberof build_event_stream.BuildMetrics
             * @static
             * @param {build_event_stream.IBuildMetrics=} [properties] Properties to set
             * @returns {build_event_stream.BuildMetrics} BuildMetrics instance
             */
            BuildMetrics.create = function create(properties) {
                return new BuildMetrics(properties);
            };
            /**
             * Encodes the specified BuildMetrics message. Does not implicitly {@link build_event_stream.BuildMetrics.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.BuildMetrics
             * @static
             * @param {build_event_stream.IBuildMetrics} message BuildMetrics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildMetrics.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actionSummary != null && message.hasOwnProperty("actionSummary"))
                    $root.build_event_stream.BuildMetrics.ActionSummary.encode(message.actionSummary, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                if (message.memoryMetrics != null && message.hasOwnProperty("memoryMetrics"))
                    $root.build_event_stream.BuildMetrics.MemoryMetrics.encode(message.memoryMetrics, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.targetMetrics != null && message.hasOwnProperty("targetMetrics"))
                    $root.build_event_stream.BuildMetrics.TargetMetrics.encode(message.targetMetrics, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                if (message.packageMetrics != null && message.hasOwnProperty("packageMetrics"))
                    $root.build_event_stream.BuildMetrics.PackageMetrics.encode(message.packageMetrics, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified BuildMetrics message, length delimited. Does not implicitly {@link build_event_stream.BuildMetrics.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.BuildMetrics
             * @static
             * @param {build_event_stream.IBuildMetrics} message BuildMetrics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a BuildMetrics message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.BuildMetrics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.BuildMetrics} BuildMetrics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildMetrics.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildMetrics();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.actionSummary = $root.build_event_stream.BuildMetrics.ActionSummary.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.memoryMetrics = $root.build_event_stream.BuildMetrics.MemoryMetrics.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.targetMetrics = $root.build_event_stream.BuildMetrics.TargetMetrics.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.packageMetrics = $root.build_event_stream.BuildMetrics.PackageMetrics.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a BuildMetrics message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.BuildMetrics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.BuildMetrics} BuildMetrics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildMetrics.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a BuildMetrics message.
             * @function verify
             * @memberof build_event_stream.BuildMetrics
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BuildMetrics.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actionSummary != null && message.hasOwnProperty("actionSummary")) {
                    var error = $root.build_event_stream.BuildMetrics.ActionSummary.verify(message.actionSummary);
                    if (error)
                        return "actionSummary." + error;
                }
                if (message.memoryMetrics != null && message.hasOwnProperty("memoryMetrics")) {
                    var error = $root.build_event_stream.BuildMetrics.MemoryMetrics.verify(message.memoryMetrics);
                    if (error)
                        return "memoryMetrics." + error;
                }
                if (message.targetMetrics != null && message.hasOwnProperty("targetMetrics")) {
                    var error = $root.build_event_stream.BuildMetrics.TargetMetrics.verify(message.targetMetrics);
                    if (error)
                        return "targetMetrics." + error;
                }
                if (message.packageMetrics != null && message.hasOwnProperty("packageMetrics")) {
                    var error = $root.build_event_stream.BuildMetrics.PackageMetrics.verify(message.packageMetrics);
                    if (error)
                        return "packageMetrics." + error;
                }
                return null;
            };
            /**
             * Creates a BuildMetrics message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.BuildMetrics
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.BuildMetrics} BuildMetrics
             */
            BuildMetrics.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.BuildMetrics)
                    return object;
                var message = new $root.build_event_stream.BuildMetrics();
                if (object.actionSummary != null) {
                    if (typeof object.actionSummary !== "object")
                        throw TypeError(".build_event_stream.BuildMetrics.actionSummary: object expected");
                    message.actionSummary = $root.build_event_stream.BuildMetrics.ActionSummary.fromObject(object.actionSummary);
                }
                if (object.memoryMetrics != null) {
                    if (typeof object.memoryMetrics !== "object")
                        throw TypeError(".build_event_stream.BuildMetrics.memoryMetrics: object expected");
                    message.memoryMetrics = $root.build_event_stream.BuildMetrics.MemoryMetrics.fromObject(object.memoryMetrics);
                }
                if (object.targetMetrics != null) {
                    if (typeof object.targetMetrics !== "object")
                        throw TypeError(".build_event_stream.BuildMetrics.targetMetrics: object expected");
                    message.targetMetrics = $root.build_event_stream.BuildMetrics.TargetMetrics.fromObject(object.targetMetrics);
                }
                if (object.packageMetrics != null) {
                    if (typeof object.packageMetrics !== "object")
                        throw TypeError(".build_event_stream.BuildMetrics.packageMetrics: object expected");
                    message.packageMetrics = $root.build_event_stream.BuildMetrics.PackageMetrics.fromObject(object.packageMetrics);
                }
                return message;
            };
            /**
             * Creates a plain object from a BuildMetrics message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.BuildMetrics
             * @static
             * @param {build_event_stream.BuildMetrics} message BuildMetrics
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BuildMetrics.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.actionSummary = null;
                    object.memoryMetrics = null;
                    object.targetMetrics = null;
                    object.packageMetrics = null;
                }
                if (message.actionSummary != null && message.hasOwnProperty("actionSummary"))
                    object.actionSummary = $root.build_event_stream.BuildMetrics.ActionSummary.toObject(message.actionSummary, options);
                if (message.memoryMetrics != null && message.hasOwnProperty("memoryMetrics"))
                    object.memoryMetrics = $root.build_event_stream.BuildMetrics.MemoryMetrics.toObject(message.memoryMetrics, options);
                if (message.targetMetrics != null && message.hasOwnProperty("targetMetrics"))
                    object.targetMetrics = $root.build_event_stream.BuildMetrics.TargetMetrics.toObject(message.targetMetrics, options);
                if (message.packageMetrics != null && message.hasOwnProperty("packageMetrics"))
                    object.packageMetrics = $root.build_event_stream.BuildMetrics.PackageMetrics.toObject(message.packageMetrics, options);
                return object;
            };
            /**
             * Converts this BuildMetrics to JSON.
             * @function toJSON
             * @memberof build_event_stream.BuildMetrics
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BuildMetrics.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            BuildMetrics.ActionSummary = (function () {
                /**
                 * Properties of an ActionSummary.
                 * @memberof build_event_stream.BuildMetrics
                 * @interface IActionSummary
                 * @property {number|Long|null} [actionsCreated] ActionSummary actionsCreated
                 * @property {number|Long|null} [actionsExecuted] ActionSummary actionsExecuted
                 */
                /**
                 * Constructs a new ActionSummary.
                 * @memberof build_event_stream.BuildMetrics
                 * @classdesc Represents an ActionSummary.
                 * @implements IActionSummary
                 * @constructor
                 * @param {build_event_stream.BuildMetrics.IActionSummary=} [properties] Properties to set
                 */
                function ActionSummary(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ActionSummary actionsCreated.
                 * @member {number|Long} actionsCreated
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @instance
                 */
                ActionSummary.prototype.actionsCreated = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                /**
                 * ActionSummary actionsExecuted.
                 * @member {number|Long} actionsExecuted
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @instance
                 */
                ActionSummary.prototype.actionsExecuted = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                /**
                 * Creates a new ActionSummary instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @static
                 * @param {build_event_stream.BuildMetrics.IActionSummary=} [properties] Properties to set
                 * @returns {build_event_stream.BuildMetrics.ActionSummary} ActionSummary instance
                 */
                ActionSummary.create = function create(properties) {
                    return new ActionSummary(properties);
                };
                /**
                 * Encodes the specified ActionSummary message. Does not implicitly {@link build_event_stream.BuildMetrics.ActionSummary.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @static
                 * @param {build_event_stream.BuildMetrics.IActionSummary} message ActionSummary message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionSummary.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionsCreated != null && message.hasOwnProperty("actionsCreated"))
                        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.actionsCreated);
                    if (message.actionsExecuted != null && message.hasOwnProperty("actionsExecuted"))
                        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.actionsExecuted);
                    return writer;
                };
                /**
                 * Encodes the specified ActionSummary message, length delimited. Does not implicitly {@link build_event_stream.BuildMetrics.ActionSummary.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @static
                 * @param {build_event_stream.BuildMetrics.IActionSummary} message ActionSummary message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionSummary.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an ActionSummary message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildMetrics.ActionSummary} ActionSummary
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionSummary.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildMetrics.ActionSummary();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.actionsCreated = reader.int64();
                                break;
                            case 2:
                                message.actionsExecuted = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an ActionSummary message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildMetrics.ActionSummary} ActionSummary
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionSummary.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an ActionSummary message.
                 * @function verify
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActionSummary.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionsCreated != null && message.hasOwnProperty("actionsCreated"))
                        if (!$util.isInteger(message.actionsCreated) && !(message.actionsCreated && $util.isInteger(message.actionsCreated.low) && $util.isInteger(message.actionsCreated.high)))
                            return "actionsCreated: integer|Long expected";
                    if (message.actionsExecuted != null && message.hasOwnProperty("actionsExecuted"))
                        if (!$util.isInteger(message.actionsExecuted) && !(message.actionsExecuted && $util.isInteger(message.actionsExecuted.low) && $util.isInteger(message.actionsExecuted.high)))
                            return "actionsExecuted: integer|Long expected";
                    return null;
                };
                /**
                 * Creates an ActionSummary message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildMetrics.ActionSummary} ActionSummary
                 */
                ActionSummary.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildMetrics.ActionSummary)
                        return object;
                    var message = new $root.build_event_stream.BuildMetrics.ActionSummary();
                    if (object.actionsCreated != null)
                        if ($util.Long)
                            (message.actionsCreated = $util.Long.fromValue(object.actionsCreated)).unsigned = false;
                        else if (typeof object.actionsCreated === "string")
                            message.actionsCreated = parseInt(object.actionsCreated, 10);
                        else if (typeof object.actionsCreated === "number")
                            message.actionsCreated = object.actionsCreated;
                        else if (typeof object.actionsCreated === "object")
                            message.actionsCreated = new $util.LongBits(object.actionsCreated.low >>> 0, object.actionsCreated.high >>> 0).toNumber();
                    if (object.actionsExecuted != null)
                        if ($util.Long)
                            (message.actionsExecuted = $util.Long.fromValue(object.actionsExecuted)).unsigned = false;
                        else if (typeof object.actionsExecuted === "string")
                            message.actionsExecuted = parseInt(object.actionsExecuted, 10);
                        else if (typeof object.actionsExecuted === "number")
                            message.actionsExecuted = object.actionsExecuted;
                        else if (typeof object.actionsExecuted === "object")
                            message.actionsExecuted = new $util.LongBits(object.actionsExecuted.low >>> 0, object.actionsExecuted.high >>> 0).toNumber();
                    return message;
                };
                /**
                 * Creates a plain object from an ActionSummary message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @static
                 * @param {build_event_stream.BuildMetrics.ActionSummary} message ActionSummary
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActionSummary.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.actionsCreated = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.actionsCreated = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.actionsExecuted = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.actionsExecuted = options.longs === String ? "0" : 0;
                    }
                    if (message.actionsCreated != null && message.hasOwnProperty("actionsCreated"))
                        if (typeof message.actionsCreated === "number")
                            object.actionsCreated = options.longs === String ? String(message.actionsCreated) : message.actionsCreated;
                        else
                            object.actionsCreated = options.longs === String ? $util.Long.prototype.toString.call(message.actionsCreated) : options.longs === Number ? new $util.LongBits(message.actionsCreated.low >>> 0, message.actionsCreated.high >>> 0).toNumber() : message.actionsCreated;
                    if (message.actionsExecuted != null && message.hasOwnProperty("actionsExecuted"))
                        if (typeof message.actionsExecuted === "number")
                            object.actionsExecuted = options.longs === String ? String(message.actionsExecuted) : message.actionsExecuted;
                        else
                            object.actionsExecuted = options.longs === String ? $util.Long.prototype.toString.call(message.actionsExecuted) : options.longs === Number ? new $util.LongBits(message.actionsExecuted.low >>> 0, message.actionsExecuted.high >>> 0).toNumber() : message.actionsExecuted;
                    return object;
                };
                /**
                 * Converts this ActionSummary to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildMetrics.ActionSummary
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActionSummary.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return ActionSummary;
            })();
            BuildMetrics.MemoryMetrics = (function () {
                /**
                 * Properties of a MemoryMetrics.
                 * @memberof build_event_stream.BuildMetrics
                 * @interface IMemoryMetrics
                 * @property {number|Long|null} [usedHeapSizePostBuild] MemoryMetrics usedHeapSizePostBuild
                 */
                /**
                 * Constructs a new MemoryMetrics.
                 * @memberof build_event_stream.BuildMetrics
                 * @classdesc Represents a MemoryMetrics.
                 * @implements IMemoryMetrics
                 * @constructor
                 * @param {build_event_stream.BuildMetrics.IMemoryMetrics=} [properties] Properties to set
                 */
                function MemoryMetrics(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * MemoryMetrics usedHeapSizePostBuild.
                 * @member {number|Long} usedHeapSizePostBuild
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @instance
                 */
                MemoryMetrics.prototype.usedHeapSizePostBuild = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                /**
                 * Creates a new MemoryMetrics instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.IMemoryMetrics=} [properties] Properties to set
                 * @returns {build_event_stream.BuildMetrics.MemoryMetrics} MemoryMetrics instance
                 */
                MemoryMetrics.create = function create(properties) {
                    return new MemoryMetrics(properties);
                };
                /**
                 * Encodes the specified MemoryMetrics message. Does not implicitly {@link build_event_stream.BuildMetrics.MemoryMetrics.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.IMemoryMetrics} message MemoryMetrics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemoryMetrics.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.usedHeapSizePostBuild != null && message.hasOwnProperty("usedHeapSizePostBuild"))
                        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.usedHeapSizePostBuild);
                    return writer;
                };
                /**
                 * Encodes the specified MemoryMetrics message, length delimited. Does not implicitly {@link build_event_stream.BuildMetrics.MemoryMetrics.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.IMemoryMetrics} message MemoryMetrics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemoryMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a MemoryMetrics message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildMetrics.MemoryMetrics} MemoryMetrics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemoryMetrics.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildMetrics.MemoryMetrics();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.usedHeapSizePostBuild = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a MemoryMetrics message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildMetrics.MemoryMetrics} MemoryMetrics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemoryMetrics.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a MemoryMetrics message.
                 * @function verify
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MemoryMetrics.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.usedHeapSizePostBuild != null && message.hasOwnProperty("usedHeapSizePostBuild"))
                        if (!$util.isInteger(message.usedHeapSizePostBuild) && !(message.usedHeapSizePostBuild && $util.isInteger(message.usedHeapSizePostBuild.low) && $util.isInteger(message.usedHeapSizePostBuild.high)))
                            return "usedHeapSizePostBuild: integer|Long expected";
                    return null;
                };
                /**
                 * Creates a MemoryMetrics message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildMetrics.MemoryMetrics} MemoryMetrics
                 */
                MemoryMetrics.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildMetrics.MemoryMetrics)
                        return object;
                    var message = new $root.build_event_stream.BuildMetrics.MemoryMetrics();
                    if (object.usedHeapSizePostBuild != null)
                        if ($util.Long)
                            (message.usedHeapSizePostBuild = $util.Long.fromValue(object.usedHeapSizePostBuild)).unsigned = false;
                        else if (typeof object.usedHeapSizePostBuild === "string")
                            message.usedHeapSizePostBuild = parseInt(object.usedHeapSizePostBuild, 10);
                        else if (typeof object.usedHeapSizePostBuild === "number")
                            message.usedHeapSizePostBuild = object.usedHeapSizePostBuild;
                        else if (typeof object.usedHeapSizePostBuild === "object")
                            message.usedHeapSizePostBuild = new $util.LongBits(object.usedHeapSizePostBuild.low >>> 0, object.usedHeapSizePostBuild.high >>> 0).toNumber();
                    return message;
                };
                /**
                 * Creates a plain object from a MemoryMetrics message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.MemoryMetrics} message MemoryMetrics
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MemoryMetrics.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.usedHeapSizePostBuild = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.usedHeapSizePostBuild = options.longs === String ? "0" : 0;
                    if (message.usedHeapSizePostBuild != null && message.hasOwnProperty("usedHeapSizePostBuild"))
                        if (typeof message.usedHeapSizePostBuild === "number")
                            object.usedHeapSizePostBuild = options.longs === String ? String(message.usedHeapSizePostBuild) : message.usedHeapSizePostBuild;
                        else
                            object.usedHeapSizePostBuild = options.longs === String ? $util.Long.prototype.toString.call(message.usedHeapSizePostBuild) : options.longs === Number ? new $util.LongBits(message.usedHeapSizePostBuild.low >>> 0, message.usedHeapSizePostBuild.high >>> 0).toNumber() : message.usedHeapSizePostBuild;
                    return object;
                };
                /**
                 * Converts this MemoryMetrics to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildMetrics.MemoryMetrics
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MemoryMetrics.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return MemoryMetrics;
            })();
            BuildMetrics.TargetMetrics = (function () {
                /**
                 * Properties of a TargetMetrics.
                 * @memberof build_event_stream.BuildMetrics
                 * @interface ITargetMetrics
                 * @property {number|Long|null} [targetsLoaded] TargetMetrics targetsLoaded
                 * @property {number|Long|null} [targetsConfigured] TargetMetrics targetsConfigured
                 */
                /**
                 * Constructs a new TargetMetrics.
                 * @memberof build_event_stream.BuildMetrics
                 * @classdesc Represents a TargetMetrics.
                 * @implements ITargetMetrics
                 * @constructor
                 * @param {build_event_stream.BuildMetrics.ITargetMetrics=} [properties] Properties to set
                 */
                function TargetMetrics(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * TargetMetrics targetsLoaded.
                 * @member {number|Long} targetsLoaded
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @instance
                 */
                TargetMetrics.prototype.targetsLoaded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                /**
                 * TargetMetrics targetsConfigured.
                 * @member {number|Long} targetsConfigured
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @instance
                 */
                TargetMetrics.prototype.targetsConfigured = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                /**
                 * Creates a new TargetMetrics instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.ITargetMetrics=} [properties] Properties to set
                 * @returns {build_event_stream.BuildMetrics.TargetMetrics} TargetMetrics instance
                 */
                TargetMetrics.create = function create(properties) {
                    return new TargetMetrics(properties);
                };
                /**
                 * Encodes the specified TargetMetrics message. Does not implicitly {@link build_event_stream.BuildMetrics.TargetMetrics.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.ITargetMetrics} message TargetMetrics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TargetMetrics.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetsLoaded != null && message.hasOwnProperty("targetsLoaded"))
                        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.targetsLoaded);
                    if (message.targetsConfigured != null && message.hasOwnProperty("targetsConfigured"))
                        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.targetsConfigured);
                    return writer;
                };
                /**
                 * Encodes the specified TargetMetrics message, length delimited. Does not implicitly {@link build_event_stream.BuildMetrics.TargetMetrics.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.ITargetMetrics} message TargetMetrics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TargetMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a TargetMetrics message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildMetrics.TargetMetrics} TargetMetrics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TargetMetrics.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildMetrics.TargetMetrics();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.targetsLoaded = reader.int64();
                                break;
                            case 2:
                                message.targetsConfigured = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a TargetMetrics message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildMetrics.TargetMetrics} TargetMetrics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TargetMetrics.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a TargetMetrics message.
                 * @function verify
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TargetMetrics.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetsLoaded != null && message.hasOwnProperty("targetsLoaded"))
                        if (!$util.isInteger(message.targetsLoaded) && !(message.targetsLoaded && $util.isInteger(message.targetsLoaded.low) && $util.isInteger(message.targetsLoaded.high)))
                            return "targetsLoaded: integer|Long expected";
                    if (message.targetsConfigured != null && message.hasOwnProperty("targetsConfigured"))
                        if (!$util.isInteger(message.targetsConfigured) && !(message.targetsConfigured && $util.isInteger(message.targetsConfigured.low) && $util.isInteger(message.targetsConfigured.high)))
                            return "targetsConfigured: integer|Long expected";
                    return null;
                };
                /**
                 * Creates a TargetMetrics message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildMetrics.TargetMetrics} TargetMetrics
                 */
                TargetMetrics.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildMetrics.TargetMetrics)
                        return object;
                    var message = new $root.build_event_stream.BuildMetrics.TargetMetrics();
                    if (object.targetsLoaded != null)
                        if ($util.Long)
                            (message.targetsLoaded = $util.Long.fromValue(object.targetsLoaded)).unsigned = false;
                        else if (typeof object.targetsLoaded === "string")
                            message.targetsLoaded = parseInt(object.targetsLoaded, 10);
                        else if (typeof object.targetsLoaded === "number")
                            message.targetsLoaded = object.targetsLoaded;
                        else if (typeof object.targetsLoaded === "object")
                            message.targetsLoaded = new $util.LongBits(object.targetsLoaded.low >>> 0, object.targetsLoaded.high >>> 0).toNumber();
                    if (object.targetsConfigured != null)
                        if ($util.Long)
                            (message.targetsConfigured = $util.Long.fromValue(object.targetsConfigured)).unsigned = false;
                        else if (typeof object.targetsConfigured === "string")
                            message.targetsConfigured = parseInt(object.targetsConfigured, 10);
                        else if (typeof object.targetsConfigured === "number")
                            message.targetsConfigured = object.targetsConfigured;
                        else if (typeof object.targetsConfigured === "object")
                            message.targetsConfigured = new $util.LongBits(object.targetsConfigured.low >>> 0, object.targetsConfigured.high >>> 0).toNumber();
                    return message;
                };
                /**
                 * Creates a plain object from a TargetMetrics message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.TargetMetrics} message TargetMetrics
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TargetMetrics.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.targetsLoaded = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.targetsLoaded = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.targetsConfigured = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.targetsConfigured = options.longs === String ? "0" : 0;
                    }
                    if (message.targetsLoaded != null && message.hasOwnProperty("targetsLoaded"))
                        if (typeof message.targetsLoaded === "number")
                            object.targetsLoaded = options.longs === String ? String(message.targetsLoaded) : message.targetsLoaded;
                        else
                            object.targetsLoaded = options.longs === String ? $util.Long.prototype.toString.call(message.targetsLoaded) : options.longs === Number ? new $util.LongBits(message.targetsLoaded.low >>> 0, message.targetsLoaded.high >>> 0).toNumber() : message.targetsLoaded;
                    if (message.targetsConfigured != null && message.hasOwnProperty("targetsConfigured"))
                        if (typeof message.targetsConfigured === "number")
                            object.targetsConfigured = options.longs === String ? String(message.targetsConfigured) : message.targetsConfigured;
                        else
                            object.targetsConfigured = options.longs === String ? $util.Long.prototype.toString.call(message.targetsConfigured) : options.longs === Number ? new $util.LongBits(message.targetsConfigured.low >>> 0, message.targetsConfigured.high >>> 0).toNumber() : message.targetsConfigured;
                    return object;
                };
                /**
                 * Converts this TargetMetrics to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildMetrics.TargetMetrics
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TargetMetrics.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return TargetMetrics;
            })();
            BuildMetrics.PackageMetrics = (function () {
                /**
                 * Properties of a PackageMetrics.
                 * @memberof build_event_stream.BuildMetrics
                 * @interface IPackageMetrics
                 * @property {number|Long|null} [packagesLoaded] PackageMetrics packagesLoaded
                 */
                /**
                 * Constructs a new PackageMetrics.
                 * @memberof build_event_stream.BuildMetrics
                 * @classdesc Represents a PackageMetrics.
                 * @implements IPackageMetrics
                 * @constructor
                 * @param {build_event_stream.BuildMetrics.IPackageMetrics=} [properties] Properties to set
                 */
                function PackageMetrics(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * PackageMetrics packagesLoaded.
                 * @member {number|Long} packagesLoaded
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @instance
                 */
                PackageMetrics.prototype.packagesLoaded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                /**
                 * Creates a new PackageMetrics instance using the specified properties.
                 * @function create
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.IPackageMetrics=} [properties] Properties to set
                 * @returns {build_event_stream.BuildMetrics.PackageMetrics} PackageMetrics instance
                 */
                PackageMetrics.create = function create(properties) {
                    return new PackageMetrics(properties);
                };
                /**
                 * Encodes the specified PackageMetrics message. Does not implicitly {@link build_event_stream.BuildMetrics.PackageMetrics.verify|verify} messages.
                 * @function encode
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.IPackageMetrics} message PackageMetrics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PackageMetrics.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.packagesLoaded != null && message.hasOwnProperty("packagesLoaded"))
                        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.packagesLoaded);
                    return writer;
                };
                /**
                 * Encodes the specified PackageMetrics message, length delimited. Does not implicitly {@link build_event_stream.BuildMetrics.PackageMetrics.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.IPackageMetrics} message PackageMetrics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PackageMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a PackageMetrics message from the specified reader or buffer.
                 * @function decode
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build_event_stream.BuildMetrics.PackageMetrics} PackageMetrics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PackageMetrics.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildMetrics.PackageMetrics();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.packagesLoaded = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a PackageMetrics message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build_event_stream.BuildMetrics.PackageMetrics} PackageMetrics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PackageMetrics.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a PackageMetrics message.
                 * @function verify
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PackageMetrics.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.packagesLoaded != null && message.hasOwnProperty("packagesLoaded"))
                        if (!$util.isInteger(message.packagesLoaded) && !(message.packagesLoaded && $util.isInteger(message.packagesLoaded.low) && $util.isInteger(message.packagesLoaded.high)))
                            return "packagesLoaded: integer|Long expected";
                    return null;
                };
                /**
                 * Creates a PackageMetrics message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build_event_stream.BuildMetrics.PackageMetrics} PackageMetrics
                 */
                PackageMetrics.fromObject = function fromObject(object) {
                    if (object instanceof $root.build_event_stream.BuildMetrics.PackageMetrics)
                        return object;
                    var message = new $root.build_event_stream.BuildMetrics.PackageMetrics();
                    if (object.packagesLoaded != null)
                        if ($util.Long)
                            (message.packagesLoaded = $util.Long.fromValue(object.packagesLoaded)).unsigned = false;
                        else if (typeof object.packagesLoaded === "string")
                            message.packagesLoaded = parseInt(object.packagesLoaded, 10);
                        else if (typeof object.packagesLoaded === "number")
                            message.packagesLoaded = object.packagesLoaded;
                        else if (typeof object.packagesLoaded === "object")
                            message.packagesLoaded = new $util.LongBits(object.packagesLoaded.low >>> 0, object.packagesLoaded.high >>> 0).toNumber();
                    return message;
                };
                /**
                 * Creates a plain object from a PackageMetrics message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @static
                 * @param {build_event_stream.BuildMetrics.PackageMetrics} message PackageMetrics
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PackageMetrics.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.packagesLoaded = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.packagesLoaded = options.longs === String ? "0" : 0;
                    if (message.packagesLoaded != null && message.hasOwnProperty("packagesLoaded"))
                        if (typeof message.packagesLoaded === "number")
                            object.packagesLoaded = options.longs === String ? String(message.packagesLoaded) : message.packagesLoaded;
                        else
                            object.packagesLoaded = options.longs === String ? $util.Long.prototype.toString.call(message.packagesLoaded) : options.longs === Number ? new $util.LongBits(message.packagesLoaded.low >>> 0, message.packagesLoaded.high >>> 0).toNumber() : message.packagesLoaded;
                    return object;
                };
                /**
                 * Converts this PackageMetrics to JSON.
                 * @function toJSON
                 * @memberof build_event_stream.BuildMetrics.PackageMetrics
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PackageMetrics.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return PackageMetrics;
            })();
            return BuildMetrics;
        })();
        build_event_stream.BuildToolLogs = (function () {
            /**
             * Properties of a BuildToolLogs.
             * @memberof build_event_stream
             * @interface IBuildToolLogs
             * @property {Array.<build_event_stream.IFile>|null} [log] BuildToolLogs log
             */
            /**
             * Constructs a new BuildToolLogs.
             * @memberof build_event_stream
             * @classdesc Represents a BuildToolLogs.
             * @implements IBuildToolLogs
             * @constructor
             * @param {build_event_stream.IBuildToolLogs=} [properties] Properties to set
             */
            function BuildToolLogs(properties) {
                this.log = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * BuildToolLogs log.
             * @member {Array.<build_event_stream.IFile>} log
             * @memberof build_event_stream.BuildToolLogs
             * @instance
             */
            BuildToolLogs.prototype.log = $util.emptyArray;
            /**
             * Creates a new BuildToolLogs instance using the specified properties.
             * @function create
             * @memberof build_event_stream.BuildToolLogs
             * @static
             * @param {build_event_stream.IBuildToolLogs=} [properties] Properties to set
             * @returns {build_event_stream.BuildToolLogs} BuildToolLogs instance
             */
            BuildToolLogs.create = function create(properties) {
                return new BuildToolLogs(properties);
            };
            /**
             * Encodes the specified BuildToolLogs message. Does not implicitly {@link build_event_stream.BuildToolLogs.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.BuildToolLogs
             * @static
             * @param {build_event_stream.IBuildToolLogs} message BuildToolLogs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildToolLogs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.log != null && message.log.length)
                    for (var i = 0; i < message.log.length; ++i)
                        $root.build_event_stream.File.encode(message.log[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified BuildToolLogs message, length delimited. Does not implicitly {@link build_event_stream.BuildToolLogs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.BuildToolLogs
             * @static
             * @param {build_event_stream.IBuildToolLogs} message BuildToolLogs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildToolLogs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a BuildToolLogs message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.BuildToolLogs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.BuildToolLogs} BuildToolLogs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildToolLogs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildToolLogs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.log && message.log.length))
                                message.log = [];
                            message.log.push($root.build_event_stream.File.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a BuildToolLogs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.BuildToolLogs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.BuildToolLogs} BuildToolLogs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildToolLogs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a BuildToolLogs message.
             * @function verify
             * @memberof build_event_stream.BuildToolLogs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BuildToolLogs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.log != null && message.hasOwnProperty("log")) {
                    if (!Array.isArray(message.log))
                        return "log: array expected";
                    for (var i = 0; i < message.log.length; ++i) {
                        var error = $root.build_event_stream.File.verify(message.log[i]);
                        if (error)
                            return "log." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a BuildToolLogs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.BuildToolLogs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.BuildToolLogs} BuildToolLogs
             */
            BuildToolLogs.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.BuildToolLogs)
                    return object;
                var message = new $root.build_event_stream.BuildToolLogs();
                if (object.log) {
                    if (!Array.isArray(object.log))
                        throw TypeError(".build_event_stream.BuildToolLogs.log: array expected");
                    message.log = [];
                    for (var i = 0; i < object.log.length; ++i) {
                        if (typeof object.log[i] !== "object")
                            throw TypeError(".build_event_stream.BuildToolLogs.log: object expected");
                        message.log[i] = $root.build_event_stream.File.fromObject(object.log[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a BuildToolLogs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.BuildToolLogs
             * @static
             * @param {build_event_stream.BuildToolLogs} message BuildToolLogs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BuildToolLogs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.log = [];
                if (message.log && message.log.length) {
                    object.log = [];
                    for (var j = 0; j < message.log.length; ++j)
                        object.log[j] = $root.build_event_stream.File.toObject(message.log[j], options);
                }
                return object;
            };
            /**
             * Converts this BuildToolLogs to JSON.
             * @function toJSON
             * @memberof build_event_stream.BuildToolLogs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BuildToolLogs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return BuildToolLogs;
        })();
        build_event_stream.BuildEvent = (function () {
            /**
             * Properties of a BuildEvent.
             * @memberof build_event_stream
             * @interface IBuildEvent
             * @property {build_event_stream.IBuildEventId|null} [id] BuildEvent id
             * @property {Array.<build_event_stream.IBuildEventId>|null} [children] BuildEvent children
             * @property {boolean|null} [lastMessage] BuildEvent lastMessage
             * @property {build_event_stream.IProgress|null} [progress] BuildEvent progress
             * @property {build_event_stream.IAborted|null} [aborted] BuildEvent aborted
             * @property {build_event_stream.IBuildStarted|null} [started] BuildEvent started
             * @property {build_event_stream.IUnstructuredCommandLine|null} [unstructuredCommandLine] BuildEvent unstructuredCommandLine
             * @property {command_line.ICommandLine|null} [structuredCommandLine] BuildEvent structuredCommandLine
             * @property {build_event_stream.IOptionsParsed|null} [optionsParsed] BuildEvent optionsParsed
             * @property {build_event_stream.IWorkspaceStatus|null} [workspaceStatus] BuildEvent workspaceStatus
             * @property {build_event_stream.IFetch|null} [fetch] BuildEvent fetch
             * @property {build_event_stream.IConfiguration|null} [configuration] BuildEvent configuration
             * @property {build_event_stream.IPatternExpanded|null} [expanded] BuildEvent expanded
             * @property {build_event_stream.ITargetConfigured|null} [configured] BuildEvent configured
             * @property {build_event_stream.IActionExecuted|null} [action] BuildEvent action
             * @property {build_event_stream.INamedSetOfFiles|null} [namedSetOfFiles] BuildEvent namedSetOfFiles
             * @property {build_event_stream.ITargetComplete|null} [completed] BuildEvent completed
             * @property {build_event_stream.ITestResult|null} [testResult] BuildEvent testResult
             * @property {build_event_stream.ITestSummary|null} [testSummary] BuildEvent testSummary
             * @property {build_event_stream.IBuildFinished|null} [finished] BuildEvent finished
             * @property {build_event_stream.IBuildToolLogs|null} [buildToolLogs] BuildEvent buildToolLogs
             * @property {build_event_stream.IBuildMetrics|null} [buildMetrics] BuildEvent buildMetrics
             */
            /**
             * Constructs a new BuildEvent.
             * @memberof build_event_stream
             * @classdesc Represents a BuildEvent.
             * @implements IBuildEvent
             * @constructor
             * @param {build_event_stream.IBuildEvent=} [properties] Properties to set
             */
            function BuildEvent(properties) {
                this.children = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * BuildEvent id.
             * @member {build_event_stream.IBuildEventId|null|undefined} id
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.id = null;
            /**
             * BuildEvent children.
             * @member {Array.<build_event_stream.IBuildEventId>} children
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.children = $util.emptyArray;
            /**
             * BuildEvent lastMessage.
             * @member {boolean} lastMessage
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.lastMessage = false;
            /**
             * BuildEvent progress.
             * @member {build_event_stream.IProgress|null|undefined} progress
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.progress = null;
            /**
             * BuildEvent aborted.
             * @member {build_event_stream.IAborted|null|undefined} aborted
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.aborted = null;
            /**
             * BuildEvent started.
             * @member {build_event_stream.IBuildStarted|null|undefined} started
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.started = null;
            /**
             * BuildEvent unstructuredCommandLine.
             * @member {build_event_stream.IUnstructuredCommandLine|null|undefined} unstructuredCommandLine
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.unstructuredCommandLine = null;
            /**
             * BuildEvent structuredCommandLine.
             * @member {command_line.ICommandLine|null|undefined} structuredCommandLine
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.structuredCommandLine = null;
            /**
             * BuildEvent optionsParsed.
             * @member {build_event_stream.IOptionsParsed|null|undefined} optionsParsed
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.optionsParsed = null;
            /**
             * BuildEvent workspaceStatus.
             * @member {build_event_stream.IWorkspaceStatus|null|undefined} workspaceStatus
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.workspaceStatus = null;
            /**
             * BuildEvent fetch.
             * @member {build_event_stream.IFetch|null|undefined} fetch
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.fetch = null;
            /**
             * BuildEvent configuration.
             * @member {build_event_stream.IConfiguration|null|undefined} configuration
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.configuration = null;
            /**
             * BuildEvent expanded.
             * @member {build_event_stream.IPatternExpanded|null|undefined} expanded
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.expanded = null;
            /**
             * BuildEvent configured.
             * @member {build_event_stream.ITargetConfigured|null|undefined} configured
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.configured = null;
            /**
             * BuildEvent action.
             * @member {build_event_stream.IActionExecuted|null|undefined} action
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.action = null;
            /**
             * BuildEvent namedSetOfFiles.
             * @member {build_event_stream.INamedSetOfFiles|null|undefined} namedSetOfFiles
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.namedSetOfFiles = null;
            /**
             * BuildEvent completed.
             * @member {build_event_stream.ITargetComplete|null|undefined} completed
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.completed = null;
            /**
             * BuildEvent testResult.
             * @member {build_event_stream.ITestResult|null|undefined} testResult
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.testResult = null;
            /**
             * BuildEvent testSummary.
             * @member {build_event_stream.ITestSummary|null|undefined} testSummary
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.testSummary = null;
            /**
             * BuildEvent finished.
             * @member {build_event_stream.IBuildFinished|null|undefined} finished
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.finished = null;
            /**
             * BuildEvent buildToolLogs.
             * @member {build_event_stream.IBuildToolLogs|null|undefined} buildToolLogs
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.buildToolLogs = null;
            /**
             * BuildEvent buildMetrics.
             * @member {build_event_stream.IBuildMetrics|null|undefined} buildMetrics
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            BuildEvent.prototype.buildMetrics = null;
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
            /**
             * BuildEvent payload.
             * @member {"progress"|"aborted"|"started"|"unstructuredCommandLine"|"structuredCommandLine"|"optionsParsed"|"workspaceStatus"|"fetch"|"configuration"|"expanded"|"configured"|"action"|"namedSetOfFiles"|"completed"|"testResult"|"testSummary"|"finished"|"buildToolLogs"|"buildMetrics"|undefined} payload
             * @memberof build_event_stream.BuildEvent
             * @instance
             */
            Object.defineProperty(BuildEvent.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["progress", "aborted", "started", "unstructuredCommandLine", "structuredCommandLine", "optionsParsed", "workspaceStatus", "fetch", "configuration", "expanded", "configured", "action", "namedSetOfFiles", "completed", "testResult", "testSummary", "finished", "buildToolLogs", "buildMetrics"]),
                set: $util.oneOfSetter($oneOfFields)
            });
            /**
             * Creates a new BuildEvent instance using the specified properties.
             * @function create
             * @memberof build_event_stream.BuildEvent
             * @static
             * @param {build_event_stream.IBuildEvent=} [properties] Properties to set
             * @returns {build_event_stream.BuildEvent} BuildEvent instance
             */
            BuildEvent.create = function create(properties) {
                return new BuildEvent(properties);
            };
            /**
             * Encodes the specified BuildEvent message. Does not implicitly {@link build_event_stream.BuildEvent.verify|verify} messages.
             * @function encode
             * @memberof build_event_stream.BuildEvent
             * @static
             * @param {build_event_stream.IBuildEvent} message BuildEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    $root.build_event_stream.BuildEventId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                if (message.children != null && message.children.length)
                    for (var i = 0; i < message.children.length; ++i)
                        $root.build_event_stream.BuildEventId.encode(message.children[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.progress != null && message.hasOwnProperty("progress"))
                    $root.build_event_stream.Progress.encode(message.progress, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                if (message.aborted != null && message.hasOwnProperty("aborted"))
                    $root.build_event_stream.Aborted.encode(message.aborted, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.started != null && message.hasOwnProperty("started"))
                    $root.build_event_stream.BuildStarted.encode(message.started, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                if (message.expanded != null && message.hasOwnProperty("expanded"))
                    $root.build_event_stream.PatternExpanded.encode(message.expanded, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
                if (message.action != null && message.hasOwnProperty("action"))
                    $root.build_event_stream.ActionExecuted.encode(message.action, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
                if (message.completed != null && message.hasOwnProperty("completed"))
                    $root.build_event_stream.TargetComplete.encode(message.completed, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                if (message.testSummary != null && message.hasOwnProperty("testSummary"))
                    $root.build_event_stream.TestSummary.encode(message.testSummary, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
                if (message.testResult != null && message.hasOwnProperty("testResult"))
                    $root.build_event_stream.TestResult.encode(message.testResult, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
                if (message.unstructuredCommandLine != null && message.hasOwnProperty("unstructuredCommandLine"))
                    $root.build_event_stream.UnstructuredCommandLine.encode(message.unstructuredCommandLine, writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
                if (message.optionsParsed != null && message.hasOwnProperty("optionsParsed"))
                    $root.build_event_stream.OptionsParsed.encode(message.optionsParsed, writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
                if (message.finished != null && message.hasOwnProperty("finished"))
                    $root.build_event_stream.BuildFinished.encode(message.finished, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
                if (message.namedSetOfFiles != null && message.hasOwnProperty("namedSetOfFiles"))
                    $root.build_event_stream.NamedSetOfFiles.encode(message.namedSetOfFiles, writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
                if (message.workspaceStatus != null && message.hasOwnProperty("workspaceStatus"))
                    $root.build_event_stream.WorkspaceStatus.encode(message.workspaceStatus, writer.uint32(/* id 16, wireType 2 =*/ 130).fork()).ldelim();
                if (message.configuration != null && message.hasOwnProperty("configuration"))
                    $root.build_event_stream.Configuration.encode(message.configuration, writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
                if (message.configured != null && message.hasOwnProperty("configured"))
                    $root.build_event_stream.TargetConfigured.encode(message.configured, writer.uint32(/* id 18, wireType 2 =*/ 146).fork()).ldelim();
                if (message.lastMessage != null && message.hasOwnProperty("lastMessage"))
                    writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.lastMessage);
                if (message.fetch != null && message.hasOwnProperty("fetch"))
                    $root.build_event_stream.Fetch.encode(message.fetch, writer.uint32(/* id 21, wireType 2 =*/ 170).fork()).ldelim();
                if (message.structuredCommandLine != null && message.hasOwnProperty("structuredCommandLine"))
                    $root.command_line.CommandLine.encode(message.structuredCommandLine, writer.uint32(/* id 22, wireType 2 =*/ 178).fork()).ldelim();
                if (message.buildToolLogs != null && message.hasOwnProperty("buildToolLogs"))
                    $root.build_event_stream.BuildToolLogs.encode(message.buildToolLogs, writer.uint32(/* id 23, wireType 2 =*/ 186).fork()).ldelim();
                if (message.buildMetrics != null && message.hasOwnProperty("buildMetrics"))
                    $root.build_event_stream.BuildMetrics.encode(message.buildMetrics, writer.uint32(/* id 24, wireType 2 =*/ 194).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified BuildEvent message, length delimited. Does not implicitly {@link build_event_stream.BuildEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof build_event_stream.BuildEvent
             * @static
             * @param {build_event_stream.IBuildEvent} message BuildEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a BuildEvent message from the specified reader or buffer.
             * @function decode
             * @memberof build_event_stream.BuildEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {build_event_stream.BuildEvent} BuildEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.build_event_stream.BuildEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.id = $root.build_event_stream.BuildEventId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.children && message.children.length))
                                message.children = [];
                            message.children.push($root.build_event_stream.BuildEventId.decode(reader, reader.uint32()));
                            break;
                        case 20:
                            message.lastMessage = reader.bool();
                            break;
                        case 3:
                            message.progress = $root.build_event_stream.Progress.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.aborted = $root.build_event_stream.Aborted.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.started = $root.build_event_stream.BuildStarted.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.unstructuredCommandLine = $root.build_event_stream.UnstructuredCommandLine.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.structuredCommandLine = $root.command_line.CommandLine.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.optionsParsed = $root.build_event_stream.OptionsParsed.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.workspaceStatus = $root.build_event_stream.WorkspaceStatus.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.fetch = $root.build_event_stream.Fetch.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.configuration = $root.build_event_stream.Configuration.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.expanded = $root.build_event_stream.PatternExpanded.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.configured = $root.build_event_stream.TargetConfigured.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.action = $root.build_event_stream.ActionExecuted.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.namedSetOfFiles = $root.build_event_stream.NamedSetOfFiles.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.completed = $root.build_event_stream.TargetComplete.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.testResult = $root.build_event_stream.TestResult.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.testSummary = $root.build_event_stream.TestSummary.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.finished = $root.build_event_stream.BuildFinished.decode(reader, reader.uint32());
                            break;
                        case 23:
                            message.buildToolLogs = $root.build_event_stream.BuildToolLogs.decode(reader, reader.uint32());
                            break;
                        case 24:
                            message.buildMetrics = $root.build_event_stream.BuildMetrics.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a BuildEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof build_event_stream.BuildEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {build_event_stream.BuildEvent} BuildEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a BuildEvent message.
             * @function verify
             * @memberof build_event_stream.BuildEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BuildEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.id != null && message.hasOwnProperty("id")) {
                    var error = $root.build_event_stream.BuildEventId.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.children != null && message.hasOwnProperty("children")) {
                    if (!Array.isArray(message.children))
                        return "children: array expected";
                    for (var i = 0; i < message.children.length; ++i) {
                        var error = $root.build_event_stream.BuildEventId.verify(message.children[i]);
                        if (error)
                            return "children." + error;
                    }
                }
                if (message.lastMessage != null && message.hasOwnProperty("lastMessage"))
                    if (typeof message.lastMessage !== "boolean")
                        return "lastMessage: boolean expected";
                if (message.progress != null && message.hasOwnProperty("progress")) {
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.Progress.verify(message.progress);
                        if (error)
                            return "progress." + error;
                    }
                }
                if (message.aborted != null && message.hasOwnProperty("aborted")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.Aborted.verify(message.aborted);
                        if (error)
                            return "aborted." + error;
                    }
                }
                if (message.started != null && message.hasOwnProperty("started")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.BuildStarted.verify(message.started);
                        if (error)
                            return "started." + error;
                    }
                }
                if (message.unstructuredCommandLine != null && message.hasOwnProperty("unstructuredCommandLine")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.UnstructuredCommandLine.verify(message.unstructuredCommandLine);
                        if (error)
                            return "unstructuredCommandLine." + error;
                    }
                }
                if (message.structuredCommandLine != null && message.hasOwnProperty("structuredCommandLine")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.command_line.CommandLine.verify(message.structuredCommandLine);
                        if (error)
                            return "structuredCommandLine." + error;
                    }
                }
                if (message.optionsParsed != null && message.hasOwnProperty("optionsParsed")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.OptionsParsed.verify(message.optionsParsed);
                        if (error)
                            return "optionsParsed." + error;
                    }
                }
                if (message.workspaceStatus != null && message.hasOwnProperty("workspaceStatus")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.WorkspaceStatus.verify(message.workspaceStatus);
                        if (error)
                            return "workspaceStatus." + error;
                    }
                }
                if (message.fetch != null && message.hasOwnProperty("fetch")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.Fetch.verify(message.fetch);
                        if (error)
                            return "fetch." + error;
                    }
                }
                if (message.configuration != null && message.hasOwnProperty("configuration")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.Configuration.verify(message.configuration);
                        if (error)
                            return "configuration." + error;
                    }
                }
                if (message.expanded != null && message.hasOwnProperty("expanded")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.PatternExpanded.verify(message.expanded);
                        if (error)
                            return "expanded." + error;
                    }
                }
                if (message.configured != null && message.hasOwnProperty("configured")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.TargetConfigured.verify(message.configured);
                        if (error)
                            return "configured." + error;
                    }
                }
                if (message.action != null && message.hasOwnProperty("action")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.ActionExecuted.verify(message.action);
                        if (error)
                            return "action." + error;
                    }
                }
                if (message.namedSetOfFiles != null && message.hasOwnProperty("namedSetOfFiles")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.NamedSetOfFiles.verify(message.namedSetOfFiles);
                        if (error)
                            return "namedSetOfFiles." + error;
                    }
                }
                if (message.completed != null && message.hasOwnProperty("completed")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.TargetComplete.verify(message.completed);
                        if (error)
                            return "completed." + error;
                    }
                }
                if (message.testResult != null && message.hasOwnProperty("testResult")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.TestResult.verify(message.testResult);
                        if (error)
                            return "testResult." + error;
                    }
                }
                if (message.testSummary != null && message.hasOwnProperty("testSummary")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.TestSummary.verify(message.testSummary);
                        if (error)
                            return "testSummary." + error;
                    }
                }
                if (message.finished != null && message.hasOwnProperty("finished")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.BuildFinished.verify(message.finished);
                        if (error)
                            return "finished." + error;
                    }
                }
                if (message.buildToolLogs != null && message.hasOwnProperty("buildToolLogs")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.BuildToolLogs.verify(message.buildToolLogs);
                        if (error)
                            return "buildToolLogs." + error;
                    }
                }
                if (message.buildMetrics != null && message.hasOwnProperty("buildMetrics")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.build_event_stream.BuildMetrics.verify(message.buildMetrics);
                        if (error)
                            return "buildMetrics." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a BuildEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof build_event_stream.BuildEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {build_event_stream.BuildEvent} BuildEvent
             */
            BuildEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.build_event_stream.BuildEvent)
                    return object;
                var message = new $root.build_event_stream.BuildEvent();
                if (object.id != null) {
                    if (typeof object.id !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.id: object expected");
                    message.id = $root.build_event_stream.BuildEventId.fromObject(object.id);
                }
                if (object.children) {
                    if (!Array.isArray(object.children))
                        throw TypeError(".build_event_stream.BuildEvent.children: array expected");
                    message.children = [];
                    for (var i = 0; i < object.children.length; ++i) {
                        if (typeof object.children[i] !== "object")
                            throw TypeError(".build_event_stream.BuildEvent.children: object expected");
                        message.children[i] = $root.build_event_stream.BuildEventId.fromObject(object.children[i]);
                    }
                }
                if (object.lastMessage != null)
                    message.lastMessage = Boolean(object.lastMessage);
                if (object.progress != null) {
                    if (typeof object.progress !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.progress: object expected");
                    message.progress = $root.build_event_stream.Progress.fromObject(object.progress);
                }
                if (object.aborted != null) {
                    if (typeof object.aborted !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.aborted: object expected");
                    message.aborted = $root.build_event_stream.Aborted.fromObject(object.aborted);
                }
                if (object.started != null) {
                    if (typeof object.started !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.started: object expected");
                    message.started = $root.build_event_stream.BuildStarted.fromObject(object.started);
                }
                if (object.unstructuredCommandLine != null) {
                    if (typeof object.unstructuredCommandLine !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.unstructuredCommandLine: object expected");
                    message.unstructuredCommandLine = $root.build_event_stream.UnstructuredCommandLine.fromObject(object.unstructuredCommandLine);
                }
                if (object.structuredCommandLine != null) {
                    if (typeof object.structuredCommandLine !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.structuredCommandLine: object expected");
                    message.structuredCommandLine = $root.command_line.CommandLine.fromObject(object.structuredCommandLine);
                }
                if (object.optionsParsed != null) {
                    if (typeof object.optionsParsed !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.optionsParsed: object expected");
                    message.optionsParsed = $root.build_event_stream.OptionsParsed.fromObject(object.optionsParsed);
                }
                if (object.workspaceStatus != null) {
                    if (typeof object.workspaceStatus !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.workspaceStatus: object expected");
                    message.workspaceStatus = $root.build_event_stream.WorkspaceStatus.fromObject(object.workspaceStatus);
                }
                if (object.fetch != null) {
                    if (typeof object.fetch !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.fetch: object expected");
                    message.fetch = $root.build_event_stream.Fetch.fromObject(object.fetch);
                }
                if (object.configuration != null) {
                    if (typeof object.configuration !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.configuration: object expected");
                    message.configuration = $root.build_event_stream.Configuration.fromObject(object.configuration);
                }
                if (object.expanded != null) {
                    if (typeof object.expanded !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.expanded: object expected");
                    message.expanded = $root.build_event_stream.PatternExpanded.fromObject(object.expanded);
                }
                if (object.configured != null) {
                    if (typeof object.configured !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.configured: object expected");
                    message.configured = $root.build_event_stream.TargetConfigured.fromObject(object.configured);
                }
                if (object.action != null) {
                    if (typeof object.action !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.action: object expected");
                    message.action = $root.build_event_stream.ActionExecuted.fromObject(object.action);
                }
                if (object.namedSetOfFiles != null) {
                    if (typeof object.namedSetOfFiles !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.namedSetOfFiles: object expected");
                    message.namedSetOfFiles = $root.build_event_stream.NamedSetOfFiles.fromObject(object.namedSetOfFiles);
                }
                if (object.completed != null) {
                    if (typeof object.completed !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.completed: object expected");
                    message.completed = $root.build_event_stream.TargetComplete.fromObject(object.completed);
                }
                if (object.testResult != null) {
                    if (typeof object.testResult !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.testResult: object expected");
                    message.testResult = $root.build_event_stream.TestResult.fromObject(object.testResult);
                }
                if (object.testSummary != null) {
                    if (typeof object.testSummary !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.testSummary: object expected");
                    message.testSummary = $root.build_event_stream.TestSummary.fromObject(object.testSummary);
                }
                if (object.finished != null) {
                    if (typeof object.finished !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.finished: object expected");
                    message.finished = $root.build_event_stream.BuildFinished.fromObject(object.finished);
                }
                if (object.buildToolLogs != null) {
                    if (typeof object.buildToolLogs !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.buildToolLogs: object expected");
                    message.buildToolLogs = $root.build_event_stream.BuildToolLogs.fromObject(object.buildToolLogs);
                }
                if (object.buildMetrics != null) {
                    if (typeof object.buildMetrics !== "object")
                        throw TypeError(".build_event_stream.BuildEvent.buildMetrics: object expected");
                    message.buildMetrics = $root.build_event_stream.BuildMetrics.fromObject(object.buildMetrics);
                }
                return message;
            };
            /**
             * Creates a plain object from a BuildEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof build_event_stream.BuildEvent
             * @static
             * @param {build_event_stream.BuildEvent} message BuildEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BuildEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.children = [];
                if (options.defaults) {
                    object.id = null;
                    object.lastMessage = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = $root.build_event_stream.BuildEventId.toObject(message.id, options);
                if (message.children && message.children.length) {
                    object.children = [];
                    for (var j = 0; j < message.children.length; ++j)
                        object.children[j] = $root.build_event_stream.BuildEventId.toObject(message.children[j], options);
                }
                if (message.progress != null && message.hasOwnProperty("progress")) {
                    object.progress = $root.build_event_stream.Progress.toObject(message.progress, options);
                    if (options.oneofs)
                        object.payload = "progress";
                }
                if (message.aborted != null && message.hasOwnProperty("aborted")) {
                    object.aborted = $root.build_event_stream.Aborted.toObject(message.aborted, options);
                    if (options.oneofs)
                        object.payload = "aborted";
                }
                if (message.started != null && message.hasOwnProperty("started")) {
                    object.started = $root.build_event_stream.BuildStarted.toObject(message.started, options);
                    if (options.oneofs)
                        object.payload = "started";
                }
                if (message.expanded != null && message.hasOwnProperty("expanded")) {
                    object.expanded = $root.build_event_stream.PatternExpanded.toObject(message.expanded, options);
                    if (options.oneofs)
                        object.payload = "expanded";
                }
                if (message.action != null && message.hasOwnProperty("action")) {
                    object.action = $root.build_event_stream.ActionExecuted.toObject(message.action, options);
                    if (options.oneofs)
                        object.payload = "action";
                }
                if (message.completed != null && message.hasOwnProperty("completed")) {
                    object.completed = $root.build_event_stream.TargetComplete.toObject(message.completed, options);
                    if (options.oneofs)
                        object.payload = "completed";
                }
                if (message.testSummary != null && message.hasOwnProperty("testSummary")) {
                    object.testSummary = $root.build_event_stream.TestSummary.toObject(message.testSummary, options);
                    if (options.oneofs)
                        object.payload = "testSummary";
                }
                if (message.testResult != null && message.hasOwnProperty("testResult")) {
                    object.testResult = $root.build_event_stream.TestResult.toObject(message.testResult, options);
                    if (options.oneofs)
                        object.payload = "testResult";
                }
                if (message.unstructuredCommandLine != null && message.hasOwnProperty("unstructuredCommandLine")) {
                    object.unstructuredCommandLine = $root.build_event_stream.UnstructuredCommandLine.toObject(message.unstructuredCommandLine, options);
                    if (options.oneofs)
                        object.payload = "unstructuredCommandLine";
                }
                if (message.optionsParsed != null && message.hasOwnProperty("optionsParsed")) {
                    object.optionsParsed = $root.build_event_stream.OptionsParsed.toObject(message.optionsParsed, options);
                    if (options.oneofs)
                        object.payload = "optionsParsed";
                }
                if (message.finished != null && message.hasOwnProperty("finished")) {
                    object.finished = $root.build_event_stream.BuildFinished.toObject(message.finished, options);
                    if (options.oneofs)
                        object.payload = "finished";
                }
                if (message.namedSetOfFiles != null && message.hasOwnProperty("namedSetOfFiles")) {
                    object.namedSetOfFiles = $root.build_event_stream.NamedSetOfFiles.toObject(message.namedSetOfFiles, options);
                    if (options.oneofs)
                        object.payload = "namedSetOfFiles";
                }
                if (message.workspaceStatus != null && message.hasOwnProperty("workspaceStatus")) {
                    object.workspaceStatus = $root.build_event_stream.WorkspaceStatus.toObject(message.workspaceStatus, options);
                    if (options.oneofs)
                        object.payload = "workspaceStatus";
                }
                if (message.configuration != null && message.hasOwnProperty("configuration")) {
                    object.configuration = $root.build_event_stream.Configuration.toObject(message.configuration, options);
                    if (options.oneofs)
                        object.payload = "configuration";
                }
                if (message.configured != null && message.hasOwnProperty("configured")) {
                    object.configured = $root.build_event_stream.TargetConfigured.toObject(message.configured, options);
                    if (options.oneofs)
                        object.payload = "configured";
                }
                if (message.lastMessage != null && message.hasOwnProperty("lastMessage"))
                    object.lastMessage = message.lastMessage;
                if (message.fetch != null && message.hasOwnProperty("fetch")) {
                    object.fetch = $root.build_event_stream.Fetch.toObject(message.fetch, options);
                    if (options.oneofs)
                        object.payload = "fetch";
                }
                if (message.structuredCommandLine != null && message.hasOwnProperty("structuredCommandLine")) {
                    object.structuredCommandLine = $root.command_line.CommandLine.toObject(message.structuredCommandLine, options);
                    if (options.oneofs)
                        object.payload = "structuredCommandLine";
                }
                if (message.buildToolLogs != null && message.hasOwnProperty("buildToolLogs")) {
                    object.buildToolLogs = $root.build_event_stream.BuildToolLogs.toObject(message.buildToolLogs, options);
                    if (options.oneofs)
                        object.payload = "buildToolLogs";
                }
                if (message.buildMetrics != null && message.hasOwnProperty("buildMetrics")) {
                    object.buildMetrics = $root.build_event_stream.BuildMetrics.toObject(message.buildMetrics, options);
                    if (options.oneofs)
                        object.payload = "buildMetrics";
                }
                return object;
            };
            /**
             * Converts this BuildEvent to JSON.
             * @function toJSON
             * @memberof build_event_stream.BuildEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BuildEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return BuildEvent;
        })();
        return build_event_stream;
    })();
    $root.skylark_debugging = (function () {
        /**
         * Namespace skylark_debugging.
         * @exports skylark_debugging
         * @namespace
         */
        var skylark_debugging = {};
        skylark_debugging.DebugRequest = (function () {
            /**
             * Properties of a DebugRequest.
             * @memberof skylark_debugging
             * @interface IDebugRequest
             * @property {number|Long|null} [sequenceNumber] DebugRequest sequenceNumber
             * @property {skylark_debugging.ISetBreakpointsRequest|null} [setBreakpoints] DebugRequest setBreakpoints
             * @property {skylark_debugging.IContinueExecutionRequest|null} [continueExecution] DebugRequest continueExecution
             * @property {skylark_debugging.IEvaluateRequest|null} [evaluate] DebugRequest evaluate
             * @property {skylark_debugging.IListFramesRequest|null} [listFrames] DebugRequest listFrames
             * @property {skylark_debugging.IStartDebuggingRequest|null} [startDebugging] DebugRequest startDebugging
             * @property {skylark_debugging.IPauseThreadRequest|null} [pauseThread] DebugRequest pauseThread
             * @property {skylark_debugging.IGetChildrenRequest|null} [getChildren] DebugRequest getChildren
             */
            /**
             * Constructs a new DebugRequest.
             * @memberof skylark_debugging
             * @classdesc Represents a DebugRequest.
             * @implements IDebugRequest
             * @constructor
             * @param {skylark_debugging.IDebugRequest=} [properties] Properties to set
             */
            function DebugRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * DebugRequest sequenceNumber.
             * @member {number|Long} sequenceNumber
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            DebugRequest.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * DebugRequest setBreakpoints.
             * @member {skylark_debugging.ISetBreakpointsRequest|null|undefined} setBreakpoints
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            DebugRequest.prototype.setBreakpoints = null;
            /**
             * DebugRequest continueExecution.
             * @member {skylark_debugging.IContinueExecutionRequest|null|undefined} continueExecution
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            DebugRequest.prototype.continueExecution = null;
            /**
             * DebugRequest evaluate.
             * @member {skylark_debugging.IEvaluateRequest|null|undefined} evaluate
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            DebugRequest.prototype.evaluate = null;
            /**
             * DebugRequest listFrames.
             * @member {skylark_debugging.IListFramesRequest|null|undefined} listFrames
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            DebugRequest.prototype.listFrames = null;
            /**
             * DebugRequest startDebugging.
             * @member {skylark_debugging.IStartDebuggingRequest|null|undefined} startDebugging
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            DebugRequest.prototype.startDebugging = null;
            /**
             * DebugRequest pauseThread.
             * @member {skylark_debugging.IPauseThreadRequest|null|undefined} pauseThread
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            DebugRequest.prototype.pauseThread = null;
            /**
             * DebugRequest getChildren.
             * @member {skylark_debugging.IGetChildrenRequest|null|undefined} getChildren
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            DebugRequest.prototype.getChildren = null;
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
            /**
             * DebugRequest payload.
             * @member {"setBreakpoints"|"continueExecution"|"evaluate"|"listFrames"|"startDebugging"|"pauseThread"|"getChildren"|undefined} payload
             * @memberof skylark_debugging.DebugRequest
             * @instance
             */
            Object.defineProperty(DebugRequest.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["setBreakpoints", "continueExecution", "evaluate", "listFrames", "startDebugging", "pauseThread", "getChildren"]),
                set: $util.oneOfSetter($oneOfFields)
            });
            /**
             * Creates a new DebugRequest instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.DebugRequest
             * @static
             * @param {skylark_debugging.IDebugRequest=} [properties] Properties to set
             * @returns {skylark_debugging.DebugRequest} DebugRequest instance
             */
            DebugRequest.create = function create(properties) {
                return new DebugRequest(properties);
            };
            /**
             * Encodes the specified DebugRequest message. Does not implicitly {@link skylark_debugging.DebugRequest.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.DebugRequest
             * @static
             * @param {skylark_debugging.IDebugRequest} message DebugRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.sequenceNumber);
                if (message.setBreakpoints != null && message.hasOwnProperty("setBreakpoints"))
                    $root.skylark_debugging.SetBreakpointsRequest.encode(message.setBreakpoints, writer.uint32(/* id 101, wireType 2 =*/ 810).fork()).ldelim();
                if (message.continueExecution != null && message.hasOwnProperty("continueExecution"))
                    $root.skylark_debugging.ContinueExecutionRequest.encode(message.continueExecution, writer.uint32(/* id 102, wireType 2 =*/ 818).fork()).ldelim();
                if (message.evaluate != null && message.hasOwnProperty("evaluate"))
                    $root.skylark_debugging.EvaluateRequest.encode(message.evaluate, writer.uint32(/* id 103, wireType 2 =*/ 826).fork()).ldelim();
                if (message.listFrames != null && message.hasOwnProperty("listFrames"))
                    $root.skylark_debugging.ListFramesRequest.encode(message.listFrames, writer.uint32(/* id 104, wireType 2 =*/ 834).fork()).ldelim();
                if (message.startDebugging != null && message.hasOwnProperty("startDebugging"))
                    $root.skylark_debugging.StartDebuggingRequest.encode(message.startDebugging, writer.uint32(/* id 105, wireType 2 =*/ 842).fork()).ldelim();
                if (message.pauseThread != null && message.hasOwnProperty("pauseThread"))
                    $root.skylark_debugging.PauseThreadRequest.encode(message.pauseThread, writer.uint32(/* id 106, wireType 2 =*/ 850).fork()).ldelim();
                if (message.getChildren != null && message.hasOwnProperty("getChildren"))
                    $root.skylark_debugging.GetChildrenRequest.encode(message.getChildren, writer.uint32(/* id 107, wireType 2 =*/ 858).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified DebugRequest message, length delimited. Does not implicitly {@link skylark_debugging.DebugRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.DebugRequest
             * @static
             * @param {skylark_debugging.IDebugRequest} message DebugRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a DebugRequest message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.DebugRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.DebugRequest} DebugRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.DebugRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.sequenceNumber = reader.int64();
                            break;
                        case 101:
                            message.setBreakpoints = $root.skylark_debugging.SetBreakpointsRequest.decode(reader, reader.uint32());
                            break;
                        case 102:
                            message.continueExecution = $root.skylark_debugging.ContinueExecutionRequest.decode(reader, reader.uint32());
                            break;
                        case 103:
                            message.evaluate = $root.skylark_debugging.EvaluateRequest.decode(reader, reader.uint32());
                            break;
                        case 104:
                            message.listFrames = $root.skylark_debugging.ListFramesRequest.decode(reader, reader.uint32());
                            break;
                        case 105:
                            message.startDebugging = $root.skylark_debugging.StartDebuggingRequest.decode(reader, reader.uint32());
                            break;
                        case 106:
                            message.pauseThread = $root.skylark_debugging.PauseThreadRequest.decode(reader, reader.uint32());
                            break;
                        case 107:
                            message.getChildren = $root.skylark_debugging.GetChildrenRequest.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a DebugRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.DebugRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.DebugRequest} DebugRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a DebugRequest message.
             * @function verify
             * @memberof skylark_debugging.DebugRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                        return "sequenceNumber: integer|Long expected";
                if (message.setBreakpoints != null && message.hasOwnProperty("setBreakpoints")) {
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.SetBreakpointsRequest.verify(message.setBreakpoints);
                        if (error)
                            return "setBreakpoints." + error;
                    }
                }
                if (message.continueExecution != null && message.hasOwnProperty("continueExecution")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.ContinueExecutionRequest.verify(message.continueExecution);
                        if (error)
                            return "continueExecution." + error;
                    }
                }
                if (message.evaluate != null && message.hasOwnProperty("evaluate")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.EvaluateRequest.verify(message.evaluate);
                        if (error)
                            return "evaluate." + error;
                    }
                }
                if (message.listFrames != null && message.hasOwnProperty("listFrames")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.ListFramesRequest.verify(message.listFrames);
                        if (error)
                            return "listFrames." + error;
                    }
                }
                if (message.startDebugging != null && message.hasOwnProperty("startDebugging")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.StartDebuggingRequest.verify(message.startDebugging);
                        if (error)
                            return "startDebugging." + error;
                    }
                }
                if (message.pauseThread != null && message.hasOwnProperty("pauseThread")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.PauseThreadRequest.verify(message.pauseThread);
                        if (error)
                            return "pauseThread." + error;
                    }
                }
                if (message.getChildren != null && message.hasOwnProperty("getChildren")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.GetChildrenRequest.verify(message.getChildren);
                        if (error)
                            return "getChildren." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a DebugRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.DebugRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.DebugRequest} DebugRequest
             */
            DebugRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.DebugRequest)
                    return object;
                var message = new $root.skylark_debugging.DebugRequest();
                if (object.sequenceNumber != null)
                    if ($util.Long)
                        (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = false;
                    else if (typeof object.sequenceNumber === "string")
                        message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                    else if (typeof object.sequenceNumber === "number")
                        message.sequenceNumber = object.sequenceNumber;
                    else if (typeof object.sequenceNumber === "object")
                        message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber();
                if (object.setBreakpoints != null) {
                    if (typeof object.setBreakpoints !== "object")
                        throw TypeError(".skylark_debugging.DebugRequest.setBreakpoints: object expected");
                    message.setBreakpoints = $root.skylark_debugging.SetBreakpointsRequest.fromObject(object.setBreakpoints);
                }
                if (object.continueExecution != null) {
                    if (typeof object.continueExecution !== "object")
                        throw TypeError(".skylark_debugging.DebugRequest.continueExecution: object expected");
                    message.continueExecution = $root.skylark_debugging.ContinueExecutionRequest.fromObject(object.continueExecution);
                }
                if (object.evaluate != null) {
                    if (typeof object.evaluate !== "object")
                        throw TypeError(".skylark_debugging.DebugRequest.evaluate: object expected");
                    message.evaluate = $root.skylark_debugging.EvaluateRequest.fromObject(object.evaluate);
                }
                if (object.listFrames != null) {
                    if (typeof object.listFrames !== "object")
                        throw TypeError(".skylark_debugging.DebugRequest.listFrames: object expected");
                    message.listFrames = $root.skylark_debugging.ListFramesRequest.fromObject(object.listFrames);
                }
                if (object.startDebugging != null) {
                    if (typeof object.startDebugging !== "object")
                        throw TypeError(".skylark_debugging.DebugRequest.startDebugging: object expected");
                    message.startDebugging = $root.skylark_debugging.StartDebuggingRequest.fromObject(object.startDebugging);
                }
                if (object.pauseThread != null) {
                    if (typeof object.pauseThread !== "object")
                        throw TypeError(".skylark_debugging.DebugRequest.pauseThread: object expected");
                    message.pauseThread = $root.skylark_debugging.PauseThreadRequest.fromObject(object.pauseThread);
                }
                if (object.getChildren != null) {
                    if (typeof object.getChildren !== "object")
                        throw TypeError(".skylark_debugging.DebugRequest.getChildren: object expected");
                    message.getChildren = $root.skylark_debugging.GetChildrenRequest.fromObject(object.getChildren);
                }
                return message;
            };
            /**
             * Creates a plain object from a DebugRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.DebugRequest
             * @static
             * @param {skylark_debugging.DebugRequest} message DebugRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.sequenceNumber = options.longs === String ? "0" : 0;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (typeof message.sequenceNumber === "number")
                        object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                    else
                        object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber() : message.sequenceNumber;
                if (message.setBreakpoints != null && message.hasOwnProperty("setBreakpoints")) {
                    object.setBreakpoints = $root.skylark_debugging.SetBreakpointsRequest.toObject(message.setBreakpoints, options);
                    if (options.oneofs)
                        object.payload = "setBreakpoints";
                }
                if (message.continueExecution != null && message.hasOwnProperty("continueExecution")) {
                    object.continueExecution = $root.skylark_debugging.ContinueExecutionRequest.toObject(message.continueExecution, options);
                    if (options.oneofs)
                        object.payload = "continueExecution";
                }
                if (message.evaluate != null && message.hasOwnProperty("evaluate")) {
                    object.evaluate = $root.skylark_debugging.EvaluateRequest.toObject(message.evaluate, options);
                    if (options.oneofs)
                        object.payload = "evaluate";
                }
                if (message.listFrames != null && message.hasOwnProperty("listFrames")) {
                    object.listFrames = $root.skylark_debugging.ListFramesRequest.toObject(message.listFrames, options);
                    if (options.oneofs)
                        object.payload = "listFrames";
                }
                if (message.startDebugging != null && message.hasOwnProperty("startDebugging")) {
                    object.startDebugging = $root.skylark_debugging.StartDebuggingRequest.toObject(message.startDebugging, options);
                    if (options.oneofs)
                        object.payload = "startDebugging";
                }
                if (message.pauseThread != null && message.hasOwnProperty("pauseThread")) {
                    object.pauseThread = $root.skylark_debugging.PauseThreadRequest.toObject(message.pauseThread, options);
                    if (options.oneofs)
                        object.payload = "pauseThread";
                }
                if (message.getChildren != null && message.hasOwnProperty("getChildren")) {
                    object.getChildren = $root.skylark_debugging.GetChildrenRequest.toObject(message.getChildren, options);
                    if (options.oneofs)
                        object.payload = "getChildren";
                }
                return object;
            };
            /**
             * Converts this DebugRequest to JSON.
             * @function toJSON
             * @memberof skylark_debugging.DebugRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return DebugRequest;
        })();
        skylark_debugging.SetBreakpointsRequest = (function () {
            /**
             * Properties of a SetBreakpointsRequest.
             * @memberof skylark_debugging
             * @interface ISetBreakpointsRequest
             * @property {Array.<skylark_debugging.IBreakpoint>|null} [breakpoint] SetBreakpointsRequest breakpoint
             */
            /**
             * Constructs a new SetBreakpointsRequest.
             * @memberof skylark_debugging
             * @classdesc Represents a SetBreakpointsRequest.
             * @implements ISetBreakpointsRequest
             * @constructor
             * @param {skylark_debugging.ISetBreakpointsRequest=} [properties] Properties to set
             */
            function SetBreakpointsRequest(properties) {
                this.breakpoint = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * SetBreakpointsRequest breakpoint.
             * @member {Array.<skylark_debugging.IBreakpoint>} breakpoint
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @instance
             */
            SetBreakpointsRequest.prototype.breakpoint = $util.emptyArray;
            /**
             * Creates a new SetBreakpointsRequest instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @static
             * @param {skylark_debugging.ISetBreakpointsRequest=} [properties] Properties to set
             * @returns {skylark_debugging.SetBreakpointsRequest} SetBreakpointsRequest instance
             */
            SetBreakpointsRequest.create = function create(properties) {
                return new SetBreakpointsRequest(properties);
            };
            /**
             * Encodes the specified SetBreakpointsRequest message. Does not implicitly {@link skylark_debugging.SetBreakpointsRequest.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @static
             * @param {skylark_debugging.ISetBreakpointsRequest} message SetBreakpointsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetBreakpointsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.breakpoint != null && message.breakpoint.length)
                    for (var i = 0; i < message.breakpoint.length; ++i)
                        $root.skylark_debugging.Breakpoint.encode(message.breakpoint[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified SetBreakpointsRequest message, length delimited. Does not implicitly {@link skylark_debugging.SetBreakpointsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @static
             * @param {skylark_debugging.ISetBreakpointsRequest} message SetBreakpointsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetBreakpointsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a SetBreakpointsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.SetBreakpointsRequest} SetBreakpointsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetBreakpointsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.SetBreakpointsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.breakpoint && message.breakpoint.length))
                                message.breakpoint = [];
                            message.breakpoint.push($root.skylark_debugging.Breakpoint.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a SetBreakpointsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.SetBreakpointsRequest} SetBreakpointsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetBreakpointsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a SetBreakpointsRequest message.
             * @function verify
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetBreakpointsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.breakpoint != null && message.hasOwnProperty("breakpoint")) {
                    if (!Array.isArray(message.breakpoint))
                        return "breakpoint: array expected";
                    for (var i = 0; i < message.breakpoint.length; ++i) {
                        var error = $root.skylark_debugging.Breakpoint.verify(message.breakpoint[i]);
                        if (error)
                            return "breakpoint." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a SetBreakpointsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.SetBreakpointsRequest} SetBreakpointsRequest
             */
            SetBreakpointsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.SetBreakpointsRequest)
                    return object;
                var message = new $root.skylark_debugging.SetBreakpointsRequest();
                if (object.breakpoint) {
                    if (!Array.isArray(object.breakpoint))
                        throw TypeError(".skylark_debugging.SetBreakpointsRequest.breakpoint: array expected");
                    message.breakpoint = [];
                    for (var i = 0; i < object.breakpoint.length; ++i) {
                        if (typeof object.breakpoint[i] !== "object")
                            throw TypeError(".skylark_debugging.SetBreakpointsRequest.breakpoint: object expected");
                        message.breakpoint[i] = $root.skylark_debugging.Breakpoint.fromObject(object.breakpoint[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a SetBreakpointsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @static
             * @param {skylark_debugging.SetBreakpointsRequest} message SetBreakpointsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetBreakpointsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.breakpoint = [];
                if (message.breakpoint && message.breakpoint.length) {
                    object.breakpoint = [];
                    for (var j = 0; j < message.breakpoint.length; ++j)
                        object.breakpoint[j] = $root.skylark_debugging.Breakpoint.toObject(message.breakpoint[j], options);
                }
                return object;
            };
            /**
             * Converts this SetBreakpointsRequest to JSON.
             * @function toJSON
             * @memberof skylark_debugging.SetBreakpointsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetBreakpointsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return SetBreakpointsRequest;
        })();
        skylark_debugging.ContinueExecutionRequest = (function () {
            /**
             * Properties of a ContinueExecutionRequest.
             * @memberof skylark_debugging
             * @interface IContinueExecutionRequest
             * @property {number|Long|null} [threadId] ContinueExecutionRequest threadId
             * @property {skylark_debugging.Stepping|null} [stepping] ContinueExecutionRequest stepping
             */
            /**
             * Constructs a new ContinueExecutionRequest.
             * @memberof skylark_debugging
             * @classdesc Represents a ContinueExecutionRequest.
             * @implements IContinueExecutionRequest
             * @constructor
             * @param {skylark_debugging.IContinueExecutionRequest=} [properties] Properties to set
             */
            function ContinueExecutionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ContinueExecutionRequest threadId.
             * @member {number|Long} threadId
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @instance
             */
            ContinueExecutionRequest.prototype.threadId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * ContinueExecutionRequest stepping.
             * @member {skylark_debugging.Stepping} stepping
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @instance
             */
            ContinueExecutionRequest.prototype.stepping = 0;
            /**
             * Creates a new ContinueExecutionRequest instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @static
             * @param {skylark_debugging.IContinueExecutionRequest=} [properties] Properties to set
             * @returns {skylark_debugging.ContinueExecutionRequest} ContinueExecutionRequest instance
             */
            ContinueExecutionRequest.create = function create(properties) {
                return new ContinueExecutionRequest(properties);
            };
            /**
             * Encodes the specified ContinueExecutionRequest message. Does not implicitly {@link skylark_debugging.ContinueExecutionRequest.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @static
             * @param {skylark_debugging.IContinueExecutionRequest} message ContinueExecutionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContinueExecutionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.threadId);
                if (message.stepping != null && message.hasOwnProperty("stepping"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.stepping);
                return writer;
            };
            /**
             * Encodes the specified ContinueExecutionRequest message, length delimited. Does not implicitly {@link skylark_debugging.ContinueExecutionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @static
             * @param {skylark_debugging.IContinueExecutionRequest} message ContinueExecutionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContinueExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ContinueExecutionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.ContinueExecutionRequest} ContinueExecutionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContinueExecutionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.ContinueExecutionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.threadId = reader.int64();
                            break;
                        case 2:
                            message.stepping = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a ContinueExecutionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.ContinueExecutionRequest} ContinueExecutionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContinueExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ContinueExecutionRequest message.
             * @function verify
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContinueExecutionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                        return "threadId: integer|Long expected";
                if (message.stepping != null && message.hasOwnProperty("stepping"))
                    switch (message.stepping) {
                        default:
                            return "stepping: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                    }
                return null;
            };
            /**
             * Creates a ContinueExecutionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.ContinueExecutionRequest} ContinueExecutionRequest
             */
            ContinueExecutionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.ContinueExecutionRequest)
                    return object;
                var message = new $root.skylark_debugging.ContinueExecutionRequest();
                if (object.threadId != null)
                    if ($util.Long)
                        (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = false;
                    else if (typeof object.threadId === "string")
                        message.threadId = parseInt(object.threadId, 10);
                    else if (typeof object.threadId === "number")
                        message.threadId = object.threadId;
                    else if (typeof object.threadId === "object")
                        message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber();
                switch (object.stepping) {
                    case "NONE":
                    case 0:
                        message.stepping = 0;
                        break;
                    case "INTO":
                    case 1:
                        message.stepping = 1;
                        break;
                    case "OVER":
                    case 2:
                        message.stepping = 2;
                        break;
                    case "OUT":
                    case 3:
                        message.stepping = 3;
                        break;
                }
                return message;
            };
            /**
             * Creates a plain object from a ContinueExecutionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @static
             * @param {skylark_debugging.ContinueExecutionRequest} message ContinueExecutionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContinueExecutionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.threadId = options.longs === String ? "0" : 0;
                    object.stepping = options.enums === String ? "NONE" : 0;
                }
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (typeof message.threadId === "number")
                        object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                    else
                        object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber() : message.threadId;
                if (message.stepping != null && message.hasOwnProperty("stepping"))
                    object.stepping = options.enums === String ? $root.skylark_debugging.Stepping[message.stepping] : message.stepping;
                return object;
            };
            /**
             * Converts this ContinueExecutionRequest to JSON.
             * @function toJSON
             * @memberof skylark_debugging.ContinueExecutionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContinueExecutionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ContinueExecutionRequest;
        })();
        skylark_debugging.EvaluateRequest = (function () {
            /**
             * Properties of an EvaluateRequest.
             * @memberof skylark_debugging
             * @interface IEvaluateRequest
             * @property {number|Long|null} [threadId] EvaluateRequest threadId
             * @property {string|null} [statement] EvaluateRequest statement
             */
            /**
             * Constructs a new EvaluateRequest.
             * @memberof skylark_debugging
             * @classdesc Represents an EvaluateRequest.
             * @implements IEvaluateRequest
             * @constructor
             * @param {skylark_debugging.IEvaluateRequest=} [properties] Properties to set
             */
            function EvaluateRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EvaluateRequest threadId.
             * @member {number|Long} threadId
             * @memberof skylark_debugging.EvaluateRequest
             * @instance
             */
            EvaluateRequest.prototype.threadId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * EvaluateRequest statement.
             * @member {string} statement
             * @memberof skylark_debugging.EvaluateRequest
             * @instance
             */
            EvaluateRequest.prototype.statement = "";
            /**
             * Creates a new EvaluateRequest instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.EvaluateRequest
             * @static
             * @param {skylark_debugging.IEvaluateRequest=} [properties] Properties to set
             * @returns {skylark_debugging.EvaluateRequest} EvaluateRequest instance
             */
            EvaluateRequest.create = function create(properties) {
                return new EvaluateRequest(properties);
            };
            /**
             * Encodes the specified EvaluateRequest message. Does not implicitly {@link skylark_debugging.EvaluateRequest.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.EvaluateRequest
             * @static
             * @param {skylark_debugging.IEvaluateRequest} message EvaluateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EvaluateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.threadId);
                if (message.statement != null && message.hasOwnProperty("statement"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.statement);
                return writer;
            };
            /**
             * Encodes the specified EvaluateRequest message, length delimited. Does not implicitly {@link skylark_debugging.EvaluateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.EvaluateRequest
             * @static
             * @param {skylark_debugging.IEvaluateRequest} message EvaluateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EvaluateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an EvaluateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.EvaluateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.EvaluateRequest} EvaluateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EvaluateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.EvaluateRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.threadId = reader.int64();
                            break;
                        case 2:
                            message.statement = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an EvaluateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.EvaluateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.EvaluateRequest} EvaluateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EvaluateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an EvaluateRequest message.
             * @function verify
             * @memberof skylark_debugging.EvaluateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EvaluateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                        return "threadId: integer|Long expected";
                if (message.statement != null && message.hasOwnProperty("statement"))
                    if (!$util.isString(message.statement))
                        return "statement: string expected";
                return null;
            };
            /**
             * Creates an EvaluateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.EvaluateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.EvaluateRequest} EvaluateRequest
             */
            EvaluateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.EvaluateRequest)
                    return object;
                var message = new $root.skylark_debugging.EvaluateRequest();
                if (object.threadId != null)
                    if ($util.Long)
                        (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = false;
                    else if (typeof object.threadId === "string")
                        message.threadId = parseInt(object.threadId, 10);
                    else if (typeof object.threadId === "number")
                        message.threadId = object.threadId;
                    else if (typeof object.threadId === "object")
                        message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber();
                if (object.statement != null)
                    message.statement = String(object.statement);
                return message;
            };
            /**
             * Creates a plain object from an EvaluateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.EvaluateRequest
             * @static
             * @param {skylark_debugging.EvaluateRequest} message EvaluateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EvaluateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.threadId = options.longs === String ? "0" : 0;
                    object.statement = "";
                }
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (typeof message.threadId === "number")
                        object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                    else
                        object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber() : message.threadId;
                if (message.statement != null && message.hasOwnProperty("statement"))
                    object.statement = message.statement;
                return object;
            };
            /**
             * Converts this EvaluateRequest to JSON.
             * @function toJSON
             * @memberof skylark_debugging.EvaluateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EvaluateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return EvaluateRequest;
        })();
        skylark_debugging.ListFramesRequest = (function () {
            /**
             * Properties of a ListFramesRequest.
             * @memberof skylark_debugging
             * @interface IListFramesRequest
             * @property {number|Long|null} [threadId] ListFramesRequest threadId
             */
            /**
             * Constructs a new ListFramesRequest.
             * @memberof skylark_debugging
             * @classdesc Represents a ListFramesRequest.
             * @implements IListFramesRequest
             * @constructor
             * @param {skylark_debugging.IListFramesRequest=} [properties] Properties to set
             */
            function ListFramesRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ListFramesRequest threadId.
             * @member {number|Long} threadId
             * @memberof skylark_debugging.ListFramesRequest
             * @instance
             */
            ListFramesRequest.prototype.threadId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new ListFramesRequest instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.ListFramesRequest
             * @static
             * @param {skylark_debugging.IListFramesRequest=} [properties] Properties to set
             * @returns {skylark_debugging.ListFramesRequest} ListFramesRequest instance
             */
            ListFramesRequest.create = function create(properties) {
                return new ListFramesRequest(properties);
            };
            /**
             * Encodes the specified ListFramesRequest message. Does not implicitly {@link skylark_debugging.ListFramesRequest.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.ListFramesRequest
             * @static
             * @param {skylark_debugging.IListFramesRequest} message ListFramesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListFramesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.threadId);
                return writer;
            };
            /**
             * Encodes the specified ListFramesRequest message, length delimited. Does not implicitly {@link skylark_debugging.ListFramesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.ListFramesRequest
             * @static
             * @param {skylark_debugging.IListFramesRequest} message ListFramesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListFramesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ListFramesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.ListFramesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.ListFramesRequest} ListFramesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListFramesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.ListFramesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.threadId = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a ListFramesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.ListFramesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.ListFramesRequest} ListFramesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListFramesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ListFramesRequest message.
             * @function verify
             * @memberof skylark_debugging.ListFramesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListFramesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                        return "threadId: integer|Long expected";
                return null;
            };
            /**
             * Creates a ListFramesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.ListFramesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.ListFramesRequest} ListFramesRequest
             */
            ListFramesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.ListFramesRequest)
                    return object;
                var message = new $root.skylark_debugging.ListFramesRequest();
                if (object.threadId != null)
                    if ($util.Long)
                        (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = false;
                    else if (typeof object.threadId === "string")
                        message.threadId = parseInt(object.threadId, 10);
                    else if (typeof object.threadId === "number")
                        message.threadId = object.threadId;
                    else if (typeof object.threadId === "object")
                        message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from a ListFramesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.ListFramesRequest
             * @static
             * @param {skylark_debugging.ListFramesRequest} message ListFramesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListFramesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.threadId = options.longs === String ? "0" : 0;
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (typeof message.threadId === "number")
                        object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                    else
                        object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber() : message.threadId;
                return object;
            };
            /**
             * Converts this ListFramesRequest to JSON.
             * @function toJSON
             * @memberof skylark_debugging.ListFramesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListFramesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ListFramesRequest;
        })();
        skylark_debugging.StartDebuggingRequest = (function () {
            /**
             * Properties of a StartDebuggingRequest.
             * @memberof skylark_debugging
             * @interface IStartDebuggingRequest
             */
            /**
             * Constructs a new StartDebuggingRequest.
             * @memberof skylark_debugging
             * @classdesc Represents a StartDebuggingRequest.
             * @implements IStartDebuggingRequest
             * @constructor
             * @param {skylark_debugging.IStartDebuggingRequest=} [properties] Properties to set
             */
            function StartDebuggingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new StartDebuggingRequest instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.StartDebuggingRequest
             * @static
             * @param {skylark_debugging.IStartDebuggingRequest=} [properties] Properties to set
             * @returns {skylark_debugging.StartDebuggingRequest} StartDebuggingRequest instance
             */
            StartDebuggingRequest.create = function create(properties) {
                return new StartDebuggingRequest(properties);
            };
            /**
             * Encodes the specified StartDebuggingRequest message. Does not implicitly {@link skylark_debugging.StartDebuggingRequest.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.StartDebuggingRequest
             * @static
             * @param {skylark_debugging.IStartDebuggingRequest} message StartDebuggingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartDebuggingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified StartDebuggingRequest message, length delimited. Does not implicitly {@link skylark_debugging.StartDebuggingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.StartDebuggingRequest
             * @static
             * @param {skylark_debugging.IStartDebuggingRequest} message StartDebuggingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartDebuggingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a StartDebuggingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.StartDebuggingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.StartDebuggingRequest} StartDebuggingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartDebuggingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.StartDebuggingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a StartDebuggingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.StartDebuggingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.StartDebuggingRequest} StartDebuggingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartDebuggingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a StartDebuggingRequest message.
             * @function verify
             * @memberof skylark_debugging.StartDebuggingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartDebuggingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates a StartDebuggingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.StartDebuggingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.StartDebuggingRequest} StartDebuggingRequest
             */
            StartDebuggingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.StartDebuggingRequest)
                    return object;
                return new $root.skylark_debugging.StartDebuggingRequest();
            };
            /**
             * Creates a plain object from a StartDebuggingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.StartDebuggingRequest
             * @static
             * @param {skylark_debugging.StartDebuggingRequest} message StartDebuggingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartDebuggingRequest.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this StartDebuggingRequest to JSON.
             * @function toJSON
             * @memberof skylark_debugging.StartDebuggingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartDebuggingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return StartDebuggingRequest;
        })();
        skylark_debugging.PauseThreadRequest = (function () {
            /**
             * Properties of a PauseThreadRequest.
             * @memberof skylark_debugging
             * @interface IPauseThreadRequest
             * @property {number|Long|null} [threadId] PauseThreadRequest threadId
             */
            /**
             * Constructs a new PauseThreadRequest.
             * @memberof skylark_debugging
             * @classdesc Represents a PauseThreadRequest.
             * @implements IPauseThreadRequest
             * @constructor
             * @param {skylark_debugging.IPauseThreadRequest=} [properties] Properties to set
             */
            function PauseThreadRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * PauseThreadRequest threadId.
             * @member {number|Long} threadId
             * @memberof skylark_debugging.PauseThreadRequest
             * @instance
             */
            PauseThreadRequest.prototype.threadId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new PauseThreadRequest instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.PauseThreadRequest
             * @static
             * @param {skylark_debugging.IPauseThreadRequest=} [properties] Properties to set
             * @returns {skylark_debugging.PauseThreadRequest} PauseThreadRequest instance
             */
            PauseThreadRequest.create = function create(properties) {
                return new PauseThreadRequest(properties);
            };
            /**
             * Encodes the specified PauseThreadRequest message. Does not implicitly {@link skylark_debugging.PauseThreadRequest.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.PauseThreadRequest
             * @static
             * @param {skylark_debugging.IPauseThreadRequest} message PauseThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PauseThreadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.threadId);
                return writer;
            };
            /**
             * Encodes the specified PauseThreadRequest message, length delimited. Does not implicitly {@link skylark_debugging.PauseThreadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.PauseThreadRequest
             * @static
             * @param {skylark_debugging.IPauseThreadRequest} message PauseThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PauseThreadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PauseThreadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.PauseThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.PauseThreadRequest} PauseThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PauseThreadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.PauseThreadRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.threadId = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a PauseThreadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.PauseThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.PauseThreadRequest} PauseThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PauseThreadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PauseThreadRequest message.
             * @function verify
             * @memberof skylark_debugging.PauseThreadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PauseThreadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                        return "threadId: integer|Long expected";
                return null;
            };
            /**
             * Creates a PauseThreadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.PauseThreadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.PauseThreadRequest} PauseThreadRequest
             */
            PauseThreadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.PauseThreadRequest)
                    return object;
                var message = new $root.skylark_debugging.PauseThreadRequest();
                if (object.threadId != null)
                    if ($util.Long)
                        (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = false;
                    else if (typeof object.threadId === "string")
                        message.threadId = parseInt(object.threadId, 10);
                    else if (typeof object.threadId === "number")
                        message.threadId = object.threadId;
                    else if (typeof object.threadId === "object")
                        message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from a PauseThreadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.PauseThreadRequest
             * @static
             * @param {skylark_debugging.PauseThreadRequest} message PauseThreadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PauseThreadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.threadId = options.longs === String ? "0" : 0;
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (typeof message.threadId === "number")
                        object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                    else
                        object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber() : message.threadId;
                return object;
            };
            /**
             * Converts this PauseThreadRequest to JSON.
             * @function toJSON
             * @memberof skylark_debugging.PauseThreadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PauseThreadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PauseThreadRequest;
        })();
        skylark_debugging.GetChildrenRequest = (function () {
            /**
             * Properties of a GetChildrenRequest.
             * @memberof skylark_debugging
             * @interface IGetChildrenRequest
             * @property {number|Long|null} [threadId] GetChildrenRequest threadId
             * @property {number|Long|null} [valueId] GetChildrenRequest valueId
             */
            /**
             * Constructs a new GetChildrenRequest.
             * @memberof skylark_debugging
             * @classdesc Represents a GetChildrenRequest.
             * @implements IGetChildrenRequest
             * @constructor
             * @param {skylark_debugging.IGetChildrenRequest=} [properties] Properties to set
             */
            function GetChildrenRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * GetChildrenRequest threadId.
             * @member {number|Long} threadId
             * @memberof skylark_debugging.GetChildrenRequest
             * @instance
             */
            GetChildrenRequest.prototype.threadId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * GetChildrenRequest valueId.
             * @member {number|Long} valueId
             * @memberof skylark_debugging.GetChildrenRequest
             * @instance
             */
            GetChildrenRequest.prototype.valueId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new GetChildrenRequest instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.GetChildrenRequest
             * @static
             * @param {skylark_debugging.IGetChildrenRequest=} [properties] Properties to set
             * @returns {skylark_debugging.GetChildrenRequest} GetChildrenRequest instance
             */
            GetChildrenRequest.create = function create(properties) {
                return new GetChildrenRequest(properties);
            };
            /**
             * Encodes the specified GetChildrenRequest message. Does not implicitly {@link skylark_debugging.GetChildrenRequest.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.GetChildrenRequest
             * @static
             * @param {skylark_debugging.IGetChildrenRequest} message GetChildrenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChildrenRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.threadId);
                if (message.valueId != null && message.hasOwnProperty("valueId"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.valueId);
                return writer;
            };
            /**
             * Encodes the specified GetChildrenRequest message, length delimited. Does not implicitly {@link skylark_debugging.GetChildrenRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.GetChildrenRequest
             * @static
             * @param {skylark_debugging.IGetChildrenRequest} message GetChildrenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChildrenRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GetChildrenRequest message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.GetChildrenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.GetChildrenRequest} GetChildrenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChildrenRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.GetChildrenRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.threadId = reader.int64();
                            break;
                        case 2:
                            message.valueId = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a GetChildrenRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.GetChildrenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.GetChildrenRequest} GetChildrenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChildrenRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GetChildrenRequest message.
             * @function verify
             * @memberof skylark_debugging.GetChildrenRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetChildrenRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                        return "threadId: integer|Long expected";
                if (message.valueId != null && message.hasOwnProperty("valueId"))
                    if (!$util.isInteger(message.valueId) && !(message.valueId && $util.isInteger(message.valueId.low) && $util.isInteger(message.valueId.high)))
                        return "valueId: integer|Long expected";
                return null;
            };
            /**
             * Creates a GetChildrenRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.GetChildrenRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.GetChildrenRequest} GetChildrenRequest
             */
            GetChildrenRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.GetChildrenRequest)
                    return object;
                var message = new $root.skylark_debugging.GetChildrenRequest();
                if (object.threadId != null)
                    if ($util.Long)
                        (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = false;
                    else if (typeof object.threadId === "string")
                        message.threadId = parseInt(object.threadId, 10);
                    else if (typeof object.threadId === "number")
                        message.threadId = object.threadId;
                    else if (typeof object.threadId === "object")
                        message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber();
                if (object.valueId != null)
                    if ($util.Long)
                        (message.valueId = $util.Long.fromValue(object.valueId)).unsigned = false;
                    else if (typeof object.valueId === "string")
                        message.valueId = parseInt(object.valueId, 10);
                    else if (typeof object.valueId === "number")
                        message.valueId = object.valueId;
                    else if (typeof object.valueId === "object")
                        message.valueId = new $util.LongBits(object.valueId.low >>> 0, object.valueId.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from a GetChildrenRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.GetChildrenRequest
             * @static
             * @param {skylark_debugging.GetChildrenRequest} message GetChildrenRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetChildrenRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.threadId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.valueId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.valueId = options.longs === String ? "0" : 0;
                }
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (typeof message.threadId === "number")
                        object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                    else
                        object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber() : message.threadId;
                if (message.valueId != null && message.hasOwnProperty("valueId"))
                    if (typeof message.valueId === "number")
                        object.valueId = options.longs === String ? String(message.valueId) : message.valueId;
                    else
                        object.valueId = options.longs === String ? $util.Long.prototype.toString.call(message.valueId) : options.longs === Number ? new $util.LongBits(message.valueId.low >>> 0, message.valueId.high >>> 0).toNumber() : message.valueId;
                return object;
            };
            /**
             * Converts this GetChildrenRequest to JSON.
             * @function toJSON
             * @memberof skylark_debugging.GetChildrenRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetChildrenRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return GetChildrenRequest;
        })();
        skylark_debugging.DebugEvent = (function () {
            /**
             * Properties of a DebugEvent.
             * @memberof skylark_debugging
             * @interface IDebugEvent
             * @property {number|Long|null} [sequenceNumber] DebugEvent sequenceNumber
             * @property {skylark_debugging.IError|null} [error] DebugEvent error
             * @property {skylark_debugging.ISetBreakpointsResponse|null} [setBreakpoints] DebugEvent setBreakpoints
             * @property {skylark_debugging.IContinueExecutionResponse|null} [continueExecution] DebugEvent continueExecution
             * @property {skylark_debugging.IEvaluateResponse|null} [evaluate] DebugEvent evaluate
             * @property {skylark_debugging.IListFramesResponse|null} [listFrames] DebugEvent listFrames
             * @property {skylark_debugging.IStartDebuggingResponse|null} [startDebugging] DebugEvent startDebugging
             * @property {skylark_debugging.IPauseThreadResponse|null} [pauseThread] DebugEvent pauseThread
             * @property {skylark_debugging.IGetChildrenResponse|null} [getChildren] DebugEvent getChildren
             * @property {skylark_debugging.IThreadPausedEvent|null} [threadPaused] DebugEvent threadPaused
             * @property {skylark_debugging.IThreadContinuedEvent|null} [threadContinued] DebugEvent threadContinued
             */
            /**
             * Constructs a new DebugEvent.
             * @memberof skylark_debugging
             * @classdesc Represents a DebugEvent.
             * @implements IDebugEvent
             * @constructor
             * @param {skylark_debugging.IDebugEvent=} [properties] Properties to set
             */
            function DebugEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * DebugEvent sequenceNumber.
             * @member {number|Long} sequenceNumber
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * DebugEvent error.
             * @member {skylark_debugging.IError|null|undefined} error
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.error = null;
            /**
             * DebugEvent setBreakpoints.
             * @member {skylark_debugging.ISetBreakpointsResponse|null|undefined} setBreakpoints
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.setBreakpoints = null;
            /**
             * DebugEvent continueExecution.
             * @member {skylark_debugging.IContinueExecutionResponse|null|undefined} continueExecution
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.continueExecution = null;
            /**
             * DebugEvent evaluate.
             * @member {skylark_debugging.IEvaluateResponse|null|undefined} evaluate
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.evaluate = null;
            /**
             * DebugEvent listFrames.
             * @member {skylark_debugging.IListFramesResponse|null|undefined} listFrames
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.listFrames = null;
            /**
             * DebugEvent startDebugging.
             * @member {skylark_debugging.IStartDebuggingResponse|null|undefined} startDebugging
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.startDebugging = null;
            /**
             * DebugEvent pauseThread.
             * @member {skylark_debugging.IPauseThreadResponse|null|undefined} pauseThread
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.pauseThread = null;
            /**
             * DebugEvent getChildren.
             * @member {skylark_debugging.IGetChildrenResponse|null|undefined} getChildren
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.getChildren = null;
            /**
             * DebugEvent threadPaused.
             * @member {skylark_debugging.IThreadPausedEvent|null|undefined} threadPaused
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.threadPaused = null;
            /**
             * DebugEvent threadContinued.
             * @member {skylark_debugging.IThreadContinuedEvent|null|undefined} threadContinued
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            DebugEvent.prototype.threadContinued = null;
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
            /**
             * DebugEvent payload.
             * @member {"error"|"setBreakpoints"|"continueExecution"|"evaluate"|"listFrames"|"startDebugging"|"pauseThread"|"getChildren"|"threadPaused"|"threadContinued"|undefined} payload
             * @memberof skylark_debugging.DebugEvent
             * @instance
             */
            Object.defineProperty(DebugEvent.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["error", "setBreakpoints", "continueExecution", "evaluate", "listFrames", "startDebugging", "pauseThread", "getChildren", "threadPaused", "threadContinued"]),
                set: $util.oneOfSetter($oneOfFields)
            });
            /**
             * Creates a new DebugEvent instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.DebugEvent
             * @static
             * @param {skylark_debugging.IDebugEvent=} [properties] Properties to set
             * @returns {skylark_debugging.DebugEvent} DebugEvent instance
             */
            DebugEvent.create = function create(properties) {
                return new DebugEvent(properties);
            };
            /**
             * Encodes the specified DebugEvent message. Does not implicitly {@link skylark_debugging.DebugEvent.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.DebugEvent
             * @static
             * @param {skylark_debugging.IDebugEvent} message DebugEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.sequenceNumber);
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.skylark_debugging.Error.encode(message.error, writer.uint32(/* id 99, wireType 2 =*/ 794).fork()).ldelim();
                if (message.setBreakpoints != null && message.hasOwnProperty("setBreakpoints"))
                    $root.skylark_debugging.SetBreakpointsResponse.encode(message.setBreakpoints, writer.uint32(/* id 101, wireType 2 =*/ 810).fork()).ldelim();
                if (message.continueExecution != null && message.hasOwnProperty("continueExecution"))
                    $root.skylark_debugging.ContinueExecutionResponse.encode(message.continueExecution, writer.uint32(/* id 102, wireType 2 =*/ 818).fork()).ldelim();
                if (message.evaluate != null && message.hasOwnProperty("evaluate"))
                    $root.skylark_debugging.EvaluateResponse.encode(message.evaluate, writer.uint32(/* id 103, wireType 2 =*/ 826).fork()).ldelim();
                if (message.listFrames != null && message.hasOwnProperty("listFrames"))
                    $root.skylark_debugging.ListFramesResponse.encode(message.listFrames, writer.uint32(/* id 104, wireType 2 =*/ 834).fork()).ldelim();
                if (message.startDebugging != null && message.hasOwnProperty("startDebugging"))
                    $root.skylark_debugging.StartDebuggingResponse.encode(message.startDebugging, writer.uint32(/* id 105, wireType 2 =*/ 842).fork()).ldelim();
                if (message.pauseThread != null && message.hasOwnProperty("pauseThread"))
                    $root.skylark_debugging.PauseThreadResponse.encode(message.pauseThread, writer.uint32(/* id 106, wireType 2 =*/ 850).fork()).ldelim();
                if (message.getChildren != null && message.hasOwnProperty("getChildren"))
                    $root.skylark_debugging.GetChildrenResponse.encode(message.getChildren, writer.uint32(/* id 107, wireType 2 =*/ 858).fork()).ldelim();
                if (message.threadPaused != null && message.hasOwnProperty("threadPaused"))
                    $root.skylark_debugging.ThreadPausedEvent.encode(message.threadPaused, writer.uint32(/* id 1001, wireType 2 =*/ 8010).fork()).ldelim();
                if (message.threadContinued != null && message.hasOwnProperty("threadContinued"))
                    $root.skylark_debugging.ThreadContinuedEvent.encode(message.threadContinued, writer.uint32(/* id 1002, wireType 2 =*/ 8018).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified DebugEvent message, length delimited. Does not implicitly {@link skylark_debugging.DebugEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.DebugEvent
             * @static
             * @param {skylark_debugging.IDebugEvent} message DebugEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a DebugEvent message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.DebugEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.DebugEvent} DebugEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.DebugEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.sequenceNumber = reader.int64();
                            break;
                        case 99:
                            message.error = $root.skylark_debugging.Error.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.setBreakpoints = $root.skylark_debugging.SetBreakpointsResponse.decode(reader, reader.uint32());
                            break;
                        case 102:
                            message.continueExecution = $root.skylark_debugging.ContinueExecutionResponse.decode(reader, reader.uint32());
                            break;
                        case 103:
                            message.evaluate = $root.skylark_debugging.EvaluateResponse.decode(reader, reader.uint32());
                            break;
                        case 104:
                            message.listFrames = $root.skylark_debugging.ListFramesResponse.decode(reader, reader.uint32());
                            break;
                        case 105:
                            message.startDebugging = $root.skylark_debugging.StartDebuggingResponse.decode(reader, reader.uint32());
                            break;
                        case 106:
                            message.pauseThread = $root.skylark_debugging.PauseThreadResponse.decode(reader, reader.uint32());
                            break;
                        case 107:
                            message.getChildren = $root.skylark_debugging.GetChildrenResponse.decode(reader, reader.uint32());
                            break;
                        case 1001:
                            message.threadPaused = $root.skylark_debugging.ThreadPausedEvent.decode(reader, reader.uint32());
                            break;
                        case 1002:
                            message.threadContinued = $root.skylark_debugging.ThreadContinuedEvent.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a DebugEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.DebugEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.DebugEvent} DebugEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a DebugEvent message.
             * @function verify
             * @memberof skylark_debugging.DebugEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                        return "sequenceNumber: integer|Long expected";
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.setBreakpoints != null && message.hasOwnProperty("setBreakpoints")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.SetBreakpointsResponse.verify(message.setBreakpoints);
                        if (error)
                            return "setBreakpoints." + error;
                    }
                }
                if (message.continueExecution != null && message.hasOwnProperty("continueExecution")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.ContinueExecutionResponse.verify(message.continueExecution);
                        if (error)
                            return "continueExecution." + error;
                    }
                }
                if (message.evaluate != null && message.hasOwnProperty("evaluate")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.EvaluateResponse.verify(message.evaluate);
                        if (error)
                            return "evaluate." + error;
                    }
                }
                if (message.listFrames != null && message.hasOwnProperty("listFrames")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.ListFramesResponse.verify(message.listFrames);
                        if (error)
                            return "listFrames." + error;
                    }
                }
                if (message.startDebugging != null && message.hasOwnProperty("startDebugging")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.StartDebuggingResponse.verify(message.startDebugging);
                        if (error)
                            return "startDebugging." + error;
                    }
                }
                if (message.pauseThread != null && message.hasOwnProperty("pauseThread")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.PauseThreadResponse.verify(message.pauseThread);
                        if (error)
                            return "pauseThread." + error;
                    }
                }
                if (message.getChildren != null && message.hasOwnProperty("getChildren")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.GetChildrenResponse.verify(message.getChildren);
                        if (error)
                            return "getChildren." + error;
                    }
                }
                if (message.threadPaused != null && message.hasOwnProperty("threadPaused")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.ThreadPausedEvent.verify(message.threadPaused);
                        if (error)
                            return "threadPaused." + error;
                    }
                }
                if (message.threadContinued != null && message.hasOwnProperty("threadContinued")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.skylark_debugging.ThreadContinuedEvent.verify(message.threadContinued);
                        if (error)
                            return "threadContinued." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a DebugEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.DebugEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.DebugEvent} DebugEvent
             */
            DebugEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.DebugEvent)
                    return object;
                var message = new $root.skylark_debugging.DebugEvent();
                if (object.sequenceNumber != null)
                    if ($util.Long)
                        (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = false;
                    else if (typeof object.sequenceNumber === "string")
                        message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                    else if (typeof object.sequenceNumber === "number")
                        message.sequenceNumber = object.sequenceNumber;
                    else if (typeof object.sequenceNumber === "object")
                        message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.error: object expected");
                    message.error = $root.skylark_debugging.Error.fromObject(object.error);
                }
                if (object.setBreakpoints != null) {
                    if (typeof object.setBreakpoints !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.setBreakpoints: object expected");
                    message.setBreakpoints = $root.skylark_debugging.SetBreakpointsResponse.fromObject(object.setBreakpoints);
                }
                if (object.continueExecution != null) {
                    if (typeof object.continueExecution !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.continueExecution: object expected");
                    message.continueExecution = $root.skylark_debugging.ContinueExecutionResponse.fromObject(object.continueExecution);
                }
                if (object.evaluate != null) {
                    if (typeof object.evaluate !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.evaluate: object expected");
                    message.evaluate = $root.skylark_debugging.EvaluateResponse.fromObject(object.evaluate);
                }
                if (object.listFrames != null) {
                    if (typeof object.listFrames !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.listFrames: object expected");
                    message.listFrames = $root.skylark_debugging.ListFramesResponse.fromObject(object.listFrames);
                }
                if (object.startDebugging != null) {
                    if (typeof object.startDebugging !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.startDebugging: object expected");
                    message.startDebugging = $root.skylark_debugging.StartDebuggingResponse.fromObject(object.startDebugging);
                }
                if (object.pauseThread != null) {
                    if (typeof object.pauseThread !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.pauseThread: object expected");
                    message.pauseThread = $root.skylark_debugging.PauseThreadResponse.fromObject(object.pauseThread);
                }
                if (object.getChildren != null) {
                    if (typeof object.getChildren !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.getChildren: object expected");
                    message.getChildren = $root.skylark_debugging.GetChildrenResponse.fromObject(object.getChildren);
                }
                if (object.threadPaused != null) {
                    if (typeof object.threadPaused !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.threadPaused: object expected");
                    message.threadPaused = $root.skylark_debugging.ThreadPausedEvent.fromObject(object.threadPaused);
                }
                if (object.threadContinued != null) {
                    if (typeof object.threadContinued !== "object")
                        throw TypeError(".skylark_debugging.DebugEvent.threadContinued: object expected");
                    message.threadContinued = $root.skylark_debugging.ThreadContinuedEvent.fromObject(object.threadContinued);
                }
                return message;
            };
            /**
             * Creates a plain object from a DebugEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.DebugEvent
             * @static
             * @param {skylark_debugging.DebugEvent} message DebugEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.sequenceNumber = options.longs === String ? "0" : 0;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (typeof message.sequenceNumber === "number")
                        object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                    else
                        object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber() : message.sequenceNumber;
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.skylark_debugging.Error.toObject(message.error, options);
                    if (options.oneofs)
                        object.payload = "error";
                }
                if (message.setBreakpoints != null && message.hasOwnProperty("setBreakpoints")) {
                    object.setBreakpoints = $root.skylark_debugging.SetBreakpointsResponse.toObject(message.setBreakpoints, options);
                    if (options.oneofs)
                        object.payload = "setBreakpoints";
                }
                if (message.continueExecution != null && message.hasOwnProperty("continueExecution")) {
                    object.continueExecution = $root.skylark_debugging.ContinueExecutionResponse.toObject(message.continueExecution, options);
                    if (options.oneofs)
                        object.payload = "continueExecution";
                }
                if (message.evaluate != null && message.hasOwnProperty("evaluate")) {
                    object.evaluate = $root.skylark_debugging.EvaluateResponse.toObject(message.evaluate, options);
                    if (options.oneofs)
                        object.payload = "evaluate";
                }
                if (message.listFrames != null && message.hasOwnProperty("listFrames")) {
                    object.listFrames = $root.skylark_debugging.ListFramesResponse.toObject(message.listFrames, options);
                    if (options.oneofs)
                        object.payload = "listFrames";
                }
                if (message.startDebugging != null && message.hasOwnProperty("startDebugging")) {
                    object.startDebugging = $root.skylark_debugging.StartDebuggingResponse.toObject(message.startDebugging, options);
                    if (options.oneofs)
                        object.payload = "startDebugging";
                }
                if (message.pauseThread != null && message.hasOwnProperty("pauseThread")) {
                    object.pauseThread = $root.skylark_debugging.PauseThreadResponse.toObject(message.pauseThread, options);
                    if (options.oneofs)
                        object.payload = "pauseThread";
                }
                if (message.getChildren != null && message.hasOwnProperty("getChildren")) {
                    object.getChildren = $root.skylark_debugging.GetChildrenResponse.toObject(message.getChildren, options);
                    if (options.oneofs)
                        object.payload = "getChildren";
                }
                if (message.threadPaused != null && message.hasOwnProperty("threadPaused")) {
                    object.threadPaused = $root.skylark_debugging.ThreadPausedEvent.toObject(message.threadPaused, options);
                    if (options.oneofs)
                        object.payload = "threadPaused";
                }
                if (message.threadContinued != null && message.hasOwnProperty("threadContinued")) {
                    object.threadContinued = $root.skylark_debugging.ThreadContinuedEvent.toObject(message.threadContinued, options);
                    if (options.oneofs)
                        object.payload = "threadContinued";
                }
                return object;
            };
            /**
             * Converts this DebugEvent to JSON.
             * @function toJSON
             * @memberof skylark_debugging.DebugEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return DebugEvent;
        })();
        skylark_debugging.Error = (function () {
            /**
             * Properties of an Error.
             * @memberof skylark_debugging
             * @interface IError
             * @property {string|null} [message] Error message
             */
            /**
             * Constructs a new Error.
             * @memberof skylark_debugging
             * @classdesc Represents an Error.
             * @implements IError
             * @constructor
             * @param {skylark_debugging.IError=} [properties] Properties to set
             */
            function Error(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Error message.
             * @member {string} message
             * @memberof skylark_debugging.Error
             * @instance
             */
            Error.prototype.message = "";
            /**
             * Creates a new Error instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.Error
             * @static
             * @param {skylark_debugging.IError=} [properties] Properties to set
             * @returns {skylark_debugging.Error} Error instance
             */
            Error.create = function create(properties) {
                return new Error(properties);
            };
            /**
             * Encodes the specified Error message. Does not implicitly {@link skylark_debugging.Error.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.Error
             * @static
             * @param {skylark_debugging.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.message);
                return writer;
            };
            /**
             * Encodes the specified Error message, length delimited. Does not implicitly {@link skylark_debugging.Error.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.Error
             * @static
             * @param {skylark_debugging.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Error message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.Error();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Error message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Error message.
             * @function verify
             * @memberof skylark_debugging.Error
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Error.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };
            /**
             * Creates an Error message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.Error
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.Error} Error
             */
            Error.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.Error)
                    return object;
                var message = new $root.skylark_debugging.Error();
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };
            /**
             * Creates a plain object from an Error message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.Error
             * @static
             * @param {skylark_debugging.Error} message Error
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Error.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.message = "";
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };
            /**
             * Converts this Error to JSON.
             * @function toJSON
             * @memberof skylark_debugging.Error
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Error.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Error;
        })();
        skylark_debugging.SetBreakpointsResponse = (function () {
            /**
             * Properties of a SetBreakpointsResponse.
             * @memberof skylark_debugging
             * @interface ISetBreakpointsResponse
             */
            /**
             * Constructs a new SetBreakpointsResponse.
             * @memberof skylark_debugging
             * @classdesc Represents a SetBreakpointsResponse.
             * @implements ISetBreakpointsResponse
             * @constructor
             * @param {skylark_debugging.ISetBreakpointsResponse=} [properties] Properties to set
             */
            function SetBreakpointsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new SetBreakpointsResponse instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @static
             * @param {skylark_debugging.ISetBreakpointsResponse=} [properties] Properties to set
             * @returns {skylark_debugging.SetBreakpointsResponse} SetBreakpointsResponse instance
             */
            SetBreakpointsResponse.create = function create(properties) {
                return new SetBreakpointsResponse(properties);
            };
            /**
             * Encodes the specified SetBreakpointsResponse message. Does not implicitly {@link skylark_debugging.SetBreakpointsResponse.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @static
             * @param {skylark_debugging.ISetBreakpointsResponse} message SetBreakpointsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetBreakpointsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified SetBreakpointsResponse message, length delimited. Does not implicitly {@link skylark_debugging.SetBreakpointsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @static
             * @param {skylark_debugging.ISetBreakpointsResponse} message SetBreakpointsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetBreakpointsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a SetBreakpointsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.SetBreakpointsResponse} SetBreakpointsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetBreakpointsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.SetBreakpointsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a SetBreakpointsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.SetBreakpointsResponse} SetBreakpointsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetBreakpointsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a SetBreakpointsResponse message.
             * @function verify
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetBreakpointsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates a SetBreakpointsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.SetBreakpointsResponse} SetBreakpointsResponse
             */
            SetBreakpointsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.SetBreakpointsResponse)
                    return object;
                return new $root.skylark_debugging.SetBreakpointsResponse();
            };
            /**
             * Creates a plain object from a SetBreakpointsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @static
             * @param {skylark_debugging.SetBreakpointsResponse} message SetBreakpointsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetBreakpointsResponse.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this SetBreakpointsResponse to JSON.
             * @function toJSON
             * @memberof skylark_debugging.SetBreakpointsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetBreakpointsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return SetBreakpointsResponse;
        })();
        skylark_debugging.ContinueExecutionResponse = (function () {
            /**
             * Properties of a ContinueExecutionResponse.
             * @memberof skylark_debugging
             * @interface IContinueExecutionResponse
             */
            /**
             * Constructs a new ContinueExecutionResponse.
             * @memberof skylark_debugging
             * @classdesc Represents a ContinueExecutionResponse.
             * @implements IContinueExecutionResponse
             * @constructor
             * @param {skylark_debugging.IContinueExecutionResponse=} [properties] Properties to set
             */
            function ContinueExecutionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new ContinueExecutionResponse instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @static
             * @param {skylark_debugging.IContinueExecutionResponse=} [properties] Properties to set
             * @returns {skylark_debugging.ContinueExecutionResponse} ContinueExecutionResponse instance
             */
            ContinueExecutionResponse.create = function create(properties) {
                return new ContinueExecutionResponse(properties);
            };
            /**
             * Encodes the specified ContinueExecutionResponse message. Does not implicitly {@link skylark_debugging.ContinueExecutionResponse.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @static
             * @param {skylark_debugging.IContinueExecutionResponse} message ContinueExecutionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContinueExecutionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified ContinueExecutionResponse message, length delimited. Does not implicitly {@link skylark_debugging.ContinueExecutionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @static
             * @param {skylark_debugging.IContinueExecutionResponse} message ContinueExecutionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContinueExecutionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ContinueExecutionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.ContinueExecutionResponse} ContinueExecutionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContinueExecutionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.ContinueExecutionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a ContinueExecutionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.ContinueExecutionResponse} ContinueExecutionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContinueExecutionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ContinueExecutionResponse message.
             * @function verify
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContinueExecutionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates a ContinueExecutionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.ContinueExecutionResponse} ContinueExecutionResponse
             */
            ContinueExecutionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.ContinueExecutionResponse)
                    return object;
                return new $root.skylark_debugging.ContinueExecutionResponse();
            };
            /**
             * Creates a plain object from a ContinueExecutionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @static
             * @param {skylark_debugging.ContinueExecutionResponse} message ContinueExecutionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContinueExecutionResponse.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this ContinueExecutionResponse to JSON.
             * @function toJSON
             * @memberof skylark_debugging.ContinueExecutionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContinueExecutionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ContinueExecutionResponse;
        })();
        skylark_debugging.EvaluateResponse = (function () {
            /**
             * Properties of an EvaluateResponse.
             * @memberof skylark_debugging
             * @interface IEvaluateResponse
             * @property {skylark_debugging.IValue|null} [result] EvaluateResponse result
             */
            /**
             * Constructs a new EvaluateResponse.
             * @memberof skylark_debugging
             * @classdesc Represents an EvaluateResponse.
             * @implements IEvaluateResponse
             * @constructor
             * @param {skylark_debugging.IEvaluateResponse=} [properties] Properties to set
             */
            function EvaluateResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EvaluateResponse result.
             * @member {skylark_debugging.IValue|null|undefined} result
             * @memberof skylark_debugging.EvaluateResponse
             * @instance
             */
            EvaluateResponse.prototype.result = null;
            /**
             * Creates a new EvaluateResponse instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.EvaluateResponse
             * @static
             * @param {skylark_debugging.IEvaluateResponse=} [properties] Properties to set
             * @returns {skylark_debugging.EvaluateResponse} EvaluateResponse instance
             */
            EvaluateResponse.create = function create(properties) {
                return new EvaluateResponse(properties);
            };
            /**
             * Encodes the specified EvaluateResponse message. Does not implicitly {@link skylark_debugging.EvaluateResponse.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.EvaluateResponse
             * @static
             * @param {skylark_debugging.IEvaluateResponse} message EvaluateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EvaluateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.result != null && message.hasOwnProperty("result"))
                    $root.skylark_debugging.Value.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified EvaluateResponse message, length delimited. Does not implicitly {@link skylark_debugging.EvaluateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.EvaluateResponse
             * @static
             * @param {skylark_debugging.IEvaluateResponse} message EvaluateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EvaluateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an EvaluateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.EvaluateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.EvaluateResponse} EvaluateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EvaluateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.EvaluateResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.result = $root.skylark_debugging.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an EvaluateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.EvaluateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.EvaluateResponse} EvaluateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EvaluateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an EvaluateResponse message.
             * @function verify
             * @memberof skylark_debugging.EvaluateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EvaluateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.skylark_debugging.Value.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                return null;
            };
            /**
             * Creates an EvaluateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.EvaluateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.EvaluateResponse} EvaluateResponse
             */
            EvaluateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.EvaluateResponse)
                    return object;
                var message = new $root.skylark_debugging.EvaluateResponse();
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".skylark_debugging.EvaluateResponse.result: object expected");
                    message.result = $root.skylark_debugging.Value.fromObject(object.result);
                }
                return message;
            };
            /**
             * Creates a plain object from an EvaluateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.EvaluateResponse
             * @static
             * @param {skylark_debugging.EvaluateResponse} message EvaluateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EvaluateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.result = null;
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.skylark_debugging.Value.toObject(message.result, options);
                return object;
            };
            /**
             * Converts this EvaluateResponse to JSON.
             * @function toJSON
             * @memberof skylark_debugging.EvaluateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EvaluateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return EvaluateResponse;
        })();
        skylark_debugging.ListFramesResponse = (function () {
            /**
             * Properties of a ListFramesResponse.
             * @memberof skylark_debugging
             * @interface IListFramesResponse
             * @property {Array.<skylark_debugging.IFrame>|null} [frame] ListFramesResponse frame
             */
            /**
             * Constructs a new ListFramesResponse.
             * @memberof skylark_debugging
             * @classdesc Represents a ListFramesResponse.
             * @implements IListFramesResponse
             * @constructor
             * @param {skylark_debugging.IListFramesResponse=} [properties] Properties to set
             */
            function ListFramesResponse(properties) {
                this.frame = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ListFramesResponse frame.
             * @member {Array.<skylark_debugging.IFrame>} frame
             * @memberof skylark_debugging.ListFramesResponse
             * @instance
             */
            ListFramesResponse.prototype.frame = $util.emptyArray;
            /**
             * Creates a new ListFramesResponse instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.ListFramesResponse
             * @static
             * @param {skylark_debugging.IListFramesResponse=} [properties] Properties to set
             * @returns {skylark_debugging.ListFramesResponse} ListFramesResponse instance
             */
            ListFramesResponse.create = function create(properties) {
                return new ListFramesResponse(properties);
            };
            /**
             * Encodes the specified ListFramesResponse message. Does not implicitly {@link skylark_debugging.ListFramesResponse.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.ListFramesResponse
             * @static
             * @param {skylark_debugging.IListFramesResponse} message ListFramesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListFramesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frame != null && message.frame.length)
                    for (var i = 0; i < message.frame.length; ++i)
                        $root.skylark_debugging.Frame.encode(message.frame[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified ListFramesResponse message, length delimited. Does not implicitly {@link skylark_debugging.ListFramesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.ListFramesResponse
             * @static
             * @param {skylark_debugging.IListFramesResponse} message ListFramesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListFramesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ListFramesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.ListFramesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.ListFramesResponse} ListFramesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListFramesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.ListFramesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.frame && message.frame.length))
                                message.frame = [];
                            message.frame.push($root.skylark_debugging.Frame.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a ListFramesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.ListFramesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.ListFramesResponse} ListFramesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListFramesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ListFramesResponse message.
             * @function verify
             * @memberof skylark_debugging.ListFramesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListFramesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frame != null && message.hasOwnProperty("frame")) {
                    if (!Array.isArray(message.frame))
                        return "frame: array expected";
                    for (var i = 0; i < message.frame.length; ++i) {
                        var error = $root.skylark_debugging.Frame.verify(message.frame[i]);
                        if (error)
                            return "frame." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a ListFramesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.ListFramesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.ListFramesResponse} ListFramesResponse
             */
            ListFramesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.ListFramesResponse)
                    return object;
                var message = new $root.skylark_debugging.ListFramesResponse();
                if (object.frame) {
                    if (!Array.isArray(object.frame))
                        throw TypeError(".skylark_debugging.ListFramesResponse.frame: array expected");
                    message.frame = [];
                    for (var i = 0; i < object.frame.length; ++i) {
                        if (typeof object.frame[i] !== "object")
                            throw TypeError(".skylark_debugging.ListFramesResponse.frame: object expected");
                        message.frame[i] = $root.skylark_debugging.Frame.fromObject(object.frame[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a ListFramesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.ListFramesResponse
             * @static
             * @param {skylark_debugging.ListFramesResponse} message ListFramesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListFramesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.frame = [];
                if (message.frame && message.frame.length) {
                    object.frame = [];
                    for (var j = 0; j < message.frame.length; ++j)
                        object.frame[j] = $root.skylark_debugging.Frame.toObject(message.frame[j], options);
                }
                return object;
            };
            /**
             * Converts this ListFramesResponse to JSON.
             * @function toJSON
             * @memberof skylark_debugging.ListFramesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListFramesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ListFramesResponse;
        })();
        skylark_debugging.StartDebuggingResponse = (function () {
            /**
             * Properties of a StartDebuggingResponse.
             * @memberof skylark_debugging
             * @interface IStartDebuggingResponse
             */
            /**
             * Constructs a new StartDebuggingResponse.
             * @memberof skylark_debugging
             * @classdesc Represents a StartDebuggingResponse.
             * @implements IStartDebuggingResponse
             * @constructor
             * @param {skylark_debugging.IStartDebuggingResponse=} [properties] Properties to set
             */
            function StartDebuggingResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new StartDebuggingResponse instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.StartDebuggingResponse
             * @static
             * @param {skylark_debugging.IStartDebuggingResponse=} [properties] Properties to set
             * @returns {skylark_debugging.StartDebuggingResponse} StartDebuggingResponse instance
             */
            StartDebuggingResponse.create = function create(properties) {
                return new StartDebuggingResponse(properties);
            };
            /**
             * Encodes the specified StartDebuggingResponse message. Does not implicitly {@link skylark_debugging.StartDebuggingResponse.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.StartDebuggingResponse
             * @static
             * @param {skylark_debugging.IStartDebuggingResponse} message StartDebuggingResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartDebuggingResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified StartDebuggingResponse message, length delimited. Does not implicitly {@link skylark_debugging.StartDebuggingResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.StartDebuggingResponse
             * @static
             * @param {skylark_debugging.IStartDebuggingResponse} message StartDebuggingResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartDebuggingResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a StartDebuggingResponse message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.StartDebuggingResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.StartDebuggingResponse} StartDebuggingResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartDebuggingResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.StartDebuggingResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a StartDebuggingResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.StartDebuggingResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.StartDebuggingResponse} StartDebuggingResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartDebuggingResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a StartDebuggingResponse message.
             * @function verify
             * @memberof skylark_debugging.StartDebuggingResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartDebuggingResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates a StartDebuggingResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.StartDebuggingResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.StartDebuggingResponse} StartDebuggingResponse
             */
            StartDebuggingResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.StartDebuggingResponse)
                    return object;
                return new $root.skylark_debugging.StartDebuggingResponse();
            };
            /**
             * Creates a plain object from a StartDebuggingResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.StartDebuggingResponse
             * @static
             * @param {skylark_debugging.StartDebuggingResponse} message StartDebuggingResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartDebuggingResponse.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this StartDebuggingResponse to JSON.
             * @function toJSON
             * @memberof skylark_debugging.StartDebuggingResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartDebuggingResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return StartDebuggingResponse;
        })();
        skylark_debugging.PauseThreadResponse = (function () {
            /**
             * Properties of a PauseThreadResponse.
             * @memberof skylark_debugging
             * @interface IPauseThreadResponse
             */
            /**
             * Constructs a new PauseThreadResponse.
             * @memberof skylark_debugging
             * @classdesc Represents a PauseThreadResponse.
             * @implements IPauseThreadResponse
             * @constructor
             * @param {skylark_debugging.IPauseThreadResponse=} [properties] Properties to set
             */
            function PauseThreadResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new PauseThreadResponse instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.PauseThreadResponse
             * @static
             * @param {skylark_debugging.IPauseThreadResponse=} [properties] Properties to set
             * @returns {skylark_debugging.PauseThreadResponse} PauseThreadResponse instance
             */
            PauseThreadResponse.create = function create(properties) {
                return new PauseThreadResponse(properties);
            };
            /**
             * Encodes the specified PauseThreadResponse message. Does not implicitly {@link skylark_debugging.PauseThreadResponse.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.PauseThreadResponse
             * @static
             * @param {skylark_debugging.IPauseThreadResponse} message PauseThreadResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PauseThreadResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified PauseThreadResponse message, length delimited. Does not implicitly {@link skylark_debugging.PauseThreadResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.PauseThreadResponse
             * @static
             * @param {skylark_debugging.IPauseThreadResponse} message PauseThreadResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PauseThreadResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PauseThreadResponse message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.PauseThreadResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.PauseThreadResponse} PauseThreadResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PauseThreadResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.PauseThreadResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a PauseThreadResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.PauseThreadResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.PauseThreadResponse} PauseThreadResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PauseThreadResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PauseThreadResponse message.
             * @function verify
             * @memberof skylark_debugging.PauseThreadResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PauseThreadResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates a PauseThreadResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.PauseThreadResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.PauseThreadResponse} PauseThreadResponse
             */
            PauseThreadResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.PauseThreadResponse)
                    return object;
                return new $root.skylark_debugging.PauseThreadResponse();
            };
            /**
             * Creates a plain object from a PauseThreadResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.PauseThreadResponse
             * @static
             * @param {skylark_debugging.PauseThreadResponse} message PauseThreadResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PauseThreadResponse.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this PauseThreadResponse to JSON.
             * @function toJSON
             * @memberof skylark_debugging.PauseThreadResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PauseThreadResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PauseThreadResponse;
        })();
        skylark_debugging.GetChildrenResponse = (function () {
            /**
             * Properties of a GetChildrenResponse.
             * @memberof skylark_debugging
             * @interface IGetChildrenResponse
             * @property {Array.<skylark_debugging.IValue>|null} [children] GetChildrenResponse children
             */
            /**
             * Constructs a new GetChildrenResponse.
             * @memberof skylark_debugging
             * @classdesc Represents a GetChildrenResponse.
             * @implements IGetChildrenResponse
             * @constructor
             * @param {skylark_debugging.IGetChildrenResponse=} [properties] Properties to set
             */
            function GetChildrenResponse(properties) {
                this.children = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * GetChildrenResponse children.
             * @member {Array.<skylark_debugging.IValue>} children
             * @memberof skylark_debugging.GetChildrenResponse
             * @instance
             */
            GetChildrenResponse.prototype.children = $util.emptyArray;
            /**
             * Creates a new GetChildrenResponse instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.GetChildrenResponse
             * @static
             * @param {skylark_debugging.IGetChildrenResponse=} [properties] Properties to set
             * @returns {skylark_debugging.GetChildrenResponse} GetChildrenResponse instance
             */
            GetChildrenResponse.create = function create(properties) {
                return new GetChildrenResponse(properties);
            };
            /**
             * Encodes the specified GetChildrenResponse message. Does not implicitly {@link skylark_debugging.GetChildrenResponse.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.GetChildrenResponse
             * @static
             * @param {skylark_debugging.IGetChildrenResponse} message GetChildrenResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChildrenResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.children != null && message.children.length)
                    for (var i = 0; i < message.children.length; ++i)
                        $root.skylark_debugging.Value.encode(message.children[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified GetChildrenResponse message, length delimited. Does not implicitly {@link skylark_debugging.GetChildrenResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.GetChildrenResponse
             * @static
             * @param {skylark_debugging.IGetChildrenResponse} message GetChildrenResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChildrenResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GetChildrenResponse message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.GetChildrenResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.GetChildrenResponse} GetChildrenResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChildrenResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.GetChildrenResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.children && message.children.length))
                                message.children = [];
                            message.children.push($root.skylark_debugging.Value.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a GetChildrenResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.GetChildrenResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.GetChildrenResponse} GetChildrenResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChildrenResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GetChildrenResponse message.
             * @function verify
             * @memberof skylark_debugging.GetChildrenResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetChildrenResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.children != null && message.hasOwnProperty("children")) {
                    if (!Array.isArray(message.children))
                        return "children: array expected";
                    for (var i = 0; i < message.children.length; ++i) {
                        var error = $root.skylark_debugging.Value.verify(message.children[i]);
                        if (error)
                            return "children." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a GetChildrenResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.GetChildrenResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.GetChildrenResponse} GetChildrenResponse
             */
            GetChildrenResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.GetChildrenResponse)
                    return object;
                var message = new $root.skylark_debugging.GetChildrenResponse();
                if (object.children) {
                    if (!Array.isArray(object.children))
                        throw TypeError(".skylark_debugging.GetChildrenResponse.children: array expected");
                    message.children = [];
                    for (var i = 0; i < object.children.length; ++i) {
                        if (typeof object.children[i] !== "object")
                            throw TypeError(".skylark_debugging.GetChildrenResponse.children: object expected");
                        message.children[i] = $root.skylark_debugging.Value.fromObject(object.children[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a GetChildrenResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.GetChildrenResponse
             * @static
             * @param {skylark_debugging.GetChildrenResponse} message GetChildrenResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetChildrenResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.children = [];
                if (message.children && message.children.length) {
                    object.children = [];
                    for (var j = 0; j < message.children.length; ++j)
                        object.children[j] = $root.skylark_debugging.Value.toObject(message.children[j], options);
                }
                return object;
            };
            /**
             * Converts this GetChildrenResponse to JSON.
             * @function toJSON
             * @memberof skylark_debugging.GetChildrenResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetChildrenResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return GetChildrenResponse;
        })();
        skylark_debugging.ThreadPausedEvent = (function () {
            /**
             * Properties of a ThreadPausedEvent.
             * @memberof skylark_debugging
             * @interface IThreadPausedEvent
             * @property {skylark_debugging.IPausedThread|null} [thread] ThreadPausedEvent thread
             */
            /**
             * Constructs a new ThreadPausedEvent.
             * @memberof skylark_debugging
             * @classdesc Represents a ThreadPausedEvent.
             * @implements IThreadPausedEvent
             * @constructor
             * @param {skylark_debugging.IThreadPausedEvent=} [properties] Properties to set
             */
            function ThreadPausedEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ThreadPausedEvent thread.
             * @member {skylark_debugging.IPausedThread|null|undefined} thread
             * @memberof skylark_debugging.ThreadPausedEvent
             * @instance
             */
            ThreadPausedEvent.prototype.thread = null;
            /**
             * Creates a new ThreadPausedEvent instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.ThreadPausedEvent
             * @static
             * @param {skylark_debugging.IThreadPausedEvent=} [properties] Properties to set
             * @returns {skylark_debugging.ThreadPausedEvent} ThreadPausedEvent instance
             */
            ThreadPausedEvent.create = function create(properties) {
                return new ThreadPausedEvent(properties);
            };
            /**
             * Encodes the specified ThreadPausedEvent message. Does not implicitly {@link skylark_debugging.ThreadPausedEvent.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.ThreadPausedEvent
             * @static
             * @param {skylark_debugging.IThreadPausedEvent} message ThreadPausedEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadPausedEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.thread != null && message.hasOwnProperty("thread"))
                    $root.skylark_debugging.PausedThread.encode(message.thread, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified ThreadPausedEvent message, length delimited. Does not implicitly {@link skylark_debugging.ThreadPausedEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.ThreadPausedEvent
             * @static
             * @param {skylark_debugging.IThreadPausedEvent} message ThreadPausedEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadPausedEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ThreadPausedEvent message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.ThreadPausedEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.ThreadPausedEvent} ThreadPausedEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadPausedEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.ThreadPausedEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.thread = $root.skylark_debugging.PausedThread.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a ThreadPausedEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.ThreadPausedEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.ThreadPausedEvent} ThreadPausedEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadPausedEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ThreadPausedEvent message.
             * @function verify
             * @memberof skylark_debugging.ThreadPausedEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ThreadPausedEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.thread != null && message.hasOwnProperty("thread")) {
                    var error = $root.skylark_debugging.PausedThread.verify(message.thread);
                    if (error)
                        return "thread." + error;
                }
                return null;
            };
            /**
             * Creates a ThreadPausedEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.ThreadPausedEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.ThreadPausedEvent} ThreadPausedEvent
             */
            ThreadPausedEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.ThreadPausedEvent)
                    return object;
                var message = new $root.skylark_debugging.ThreadPausedEvent();
                if (object.thread != null) {
                    if (typeof object.thread !== "object")
                        throw TypeError(".skylark_debugging.ThreadPausedEvent.thread: object expected");
                    message.thread = $root.skylark_debugging.PausedThread.fromObject(object.thread);
                }
                return message;
            };
            /**
             * Creates a plain object from a ThreadPausedEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.ThreadPausedEvent
             * @static
             * @param {skylark_debugging.ThreadPausedEvent} message ThreadPausedEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ThreadPausedEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.thread = null;
                if (message.thread != null && message.hasOwnProperty("thread"))
                    object.thread = $root.skylark_debugging.PausedThread.toObject(message.thread, options);
                return object;
            };
            /**
             * Converts this ThreadPausedEvent to JSON.
             * @function toJSON
             * @memberof skylark_debugging.ThreadPausedEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ThreadPausedEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ThreadPausedEvent;
        })();
        skylark_debugging.ThreadContinuedEvent = (function () {
            /**
             * Properties of a ThreadContinuedEvent.
             * @memberof skylark_debugging
             * @interface IThreadContinuedEvent
             * @property {number|Long|null} [threadId] ThreadContinuedEvent threadId
             */
            /**
             * Constructs a new ThreadContinuedEvent.
             * @memberof skylark_debugging
             * @classdesc Represents a ThreadContinuedEvent.
             * @implements IThreadContinuedEvent
             * @constructor
             * @param {skylark_debugging.IThreadContinuedEvent=} [properties] Properties to set
             */
            function ThreadContinuedEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ThreadContinuedEvent threadId.
             * @member {number|Long} threadId
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @instance
             */
            ThreadContinuedEvent.prototype.threadId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new ThreadContinuedEvent instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @static
             * @param {skylark_debugging.IThreadContinuedEvent=} [properties] Properties to set
             * @returns {skylark_debugging.ThreadContinuedEvent} ThreadContinuedEvent instance
             */
            ThreadContinuedEvent.create = function create(properties) {
                return new ThreadContinuedEvent(properties);
            };
            /**
             * Encodes the specified ThreadContinuedEvent message. Does not implicitly {@link skylark_debugging.ThreadContinuedEvent.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @static
             * @param {skylark_debugging.IThreadContinuedEvent} message ThreadContinuedEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadContinuedEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.threadId);
                return writer;
            };
            /**
             * Encodes the specified ThreadContinuedEvent message, length delimited. Does not implicitly {@link skylark_debugging.ThreadContinuedEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @static
             * @param {skylark_debugging.IThreadContinuedEvent} message ThreadContinuedEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadContinuedEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ThreadContinuedEvent message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.ThreadContinuedEvent} ThreadContinuedEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadContinuedEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.ThreadContinuedEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.threadId = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a ThreadContinuedEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.ThreadContinuedEvent} ThreadContinuedEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadContinuedEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ThreadContinuedEvent message.
             * @function verify
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ThreadContinuedEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (!$util.isInteger(message.threadId) && !(message.threadId && $util.isInteger(message.threadId.low) && $util.isInteger(message.threadId.high)))
                        return "threadId: integer|Long expected";
                return null;
            };
            /**
             * Creates a ThreadContinuedEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.ThreadContinuedEvent} ThreadContinuedEvent
             */
            ThreadContinuedEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.ThreadContinuedEvent)
                    return object;
                var message = new $root.skylark_debugging.ThreadContinuedEvent();
                if (object.threadId != null)
                    if ($util.Long)
                        (message.threadId = $util.Long.fromValue(object.threadId)).unsigned = false;
                    else if (typeof object.threadId === "string")
                        message.threadId = parseInt(object.threadId, 10);
                    else if (typeof object.threadId === "number")
                        message.threadId = object.threadId;
                    else if (typeof object.threadId === "object")
                        message.threadId = new $util.LongBits(object.threadId.low >>> 0, object.threadId.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from a ThreadContinuedEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @static
             * @param {skylark_debugging.ThreadContinuedEvent} message ThreadContinuedEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ThreadContinuedEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.threadId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.threadId = options.longs === String ? "0" : 0;
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (typeof message.threadId === "number")
                        object.threadId = options.longs === String ? String(message.threadId) : message.threadId;
                    else
                        object.threadId = options.longs === String ? $util.Long.prototype.toString.call(message.threadId) : options.longs === Number ? new $util.LongBits(message.threadId.low >>> 0, message.threadId.high >>> 0).toNumber() : message.threadId;
                return object;
            };
            /**
             * Converts this ThreadContinuedEvent to JSON.
             * @function toJSON
             * @memberof skylark_debugging.ThreadContinuedEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ThreadContinuedEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ThreadContinuedEvent;
        })();
        skylark_debugging.Breakpoint = (function () {
            /**
             * Properties of a Breakpoint.
             * @memberof skylark_debugging
             * @interface IBreakpoint
             * @property {skylark_debugging.ILocation|null} [location] Breakpoint location
             * @property {string|null} [expression] Breakpoint expression
             */
            /**
             * Constructs a new Breakpoint.
             * @memberof skylark_debugging
             * @classdesc Represents a Breakpoint.
             * @implements IBreakpoint
             * @constructor
             * @param {skylark_debugging.IBreakpoint=} [properties] Properties to set
             */
            function Breakpoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Breakpoint location.
             * @member {skylark_debugging.ILocation|null|undefined} location
             * @memberof skylark_debugging.Breakpoint
             * @instance
             */
            Breakpoint.prototype.location = null;
            /**
             * Breakpoint expression.
             * @member {string} expression
             * @memberof skylark_debugging.Breakpoint
             * @instance
             */
            Breakpoint.prototype.expression = "";
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
            /**
             * Breakpoint condition.
             * @member {"location"|undefined} condition
             * @memberof skylark_debugging.Breakpoint
             * @instance
             */
            Object.defineProperty(Breakpoint.prototype, "condition", {
                get: $util.oneOfGetter($oneOfFields = ["location"]),
                set: $util.oneOfSetter($oneOfFields)
            });
            /**
             * Creates a new Breakpoint instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.Breakpoint
             * @static
             * @param {skylark_debugging.IBreakpoint=} [properties] Properties to set
             * @returns {skylark_debugging.Breakpoint} Breakpoint instance
             */
            Breakpoint.create = function create(properties) {
                return new Breakpoint(properties);
            };
            /**
             * Encodes the specified Breakpoint message. Does not implicitly {@link skylark_debugging.Breakpoint.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.Breakpoint
             * @static
             * @param {skylark_debugging.IBreakpoint} message Breakpoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Breakpoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.hasOwnProperty("location"))
                    $root.skylark_debugging.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                if (message.expression != null && message.hasOwnProperty("expression"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.expression);
                return writer;
            };
            /**
             * Encodes the specified Breakpoint message, length delimited. Does not implicitly {@link skylark_debugging.Breakpoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.Breakpoint
             * @static
             * @param {skylark_debugging.IBreakpoint} message Breakpoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Breakpoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Breakpoint message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.Breakpoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.Breakpoint} Breakpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Breakpoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.Breakpoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.location = $root.skylark_debugging.Location.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.expression = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Breakpoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.Breakpoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.Breakpoint} Breakpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Breakpoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Breakpoint message.
             * @function verify
             * @memberof skylark_debugging.Breakpoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Breakpoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.location != null && message.hasOwnProperty("location")) {
                    properties.condition = 1;
                    {
                        var error = $root.skylark_debugging.Location.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                }
                if (message.expression != null && message.hasOwnProperty("expression"))
                    if (!$util.isString(message.expression))
                        return "expression: string expected";
                return null;
            };
            /**
             * Creates a Breakpoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.Breakpoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.Breakpoint} Breakpoint
             */
            Breakpoint.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.Breakpoint)
                    return object;
                var message = new $root.skylark_debugging.Breakpoint();
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".skylark_debugging.Breakpoint.location: object expected");
                    message.location = $root.skylark_debugging.Location.fromObject(object.location);
                }
                if (object.expression != null)
                    message.expression = String(object.expression);
                return message;
            };
            /**
             * Creates a plain object from a Breakpoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.Breakpoint
             * @static
             * @param {skylark_debugging.Breakpoint} message Breakpoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Breakpoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.expression = "";
                if (message.location != null && message.hasOwnProperty("location")) {
                    object.location = $root.skylark_debugging.Location.toObject(message.location, options);
                    if (options.oneofs)
                        object.condition = "location";
                }
                if (message.expression != null && message.hasOwnProperty("expression"))
                    object.expression = message.expression;
                return object;
            };
            /**
             * Converts this Breakpoint to JSON.
             * @function toJSON
             * @memberof skylark_debugging.Breakpoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Breakpoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Breakpoint;
        })();
        skylark_debugging.Frame = (function () {
            /**
             * Properties of a Frame.
             * @memberof skylark_debugging
             * @interface IFrame
             * @property {string|null} [functionName] Frame functionName
             * @property {Array.<skylark_debugging.IScope>|null} [scope] Frame scope
             * @property {skylark_debugging.ILocation|null} [location] Frame location
             */
            /**
             * Constructs a new Frame.
             * @memberof skylark_debugging
             * @classdesc Represents a Frame.
             * @implements IFrame
             * @constructor
             * @param {skylark_debugging.IFrame=} [properties] Properties to set
             */
            function Frame(properties) {
                this.scope = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Frame functionName.
             * @member {string} functionName
             * @memberof skylark_debugging.Frame
             * @instance
             */
            Frame.prototype.functionName = "";
            /**
             * Frame scope.
             * @member {Array.<skylark_debugging.IScope>} scope
             * @memberof skylark_debugging.Frame
             * @instance
             */
            Frame.prototype.scope = $util.emptyArray;
            /**
             * Frame location.
             * @member {skylark_debugging.ILocation|null|undefined} location
             * @memberof skylark_debugging.Frame
             * @instance
             */
            Frame.prototype.location = null;
            /**
             * Creates a new Frame instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.Frame
             * @static
             * @param {skylark_debugging.IFrame=} [properties] Properties to set
             * @returns {skylark_debugging.Frame} Frame instance
             */
            Frame.create = function create(properties) {
                return new Frame(properties);
            };
            /**
             * Encodes the specified Frame message. Does not implicitly {@link skylark_debugging.Frame.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.Frame
             * @static
             * @param {skylark_debugging.IFrame} message Frame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Frame.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.functionName != null && message.hasOwnProperty("functionName"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.functionName);
                if (message.scope != null && message.scope.length)
                    for (var i = 0; i < message.scope.length; ++i)
                        $root.skylark_debugging.Scope.encode(message.scope[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.location != null && message.hasOwnProperty("location"))
                    $root.skylark_debugging.Location.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified Frame message, length delimited. Does not implicitly {@link skylark_debugging.Frame.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.Frame
             * @static
             * @param {skylark_debugging.IFrame} message Frame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Frame.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Frame message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.Frame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.Frame} Frame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Frame.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.Frame();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.functionName = reader.string();
                            break;
                        case 2:
                            if (!(message.scope && message.scope.length))
                                message.scope = [];
                            message.scope.push($root.skylark_debugging.Scope.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.location = $root.skylark_debugging.Location.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Frame message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.Frame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.Frame} Frame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Frame.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Frame message.
             * @function verify
             * @memberof skylark_debugging.Frame
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Frame.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.functionName != null && message.hasOwnProperty("functionName"))
                    if (!$util.isString(message.functionName))
                        return "functionName: string expected";
                if (message.scope != null && message.hasOwnProperty("scope")) {
                    if (!Array.isArray(message.scope))
                        return "scope: array expected";
                    for (var i = 0; i < message.scope.length; ++i) {
                        var error = $root.skylark_debugging.Scope.verify(message.scope[i]);
                        if (error)
                            return "scope." + error;
                    }
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    var error = $root.skylark_debugging.Location.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                return null;
            };
            /**
             * Creates a Frame message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.Frame
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.Frame} Frame
             */
            Frame.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.Frame)
                    return object;
                var message = new $root.skylark_debugging.Frame();
                if (object.functionName != null)
                    message.functionName = String(object.functionName);
                if (object.scope) {
                    if (!Array.isArray(object.scope))
                        throw TypeError(".skylark_debugging.Frame.scope: array expected");
                    message.scope = [];
                    for (var i = 0; i < object.scope.length; ++i) {
                        if (typeof object.scope[i] !== "object")
                            throw TypeError(".skylark_debugging.Frame.scope: object expected");
                        message.scope[i] = $root.skylark_debugging.Scope.fromObject(object.scope[i]);
                    }
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".skylark_debugging.Frame.location: object expected");
                    message.location = $root.skylark_debugging.Location.fromObject(object.location);
                }
                return message;
            };
            /**
             * Creates a plain object from a Frame message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.Frame
             * @static
             * @param {skylark_debugging.Frame} message Frame
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Frame.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.scope = [];
                if (options.defaults) {
                    object.functionName = "";
                    object.location = null;
                }
                if (message.functionName != null && message.hasOwnProperty("functionName"))
                    object.functionName = message.functionName;
                if (message.scope && message.scope.length) {
                    object.scope = [];
                    for (var j = 0; j < message.scope.length; ++j)
                        object.scope[j] = $root.skylark_debugging.Scope.toObject(message.scope[j], options);
                }
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.skylark_debugging.Location.toObject(message.location, options);
                return object;
            };
            /**
             * Converts this Frame to JSON.
             * @function toJSON
             * @memberof skylark_debugging.Frame
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Frame.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Frame;
        })();
        skylark_debugging.Location = (function () {
            /**
             * Properties of a Location.
             * @memberof skylark_debugging
             * @interface ILocation
             * @property {string|null} [path] Location path
             * @property {number|null} [lineNumber] Location lineNumber
             * @property {number|null} [columnNumber] Location columnNumber
             */
            /**
             * Constructs a new Location.
             * @memberof skylark_debugging
             * @classdesc Represents a Location.
             * @implements ILocation
             * @constructor
             * @param {skylark_debugging.ILocation=} [properties] Properties to set
             */
            function Location(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Location path.
             * @member {string} path
             * @memberof skylark_debugging.Location
             * @instance
             */
            Location.prototype.path = "";
            /**
             * Location lineNumber.
             * @member {number} lineNumber
             * @memberof skylark_debugging.Location
             * @instance
             */
            Location.prototype.lineNumber = 0;
            /**
             * Location columnNumber.
             * @member {number} columnNumber
             * @memberof skylark_debugging.Location
             * @instance
             */
            Location.prototype.columnNumber = 0;
            /**
             * Creates a new Location instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.Location
             * @static
             * @param {skylark_debugging.ILocation=} [properties] Properties to set
             * @returns {skylark_debugging.Location} Location instance
             */
            Location.create = function create(properties) {
                return new Location(properties);
            };
            /**
             * Encodes the specified Location message. Does not implicitly {@link skylark_debugging.Location.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.Location
             * @static
             * @param {skylark_debugging.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.path);
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.lineNumber);
                if (message.columnNumber != null && message.hasOwnProperty("columnNumber"))
                    writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.columnNumber);
                return writer;
            };
            /**
             * Encodes the specified Location message, length delimited. Does not implicitly {@link skylark_debugging.Location.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.Location
             * @static
             * @param {skylark_debugging.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Location message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.Location();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.path = reader.string();
                            break;
                        case 2:
                            message.lineNumber = reader.uint32();
                            break;
                        case 3:
                            message.columnNumber = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Location message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Location message.
             * @function verify
             * @memberof skylark_debugging.Location
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Location.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    if (!$util.isInteger(message.lineNumber))
                        return "lineNumber: integer expected";
                if (message.columnNumber != null && message.hasOwnProperty("columnNumber"))
                    if (!$util.isInteger(message.columnNumber))
                        return "columnNumber: integer expected";
                return null;
            };
            /**
             * Creates a Location message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.Location
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.Location} Location
             */
            Location.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.Location)
                    return object;
                var message = new $root.skylark_debugging.Location();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.lineNumber != null)
                    message.lineNumber = object.lineNumber >>> 0;
                if (object.columnNumber != null)
                    message.columnNumber = object.columnNumber >>> 0;
                return message;
            };
            /**
             * Creates a plain object from a Location message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.Location
             * @static
             * @param {skylark_debugging.Location} message Location
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Location.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.lineNumber = 0;
                    object.columnNumber = 0;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.lineNumber != null && message.hasOwnProperty("lineNumber"))
                    object.lineNumber = message.lineNumber;
                if (message.columnNumber != null && message.hasOwnProperty("columnNumber"))
                    object.columnNumber = message.columnNumber;
                return object;
            };
            /**
             * Converts this Location to JSON.
             * @function toJSON
             * @memberof skylark_debugging.Location
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Location.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Location;
        })();
        skylark_debugging.Scope = (function () {
            /**
             * Properties of a Scope.
             * @memberof skylark_debugging
             * @interface IScope
             * @property {string|null} [name] Scope name
             * @property {Array.<skylark_debugging.IValue>|null} [binding] Scope binding
             */
            /**
             * Constructs a new Scope.
             * @memberof skylark_debugging
             * @classdesc Represents a Scope.
             * @implements IScope
             * @constructor
             * @param {skylark_debugging.IScope=} [properties] Properties to set
             */
            function Scope(properties) {
                this.binding = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Scope name.
             * @member {string} name
             * @memberof skylark_debugging.Scope
             * @instance
             */
            Scope.prototype.name = "";
            /**
             * Scope binding.
             * @member {Array.<skylark_debugging.IValue>} binding
             * @memberof skylark_debugging.Scope
             * @instance
             */
            Scope.prototype.binding = $util.emptyArray;
            /**
             * Creates a new Scope instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.Scope
             * @static
             * @param {skylark_debugging.IScope=} [properties] Properties to set
             * @returns {skylark_debugging.Scope} Scope instance
             */
            Scope.create = function create(properties) {
                return new Scope(properties);
            };
            /**
             * Encodes the specified Scope message. Does not implicitly {@link skylark_debugging.Scope.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.Scope
             * @static
             * @param {skylark_debugging.IScope} message Scope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                if (message.binding != null && message.binding.length)
                    for (var i = 0; i < message.binding.length; ++i)
                        $root.skylark_debugging.Value.encode(message.binding[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified Scope message, length delimited. Does not implicitly {@link skylark_debugging.Scope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.Scope
             * @static
             * @param {skylark_debugging.IScope} message Scope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Scope message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.Scope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.Scope} Scope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.Scope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.binding && message.binding.length))
                                message.binding = [];
                            message.binding.push($root.skylark_debugging.Value.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Scope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.Scope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.Scope} Scope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Scope message.
             * @function verify
             * @memberof skylark_debugging.Scope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Scope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.binding != null && message.hasOwnProperty("binding")) {
                    if (!Array.isArray(message.binding))
                        return "binding: array expected";
                    for (var i = 0; i < message.binding.length; ++i) {
                        var error = $root.skylark_debugging.Value.verify(message.binding[i]);
                        if (error)
                            return "binding." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a Scope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.Scope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.Scope} Scope
             */
            Scope.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.Scope)
                    return object;
                var message = new $root.skylark_debugging.Scope();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.binding) {
                    if (!Array.isArray(object.binding))
                        throw TypeError(".skylark_debugging.Scope.binding: array expected");
                    message.binding = [];
                    for (var i = 0; i < object.binding.length; ++i) {
                        if (typeof object.binding[i] !== "object")
                            throw TypeError(".skylark_debugging.Scope.binding: object expected");
                        message.binding[i] = $root.skylark_debugging.Value.fromObject(object.binding[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a Scope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.Scope
             * @static
             * @param {skylark_debugging.Scope} message Scope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Scope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.binding = [];
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.binding && message.binding.length) {
                    object.binding = [];
                    for (var j = 0; j < message.binding.length; ++j)
                        object.binding[j] = $root.skylark_debugging.Value.toObject(message.binding[j], options);
                }
                return object;
            };
            /**
             * Converts this Scope to JSON.
             * @function toJSON
             * @memberof skylark_debugging.Scope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Scope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Scope;
        })();
        /**
         * Stepping enum.
         * @name skylark_debugging.Stepping
         * @enum {string}
         * @property {number} NONE=0 NONE value
         * @property {number} INTO=1 INTO value
         * @property {number} OVER=2 OVER value
         * @property {number} OUT=3 OUT value
         */
        skylark_debugging.Stepping = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "INTO"] = 1;
            values[valuesById[2] = "OVER"] = 2;
            values[valuesById[3] = "OUT"] = 3;
            return values;
        })();
        skylark_debugging.PausedThread = (function () {
            /**
             * Properties of a PausedThread.
             * @memberof skylark_debugging
             * @interface IPausedThread
             * @property {number|Long|null} [id] PausedThread id
             * @property {string|null} [name] PausedThread name
             * @property {skylark_debugging.PauseReason|null} [pauseReason] PausedThread pauseReason
             * @property {skylark_debugging.ILocation|null} [location] PausedThread location
             * @property {skylark_debugging.IError|null} [conditionalBreakpointError] PausedThread conditionalBreakpointError
             */
            /**
             * Constructs a new PausedThread.
             * @memberof skylark_debugging
             * @classdesc Represents a PausedThread.
             * @implements IPausedThread
             * @constructor
             * @param {skylark_debugging.IPausedThread=} [properties] Properties to set
             */
            function PausedThread(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * PausedThread id.
             * @member {number|Long} id
             * @memberof skylark_debugging.PausedThread
             * @instance
             */
            PausedThread.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * PausedThread name.
             * @member {string} name
             * @memberof skylark_debugging.PausedThread
             * @instance
             */
            PausedThread.prototype.name = "";
            /**
             * PausedThread pauseReason.
             * @member {skylark_debugging.PauseReason} pauseReason
             * @memberof skylark_debugging.PausedThread
             * @instance
             */
            PausedThread.prototype.pauseReason = 0;
            /**
             * PausedThread location.
             * @member {skylark_debugging.ILocation|null|undefined} location
             * @memberof skylark_debugging.PausedThread
             * @instance
             */
            PausedThread.prototype.location = null;
            /**
             * PausedThread conditionalBreakpointError.
             * @member {skylark_debugging.IError|null|undefined} conditionalBreakpointError
             * @memberof skylark_debugging.PausedThread
             * @instance
             */
            PausedThread.prototype.conditionalBreakpointError = null;
            /**
             * Creates a new PausedThread instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.PausedThread
             * @static
             * @param {skylark_debugging.IPausedThread=} [properties] Properties to set
             * @returns {skylark_debugging.PausedThread} PausedThread instance
             */
            PausedThread.create = function create(properties) {
                return new PausedThread(properties);
            };
            /**
             * Encodes the specified PausedThread message. Does not implicitly {@link skylark_debugging.PausedThread.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.PausedThread
             * @static
             * @param {skylark_debugging.IPausedThread} message PausedThread message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PausedThread.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
                if (message.pauseReason != null && message.hasOwnProperty("pauseReason"))
                    writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.pauseReason);
                if (message.location != null && message.hasOwnProperty("location"))
                    $root.skylark_debugging.Location.encode(message.location, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.conditionalBreakpointError != null && message.hasOwnProperty("conditionalBreakpointError"))
                    $root.skylark_debugging.Error.encode(message.conditionalBreakpointError, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified PausedThread message, length delimited. Does not implicitly {@link skylark_debugging.PausedThread.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.PausedThread
             * @static
             * @param {skylark_debugging.IPausedThread} message PausedThread message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PausedThread.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PausedThread message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.PausedThread
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.PausedThread} PausedThread
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PausedThread.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.PausedThread();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.id = reader.int64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.pauseReason = reader.int32();
                            break;
                        case 4:
                            message.location = $root.skylark_debugging.Location.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.conditionalBreakpointError = $root.skylark_debugging.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a PausedThread message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.PausedThread
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.PausedThread} PausedThread
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PausedThread.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PausedThread message.
             * @function verify
             * @memberof skylark_debugging.PausedThread
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PausedThread.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.pauseReason != null && message.hasOwnProperty("pauseReason"))
                    switch (message.pauseReason) {
                        default:
                            return "pauseReason: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                    }
                if (message.location != null && message.hasOwnProperty("location")) {
                    var error = $root.skylark_debugging.Location.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.conditionalBreakpointError != null && message.hasOwnProperty("conditionalBreakpointError")) {
                    var error = $root.skylark_debugging.Error.verify(message.conditionalBreakpointError);
                    if (error)
                        return "conditionalBreakpointError." + error;
                }
                return null;
            };
            /**
             * Creates a PausedThread message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.PausedThread
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.PausedThread} PausedThread
             */
            PausedThread.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.PausedThread)
                    return object;
                var message = new $root.skylark_debugging.PausedThread();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.pauseReason) {
                    case "UNSET":
                    case 0:
                        message.pauseReason = 0;
                        break;
                    case "STEPPING":
                    case 1:
                        message.pauseReason = 1;
                        break;
                    case "ALL_THREADS_PAUSED":
                    case 2:
                        message.pauseReason = 2;
                        break;
                    case "PAUSE_THREAD_REQUEST":
                    case 3:
                        message.pauseReason = 3;
                        break;
                    case "HIT_BREAKPOINT":
                    case 4:
                        message.pauseReason = 4;
                        break;
                    case "CONDITIONAL_BREAKPOINT_ERROR":
                    case 5:
                        message.pauseReason = 5;
                        break;
                    case "INITIALIZING":
                    case 6:
                        message.pauseReason = 6;
                        break;
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".skylark_debugging.PausedThread.location: object expected");
                    message.location = $root.skylark_debugging.Location.fromObject(object.location);
                }
                if (object.conditionalBreakpointError != null) {
                    if (typeof object.conditionalBreakpointError !== "object")
                        throw TypeError(".skylark_debugging.PausedThread.conditionalBreakpointError: object expected");
                    message.conditionalBreakpointError = $root.skylark_debugging.Error.fromObject(object.conditionalBreakpointError);
                }
                return message;
            };
            /**
             * Creates a plain object from a PausedThread message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.PausedThread
             * @static
             * @param {skylark_debugging.PausedThread} message PausedThread
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PausedThread.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.id = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.pauseReason = options.enums === String ? "UNSET" : 0;
                    object.location = null;
                    object.conditionalBreakpointError = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.pauseReason != null && message.hasOwnProperty("pauseReason"))
                    object.pauseReason = options.enums === String ? $root.skylark_debugging.PauseReason[message.pauseReason] : message.pauseReason;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.skylark_debugging.Location.toObject(message.location, options);
                if (message.conditionalBreakpointError != null && message.hasOwnProperty("conditionalBreakpointError"))
                    object.conditionalBreakpointError = $root.skylark_debugging.Error.toObject(message.conditionalBreakpointError, options);
                return object;
            };
            /**
             * Converts this PausedThread to JSON.
             * @function toJSON
             * @memberof skylark_debugging.PausedThread
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PausedThread.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PausedThread;
        })();
        /**
         * PauseReason enum.
         * @name skylark_debugging.PauseReason
         * @enum {string}
         * @property {number} UNSET=0 UNSET value
         * @property {number} STEPPING=1 STEPPING value
         * @property {number} ALL_THREADS_PAUSED=2 ALL_THREADS_PAUSED value
         * @property {number} PAUSE_THREAD_REQUEST=3 PAUSE_THREAD_REQUEST value
         * @property {number} HIT_BREAKPOINT=4 HIT_BREAKPOINT value
         * @property {number} CONDITIONAL_BREAKPOINT_ERROR=5 CONDITIONAL_BREAKPOINT_ERROR value
         * @property {number} INITIALIZING=6 INITIALIZING value
         */
        skylark_debugging.PauseReason = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSET"] = 0;
            values[valuesById[1] = "STEPPING"] = 1;
            values[valuesById[2] = "ALL_THREADS_PAUSED"] = 2;
            values[valuesById[3] = "PAUSE_THREAD_REQUEST"] = 3;
            values[valuesById[4] = "HIT_BREAKPOINT"] = 4;
            values[valuesById[5] = "CONDITIONAL_BREAKPOINT_ERROR"] = 5;
            values[valuesById[6] = "INITIALIZING"] = 6;
            return values;
        })();
        skylark_debugging.Value = (function () {
            /**
             * Properties of a Value.
             * @memberof skylark_debugging
             * @interface IValue
             * @property {string|null} [label] Value label
             * @property {string|null} [description] Value description
             * @property {string|null} [type] Value type
             * @property {boolean|null} [hasChildren] Value hasChildren
             * @property {number|Long|null} [id] Value id
             */
            /**
             * Constructs a new Value.
             * @memberof skylark_debugging
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {skylark_debugging.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Value label.
             * @member {string} label
             * @memberof skylark_debugging.Value
             * @instance
             */
            Value.prototype.label = "";
            /**
             * Value description.
             * @member {string} description
             * @memberof skylark_debugging.Value
             * @instance
             */
            Value.prototype.description = "";
            /**
             * Value type.
             * @member {string} type
             * @memberof skylark_debugging.Value
             * @instance
             */
            Value.prototype.type = "";
            /**
             * Value hasChildren.
             * @member {boolean} hasChildren
             * @memberof skylark_debugging.Value
             * @instance
             */
            Value.prototype.hasChildren = false;
            /**
             * Value id.
             * @member {number|Long} id
             * @memberof skylark_debugging.Value
             * @instance
             */
            Value.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof skylark_debugging.Value
             * @static
             * @param {skylark_debugging.IValue=} [properties] Properties to set
             * @returns {skylark_debugging.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };
            /**
             * Encodes the specified Value message. Does not implicitly {@link skylark_debugging.Value.verify|verify} messages.
             * @function encode
             * @memberof skylark_debugging.Value
             * @static
             * @param {skylark_debugging.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.label);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.description);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.type);
                if (message.hasChildren != null && message.hasOwnProperty("hasChildren"))
                    writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.hasChildren);
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.id);
                return writer;
            };
            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link skylark_debugging.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof skylark_debugging.Value
             * @static
             * @param {skylark_debugging.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof skylark_debugging.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {skylark_debugging.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.skylark_debugging.Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.label = reader.string();
                            break;
                        case 2:
                            message.description = reader.string();
                            break;
                        case 3:
                            message.type = reader.string();
                            break;
                        case 4:
                            message.hasChildren = reader.bool();
                            break;
                        case 5:
                            message.id = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof skylark_debugging.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {skylark_debugging.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Value message.
             * @function verify
             * @memberof skylark_debugging.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.hasChildren != null && message.hasOwnProperty("hasChildren"))
                    if (typeof message.hasChildren !== "boolean")
                        return "hasChildren: boolean expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                return null;
            };
            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof skylark_debugging.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {skylark_debugging.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.skylark_debugging.Value)
                    return object;
                var message = new $root.skylark_debugging.Value();
                if (object.label != null)
                    message.label = String(object.label);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.type != null)
                    message.type = String(object.type);
                if (object.hasChildren != null)
                    message.hasChildren = Boolean(object.hasChildren);
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                return message;
            };
            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof skylark_debugging.Value
             * @static
             * @param {skylark_debugging.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.label = "";
                    object.description = "";
                    object.type = "";
                    object.hasChildren = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.id = options.longs === String ? "0" : 0;
                }
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.hasChildren != null && message.hasOwnProperty("hasChildren"))
                    object.hasChildren = message.hasChildren;
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                return object;
            };
            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof skylark_debugging.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Value;
        })();
        return skylark_debugging;
    })();
    $root.blaze_query = (function () {
        /**
         * Namespace blaze_query.
         * @exports blaze_query
         * @namespace
         */
        var blaze_query = {};
        blaze_query.License = (function () {
            /**
             * Properties of a License.
             * @memberof blaze_query
             * @interface ILicense
             * @property {Array.<string>|null} [licenseType] License licenseType
             * @property {Array.<string>|null} [exception] License exception
             */
            /**
             * Constructs a new License.
             * @memberof blaze_query
             * @classdesc Represents a License.
             * @implements ILicense
             * @constructor
             * @param {blaze_query.ILicense=} [properties] Properties to set
             */
            function License(properties) {
                this.licenseType = [];
                this.exception = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * License licenseType.
             * @member {Array.<string>} licenseType
             * @memberof blaze_query.License
             * @instance
             */
            License.prototype.licenseType = $util.emptyArray;
            /**
             * License exception.
             * @member {Array.<string>} exception
             * @memberof blaze_query.License
             * @instance
             */
            License.prototype.exception = $util.emptyArray;
            /**
             * Creates a new License instance using the specified properties.
             * @function create
             * @memberof blaze_query.License
             * @static
             * @param {blaze_query.ILicense=} [properties] Properties to set
             * @returns {blaze_query.License} License instance
             */
            License.create = function create(properties) {
                return new License(properties);
            };
            /**
             * Encodes the specified License message. Does not implicitly {@link blaze_query.License.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.License
             * @static
             * @param {blaze_query.ILicense} message License message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            License.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.licenseType != null && message.licenseType.length)
                    for (var i = 0; i < message.licenseType.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.licenseType[i]);
                if (message.exception != null && message.exception.length)
                    for (var i = 0; i < message.exception.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.exception[i]);
                return writer;
            };
            /**
             * Encodes the specified License message, length delimited. Does not implicitly {@link blaze_query.License.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.License
             * @static
             * @param {blaze_query.ILicense} message License message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            License.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a License message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.License
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.License} License
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            License.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.License();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.licenseType && message.licenseType.length))
                                message.licenseType = [];
                            message.licenseType.push(reader.string());
                            break;
                        case 2:
                            if (!(message.exception && message.exception.length))
                                message.exception = [];
                            message.exception.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a License message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.License
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.License} License
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            License.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a License message.
             * @function verify
             * @memberof blaze_query.License
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            License.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.licenseType != null && message.hasOwnProperty("licenseType")) {
                    if (!Array.isArray(message.licenseType))
                        return "licenseType: array expected";
                    for (var i = 0; i < message.licenseType.length; ++i)
                        if (!$util.isString(message.licenseType[i]))
                            return "licenseType: string[] expected";
                }
                if (message.exception != null && message.hasOwnProperty("exception")) {
                    if (!Array.isArray(message.exception))
                        return "exception: array expected";
                    for (var i = 0; i < message.exception.length; ++i)
                        if (!$util.isString(message.exception[i]))
                            return "exception: string[] expected";
                }
                return null;
            };
            /**
             * Creates a License message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.License
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.License} License
             */
            License.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.License)
                    return object;
                var message = new $root.blaze_query.License();
                if (object.licenseType) {
                    if (!Array.isArray(object.licenseType))
                        throw TypeError(".blaze_query.License.licenseType: array expected");
                    message.licenseType = [];
                    for (var i = 0; i < object.licenseType.length; ++i)
                        message.licenseType[i] = String(object.licenseType[i]);
                }
                if (object.exception) {
                    if (!Array.isArray(object.exception))
                        throw TypeError(".blaze_query.License.exception: array expected");
                    message.exception = [];
                    for (var i = 0; i < object.exception.length; ++i)
                        message.exception[i] = String(object.exception[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from a License message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.License
             * @static
             * @param {blaze_query.License} message License
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            License.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.licenseType = [];
                    object.exception = [];
                }
                if (message.licenseType && message.licenseType.length) {
                    object.licenseType = [];
                    for (var j = 0; j < message.licenseType.length; ++j)
                        object.licenseType[j] = message.licenseType[j];
                }
                if (message.exception && message.exception.length) {
                    object.exception = [];
                    for (var j = 0; j < message.exception.length; ++j)
                        object.exception[j] = message.exception[j];
                }
                return object;
            };
            /**
             * Converts this License to JSON.
             * @function toJSON
             * @memberof blaze_query.License
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            License.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return License;
        })();
        blaze_query.StringDictEntry = (function () {
            /**
             * Properties of a StringDictEntry.
             * @memberof blaze_query
             * @interface IStringDictEntry
             * @property {string} key StringDictEntry key
             * @property {string} value StringDictEntry value
             */
            /**
             * Constructs a new StringDictEntry.
             * @memberof blaze_query
             * @classdesc Represents a StringDictEntry.
             * @implements IStringDictEntry
             * @constructor
             * @param {blaze_query.IStringDictEntry=} [properties] Properties to set
             */
            function StringDictEntry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * StringDictEntry key.
             * @member {string} key
             * @memberof blaze_query.StringDictEntry
             * @instance
             */
            StringDictEntry.prototype.key = "";
            /**
             * StringDictEntry value.
             * @member {string} value
             * @memberof blaze_query.StringDictEntry
             * @instance
             */
            StringDictEntry.prototype.value = "";
            /**
             * Creates a new StringDictEntry instance using the specified properties.
             * @function create
             * @memberof blaze_query.StringDictEntry
             * @static
             * @param {blaze_query.IStringDictEntry=} [properties] Properties to set
             * @returns {blaze_query.StringDictEntry} StringDictEntry instance
             */
            StringDictEntry.create = function create(properties) {
                return new StringDictEntry(properties);
            };
            /**
             * Encodes the specified StringDictEntry message. Does not implicitly {@link blaze_query.StringDictEntry.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.StringDictEntry
             * @static
             * @param {blaze_query.IStringDictEntry} message StringDictEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringDictEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
                return writer;
            };
            /**
             * Encodes the specified StringDictEntry message, length delimited. Does not implicitly {@link blaze_query.StringDictEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.StringDictEntry
             * @static
             * @param {blaze_query.IStringDictEntry} message StringDictEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringDictEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a StringDictEntry message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.StringDictEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.StringDictEntry} StringDictEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringDictEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.StringDictEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("key"))
                    throw $util.ProtocolError("missing required 'key'", { instance: message });
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                return message;
            };
            /**
             * Decodes a StringDictEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.StringDictEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.StringDictEntry} StringDictEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringDictEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a StringDictEntry message.
             * @function verify
             * @memberof blaze_query.StringDictEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StringDictEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.key))
                    return "key: string expected";
                if (!$util.isString(message.value))
                    return "value: string expected";
                return null;
            };
            /**
             * Creates a StringDictEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.StringDictEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.StringDictEntry} StringDictEntry
             */
            StringDictEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.StringDictEntry)
                    return object;
                var message = new $root.blaze_query.StringDictEntry();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
            /**
             * Creates a plain object from a StringDictEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.StringDictEntry
             * @static
             * @param {blaze_query.StringDictEntry} message StringDictEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringDictEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
            /**
             * Converts this StringDictEntry to JSON.
             * @function toJSON
             * @memberof blaze_query.StringDictEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringDictEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return StringDictEntry;
        })();
        blaze_query.LabelDictUnaryEntry = (function () {
            /**
             * Properties of a LabelDictUnaryEntry.
             * @memberof blaze_query
             * @interface ILabelDictUnaryEntry
             * @property {string} key LabelDictUnaryEntry key
             * @property {string} value LabelDictUnaryEntry value
             */
            /**
             * Constructs a new LabelDictUnaryEntry.
             * @memberof blaze_query
             * @classdesc Represents a LabelDictUnaryEntry.
             * @implements ILabelDictUnaryEntry
             * @constructor
             * @param {blaze_query.ILabelDictUnaryEntry=} [properties] Properties to set
             */
            function LabelDictUnaryEntry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * LabelDictUnaryEntry key.
             * @member {string} key
             * @memberof blaze_query.LabelDictUnaryEntry
             * @instance
             */
            LabelDictUnaryEntry.prototype.key = "";
            /**
             * LabelDictUnaryEntry value.
             * @member {string} value
             * @memberof blaze_query.LabelDictUnaryEntry
             * @instance
             */
            LabelDictUnaryEntry.prototype.value = "";
            /**
             * Creates a new LabelDictUnaryEntry instance using the specified properties.
             * @function create
             * @memberof blaze_query.LabelDictUnaryEntry
             * @static
             * @param {blaze_query.ILabelDictUnaryEntry=} [properties] Properties to set
             * @returns {blaze_query.LabelDictUnaryEntry} LabelDictUnaryEntry instance
             */
            LabelDictUnaryEntry.create = function create(properties) {
                return new LabelDictUnaryEntry(properties);
            };
            /**
             * Encodes the specified LabelDictUnaryEntry message. Does not implicitly {@link blaze_query.LabelDictUnaryEntry.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.LabelDictUnaryEntry
             * @static
             * @param {blaze_query.ILabelDictUnaryEntry} message LabelDictUnaryEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelDictUnaryEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
                return writer;
            };
            /**
             * Encodes the specified LabelDictUnaryEntry message, length delimited. Does not implicitly {@link blaze_query.LabelDictUnaryEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.LabelDictUnaryEntry
             * @static
             * @param {blaze_query.ILabelDictUnaryEntry} message LabelDictUnaryEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelDictUnaryEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LabelDictUnaryEntry message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.LabelDictUnaryEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.LabelDictUnaryEntry} LabelDictUnaryEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelDictUnaryEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.LabelDictUnaryEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("key"))
                    throw $util.ProtocolError("missing required 'key'", { instance: message });
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                return message;
            };
            /**
             * Decodes a LabelDictUnaryEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.LabelDictUnaryEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.LabelDictUnaryEntry} LabelDictUnaryEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelDictUnaryEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LabelDictUnaryEntry message.
             * @function verify
             * @memberof blaze_query.LabelDictUnaryEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LabelDictUnaryEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.key))
                    return "key: string expected";
                if (!$util.isString(message.value))
                    return "value: string expected";
                return null;
            };
            /**
             * Creates a LabelDictUnaryEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.LabelDictUnaryEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.LabelDictUnaryEntry} LabelDictUnaryEntry
             */
            LabelDictUnaryEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.LabelDictUnaryEntry)
                    return object;
                var message = new $root.blaze_query.LabelDictUnaryEntry();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
            /**
             * Creates a plain object from a LabelDictUnaryEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.LabelDictUnaryEntry
             * @static
             * @param {blaze_query.LabelDictUnaryEntry} message LabelDictUnaryEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LabelDictUnaryEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
            /**
             * Converts this LabelDictUnaryEntry to JSON.
             * @function toJSON
             * @memberof blaze_query.LabelDictUnaryEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LabelDictUnaryEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return LabelDictUnaryEntry;
        })();
        blaze_query.LabelListDictEntry = (function () {
            /**
             * Properties of a LabelListDictEntry.
             * @memberof blaze_query
             * @interface ILabelListDictEntry
             * @property {string} key LabelListDictEntry key
             * @property {Array.<string>|null} [value] LabelListDictEntry value
             */
            /**
             * Constructs a new LabelListDictEntry.
             * @memberof blaze_query
             * @classdesc Represents a LabelListDictEntry.
             * @implements ILabelListDictEntry
             * @constructor
             * @param {blaze_query.ILabelListDictEntry=} [properties] Properties to set
             */
            function LabelListDictEntry(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * LabelListDictEntry key.
             * @member {string} key
             * @memberof blaze_query.LabelListDictEntry
             * @instance
             */
            LabelListDictEntry.prototype.key = "";
            /**
             * LabelListDictEntry value.
             * @member {Array.<string>} value
             * @memberof blaze_query.LabelListDictEntry
             * @instance
             */
            LabelListDictEntry.prototype.value = $util.emptyArray;
            /**
             * Creates a new LabelListDictEntry instance using the specified properties.
             * @function create
             * @memberof blaze_query.LabelListDictEntry
             * @static
             * @param {blaze_query.ILabelListDictEntry=} [properties] Properties to set
             * @returns {blaze_query.LabelListDictEntry} LabelListDictEntry instance
             */
            LabelListDictEntry.create = function create(properties) {
                return new LabelListDictEntry(properties);
            };
            /**
             * Encodes the specified LabelListDictEntry message. Does not implicitly {@link blaze_query.LabelListDictEntry.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.LabelListDictEntry
             * @static
             * @param {blaze_query.ILabelListDictEntry} message LabelListDictEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelListDictEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value[i]);
                return writer;
            };
            /**
             * Encodes the specified LabelListDictEntry message, length delimited. Does not implicitly {@link blaze_query.LabelListDictEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.LabelListDictEntry
             * @static
             * @param {blaze_query.ILabelListDictEntry} message LabelListDictEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelListDictEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LabelListDictEntry message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.LabelListDictEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.LabelListDictEntry} LabelListDictEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelListDictEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.LabelListDictEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("key"))
                    throw $util.ProtocolError("missing required 'key'", { instance: message });
                return message;
            };
            /**
             * Decodes a LabelListDictEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.LabelListDictEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.LabelListDictEntry} LabelListDictEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelListDictEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LabelListDictEntry message.
             * @function verify
             * @memberof blaze_query.LabelListDictEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LabelListDictEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.key))
                    return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!$util.isString(message.value[i]))
                            return "value: string[] expected";
                }
                return null;
            };
            /**
             * Creates a LabelListDictEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.LabelListDictEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.LabelListDictEntry} LabelListDictEntry
             */
            LabelListDictEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.LabelListDictEntry)
                    return object;
                var message = new $root.blaze_query.LabelListDictEntry();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".blaze_query.LabelListDictEntry.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        message.value[i] = String(object.value[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from a LabelListDictEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.LabelListDictEntry
             * @static
             * @param {blaze_query.LabelListDictEntry} message LabelListDictEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LabelListDictEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = message.value[j];
                }
                return object;
            };
            /**
             * Converts this LabelListDictEntry to JSON.
             * @function toJSON
             * @memberof blaze_query.LabelListDictEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LabelListDictEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return LabelListDictEntry;
        })();
        blaze_query.LabelKeyedStringDictEntry = (function () {
            /**
             * Properties of a LabelKeyedStringDictEntry.
             * @memberof blaze_query
             * @interface ILabelKeyedStringDictEntry
             * @property {string} key LabelKeyedStringDictEntry key
             * @property {string} value LabelKeyedStringDictEntry value
             */
            /**
             * Constructs a new LabelKeyedStringDictEntry.
             * @memberof blaze_query
             * @classdesc Represents a LabelKeyedStringDictEntry.
             * @implements ILabelKeyedStringDictEntry
             * @constructor
             * @param {blaze_query.ILabelKeyedStringDictEntry=} [properties] Properties to set
             */
            function LabelKeyedStringDictEntry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * LabelKeyedStringDictEntry key.
             * @member {string} key
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @instance
             */
            LabelKeyedStringDictEntry.prototype.key = "";
            /**
             * LabelKeyedStringDictEntry value.
             * @member {string} value
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @instance
             */
            LabelKeyedStringDictEntry.prototype.value = "";
            /**
             * Creates a new LabelKeyedStringDictEntry instance using the specified properties.
             * @function create
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @static
             * @param {blaze_query.ILabelKeyedStringDictEntry=} [properties] Properties to set
             * @returns {blaze_query.LabelKeyedStringDictEntry} LabelKeyedStringDictEntry instance
             */
            LabelKeyedStringDictEntry.create = function create(properties) {
                return new LabelKeyedStringDictEntry(properties);
            };
            /**
             * Encodes the specified LabelKeyedStringDictEntry message. Does not implicitly {@link blaze_query.LabelKeyedStringDictEntry.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @static
             * @param {blaze_query.ILabelKeyedStringDictEntry} message LabelKeyedStringDictEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelKeyedStringDictEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
                return writer;
            };
            /**
             * Encodes the specified LabelKeyedStringDictEntry message, length delimited. Does not implicitly {@link blaze_query.LabelKeyedStringDictEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @static
             * @param {blaze_query.ILabelKeyedStringDictEntry} message LabelKeyedStringDictEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LabelKeyedStringDictEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LabelKeyedStringDictEntry message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.LabelKeyedStringDictEntry} LabelKeyedStringDictEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelKeyedStringDictEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.LabelKeyedStringDictEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("key"))
                    throw $util.ProtocolError("missing required 'key'", { instance: message });
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                return message;
            };
            /**
             * Decodes a LabelKeyedStringDictEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.LabelKeyedStringDictEntry} LabelKeyedStringDictEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LabelKeyedStringDictEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LabelKeyedStringDictEntry message.
             * @function verify
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LabelKeyedStringDictEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.key))
                    return "key: string expected";
                if (!$util.isString(message.value))
                    return "value: string expected";
                return null;
            };
            /**
             * Creates a LabelKeyedStringDictEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.LabelKeyedStringDictEntry} LabelKeyedStringDictEntry
             */
            LabelKeyedStringDictEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.LabelKeyedStringDictEntry)
                    return object;
                var message = new $root.blaze_query.LabelKeyedStringDictEntry();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
            /**
             * Creates a plain object from a LabelKeyedStringDictEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @static
             * @param {blaze_query.LabelKeyedStringDictEntry} message LabelKeyedStringDictEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LabelKeyedStringDictEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
            /**
             * Converts this LabelKeyedStringDictEntry to JSON.
             * @function toJSON
             * @memberof blaze_query.LabelKeyedStringDictEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LabelKeyedStringDictEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return LabelKeyedStringDictEntry;
        })();
        blaze_query.StringListDictEntry = (function () {
            /**
             * Properties of a StringListDictEntry.
             * @memberof blaze_query
             * @interface IStringListDictEntry
             * @property {string} key StringListDictEntry key
             * @property {Array.<string>|null} [value] StringListDictEntry value
             */
            /**
             * Constructs a new StringListDictEntry.
             * @memberof blaze_query
             * @classdesc Represents a StringListDictEntry.
             * @implements IStringListDictEntry
             * @constructor
             * @param {blaze_query.IStringListDictEntry=} [properties] Properties to set
             */
            function StringListDictEntry(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * StringListDictEntry key.
             * @member {string} key
             * @memberof blaze_query.StringListDictEntry
             * @instance
             */
            StringListDictEntry.prototype.key = "";
            /**
             * StringListDictEntry value.
             * @member {Array.<string>} value
             * @memberof blaze_query.StringListDictEntry
             * @instance
             */
            StringListDictEntry.prototype.value = $util.emptyArray;
            /**
             * Creates a new StringListDictEntry instance using the specified properties.
             * @function create
             * @memberof blaze_query.StringListDictEntry
             * @static
             * @param {blaze_query.IStringListDictEntry=} [properties] Properties to set
             * @returns {blaze_query.StringListDictEntry} StringListDictEntry instance
             */
            StringListDictEntry.create = function create(properties) {
                return new StringListDictEntry(properties);
            };
            /**
             * Encodes the specified StringListDictEntry message. Does not implicitly {@link blaze_query.StringListDictEntry.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.StringListDictEntry
             * @static
             * @param {blaze_query.IStringListDictEntry} message StringListDictEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringListDictEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value[i]);
                return writer;
            };
            /**
             * Encodes the specified StringListDictEntry message, length delimited. Does not implicitly {@link blaze_query.StringListDictEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.StringListDictEntry
             * @static
             * @param {blaze_query.IStringListDictEntry} message StringListDictEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringListDictEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a StringListDictEntry message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.StringListDictEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.StringListDictEntry} StringListDictEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringListDictEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.StringListDictEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("key"))
                    throw $util.ProtocolError("missing required 'key'", { instance: message });
                return message;
            };
            /**
             * Decodes a StringListDictEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.StringListDictEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.StringListDictEntry} StringListDictEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringListDictEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a StringListDictEntry message.
             * @function verify
             * @memberof blaze_query.StringListDictEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StringListDictEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.key))
                    return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!$util.isString(message.value[i]))
                            return "value: string[] expected";
                }
                return null;
            };
            /**
             * Creates a StringListDictEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.StringListDictEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.StringListDictEntry} StringListDictEntry
             */
            StringListDictEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.StringListDictEntry)
                    return object;
                var message = new $root.blaze_query.StringListDictEntry();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".blaze_query.StringListDictEntry.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        message.value[i] = String(object.value[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from a StringListDictEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.StringListDictEntry
             * @static
             * @param {blaze_query.StringListDictEntry} message StringListDictEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringListDictEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = message.value[j];
                }
                return object;
            };
            /**
             * Converts this StringListDictEntry to JSON.
             * @function toJSON
             * @memberof blaze_query.StringListDictEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringListDictEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return StringListDictEntry;
        })();
        blaze_query.FilesetEntry = (function () {
            /**
             * Properties of a FilesetEntry.
             * @memberof blaze_query
             * @interface IFilesetEntry
             * @property {string} source FilesetEntry source
             * @property {string} destinationDirectory FilesetEntry destinationDirectory
             * @property {boolean|null} [filesPresent] FilesetEntry filesPresent
             * @property {Array.<string>|null} [file] FilesetEntry file
             * @property {Array.<string>|null} [exclude] FilesetEntry exclude
             * @property {blaze_query.FilesetEntry.SymlinkBehavior|null} [symlinkBehavior] FilesetEntry symlinkBehavior
             * @property {string|null} [stripPrefix] FilesetEntry stripPrefix
             */
            /**
             * Constructs a new FilesetEntry.
             * @memberof blaze_query
             * @classdesc Represents a FilesetEntry.
             * @implements IFilesetEntry
             * @constructor
             * @param {blaze_query.IFilesetEntry=} [properties] Properties to set
             */
            function FilesetEntry(properties) {
                this.file = [];
                this.exclude = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FilesetEntry source.
             * @member {string} source
             * @memberof blaze_query.FilesetEntry
             * @instance
             */
            FilesetEntry.prototype.source = "";
            /**
             * FilesetEntry destinationDirectory.
             * @member {string} destinationDirectory
             * @memberof blaze_query.FilesetEntry
             * @instance
             */
            FilesetEntry.prototype.destinationDirectory = "";
            /**
             * FilesetEntry filesPresent.
             * @member {boolean} filesPresent
             * @memberof blaze_query.FilesetEntry
             * @instance
             */
            FilesetEntry.prototype.filesPresent = false;
            /**
             * FilesetEntry file.
             * @member {Array.<string>} file
             * @memberof blaze_query.FilesetEntry
             * @instance
             */
            FilesetEntry.prototype.file = $util.emptyArray;
            /**
             * FilesetEntry exclude.
             * @member {Array.<string>} exclude
             * @memberof blaze_query.FilesetEntry
             * @instance
             */
            FilesetEntry.prototype.exclude = $util.emptyArray;
            /**
             * FilesetEntry symlinkBehavior.
             * @member {blaze_query.FilesetEntry.SymlinkBehavior} symlinkBehavior
             * @memberof blaze_query.FilesetEntry
             * @instance
             */
            FilesetEntry.prototype.symlinkBehavior = 1;
            /**
             * FilesetEntry stripPrefix.
             * @member {string} stripPrefix
             * @memberof blaze_query.FilesetEntry
             * @instance
             */
            FilesetEntry.prototype.stripPrefix = "";
            /**
             * Creates a new FilesetEntry instance using the specified properties.
             * @function create
             * @memberof blaze_query.FilesetEntry
             * @static
             * @param {blaze_query.IFilesetEntry=} [properties] Properties to set
             * @returns {blaze_query.FilesetEntry} FilesetEntry instance
             */
            FilesetEntry.create = function create(properties) {
                return new FilesetEntry(properties);
            };
            /**
             * Encodes the specified FilesetEntry message. Does not implicitly {@link blaze_query.FilesetEntry.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.FilesetEntry
             * @static
             * @param {blaze_query.IFilesetEntry} message FilesetEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilesetEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.source);
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.destinationDirectory);
                if (message.file != null && message.file.length)
                    for (var i = 0; i < message.file.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.file[i]);
                if (message.exclude != null && message.exclude.length)
                    for (var i = 0; i < message.exclude.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.exclude[i]);
                if (message.symlinkBehavior != null && message.hasOwnProperty("symlinkBehavior"))
                    writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.symlinkBehavior);
                if (message.stripPrefix != null && message.hasOwnProperty("stripPrefix"))
                    writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.stripPrefix);
                if (message.filesPresent != null && message.hasOwnProperty("filesPresent"))
                    writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.filesPresent);
                return writer;
            };
            /**
             * Encodes the specified FilesetEntry message, length delimited. Does not implicitly {@link blaze_query.FilesetEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.FilesetEntry
             * @static
             * @param {blaze_query.IFilesetEntry} message FilesetEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilesetEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a FilesetEntry message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.FilesetEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.FilesetEntry} FilesetEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilesetEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.FilesetEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.source = reader.string();
                            break;
                        case 2:
                            message.destinationDirectory = reader.string();
                            break;
                        case 7:
                            message.filesPresent = reader.bool();
                            break;
                        case 3:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push(reader.string());
                            break;
                        case 4:
                            if (!(message.exclude && message.exclude.length))
                                message.exclude = [];
                            message.exclude.push(reader.string());
                            break;
                        case 5:
                            message.symlinkBehavior = reader.int32();
                            break;
                        case 6:
                            message.stripPrefix = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("source"))
                    throw $util.ProtocolError("missing required 'source'", { instance: message });
                if (!message.hasOwnProperty("destinationDirectory"))
                    throw $util.ProtocolError("missing required 'destinationDirectory'", { instance: message });
                return message;
            };
            /**
             * Decodes a FilesetEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.FilesetEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.FilesetEntry} FilesetEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilesetEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a FilesetEntry message.
             * @function verify
             * @memberof blaze_query.FilesetEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilesetEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.source))
                    return "source: string expected";
                if (!$util.isString(message.destinationDirectory))
                    return "destinationDirectory: string expected";
                if (message.filesPresent != null && message.hasOwnProperty("filesPresent"))
                    if (typeof message.filesPresent !== "boolean")
                        return "filesPresent: boolean expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (var i = 0; i < message.file.length; ++i)
                        if (!$util.isString(message.file[i]))
                            return "file: string[] expected";
                }
                if (message.exclude != null && message.hasOwnProperty("exclude")) {
                    if (!Array.isArray(message.exclude))
                        return "exclude: array expected";
                    for (var i = 0; i < message.exclude.length; ++i)
                        if (!$util.isString(message.exclude[i]))
                            return "exclude: string[] expected";
                }
                if (message.symlinkBehavior != null && message.hasOwnProperty("symlinkBehavior"))
                    switch (message.symlinkBehavior) {
                        default:
                            return "symlinkBehavior: enum value expected";
                        case 1:
                        case 2:
                            break;
                    }
                if (message.stripPrefix != null && message.hasOwnProperty("stripPrefix"))
                    if (!$util.isString(message.stripPrefix))
                        return "stripPrefix: string expected";
                return null;
            };
            /**
             * Creates a FilesetEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.FilesetEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.FilesetEntry} FilesetEntry
             */
            FilesetEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.FilesetEntry)
                    return object;
                var message = new $root.blaze_query.FilesetEntry();
                if (object.source != null)
                    message.source = String(object.source);
                if (object.destinationDirectory != null)
                    message.destinationDirectory = String(object.destinationDirectory);
                if (object.filesPresent != null)
                    message.filesPresent = Boolean(object.filesPresent);
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".blaze_query.FilesetEntry.file: array expected");
                    message.file = [];
                    for (var i = 0; i < object.file.length; ++i)
                        message.file[i] = String(object.file[i]);
                }
                if (object.exclude) {
                    if (!Array.isArray(object.exclude))
                        throw TypeError(".blaze_query.FilesetEntry.exclude: array expected");
                    message.exclude = [];
                    for (var i = 0; i < object.exclude.length; ++i)
                        message.exclude[i] = String(object.exclude[i]);
                }
                switch (object.symlinkBehavior) {
                    case "COPY":
                    case 1:
                        message.symlinkBehavior = 1;
                        break;
                    case "DEREFERENCE":
                    case 2:
                        message.symlinkBehavior = 2;
                        break;
                }
                if (object.stripPrefix != null)
                    message.stripPrefix = String(object.stripPrefix);
                return message;
            };
            /**
             * Creates a plain object from a FilesetEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.FilesetEntry
             * @static
             * @param {blaze_query.FilesetEntry} message FilesetEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilesetEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.file = [];
                    object.exclude = [];
                }
                if (options.defaults) {
                    object.source = "";
                    object.destinationDirectory = "";
                    object.symlinkBehavior = options.enums === String ? "COPY" : 1;
                    object.stripPrefix = "";
                    object.filesPresent = false;
                }
                if (message.source != null && message.hasOwnProperty("source"))
                    object.source = message.source;
                if (message.destinationDirectory != null && message.hasOwnProperty("destinationDirectory"))
                    object.destinationDirectory = message.destinationDirectory;
                if (message.file && message.file.length) {
                    object.file = [];
                    for (var j = 0; j < message.file.length; ++j)
                        object.file[j] = message.file[j];
                }
                if (message.exclude && message.exclude.length) {
                    object.exclude = [];
                    for (var j = 0; j < message.exclude.length; ++j)
                        object.exclude[j] = message.exclude[j];
                }
                if (message.symlinkBehavior != null && message.hasOwnProperty("symlinkBehavior"))
                    object.symlinkBehavior = options.enums === String ? $root.blaze_query.FilesetEntry.SymlinkBehavior[message.symlinkBehavior] : message.symlinkBehavior;
                if (message.stripPrefix != null && message.hasOwnProperty("stripPrefix"))
                    object.stripPrefix = message.stripPrefix;
                if (message.filesPresent != null && message.hasOwnProperty("filesPresent"))
                    object.filesPresent = message.filesPresent;
                return object;
            };
            /**
             * Converts this FilesetEntry to JSON.
             * @function toJSON
             * @memberof blaze_query.FilesetEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilesetEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * SymlinkBehavior enum.
             * @name blaze_query.FilesetEntry.SymlinkBehavior
             * @enum {string}
             * @property {number} COPY=1 COPY value
             * @property {number} DEREFERENCE=2 DEREFERENCE value
             */
            FilesetEntry.SymlinkBehavior = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "COPY"] = 1;
                values[valuesById[2] = "DEREFERENCE"] = 2;
                return values;
            })();
            return FilesetEntry;
        })();
        blaze_query.Attribute = (function () {
            /**
             * Properties of an Attribute.
             * @memberof blaze_query
             * @interface IAttribute
             * @property {string} name Attribute name
             * @property {blaze_query.ILocation|null} [DEPRECATEDParseableLocation] Attribute DEPRECATEDParseableLocation
             * @property {boolean|null} [explicitlySpecified] Attribute explicitlySpecified
             * @property {boolean|null} [nodep] Attribute nodep
             * @property {blaze_query.Attribute.Discriminator} type Attribute type
             * @property {number|null} [intValue] Attribute intValue
             * @property {string|null} [stringValue] Attribute stringValue
             * @property {boolean|null} [booleanValue] Attribute booleanValue
             * @property {blaze_query.Attribute.Tristate|null} [tristateValue] Attribute tristateValue
             * @property {Array.<string>|null} [stringListValue] Attribute stringListValue
             * @property {blaze_query.ILicense|null} [license] Attribute license
             * @property {Array.<blaze_query.IStringDictEntry>|null} [stringDictValue] Attribute stringDictValue
             * @property {Array.<blaze_query.IFilesetEntry>|null} [filesetListValue] Attribute filesetListValue
             * @property {Array.<blaze_query.ILabelListDictEntry>|null} [labelListDictValue] Attribute labelListDictValue
             * @property {Array.<blaze_query.IStringListDictEntry>|null} [stringListDictValue] Attribute stringListDictValue
             * @property {Array.<number>|null} [intListValue] Attribute intListValue
             * @property {Array.<blaze_query.ILabelDictUnaryEntry>|null} [labelDictUnaryValue] Attribute labelDictUnaryValue
             * @property {Array.<blaze_query.ILabelKeyedStringDictEntry>|null} [labelKeyedStringDictValue] Attribute labelKeyedStringDictValue
             * @property {blaze_query.Attribute.ISelectorList|null} [selectorList] Attribute selectorList
             * @property {Array.<blaze_query.IDEPRECATED_GlobCriteria>|null} [DEPRECATEDGlobCriteria] Attribute DEPRECATEDGlobCriteria
             * @property {Array.<Uint8Array>|null} [DEPRECATEDStringDictUnaryValue] Attribute DEPRECATEDStringDictUnaryValue
             */
            /**
             * Constructs a new Attribute.
             * @memberof blaze_query
             * @classdesc Represents an Attribute.
             * @implements IAttribute
             * @constructor
             * @param {blaze_query.IAttribute=} [properties] Properties to set
             */
            function Attribute(properties) {
                this.stringListValue = [];
                this.stringDictValue = [];
                this.filesetListValue = [];
                this.labelListDictValue = [];
                this.stringListDictValue = [];
                this.intListValue = [];
                this.labelDictUnaryValue = [];
                this.labelKeyedStringDictValue = [];
                this.DEPRECATEDGlobCriteria = [];
                this.DEPRECATEDStringDictUnaryValue = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Attribute name.
             * @member {string} name
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.name = "";
            /**
             * Attribute DEPRECATEDParseableLocation.
             * @member {blaze_query.ILocation|null|undefined} DEPRECATEDParseableLocation
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.DEPRECATEDParseableLocation = null;
            /**
             * Attribute explicitlySpecified.
             * @member {boolean} explicitlySpecified
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.explicitlySpecified = false;
            /**
             * Attribute nodep.
             * @member {boolean} nodep
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.nodep = false;
            /**
             * Attribute type.
             * @member {blaze_query.Attribute.Discriminator} type
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.type = 1;
            /**
             * Attribute intValue.
             * @member {number} intValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.intValue = 0;
            /**
             * Attribute stringValue.
             * @member {string} stringValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.stringValue = "";
            /**
             * Attribute booleanValue.
             * @member {boolean} booleanValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.booleanValue = false;
            /**
             * Attribute tristateValue.
             * @member {blaze_query.Attribute.Tristate} tristateValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.tristateValue = 0;
            /**
             * Attribute stringListValue.
             * @member {Array.<string>} stringListValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.stringListValue = $util.emptyArray;
            /**
             * Attribute license.
             * @member {blaze_query.ILicense|null|undefined} license
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.license = null;
            /**
             * Attribute stringDictValue.
             * @member {Array.<blaze_query.IStringDictEntry>} stringDictValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.stringDictValue = $util.emptyArray;
            /**
             * Attribute filesetListValue.
             * @member {Array.<blaze_query.IFilesetEntry>} filesetListValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.filesetListValue = $util.emptyArray;
            /**
             * Attribute labelListDictValue.
             * @member {Array.<blaze_query.ILabelListDictEntry>} labelListDictValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.labelListDictValue = $util.emptyArray;
            /**
             * Attribute stringListDictValue.
             * @member {Array.<blaze_query.IStringListDictEntry>} stringListDictValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.stringListDictValue = $util.emptyArray;
            /**
             * Attribute intListValue.
             * @member {Array.<number>} intListValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.intListValue = $util.emptyArray;
            /**
             * Attribute labelDictUnaryValue.
             * @member {Array.<blaze_query.ILabelDictUnaryEntry>} labelDictUnaryValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.labelDictUnaryValue = $util.emptyArray;
            /**
             * Attribute labelKeyedStringDictValue.
             * @member {Array.<blaze_query.ILabelKeyedStringDictEntry>} labelKeyedStringDictValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.labelKeyedStringDictValue = $util.emptyArray;
            /**
             * Attribute selectorList.
             * @member {blaze_query.Attribute.ISelectorList|null|undefined} selectorList
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.selectorList = null;
            /**
             * Attribute DEPRECATEDGlobCriteria.
             * @member {Array.<blaze_query.IDEPRECATED_GlobCriteria>} DEPRECATEDGlobCriteria
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.DEPRECATEDGlobCriteria = $util.emptyArray;
            /**
             * Attribute DEPRECATEDStringDictUnaryValue.
             * @member {Array.<Uint8Array>} DEPRECATEDStringDictUnaryValue
             * @memberof blaze_query.Attribute
             * @instance
             */
            Attribute.prototype.DEPRECATEDStringDictUnaryValue = $util.emptyArray;
            /**
             * Creates a new Attribute instance using the specified properties.
             * @function create
             * @memberof blaze_query.Attribute
             * @static
             * @param {blaze_query.IAttribute=} [properties] Properties to set
             * @returns {blaze_query.Attribute} Attribute instance
             */
            Attribute.create = function create(properties) {
                return new Attribute(properties);
            };
            /**
             * Encodes the specified Attribute message. Does not implicitly {@link blaze_query.Attribute.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.Attribute
             * @static
             * @param {blaze_query.IAttribute} message Attribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attribute.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.type);
                if (message.intValue != null && message.hasOwnProperty("intValue"))
                    writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.intValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.stringValue);
                if (message.stringListValue != null && message.stringListValue.length)
                    for (var i = 0; i < message.stringListValue.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.stringListValue[i]);
                if (message.license != null && message.hasOwnProperty("license"))
                    $root.blaze_query.License.encode(message.license, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
                if (message.stringDictValue != null && message.stringDictValue.length)
                    for (var i = 0; i < message.stringDictValue.length; ++i)
                        $root.blaze_query.StringDictEntry.encode(message.stringDictValue[i], writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                if (message.filesetListValue != null && message.filesetListValue.length)
                    for (var i = 0; i < message.filesetListValue.length; ++i)
                        $root.blaze_query.FilesetEntry.encode(message.filesetListValue[i], writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
                if (message.labelListDictValue != null && message.labelListDictValue.length)
                    for (var i = 0; i < message.labelListDictValue.length; ++i)
                        $root.blaze_query.LabelListDictEntry.encode(message.labelListDictValue[i], writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
                if (message.stringListDictValue != null && message.stringListDictValue.length)
                    for (var i = 0; i < message.stringListDictValue.length; ++i)
                        $root.blaze_query.StringListDictEntry.encode(message.stringListDictValue[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation"))
                    $root.blaze_query.Location.encode(message.DEPRECATEDParseableLocation, writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
                if (message.explicitlySpecified != null && message.hasOwnProperty("explicitlySpecified"))
                    writer.uint32(/* id 13, wireType 0 =*/ 104).bool(message.explicitlySpecified);
                if (message.booleanValue != null && message.hasOwnProperty("booleanValue"))
                    writer.uint32(/* id 14, wireType 0 =*/ 112).bool(message.booleanValue);
                if (message.tristateValue != null && message.hasOwnProperty("tristateValue"))
                    writer.uint32(/* id 15, wireType 0 =*/ 120).int32(message.tristateValue);
                if (message.DEPRECATEDGlobCriteria != null && message.DEPRECATEDGlobCriteria.length)
                    for (var i = 0; i < message.DEPRECATEDGlobCriteria.length; ++i)
                        $root.blaze_query.DEPRECATED_GlobCriteria.encode(message.DEPRECATEDGlobCriteria[i], writer.uint32(/* id 16, wireType 2 =*/ 130).fork()).ldelim();
                if (message.intListValue != null && message.intListValue.length)
                    for (var i = 0; i < message.intListValue.length; ++i)
                        writer.uint32(/* id 17, wireType 0 =*/ 136).int32(message.intListValue[i]);
                if (message.DEPRECATEDStringDictUnaryValue != null && message.DEPRECATEDStringDictUnaryValue.length)
                    for (var i = 0; i < message.DEPRECATEDStringDictUnaryValue.length; ++i)
                        writer.uint32(/* id 18, wireType 2 =*/ 146).bytes(message.DEPRECATEDStringDictUnaryValue[i]);
                if (message.labelDictUnaryValue != null && message.labelDictUnaryValue.length)
                    for (var i = 0; i < message.labelDictUnaryValue.length; ++i)
                        $root.blaze_query.LabelDictUnaryEntry.encode(message.labelDictUnaryValue[i], writer.uint32(/* id 19, wireType 2 =*/ 154).fork()).ldelim();
                if (message.nodep != null && message.hasOwnProperty("nodep"))
                    writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.nodep);
                if (message.selectorList != null && message.hasOwnProperty("selectorList"))
                    $root.blaze_query.Attribute.SelectorList.encode(message.selectorList, writer.uint32(/* id 21, wireType 2 =*/ 170).fork()).ldelim();
                if (message.labelKeyedStringDictValue != null && message.labelKeyedStringDictValue.length)
                    for (var i = 0; i < message.labelKeyedStringDictValue.length; ++i)
                        $root.blaze_query.LabelKeyedStringDictEntry.encode(message.labelKeyedStringDictValue[i], writer.uint32(/* id 22, wireType 2 =*/ 178).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified Attribute message, length delimited. Does not implicitly {@link blaze_query.Attribute.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.Attribute
             * @static
             * @param {blaze_query.IAttribute} message Attribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attribute.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Attribute message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.Attribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.Attribute} Attribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attribute.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.Attribute();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 12:
                            message.DEPRECATEDParseableLocation = $root.blaze_query.Location.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.explicitlySpecified = reader.bool();
                            break;
                        case 20:
                            message.nodep = reader.bool();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        case 3:
                            message.intValue = reader.int32();
                            break;
                        case 5:
                            message.stringValue = reader.string();
                            break;
                        case 14:
                            message.booleanValue = reader.bool();
                            break;
                        case 15:
                            message.tristateValue = reader.int32();
                            break;
                        case 6:
                            if (!(message.stringListValue && message.stringListValue.length))
                                message.stringListValue = [];
                            message.stringListValue.push(reader.string());
                            break;
                        case 7:
                            message.license = $root.blaze_query.License.decode(reader, reader.uint32());
                            break;
                        case 8:
                            if (!(message.stringDictValue && message.stringDictValue.length))
                                message.stringDictValue = [];
                            message.stringDictValue.push($root.blaze_query.StringDictEntry.decode(reader, reader.uint32()));
                            break;
                        case 9:
                            if (!(message.filesetListValue && message.filesetListValue.length))
                                message.filesetListValue = [];
                            message.filesetListValue.push($root.blaze_query.FilesetEntry.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.labelListDictValue && message.labelListDictValue.length))
                                message.labelListDictValue = [];
                            message.labelListDictValue.push($root.blaze_query.LabelListDictEntry.decode(reader, reader.uint32()));
                            break;
                        case 11:
                            if (!(message.stringListDictValue && message.stringListDictValue.length))
                                message.stringListDictValue = [];
                            message.stringListDictValue.push($root.blaze_query.StringListDictEntry.decode(reader, reader.uint32()));
                            break;
                        case 17:
                            if (!(message.intListValue && message.intListValue.length))
                                message.intListValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.intListValue.push(reader.int32());
                            }
                            else
                                message.intListValue.push(reader.int32());
                            break;
                        case 19:
                            if (!(message.labelDictUnaryValue && message.labelDictUnaryValue.length))
                                message.labelDictUnaryValue = [];
                            message.labelDictUnaryValue.push($root.blaze_query.LabelDictUnaryEntry.decode(reader, reader.uint32()));
                            break;
                        case 22:
                            if (!(message.labelKeyedStringDictValue && message.labelKeyedStringDictValue.length))
                                message.labelKeyedStringDictValue = [];
                            message.labelKeyedStringDictValue.push($root.blaze_query.LabelKeyedStringDictEntry.decode(reader, reader.uint32()));
                            break;
                        case 21:
                            message.selectorList = $root.blaze_query.Attribute.SelectorList.decode(reader, reader.uint32());
                            break;
                        case 16:
                            if (!(message.DEPRECATEDGlobCriteria && message.DEPRECATEDGlobCriteria.length))
                                message.DEPRECATEDGlobCriteria = [];
                            message.DEPRECATEDGlobCriteria.push($root.blaze_query.DEPRECATED_GlobCriteria.decode(reader, reader.uint32()));
                            break;
                        case 18:
                            if (!(message.DEPRECATEDStringDictUnaryValue && message.DEPRECATEDStringDictUnaryValue.length))
                                message.DEPRECATEDStringDictUnaryValue = [];
                            message.DEPRECATEDStringDictUnaryValue.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };
            /**
             * Decodes an Attribute message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.Attribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.Attribute} Attribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attribute.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Attribute message.
             * @function verify
             * @memberof blaze_query.Attribute
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Attribute.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation")) {
                    var error = $root.blaze_query.Location.verify(message.DEPRECATEDParseableLocation);
                    if (error)
                        return "DEPRECATEDParseableLocation." + error;
                }
                if (message.explicitlySpecified != null && message.hasOwnProperty("explicitlySpecified"))
                    if (typeof message.explicitlySpecified !== "boolean")
                        return "explicitlySpecified: boolean expected";
                if (message.nodep != null && message.hasOwnProperty("nodep"))
                    if (typeof message.nodep !== "boolean")
                        return "nodep: boolean expected";
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 17:
                        break;
                }
                if (message.intValue != null && message.hasOwnProperty("intValue"))
                    if (!$util.isInteger(message.intValue))
                        return "intValue: integer expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                if (message.booleanValue != null && message.hasOwnProperty("booleanValue"))
                    if (typeof message.booleanValue !== "boolean")
                        return "booleanValue: boolean expected";
                if (message.tristateValue != null && message.hasOwnProperty("tristateValue"))
                    switch (message.tristateValue) {
                        default:
                            return "tristateValue: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                    }
                if (message.stringListValue != null && message.hasOwnProperty("stringListValue")) {
                    if (!Array.isArray(message.stringListValue))
                        return "stringListValue: array expected";
                    for (var i = 0; i < message.stringListValue.length; ++i)
                        if (!$util.isString(message.stringListValue[i]))
                            return "stringListValue: string[] expected";
                }
                if (message.license != null && message.hasOwnProperty("license")) {
                    var error = $root.blaze_query.License.verify(message.license);
                    if (error)
                        return "license." + error;
                }
                if (message.stringDictValue != null && message.hasOwnProperty("stringDictValue")) {
                    if (!Array.isArray(message.stringDictValue))
                        return "stringDictValue: array expected";
                    for (var i = 0; i < message.stringDictValue.length; ++i) {
                        var error = $root.blaze_query.StringDictEntry.verify(message.stringDictValue[i]);
                        if (error)
                            return "stringDictValue." + error;
                    }
                }
                if (message.filesetListValue != null && message.hasOwnProperty("filesetListValue")) {
                    if (!Array.isArray(message.filesetListValue))
                        return "filesetListValue: array expected";
                    for (var i = 0; i < message.filesetListValue.length; ++i) {
                        var error = $root.blaze_query.FilesetEntry.verify(message.filesetListValue[i]);
                        if (error)
                            return "filesetListValue." + error;
                    }
                }
                if (message.labelListDictValue != null && message.hasOwnProperty("labelListDictValue")) {
                    if (!Array.isArray(message.labelListDictValue))
                        return "labelListDictValue: array expected";
                    for (var i = 0; i < message.labelListDictValue.length; ++i) {
                        var error = $root.blaze_query.LabelListDictEntry.verify(message.labelListDictValue[i]);
                        if (error)
                            return "labelListDictValue." + error;
                    }
                }
                if (message.stringListDictValue != null && message.hasOwnProperty("stringListDictValue")) {
                    if (!Array.isArray(message.stringListDictValue))
                        return "stringListDictValue: array expected";
                    for (var i = 0; i < message.stringListDictValue.length; ++i) {
                        var error = $root.blaze_query.StringListDictEntry.verify(message.stringListDictValue[i]);
                        if (error)
                            return "stringListDictValue." + error;
                    }
                }
                if (message.intListValue != null && message.hasOwnProperty("intListValue")) {
                    if (!Array.isArray(message.intListValue))
                        return "intListValue: array expected";
                    for (var i = 0; i < message.intListValue.length; ++i)
                        if (!$util.isInteger(message.intListValue[i]))
                            return "intListValue: integer[] expected";
                }
                if (message.labelDictUnaryValue != null && message.hasOwnProperty("labelDictUnaryValue")) {
                    if (!Array.isArray(message.labelDictUnaryValue))
                        return "labelDictUnaryValue: array expected";
                    for (var i = 0; i < message.labelDictUnaryValue.length; ++i) {
                        var error = $root.blaze_query.LabelDictUnaryEntry.verify(message.labelDictUnaryValue[i]);
                        if (error)
                            return "labelDictUnaryValue." + error;
                    }
                }
                if (message.labelKeyedStringDictValue != null && message.hasOwnProperty("labelKeyedStringDictValue")) {
                    if (!Array.isArray(message.labelKeyedStringDictValue))
                        return "labelKeyedStringDictValue: array expected";
                    for (var i = 0; i < message.labelKeyedStringDictValue.length; ++i) {
                        var error = $root.blaze_query.LabelKeyedStringDictEntry.verify(message.labelKeyedStringDictValue[i]);
                        if (error)
                            return "labelKeyedStringDictValue." + error;
                    }
                }
                if (message.selectorList != null && message.hasOwnProperty("selectorList")) {
                    var error = $root.blaze_query.Attribute.SelectorList.verify(message.selectorList);
                    if (error)
                        return "selectorList." + error;
                }
                if (message.DEPRECATEDGlobCriteria != null && message.hasOwnProperty("DEPRECATEDGlobCriteria")) {
                    if (!Array.isArray(message.DEPRECATEDGlobCriteria))
                        return "DEPRECATEDGlobCriteria: array expected";
                    for (var i = 0; i < message.DEPRECATEDGlobCriteria.length; ++i) {
                        var error = $root.blaze_query.DEPRECATED_GlobCriteria.verify(message.DEPRECATEDGlobCriteria[i]);
                        if (error)
                            return "DEPRECATEDGlobCriteria." + error;
                    }
                }
                if (message.DEPRECATEDStringDictUnaryValue != null && message.hasOwnProperty("DEPRECATEDStringDictUnaryValue")) {
                    if (!Array.isArray(message.DEPRECATEDStringDictUnaryValue))
                        return "DEPRECATEDStringDictUnaryValue: array expected";
                    for (var i = 0; i < message.DEPRECATEDStringDictUnaryValue.length; ++i)
                        if (!(message.DEPRECATEDStringDictUnaryValue[i] && typeof message.DEPRECATEDStringDictUnaryValue[i].length === "number" || $util.isString(message.DEPRECATEDStringDictUnaryValue[i])))
                            return "DEPRECATEDStringDictUnaryValue: buffer[] expected";
                }
                return null;
            };
            /**
             * Creates an Attribute message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.Attribute
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.Attribute} Attribute
             */
            Attribute.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.Attribute)
                    return object;
                var message = new $root.blaze_query.Attribute();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.DEPRECATEDParseableLocation != null) {
                    if (typeof object.DEPRECATEDParseableLocation !== "object")
                        throw TypeError(".blaze_query.Attribute.DEPRECATEDParseableLocation: object expected");
                    message.DEPRECATEDParseableLocation = $root.blaze_query.Location.fromObject(object.DEPRECATEDParseableLocation);
                }
                if (object.explicitlySpecified != null)
                    message.explicitlySpecified = Boolean(object.explicitlySpecified);
                if (object.nodep != null)
                    message.nodep = Boolean(object.nodep);
                switch (object.type) {
                    case "INTEGER":
                    case 1:
                        message.type = 1;
                        break;
                    case "STRING":
                    case 2:
                        message.type = 2;
                        break;
                    case "LABEL":
                    case 3:
                        message.type = 3;
                        break;
                    case "OUTPUT":
                    case 4:
                        message.type = 4;
                        break;
                    case "STRING_LIST":
                    case 5:
                        message.type = 5;
                        break;
                    case "LABEL_LIST":
                    case 6:
                        message.type = 6;
                        break;
                    case "OUTPUT_LIST":
                    case 7:
                        message.type = 7;
                        break;
                    case "DISTRIBUTION_SET":
                    case 8:
                        message.type = 8;
                        break;
                    case "LICENSE":
                    case 9:
                        message.type = 9;
                        break;
                    case "STRING_DICT":
                    case 10:
                        message.type = 10;
                        break;
                    case "FILESET_ENTRY_LIST":
                    case 11:
                        message.type = 11;
                        break;
                    case "LABEL_LIST_DICT":
                    case 12:
                        message.type = 12;
                        break;
                    case "STRING_LIST_DICT":
                    case 13:
                        message.type = 13;
                        break;
                    case "BOOLEAN":
                    case 14:
                        message.type = 14;
                        break;
                    case "TRISTATE":
                    case 15:
                        message.type = 15;
                        break;
                    case "INTEGER_LIST":
                    case 16:
                        message.type = 16;
                        break;
                    case "UNKNOWN":
                    case 18:
                        message.type = 18;
                        break;
                    case "LABEL_DICT_UNARY":
                    case 19:
                        message.type = 19;
                        break;
                    case "SELECTOR_LIST":
                    case 20:
                        message.type = 20;
                        break;
                    case "LABEL_KEYED_STRING_DICT":
                    case 21:
                        message.type = 21;
                        break;
                    case "DEPRECATED_STRING_DICT_UNARY":
                    case 17:
                        message.type = 17;
                        break;
                }
                if (object.intValue != null)
                    message.intValue = object.intValue | 0;
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.booleanValue != null)
                    message.booleanValue = Boolean(object.booleanValue);
                switch (object.tristateValue) {
                    case "NO":
                    case 0:
                        message.tristateValue = 0;
                        break;
                    case "YES":
                    case 1:
                        message.tristateValue = 1;
                        break;
                    case "AUTO":
                    case 2:
                        message.tristateValue = 2;
                        break;
                }
                if (object.stringListValue) {
                    if (!Array.isArray(object.stringListValue))
                        throw TypeError(".blaze_query.Attribute.stringListValue: array expected");
                    message.stringListValue = [];
                    for (var i = 0; i < object.stringListValue.length; ++i)
                        message.stringListValue[i] = String(object.stringListValue[i]);
                }
                if (object.license != null) {
                    if (typeof object.license !== "object")
                        throw TypeError(".blaze_query.Attribute.license: object expected");
                    message.license = $root.blaze_query.License.fromObject(object.license);
                }
                if (object.stringDictValue) {
                    if (!Array.isArray(object.stringDictValue))
                        throw TypeError(".blaze_query.Attribute.stringDictValue: array expected");
                    message.stringDictValue = [];
                    for (var i = 0; i < object.stringDictValue.length; ++i) {
                        if (typeof object.stringDictValue[i] !== "object")
                            throw TypeError(".blaze_query.Attribute.stringDictValue: object expected");
                        message.stringDictValue[i] = $root.blaze_query.StringDictEntry.fromObject(object.stringDictValue[i]);
                    }
                }
                if (object.filesetListValue) {
                    if (!Array.isArray(object.filesetListValue))
                        throw TypeError(".blaze_query.Attribute.filesetListValue: array expected");
                    message.filesetListValue = [];
                    for (var i = 0; i < object.filesetListValue.length; ++i) {
                        if (typeof object.filesetListValue[i] !== "object")
                            throw TypeError(".blaze_query.Attribute.filesetListValue: object expected");
                        message.filesetListValue[i] = $root.blaze_query.FilesetEntry.fromObject(object.filesetListValue[i]);
                    }
                }
                if (object.labelListDictValue) {
                    if (!Array.isArray(object.labelListDictValue))
                        throw TypeError(".blaze_query.Attribute.labelListDictValue: array expected");
                    message.labelListDictValue = [];
                    for (var i = 0; i < object.labelListDictValue.length; ++i) {
                        if (typeof object.labelListDictValue[i] !== "object")
                            throw TypeError(".blaze_query.Attribute.labelListDictValue: object expected");
                        message.labelListDictValue[i] = $root.blaze_query.LabelListDictEntry.fromObject(object.labelListDictValue[i]);
                    }
                }
                if (object.stringListDictValue) {
                    if (!Array.isArray(object.stringListDictValue))
                        throw TypeError(".blaze_query.Attribute.stringListDictValue: array expected");
                    message.stringListDictValue = [];
                    for (var i = 0; i < object.stringListDictValue.length; ++i) {
                        if (typeof object.stringListDictValue[i] !== "object")
                            throw TypeError(".blaze_query.Attribute.stringListDictValue: object expected");
                        message.stringListDictValue[i] = $root.blaze_query.StringListDictEntry.fromObject(object.stringListDictValue[i]);
                    }
                }
                if (object.intListValue) {
                    if (!Array.isArray(object.intListValue))
                        throw TypeError(".blaze_query.Attribute.intListValue: array expected");
                    message.intListValue = [];
                    for (var i = 0; i < object.intListValue.length; ++i)
                        message.intListValue[i] = object.intListValue[i] | 0;
                }
                if (object.labelDictUnaryValue) {
                    if (!Array.isArray(object.labelDictUnaryValue))
                        throw TypeError(".blaze_query.Attribute.labelDictUnaryValue: array expected");
                    message.labelDictUnaryValue = [];
                    for (var i = 0; i < object.labelDictUnaryValue.length; ++i) {
                        if (typeof object.labelDictUnaryValue[i] !== "object")
                            throw TypeError(".blaze_query.Attribute.labelDictUnaryValue: object expected");
                        message.labelDictUnaryValue[i] = $root.blaze_query.LabelDictUnaryEntry.fromObject(object.labelDictUnaryValue[i]);
                    }
                }
                if (object.labelKeyedStringDictValue) {
                    if (!Array.isArray(object.labelKeyedStringDictValue))
                        throw TypeError(".blaze_query.Attribute.labelKeyedStringDictValue: array expected");
                    message.labelKeyedStringDictValue = [];
                    for (var i = 0; i < object.labelKeyedStringDictValue.length; ++i) {
                        if (typeof object.labelKeyedStringDictValue[i] !== "object")
                            throw TypeError(".blaze_query.Attribute.labelKeyedStringDictValue: object expected");
                        message.labelKeyedStringDictValue[i] = $root.blaze_query.LabelKeyedStringDictEntry.fromObject(object.labelKeyedStringDictValue[i]);
                    }
                }
                if (object.selectorList != null) {
                    if (typeof object.selectorList !== "object")
                        throw TypeError(".blaze_query.Attribute.selectorList: object expected");
                    message.selectorList = $root.blaze_query.Attribute.SelectorList.fromObject(object.selectorList);
                }
                if (object.DEPRECATEDGlobCriteria) {
                    if (!Array.isArray(object.DEPRECATEDGlobCriteria))
                        throw TypeError(".blaze_query.Attribute.DEPRECATEDGlobCriteria: array expected");
                    message.DEPRECATEDGlobCriteria = [];
                    for (var i = 0; i < object.DEPRECATEDGlobCriteria.length; ++i) {
                        if (typeof object.DEPRECATEDGlobCriteria[i] !== "object")
                            throw TypeError(".blaze_query.Attribute.DEPRECATEDGlobCriteria: object expected");
                        message.DEPRECATEDGlobCriteria[i] = $root.blaze_query.DEPRECATED_GlobCriteria.fromObject(object.DEPRECATEDGlobCriteria[i]);
                    }
                }
                if (object.DEPRECATEDStringDictUnaryValue) {
                    if (!Array.isArray(object.DEPRECATEDStringDictUnaryValue))
                        throw TypeError(".blaze_query.Attribute.DEPRECATEDStringDictUnaryValue: array expected");
                    message.DEPRECATEDStringDictUnaryValue = [];
                    for (var i = 0; i < object.DEPRECATEDStringDictUnaryValue.length; ++i)
                        if (typeof object.DEPRECATEDStringDictUnaryValue[i] === "string")
                            $util.base64.decode(object.DEPRECATEDStringDictUnaryValue[i], message.DEPRECATEDStringDictUnaryValue[i] = $util.newBuffer($util.base64.length(object.DEPRECATEDStringDictUnaryValue[i])), 0);
                        else if (object.DEPRECATEDStringDictUnaryValue[i].length)
                            message.DEPRECATEDStringDictUnaryValue[i] = object.DEPRECATEDStringDictUnaryValue[i];
                }
                return message;
            };
            /**
             * Creates a plain object from an Attribute message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.Attribute
             * @static
             * @param {blaze_query.Attribute} message Attribute
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Attribute.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.stringListValue = [];
                    object.stringDictValue = [];
                    object.filesetListValue = [];
                    object.labelListDictValue = [];
                    object.stringListDictValue = [];
                    object.DEPRECATEDGlobCriteria = [];
                    object.intListValue = [];
                    object.DEPRECATEDStringDictUnaryValue = [];
                    object.labelDictUnaryValue = [];
                    object.labelKeyedStringDictValue = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "INTEGER" : 1;
                    object.intValue = 0;
                    object.stringValue = "";
                    object.license = null;
                    object.DEPRECATEDParseableLocation = null;
                    object.explicitlySpecified = false;
                    object.booleanValue = false;
                    object.tristateValue = options.enums === String ? "NO" : 0;
                    object.nodep = false;
                    object.selectorList = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.blaze_query.Attribute.Discriminator[message.type] : message.type;
                if (message.intValue != null && message.hasOwnProperty("intValue"))
                    object.intValue = message.intValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = message.stringValue;
                if (message.stringListValue && message.stringListValue.length) {
                    object.stringListValue = [];
                    for (var j = 0; j < message.stringListValue.length; ++j)
                        object.stringListValue[j] = message.stringListValue[j];
                }
                if (message.license != null && message.hasOwnProperty("license"))
                    object.license = $root.blaze_query.License.toObject(message.license, options);
                if (message.stringDictValue && message.stringDictValue.length) {
                    object.stringDictValue = [];
                    for (var j = 0; j < message.stringDictValue.length; ++j)
                        object.stringDictValue[j] = $root.blaze_query.StringDictEntry.toObject(message.stringDictValue[j], options);
                }
                if (message.filesetListValue && message.filesetListValue.length) {
                    object.filesetListValue = [];
                    for (var j = 0; j < message.filesetListValue.length; ++j)
                        object.filesetListValue[j] = $root.blaze_query.FilesetEntry.toObject(message.filesetListValue[j], options);
                }
                if (message.labelListDictValue && message.labelListDictValue.length) {
                    object.labelListDictValue = [];
                    for (var j = 0; j < message.labelListDictValue.length; ++j)
                        object.labelListDictValue[j] = $root.blaze_query.LabelListDictEntry.toObject(message.labelListDictValue[j], options);
                }
                if (message.stringListDictValue && message.stringListDictValue.length) {
                    object.stringListDictValue = [];
                    for (var j = 0; j < message.stringListDictValue.length; ++j)
                        object.stringListDictValue[j] = $root.blaze_query.StringListDictEntry.toObject(message.stringListDictValue[j], options);
                }
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation"))
                    object.DEPRECATEDParseableLocation = $root.blaze_query.Location.toObject(message.DEPRECATEDParseableLocation, options);
                if (message.explicitlySpecified != null && message.hasOwnProperty("explicitlySpecified"))
                    object.explicitlySpecified = message.explicitlySpecified;
                if (message.booleanValue != null && message.hasOwnProperty("booleanValue"))
                    object.booleanValue = message.booleanValue;
                if (message.tristateValue != null && message.hasOwnProperty("tristateValue"))
                    object.tristateValue = options.enums === String ? $root.blaze_query.Attribute.Tristate[message.tristateValue] : message.tristateValue;
                if (message.DEPRECATEDGlobCriteria && message.DEPRECATEDGlobCriteria.length) {
                    object.DEPRECATEDGlobCriteria = [];
                    for (var j = 0; j < message.DEPRECATEDGlobCriteria.length; ++j)
                        object.DEPRECATEDGlobCriteria[j] = $root.blaze_query.DEPRECATED_GlobCriteria.toObject(message.DEPRECATEDGlobCriteria[j], options);
                }
                if (message.intListValue && message.intListValue.length) {
                    object.intListValue = [];
                    for (var j = 0; j < message.intListValue.length; ++j)
                        object.intListValue[j] = message.intListValue[j];
                }
                if (message.DEPRECATEDStringDictUnaryValue && message.DEPRECATEDStringDictUnaryValue.length) {
                    object.DEPRECATEDStringDictUnaryValue = [];
                    for (var j = 0; j < message.DEPRECATEDStringDictUnaryValue.length; ++j)
                        object.DEPRECATEDStringDictUnaryValue[j] = options.bytes === String ? $util.base64.encode(message.DEPRECATEDStringDictUnaryValue[j], 0, message.DEPRECATEDStringDictUnaryValue[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.DEPRECATEDStringDictUnaryValue[j]) : message.DEPRECATEDStringDictUnaryValue[j];
                }
                if (message.labelDictUnaryValue && message.labelDictUnaryValue.length) {
                    object.labelDictUnaryValue = [];
                    for (var j = 0; j < message.labelDictUnaryValue.length; ++j)
                        object.labelDictUnaryValue[j] = $root.blaze_query.LabelDictUnaryEntry.toObject(message.labelDictUnaryValue[j], options);
                }
                if (message.nodep != null && message.hasOwnProperty("nodep"))
                    object.nodep = message.nodep;
                if (message.selectorList != null && message.hasOwnProperty("selectorList"))
                    object.selectorList = $root.blaze_query.Attribute.SelectorList.toObject(message.selectorList, options);
                if (message.labelKeyedStringDictValue && message.labelKeyedStringDictValue.length) {
                    object.labelKeyedStringDictValue = [];
                    for (var j = 0; j < message.labelKeyedStringDictValue.length; ++j)
                        object.labelKeyedStringDictValue[j] = $root.blaze_query.LabelKeyedStringDictEntry.toObject(message.labelKeyedStringDictValue[j], options);
                }
                return object;
            };
            /**
             * Converts this Attribute to JSON.
             * @function toJSON
             * @memberof blaze_query.Attribute
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Attribute.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Discriminator enum.
             * @name blaze_query.Attribute.Discriminator
             * @enum {string}
             * @property {number} INTEGER=1 INTEGER value
             * @property {number} STRING=2 STRING value
             * @property {number} LABEL=3 LABEL value
             * @property {number} OUTPUT=4 OUTPUT value
             * @property {number} STRING_LIST=5 STRING_LIST value
             * @property {number} LABEL_LIST=6 LABEL_LIST value
             * @property {number} OUTPUT_LIST=7 OUTPUT_LIST value
             * @property {number} DISTRIBUTION_SET=8 DISTRIBUTION_SET value
             * @property {number} LICENSE=9 LICENSE value
             * @property {number} STRING_DICT=10 STRING_DICT value
             * @property {number} FILESET_ENTRY_LIST=11 FILESET_ENTRY_LIST value
             * @property {number} LABEL_LIST_DICT=12 LABEL_LIST_DICT value
             * @property {number} STRING_LIST_DICT=13 STRING_LIST_DICT value
             * @property {number} BOOLEAN=14 BOOLEAN value
             * @property {number} TRISTATE=15 TRISTATE value
             * @property {number} INTEGER_LIST=16 INTEGER_LIST value
             * @property {number} UNKNOWN=18 UNKNOWN value
             * @property {number} LABEL_DICT_UNARY=19 LABEL_DICT_UNARY value
             * @property {number} SELECTOR_LIST=20 SELECTOR_LIST value
             * @property {number} LABEL_KEYED_STRING_DICT=21 LABEL_KEYED_STRING_DICT value
             * @property {number} DEPRECATED_STRING_DICT_UNARY=17 DEPRECATED_STRING_DICT_UNARY value
             */
            Attribute.Discriminator = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "INTEGER"] = 1;
                values[valuesById[2] = "STRING"] = 2;
                values[valuesById[3] = "LABEL"] = 3;
                values[valuesById[4] = "OUTPUT"] = 4;
                values[valuesById[5] = "STRING_LIST"] = 5;
                values[valuesById[6] = "LABEL_LIST"] = 6;
                values[valuesById[7] = "OUTPUT_LIST"] = 7;
                values[valuesById[8] = "DISTRIBUTION_SET"] = 8;
                values[valuesById[9] = "LICENSE"] = 9;
                values[valuesById[10] = "STRING_DICT"] = 10;
                values[valuesById[11] = "FILESET_ENTRY_LIST"] = 11;
                values[valuesById[12] = "LABEL_LIST_DICT"] = 12;
                values[valuesById[13] = "STRING_LIST_DICT"] = 13;
                values[valuesById[14] = "BOOLEAN"] = 14;
                values[valuesById[15] = "TRISTATE"] = 15;
                values[valuesById[16] = "INTEGER_LIST"] = 16;
                values[valuesById[18] = "UNKNOWN"] = 18;
                values[valuesById[19] = "LABEL_DICT_UNARY"] = 19;
                values[valuesById[20] = "SELECTOR_LIST"] = 20;
                values[valuesById[21] = "LABEL_KEYED_STRING_DICT"] = 21;
                values[valuesById[17] = "DEPRECATED_STRING_DICT_UNARY"] = 17;
                return values;
            })();
            /**
             * Tristate enum.
             * @name blaze_query.Attribute.Tristate
             * @enum {string}
             * @property {number} NO=0 NO value
             * @property {number} YES=1 YES value
             * @property {number} AUTO=2 AUTO value
             */
            Attribute.Tristate = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NO"] = 0;
                values[valuesById[1] = "YES"] = 1;
                values[valuesById[2] = "AUTO"] = 2;
                return values;
            })();
            Attribute.SelectorEntry = (function () {
                /**
                 * Properties of a SelectorEntry.
                 * @memberof blaze_query.Attribute
                 * @interface ISelectorEntry
                 * @property {string|null} [label] SelectorEntry label
                 * @property {boolean|null} [isDefaultValue] SelectorEntry isDefaultValue
                 * @property {number|null} [intValue] SelectorEntry intValue
                 * @property {string|null} [stringValue] SelectorEntry stringValue
                 * @property {boolean|null} [booleanValue] SelectorEntry booleanValue
                 * @property {blaze_query.Attribute.Tristate|null} [tristateValue] SelectorEntry tristateValue
                 * @property {Array.<string>|null} [stringListValue] SelectorEntry stringListValue
                 * @property {blaze_query.ILicense|null} [license] SelectorEntry license
                 * @property {Array.<blaze_query.IStringDictEntry>|null} [stringDictValue] SelectorEntry stringDictValue
                 * @property {Array.<blaze_query.IFilesetEntry>|null} [filesetListValue] SelectorEntry filesetListValue
                 * @property {Array.<blaze_query.ILabelListDictEntry>|null} [labelListDictValue] SelectorEntry labelListDictValue
                 * @property {Array.<blaze_query.IStringListDictEntry>|null} [stringListDictValue] SelectorEntry stringListDictValue
                 * @property {Array.<number>|null} [intListValue] SelectorEntry intListValue
                 * @property {Array.<blaze_query.ILabelDictUnaryEntry>|null} [labelDictUnaryValue] SelectorEntry labelDictUnaryValue
                 * @property {Array.<blaze_query.ILabelKeyedStringDictEntry>|null} [labelKeyedStringDictValue] SelectorEntry labelKeyedStringDictValue
                 * @property {Array.<blaze_query.IDEPRECATED_GlobCriteria>|null} [DEPRECATEDGlobCriteria] SelectorEntry DEPRECATEDGlobCriteria
                 * @property {Array.<Uint8Array>|null} [DEPRECATEDStringDictUnaryValue] SelectorEntry DEPRECATEDStringDictUnaryValue
                 */
                /**
                 * Constructs a new SelectorEntry.
                 * @memberof blaze_query.Attribute
                 * @classdesc Represents a SelectorEntry.
                 * @implements ISelectorEntry
                 * @constructor
                 * @param {blaze_query.Attribute.ISelectorEntry=} [properties] Properties to set
                 */
                function SelectorEntry(properties) {
                    this.stringListValue = [];
                    this.stringDictValue = [];
                    this.filesetListValue = [];
                    this.labelListDictValue = [];
                    this.stringListDictValue = [];
                    this.intListValue = [];
                    this.labelDictUnaryValue = [];
                    this.labelKeyedStringDictValue = [];
                    this.DEPRECATEDGlobCriteria = [];
                    this.DEPRECATEDStringDictUnaryValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * SelectorEntry label.
                 * @member {string} label
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.label = "";
                /**
                 * SelectorEntry isDefaultValue.
                 * @member {boolean} isDefaultValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.isDefaultValue = false;
                /**
                 * SelectorEntry intValue.
                 * @member {number} intValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.intValue = 0;
                /**
                 * SelectorEntry stringValue.
                 * @member {string} stringValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.stringValue = "";
                /**
                 * SelectorEntry booleanValue.
                 * @member {boolean} booleanValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.booleanValue = false;
                /**
                 * SelectorEntry tristateValue.
                 * @member {blaze_query.Attribute.Tristate} tristateValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.tristateValue = 0;
                /**
                 * SelectorEntry stringListValue.
                 * @member {Array.<string>} stringListValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.stringListValue = $util.emptyArray;
                /**
                 * SelectorEntry license.
                 * @member {blaze_query.ILicense|null|undefined} license
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.license = null;
                /**
                 * SelectorEntry stringDictValue.
                 * @member {Array.<blaze_query.IStringDictEntry>} stringDictValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.stringDictValue = $util.emptyArray;
                /**
                 * SelectorEntry filesetListValue.
                 * @member {Array.<blaze_query.IFilesetEntry>} filesetListValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.filesetListValue = $util.emptyArray;
                /**
                 * SelectorEntry labelListDictValue.
                 * @member {Array.<blaze_query.ILabelListDictEntry>} labelListDictValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.labelListDictValue = $util.emptyArray;
                /**
                 * SelectorEntry stringListDictValue.
                 * @member {Array.<blaze_query.IStringListDictEntry>} stringListDictValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.stringListDictValue = $util.emptyArray;
                /**
                 * SelectorEntry intListValue.
                 * @member {Array.<number>} intListValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.intListValue = $util.emptyArray;
                /**
                 * SelectorEntry labelDictUnaryValue.
                 * @member {Array.<blaze_query.ILabelDictUnaryEntry>} labelDictUnaryValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.labelDictUnaryValue = $util.emptyArray;
                /**
                 * SelectorEntry labelKeyedStringDictValue.
                 * @member {Array.<blaze_query.ILabelKeyedStringDictEntry>} labelKeyedStringDictValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.labelKeyedStringDictValue = $util.emptyArray;
                /**
                 * SelectorEntry DEPRECATEDGlobCriteria.
                 * @member {Array.<blaze_query.IDEPRECATED_GlobCriteria>} DEPRECATEDGlobCriteria
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.DEPRECATEDGlobCriteria = $util.emptyArray;
                /**
                 * SelectorEntry DEPRECATEDStringDictUnaryValue.
                 * @member {Array.<Uint8Array>} DEPRECATEDStringDictUnaryValue
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 */
                SelectorEntry.prototype.DEPRECATEDStringDictUnaryValue = $util.emptyArray;
                /**
                 * Creates a new SelectorEntry instance using the specified properties.
                 * @function create
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @static
                 * @param {blaze_query.Attribute.ISelectorEntry=} [properties] Properties to set
                 * @returns {blaze_query.Attribute.SelectorEntry} SelectorEntry instance
                 */
                SelectorEntry.create = function create(properties) {
                    return new SelectorEntry(properties);
                };
                /**
                 * Encodes the specified SelectorEntry message. Does not implicitly {@link blaze_query.Attribute.SelectorEntry.verify|verify} messages.
                 * @function encode
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @static
                 * @param {blaze_query.Attribute.ISelectorEntry} message SelectorEntry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SelectorEntry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.label);
                    if (message.intValue != null && message.hasOwnProperty("intValue"))
                        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.intValue);
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.stringValue);
                    if (message.booleanValue != null && message.hasOwnProperty("booleanValue"))
                        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.booleanValue);
                    if (message.tristateValue != null && message.hasOwnProperty("tristateValue"))
                        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.tristateValue);
                    if (message.stringListValue != null && message.stringListValue.length)
                        for (var i = 0; i < message.stringListValue.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.stringListValue[i]);
                    if (message.license != null && message.hasOwnProperty("license"))
                        $root.blaze_query.License.encode(message.license, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
                    if (message.stringDictValue != null && message.stringDictValue.length)
                        for (var i = 0; i < message.stringDictValue.length; ++i)
                            $root.blaze_query.StringDictEntry.encode(message.stringDictValue[i], writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                    if (message.filesetListValue != null && message.filesetListValue.length)
                        for (var i = 0; i < message.filesetListValue.length; ++i)
                            $root.blaze_query.FilesetEntry.encode(message.filesetListValue[i], writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
                    if (message.labelListDictValue != null && message.labelListDictValue.length)
                        for (var i = 0; i < message.labelListDictValue.length; ++i)
                            $root.blaze_query.LabelListDictEntry.encode(message.labelListDictValue[i], writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
                    if (message.stringListDictValue != null && message.stringListDictValue.length)
                        for (var i = 0; i < message.stringListDictValue.length; ++i)
                            $root.blaze_query.StringListDictEntry.encode(message.stringListDictValue[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
                    if (message.DEPRECATEDGlobCriteria != null && message.DEPRECATEDGlobCriteria.length)
                        for (var i = 0; i < message.DEPRECATEDGlobCriteria.length; ++i)
                            $root.blaze_query.DEPRECATED_GlobCriteria.encode(message.DEPRECATEDGlobCriteria[i], writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
                    if (message.intListValue != null && message.intListValue.length)
                        for (var i = 0; i < message.intListValue.length; ++i)
                            writer.uint32(/* id 13, wireType 0 =*/ 104).int32(message.intListValue[i]);
                    if (message.DEPRECATEDStringDictUnaryValue != null && message.DEPRECATEDStringDictUnaryValue.length)
                        for (var i = 0; i < message.DEPRECATEDStringDictUnaryValue.length; ++i)
                            writer.uint32(/* id 14, wireType 2 =*/ 114).bytes(message.DEPRECATEDStringDictUnaryValue[i]);
                    if (message.labelDictUnaryValue != null && message.labelDictUnaryValue.length)
                        for (var i = 0; i < message.labelDictUnaryValue.length; ++i)
                            $root.blaze_query.LabelDictUnaryEntry.encode(message.labelDictUnaryValue[i], writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
                    if (message.isDefaultValue != null && message.hasOwnProperty("isDefaultValue"))
                        writer.uint32(/* id 16, wireType 0 =*/ 128).bool(message.isDefaultValue);
                    if (message.labelKeyedStringDictValue != null && message.labelKeyedStringDictValue.length)
                        for (var i = 0; i < message.labelKeyedStringDictValue.length; ++i)
                            $root.blaze_query.LabelKeyedStringDictEntry.encode(message.labelKeyedStringDictValue[i], writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified SelectorEntry message, length delimited. Does not implicitly {@link blaze_query.Attribute.SelectorEntry.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @static
                 * @param {blaze_query.Attribute.ISelectorEntry} message SelectorEntry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SelectorEntry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a SelectorEntry message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze_query.Attribute.SelectorEntry} SelectorEntry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SelectorEntry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.Attribute.SelectorEntry();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.label = reader.string();
                                break;
                            case 16:
                                message.isDefaultValue = reader.bool();
                                break;
                            case 2:
                                message.intValue = reader.int32();
                                break;
                            case 3:
                                message.stringValue = reader.string();
                                break;
                            case 4:
                                message.booleanValue = reader.bool();
                                break;
                            case 5:
                                message.tristateValue = reader.int32();
                                break;
                            case 6:
                                if (!(message.stringListValue && message.stringListValue.length))
                                    message.stringListValue = [];
                                message.stringListValue.push(reader.string());
                                break;
                            case 7:
                                message.license = $root.blaze_query.License.decode(reader, reader.uint32());
                                break;
                            case 8:
                                if (!(message.stringDictValue && message.stringDictValue.length))
                                    message.stringDictValue = [];
                                message.stringDictValue.push($root.blaze_query.StringDictEntry.decode(reader, reader.uint32()));
                                break;
                            case 9:
                                if (!(message.filesetListValue && message.filesetListValue.length))
                                    message.filesetListValue = [];
                                message.filesetListValue.push($root.blaze_query.FilesetEntry.decode(reader, reader.uint32()));
                                break;
                            case 10:
                                if (!(message.labelListDictValue && message.labelListDictValue.length))
                                    message.labelListDictValue = [];
                                message.labelListDictValue.push($root.blaze_query.LabelListDictEntry.decode(reader, reader.uint32()));
                                break;
                            case 11:
                                if (!(message.stringListDictValue && message.stringListDictValue.length))
                                    message.stringListDictValue = [];
                                message.stringListDictValue.push($root.blaze_query.StringListDictEntry.decode(reader, reader.uint32()));
                                break;
                            case 13:
                                if (!(message.intListValue && message.intListValue.length))
                                    message.intListValue = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.intListValue.push(reader.int32());
                                }
                                else
                                    message.intListValue.push(reader.int32());
                                break;
                            case 15:
                                if (!(message.labelDictUnaryValue && message.labelDictUnaryValue.length))
                                    message.labelDictUnaryValue = [];
                                message.labelDictUnaryValue.push($root.blaze_query.LabelDictUnaryEntry.decode(reader, reader.uint32()));
                                break;
                            case 17:
                                if (!(message.labelKeyedStringDictValue && message.labelKeyedStringDictValue.length))
                                    message.labelKeyedStringDictValue = [];
                                message.labelKeyedStringDictValue.push($root.blaze_query.LabelKeyedStringDictEntry.decode(reader, reader.uint32()));
                                break;
                            case 12:
                                if (!(message.DEPRECATEDGlobCriteria && message.DEPRECATEDGlobCriteria.length))
                                    message.DEPRECATEDGlobCriteria = [];
                                message.DEPRECATEDGlobCriteria.push($root.blaze_query.DEPRECATED_GlobCriteria.decode(reader, reader.uint32()));
                                break;
                            case 14:
                                if (!(message.DEPRECATEDStringDictUnaryValue && message.DEPRECATEDStringDictUnaryValue.length))
                                    message.DEPRECATEDStringDictUnaryValue = [];
                                message.DEPRECATEDStringDictUnaryValue.push(reader.bytes());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a SelectorEntry message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze_query.Attribute.SelectorEntry} SelectorEntry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SelectorEntry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a SelectorEntry message.
                 * @function verify
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SelectorEntry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.isDefaultValue != null && message.hasOwnProperty("isDefaultValue"))
                        if (typeof message.isDefaultValue !== "boolean")
                            return "isDefaultValue: boolean expected";
                    if (message.intValue != null && message.hasOwnProperty("intValue"))
                        if (!$util.isInteger(message.intValue))
                            return "intValue: integer expected";
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        if (!$util.isString(message.stringValue))
                            return "stringValue: string expected";
                    if (message.booleanValue != null && message.hasOwnProperty("booleanValue"))
                        if (typeof message.booleanValue !== "boolean")
                            return "booleanValue: boolean expected";
                    if (message.tristateValue != null && message.hasOwnProperty("tristateValue"))
                        switch (message.tristateValue) {
                            default:
                                return "tristateValue: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                        }
                    if (message.stringListValue != null && message.hasOwnProperty("stringListValue")) {
                        if (!Array.isArray(message.stringListValue))
                            return "stringListValue: array expected";
                        for (var i = 0; i < message.stringListValue.length; ++i)
                            if (!$util.isString(message.stringListValue[i]))
                                return "stringListValue: string[] expected";
                    }
                    if (message.license != null && message.hasOwnProperty("license")) {
                        var error = $root.blaze_query.License.verify(message.license);
                        if (error)
                            return "license." + error;
                    }
                    if (message.stringDictValue != null && message.hasOwnProperty("stringDictValue")) {
                        if (!Array.isArray(message.stringDictValue))
                            return "stringDictValue: array expected";
                        for (var i = 0; i < message.stringDictValue.length; ++i) {
                            var error = $root.blaze_query.StringDictEntry.verify(message.stringDictValue[i]);
                            if (error)
                                return "stringDictValue." + error;
                        }
                    }
                    if (message.filesetListValue != null && message.hasOwnProperty("filesetListValue")) {
                        if (!Array.isArray(message.filesetListValue))
                            return "filesetListValue: array expected";
                        for (var i = 0; i < message.filesetListValue.length; ++i) {
                            var error = $root.blaze_query.FilesetEntry.verify(message.filesetListValue[i]);
                            if (error)
                                return "filesetListValue." + error;
                        }
                    }
                    if (message.labelListDictValue != null && message.hasOwnProperty("labelListDictValue")) {
                        if (!Array.isArray(message.labelListDictValue))
                            return "labelListDictValue: array expected";
                        for (var i = 0; i < message.labelListDictValue.length; ++i) {
                            var error = $root.blaze_query.LabelListDictEntry.verify(message.labelListDictValue[i]);
                            if (error)
                                return "labelListDictValue." + error;
                        }
                    }
                    if (message.stringListDictValue != null && message.hasOwnProperty("stringListDictValue")) {
                        if (!Array.isArray(message.stringListDictValue))
                            return "stringListDictValue: array expected";
                        for (var i = 0; i < message.stringListDictValue.length; ++i) {
                            var error = $root.blaze_query.StringListDictEntry.verify(message.stringListDictValue[i]);
                            if (error)
                                return "stringListDictValue." + error;
                        }
                    }
                    if (message.intListValue != null && message.hasOwnProperty("intListValue")) {
                        if (!Array.isArray(message.intListValue))
                            return "intListValue: array expected";
                        for (var i = 0; i < message.intListValue.length; ++i)
                            if (!$util.isInteger(message.intListValue[i]))
                                return "intListValue: integer[] expected";
                    }
                    if (message.labelDictUnaryValue != null && message.hasOwnProperty("labelDictUnaryValue")) {
                        if (!Array.isArray(message.labelDictUnaryValue))
                            return "labelDictUnaryValue: array expected";
                        for (var i = 0; i < message.labelDictUnaryValue.length; ++i) {
                            var error = $root.blaze_query.LabelDictUnaryEntry.verify(message.labelDictUnaryValue[i]);
                            if (error)
                                return "labelDictUnaryValue." + error;
                        }
                    }
                    if (message.labelKeyedStringDictValue != null && message.hasOwnProperty("labelKeyedStringDictValue")) {
                        if (!Array.isArray(message.labelKeyedStringDictValue))
                            return "labelKeyedStringDictValue: array expected";
                        for (var i = 0; i < message.labelKeyedStringDictValue.length; ++i) {
                            var error = $root.blaze_query.LabelKeyedStringDictEntry.verify(message.labelKeyedStringDictValue[i]);
                            if (error)
                                return "labelKeyedStringDictValue." + error;
                        }
                    }
                    if (message.DEPRECATEDGlobCriteria != null && message.hasOwnProperty("DEPRECATEDGlobCriteria")) {
                        if (!Array.isArray(message.DEPRECATEDGlobCriteria))
                            return "DEPRECATEDGlobCriteria: array expected";
                        for (var i = 0; i < message.DEPRECATEDGlobCriteria.length; ++i) {
                            var error = $root.blaze_query.DEPRECATED_GlobCriteria.verify(message.DEPRECATEDGlobCriteria[i]);
                            if (error)
                                return "DEPRECATEDGlobCriteria." + error;
                        }
                    }
                    if (message.DEPRECATEDStringDictUnaryValue != null && message.hasOwnProperty("DEPRECATEDStringDictUnaryValue")) {
                        if (!Array.isArray(message.DEPRECATEDStringDictUnaryValue))
                            return "DEPRECATEDStringDictUnaryValue: array expected";
                        for (var i = 0; i < message.DEPRECATEDStringDictUnaryValue.length; ++i)
                            if (!(message.DEPRECATEDStringDictUnaryValue[i] && typeof message.DEPRECATEDStringDictUnaryValue[i].length === "number" || $util.isString(message.DEPRECATEDStringDictUnaryValue[i])))
                                return "DEPRECATEDStringDictUnaryValue: buffer[] expected";
                    }
                    return null;
                };
                /**
                 * Creates a SelectorEntry message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze_query.Attribute.SelectorEntry} SelectorEntry
                 */
                SelectorEntry.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze_query.Attribute.SelectorEntry)
                        return object;
                    var message = new $root.blaze_query.Attribute.SelectorEntry();
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.isDefaultValue != null)
                        message.isDefaultValue = Boolean(object.isDefaultValue);
                    if (object.intValue != null)
                        message.intValue = object.intValue | 0;
                    if (object.stringValue != null)
                        message.stringValue = String(object.stringValue);
                    if (object.booleanValue != null)
                        message.booleanValue = Boolean(object.booleanValue);
                    switch (object.tristateValue) {
                        case "NO":
                        case 0:
                            message.tristateValue = 0;
                            break;
                        case "YES":
                        case 1:
                            message.tristateValue = 1;
                            break;
                        case "AUTO":
                        case 2:
                            message.tristateValue = 2;
                            break;
                    }
                    if (object.stringListValue) {
                        if (!Array.isArray(object.stringListValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.stringListValue: array expected");
                        message.stringListValue = [];
                        for (var i = 0; i < object.stringListValue.length; ++i)
                            message.stringListValue[i] = String(object.stringListValue[i]);
                    }
                    if (object.license != null) {
                        if (typeof object.license !== "object")
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.license: object expected");
                        message.license = $root.blaze_query.License.fromObject(object.license);
                    }
                    if (object.stringDictValue) {
                        if (!Array.isArray(object.stringDictValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.stringDictValue: array expected");
                        message.stringDictValue = [];
                        for (var i = 0; i < object.stringDictValue.length; ++i) {
                            if (typeof object.stringDictValue[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.SelectorEntry.stringDictValue: object expected");
                            message.stringDictValue[i] = $root.blaze_query.StringDictEntry.fromObject(object.stringDictValue[i]);
                        }
                    }
                    if (object.filesetListValue) {
                        if (!Array.isArray(object.filesetListValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.filesetListValue: array expected");
                        message.filesetListValue = [];
                        for (var i = 0; i < object.filesetListValue.length; ++i) {
                            if (typeof object.filesetListValue[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.SelectorEntry.filesetListValue: object expected");
                            message.filesetListValue[i] = $root.blaze_query.FilesetEntry.fromObject(object.filesetListValue[i]);
                        }
                    }
                    if (object.labelListDictValue) {
                        if (!Array.isArray(object.labelListDictValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.labelListDictValue: array expected");
                        message.labelListDictValue = [];
                        for (var i = 0; i < object.labelListDictValue.length; ++i) {
                            if (typeof object.labelListDictValue[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.SelectorEntry.labelListDictValue: object expected");
                            message.labelListDictValue[i] = $root.blaze_query.LabelListDictEntry.fromObject(object.labelListDictValue[i]);
                        }
                    }
                    if (object.stringListDictValue) {
                        if (!Array.isArray(object.stringListDictValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.stringListDictValue: array expected");
                        message.stringListDictValue = [];
                        for (var i = 0; i < object.stringListDictValue.length; ++i) {
                            if (typeof object.stringListDictValue[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.SelectorEntry.stringListDictValue: object expected");
                            message.stringListDictValue[i] = $root.blaze_query.StringListDictEntry.fromObject(object.stringListDictValue[i]);
                        }
                    }
                    if (object.intListValue) {
                        if (!Array.isArray(object.intListValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.intListValue: array expected");
                        message.intListValue = [];
                        for (var i = 0; i < object.intListValue.length; ++i)
                            message.intListValue[i] = object.intListValue[i] | 0;
                    }
                    if (object.labelDictUnaryValue) {
                        if (!Array.isArray(object.labelDictUnaryValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.labelDictUnaryValue: array expected");
                        message.labelDictUnaryValue = [];
                        for (var i = 0; i < object.labelDictUnaryValue.length; ++i) {
                            if (typeof object.labelDictUnaryValue[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.SelectorEntry.labelDictUnaryValue: object expected");
                            message.labelDictUnaryValue[i] = $root.blaze_query.LabelDictUnaryEntry.fromObject(object.labelDictUnaryValue[i]);
                        }
                    }
                    if (object.labelKeyedStringDictValue) {
                        if (!Array.isArray(object.labelKeyedStringDictValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.labelKeyedStringDictValue: array expected");
                        message.labelKeyedStringDictValue = [];
                        for (var i = 0; i < object.labelKeyedStringDictValue.length; ++i) {
                            if (typeof object.labelKeyedStringDictValue[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.SelectorEntry.labelKeyedStringDictValue: object expected");
                            message.labelKeyedStringDictValue[i] = $root.blaze_query.LabelKeyedStringDictEntry.fromObject(object.labelKeyedStringDictValue[i]);
                        }
                    }
                    if (object.DEPRECATEDGlobCriteria) {
                        if (!Array.isArray(object.DEPRECATEDGlobCriteria))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.DEPRECATEDGlobCriteria: array expected");
                        message.DEPRECATEDGlobCriteria = [];
                        for (var i = 0; i < object.DEPRECATEDGlobCriteria.length; ++i) {
                            if (typeof object.DEPRECATEDGlobCriteria[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.SelectorEntry.DEPRECATEDGlobCriteria: object expected");
                            message.DEPRECATEDGlobCriteria[i] = $root.blaze_query.DEPRECATED_GlobCriteria.fromObject(object.DEPRECATEDGlobCriteria[i]);
                        }
                    }
                    if (object.DEPRECATEDStringDictUnaryValue) {
                        if (!Array.isArray(object.DEPRECATEDStringDictUnaryValue))
                            throw TypeError(".blaze_query.Attribute.SelectorEntry.DEPRECATEDStringDictUnaryValue: array expected");
                        message.DEPRECATEDStringDictUnaryValue = [];
                        for (var i = 0; i < object.DEPRECATEDStringDictUnaryValue.length; ++i)
                            if (typeof object.DEPRECATEDStringDictUnaryValue[i] === "string")
                                $util.base64.decode(object.DEPRECATEDStringDictUnaryValue[i], message.DEPRECATEDStringDictUnaryValue[i] = $util.newBuffer($util.base64.length(object.DEPRECATEDStringDictUnaryValue[i])), 0);
                            else if (object.DEPRECATEDStringDictUnaryValue[i].length)
                                message.DEPRECATEDStringDictUnaryValue[i] = object.DEPRECATEDStringDictUnaryValue[i];
                    }
                    return message;
                };
                /**
                 * Creates a plain object from a SelectorEntry message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @static
                 * @param {blaze_query.Attribute.SelectorEntry} message SelectorEntry
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SelectorEntry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.stringListValue = [];
                        object.stringDictValue = [];
                        object.filesetListValue = [];
                        object.labelListDictValue = [];
                        object.stringListDictValue = [];
                        object.DEPRECATEDGlobCriteria = [];
                        object.intListValue = [];
                        object.DEPRECATEDStringDictUnaryValue = [];
                        object.labelDictUnaryValue = [];
                        object.labelKeyedStringDictValue = [];
                    }
                    if (options.defaults) {
                        object.label = "";
                        object.intValue = 0;
                        object.stringValue = "";
                        object.booleanValue = false;
                        object.tristateValue = options.enums === String ? "NO" : 0;
                        object.license = null;
                        object.isDefaultValue = false;
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.intValue != null && message.hasOwnProperty("intValue"))
                        object.intValue = message.intValue;
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        object.stringValue = message.stringValue;
                    if (message.booleanValue != null && message.hasOwnProperty("booleanValue"))
                        object.booleanValue = message.booleanValue;
                    if (message.tristateValue != null && message.hasOwnProperty("tristateValue"))
                        object.tristateValue = options.enums === String ? $root.blaze_query.Attribute.Tristate[message.tristateValue] : message.tristateValue;
                    if (message.stringListValue && message.stringListValue.length) {
                        object.stringListValue = [];
                        for (var j = 0; j < message.stringListValue.length; ++j)
                            object.stringListValue[j] = message.stringListValue[j];
                    }
                    if (message.license != null && message.hasOwnProperty("license"))
                        object.license = $root.blaze_query.License.toObject(message.license, options);
                    if (message.stringDictValue && message.stringDictValue.length) {
                        object.stringDictValue = [];
                        for (var j = 0; j < message.stringDictValue.length; ++j)
                            object.stringDictValue[j] = $root.blaze_query.StringDictEntry.toObject(message.stringDictValue[j], options);
                    }
                    if (message.filesetListValue && message.filesetListValue.length) {
                        object.filesetListValue = [];
                        for (var j = 0; j < message.filesetListValue.length; ++j)
                            object.filesetListValue[j] = $root.blaze_query.FilesetEntry.toObject(message.filesetListValue[j], options);
                    }
                    if (message.labelListDictValue && message.labelListDictValue.length) {
                        object.labelListDictValue = [];
                        for (var j = 0; j < message.labelListDictValue.length; ++j)
                            object.labelListDictValue[j] = $root.blaze_query.LabelListDictEntry.toObject(message.labelListDictValue[j], options);
                    }
                    if (message.stringListDictValue && message.stringListDictValue.length) {
                        object.stringListDictValue = [];
                        for (var j = 0; j < message.stringListDictValue.length; ++j)
                            object.stringListDictValue[j] = $root.blaze_query.StringListDictEntry.toObject(message.stringListDictValue[j], options);
                    }
                    if (message.DEPRECATEDGlobCriteria && message.DEPRECATEDGlobCriteria.length) {
                        object.DEPRECATEDGlobCriteria = [];
                        for (var j = 0; j < message.DEPRECATEDGlobCriteria.length; ++j)
                            object.DEPRECATEDGlobCriteria[j] = $root.blaze_query.DEPRECATED_GlobCriteria.toObject(message.DEPRECATEDGlobCriteria[j], options);
                    }
                    if (message.intListValue && message.intListValue.length) {
                        object.intListValue = [];
                        for (var j = 0; j < message.intListValue.length; ++j)
                            object.intListValue[j] = message.intListValue[j];
                    }
                    if (message.DEPRECATEDStringDictUnaryValue && message.DEPRECATEDStringDictUnaryValue.length) {
                        object.DEPRECATEDStringDictUnaryValue = [];
                        for (var j = 0; j < message.DEPRECATEDStringDictUnaryValue.length; ++j)
                            object.DEPRECATEDStringDictUnaryValue[j] = options.bytes === String ? $util.base64.encode(message.DEPRECATEDStringDictUnaryValue[j], 0, message.DEPRECATEDStringDictUnaryValue[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.DEPRECATEDStringDictUnaryValue[j]) : message.DEPRECATEDStringDictUnaryValue[j];
                    }
                    if (message.labelDictUnaryValue && message.labelDictUnaryValue.length) {
                        object.labelDictUnaryValue = [];
                        for (var j = 0; j < message.labelDictUnaryValue.length; ++j)
                            object.labelDictUnaryValue[j] = $root.blaze_query.LabelDictUnaryEntry.toObject(message.labelDictUnaryValue[j], options);
                    }
                    if (message.isDefaultValue != null && message.hasOwnProperty("isDefaultValue"))
                        object.isDefaultValue = message.isDefaultValue;
                    if (message.labelKeyedStringDictValue && message.labelKeyedStringDictValue.length) {
                        object.labelKeyedStringDictValue = [];
                        for (var j = 0; j < message.labelKeyedStringDictValue.length; ++j)
                            object.labelKeyedStringDictValue[j] = $root.blaze_query.LabelKeyedStringDictEntry.toObject(message.labelKeyedStringDictValue[j], options);
                    }
                    return object;
                };
                /**
                 * Converts this SelectorEntry to JSON.
                 * @function toJSON
                 * @memberof blaze_query.Attribute.SelectorEntry
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SelectorEntry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return SelectorEntry;
            })();
            Attribute.Selector = (function () {
                /**
                 * Properties of a Selector.
                 * @memberof blaze_query.Attribute
                 * @interface ISelector
                 * @property {Array.<blaze_query.Attribute.ISelectorEntry>|null} [entries] Selector entries
                 * @property {boolean|null} [hasDefaultValue] Selector hasDefaultValue
                 * @property {string|null} [noMatchError] Selector noMatchError
                 */
                /**
                 * Constructs a new Selector.
                 * @memberof blaze_query.Attribute
                 * @classdesc Represents a Selector.
                 * @implements ISelector
                 * @constructor
                 * @param {blaze_query.Attribute.ISelector=} [properties] Properties to set
                 */
                function Selector(properties) {
                    this.entries = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Selector entries.
                 * @member {Array.<blaze_query.Attribute.ISelectorEntry>} entries
                 * @memberof blaze_query.Attribute.Selector
                 * @instance
                 */
                Selector.prototype.entries = $util.emptyArray;
                /**
                 * Selector hasDefaultValue.
                 * @member {boolean} hasDefaultValue
                 * @memberof blaze_query.Attribute.Selector
                 * @instance
                 */
                Selector.prototype.hasDefaultValue = false;
                /**
                 * Selector noMatchError.
                 * @member {string} noMatchError
                 * @memberof blaze_query.Attribute.Selector
                 * @instance
                 */
                Selector.prototype.noMatchError = "";
                /**
                 * Creates a new Selector instance using the specified properties.
                 * @function create
                 * @memberof blaze_query.Attribute.Selector
                 * @static
                 * @param {blaze_query.Attribute.ISelector=} [properties] Properties to set
                 * @returns {blaze_query.Attribute.Selector} Selector instance
                 */
                Selector.create = function create(properties) {
                    return new Selector(properties);
                };
                /**
                 * Encodes the specified Selector message. Does not implicitly {@link blaze_query.Attribute.Selector.verify|verify} messages.
                 * @function encode
                 * @memberof blaze_query.Attribute.Selector
                 * @static
                 * @param {blaze_query.Attribute.ISelector} message Selector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Selector.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entries != null && message.entries.length)
                        for (var i = 0; i < message.entries.length; ++i)
                            $root.blaze_query.Attribute.SelectorEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                    if (message.hasDefaultValue != null && message.hasOwnProperty("hasDefaultValue"))
                        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.hasDefaultValue);
                    if (message.noMatchError != null && message.hasOwnProperty("noMatchError"))
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.noMatchError);
                    return writer;
                };
                /**
                 * Encodes the specified Selector message, length delimited. Does not implicitly {@link blaze_query.Attribute.Selector.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze_query.Attribute.Selector
                 * @static
                 * @param {blaze_query.Attribute.ISelector} message Selector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Selector.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a Selector message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze_query.Attribute.Selector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze_query.Attribute.Selector} Selector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Selector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.Attribute.Selector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.entries && message.entries.length))
                                    message.entries = [];
                                message.entries.push($root.blaze_query.Attribute.SelectorEntry.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.hasDefaultValue = reader.bool();
                                break;
                            case 3:
                                message.noMatchError = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a Selector message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze_query.Attribute.Selector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze_query.Attribute.Selector} Selector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Selector.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a Selector message.
                 * @function verify
                 * @memberof blaze_query.Attribute.Selector
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Selector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entries != null && message.hasOwnProperty("entries")) {
                        if (!Array.isArray(message.entries))
                            return "entries: array expected";
                        for (var i = 0; i < message.entries.length; ++i) {
                            var error = $root.blaze_query.Attribute.SelectorEntry.verify(message.entries[i]);
                            if (error)
                                return "entries." + error;
                        }
                    }
                    if (message.hasDefaultValue != null && message.hasOwnProperty("hasDefaultValue"))
                        if (typeof message.hasDefaultValue !== "boolean")
                            return "hasDefaultValue: boolean expected";
                    if (message.noMatchError != null && message.hasOwnProperty("noMatchError"))
                        if (!$util.isString(message.noMatchError))
                            return "noMatchError: string expected";
                    return null;
                };
                /**
                 * Creates a Selector message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze_query.Attribute.Selector
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze_query.Attribute.Selector} Selector
                 */
                Selector.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze_query.Attribute.Selector)
                        return object;
                    var message = new $root.blaze_query.Attribute.Selector();
                    if (object.entries) {
                        if (!Array.isArray(object.entries))
                            throw TypeError(".blaze_query.Attribute.Selector.entries: array expected");
                        message.entries = [];
                        for (var i = 0; i < object.entries.length; ++i) {
                            if (typeof object.entries[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.Selector.entries: object expected");
                            message.entries[i] = $root.blaze_query.Attribute.SelectorEntry.fromObject(object.entries[i]);
                        }
                    }
                    if (object.hasDefaultValue != null)
                        message.hasDefaultValue = Boolean(object.hasDefaultValue);
                    if (object.noMatchError != null)
                        message.noMatchError = String(object.noMatchError);
                    return message;
                };
                /**
                 * Creates a plain object from a Selector message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze_query.Attribute.Selector
                 * @static
                 * @param {blaze_query.Attribute.Selector} message Selector
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Selector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.entries = [];
                    if (options.defaults) {
                        object.hasDefaultValue = false;
                        object.noMatchError = "";
                    }
                    if (message.entries && message.entries.length) {
                        object.entries = [];
                        for (var j = 0; j < message.entries.length; ++j)
                            object.entries[j] = $root.blaze_query.Attribute.SelectorEntry.toObject(message.entries[j], options);
                    }
                    if (message.hasDefaultValue != null && message.hasOwnProperty("hasDefaultValue"))
                        object.hasDefaultValue = message.hasDefaultValue;
                    if (message.noMatchError != null && message.hasOwnProperty("noMatchError"))
                        object.noMatchError = message.noMatchError;
                    return object;
                };
                /**
                 * Converts this Selector to JSON.
                 * @function toJSON
                 * @memberof blaze_query.Attribute.Selector
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Selector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return Selector;
            })();
            Attribute.SelectorList = (function () {
                /**
                 * Properties of a SelectorList.
                 * @memberof blaze_query.Attribute
                 * @interface ISelectorList
                 * @property {blaze_query.Attribute.Discriminator|null} [type] SelectorList type
                 * @property {Array.<blaze_query.Attribute.ISelector>|null} [elements] SelectorList elements
                 */
                /**
                 * Constructs a new SelectorList.
                 * @memberof blaze_query.Attribute
                 * @classdesc Represents a SelectorList.
                 * @implements ISelectorList
                 * @constructor
                 * @param {blaze_query.Attribute.ISelectorList=} [properties] Properties to set
                 */
                function SelectorList(properties) {
                    this.elements = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * SelectorList type.
                 * @member {blaze_query.Attribute.Discriminator} type
                 * @memberof blaze_query.Attribute.SelectorList
                 * @instance
                 */
                SelectorList.prototype.type = 1;
                /**
                 * SelectorList elements.
                 * @member {Array.<blaze_query.Attribute.ISelector>} elements
                 * @memberof blaze_query.Attribute.SelectorList
                 * @instance
                 */
                SelectorList.prototype.elements = $util.emptyArray;
                /**
                 * Creates a new SelectorList instance using the specified properties.
                 * @function create
                 * @memberof blaze_query.Attribute.SelectorList
                 * @static
                 * @param {blaze_query.Attribute.ISelectorList=} [properties] Properties to set
                 * @returns {blaze_query.Attribute.SelectorList} SelectorList instance
                 */
                SelectorList.create = function create(properties) {
                    return new SelectorList(properties);
                };
                /**
                 * Encodes the specified SelectorList message. Does not implicitly {@link blaze_query.Attribute.SelectorList.verify|verify} messages.
                 * @function encode
                 * @memberof blaze_query.Attribute.SelectorList
                 * @static
                 * @param {blaze_query.Attribute.ISelectorList} message SelectorList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SelectorList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
                    if (message.elements != null && message.elements.length)
                        for (var i = 0; i < message.elements.length; ++i)
                            $root.blaze_query.Attribute.Selector.encode(message.elements[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified SelectorList message, length delimited. Does not implicitly {@link blaze_query.Attribute.SelectorList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze_query.Attribute.SelectorList
                 * @static
                 * @param {blaze_query.Attribute.ISelectorList} message SelectorList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SelectorList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a SelectorList message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze_query.Attribute.SelectorList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze_query.Attribute.SelectorList} SelectorList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SelectorList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.Attribute.SelectorList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                if (!(message.elements && message.elements.length))
                                    message.elements = [];
                                message.elements.push($root.blaze_query.Attribute.Selector.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a SelectorList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze_query.Attribute.SelectorList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze_query.Attribute.SelectorList} SelectorList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SelectorList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a SelectorList message.
                 * @function verify
                 * @memberof blaze_query.Attribute.SelectorList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SelectorList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 15:
                            case 16:
                            case 18:
                            case 19:
                            case 20:
                            case 21:
                            case 17:
                                break;
                        }
                    if (message.elements != null && message.hasOwnProperty("elements")) {
                        if (!Array.isArray(message.elements))
                            return "elements: array expected";
                        for (var i = 0; i < message.elements.length; ++i) {
                            var error = $root.blaze_query.Attribute.Selector.verify(message.elements[i]);
                            if (error)
                                return "elements." + error;
                        }
                    }
                    return null;
                };
                /**
                 * Creates a SelectorList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze_query.Attribute.SelectorList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze_query.Attribute.SelectorList} SelectorList
                 */
                SelectorList.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze_query.Attribute.SelectorList)
                        return object;
                    var message = new $root.blaze_query.Attribute.SelectorList();
                    switch (object.type) {
                        case "INTEGER":
                        case 1:
                            message.type = 1;
                            break;
                        case "STRING":
                        case 2:
                            message.type = 2;
                            break;
                        case "LABEL":
                        case 3:
                            message.type = 3;
                            break;
                        case "OUTPUT":
                        case 4:
                            message.type = 4;
                            break;
                        case "STRING_LIST":
                        case 5:
                            message.type = 5;
                            break;
                        case "LABEL_LIST":
                        case 6:
                            message.type = 6;
                            break;
                        case "OUTPUT_LIST":
                        case 7:
                            message.type = 7;
                            break;
                        case "DISTRIBUTION_SET":
                        case 8:
                            message.type = 8;
                            break;
                        case "LICENSE":
                        case 9:
                            message.type = 9;
                            break;
                        case "STRING_DICT":
                        case 10:
                            message.type = 10;
                            break;
                        case "FILESET_ENTRY_LIST":
                        case 11:
                            message.type = 11;
                            break;
                        case "LABEL_LIST_DICT":
                        case 12:
                            message.type = 12;
                            break;
                        case "STRING_LIST_DICT":
                        case 13:
                            message.type = 13;
                            break;
                        case "BOOLEAN":
                        case 14:
                            message.type = 14;
                            break;
                        case "TRISTATE":
                        case 15:
                            message.type = 15;
                            break;
                        case "INTEGER_LIST":
                        case 16:
                            message.type = 16;
                            break;
                        case "UNKNOWN":
                        case 18:
                            message.type = 18;
                            break;
                        case "LABEL_DICT_UNARY":
                        case 19:
                            message.type = 19;
                            break;
                        case "SELECTOR_LIST":
                        case 20:
                            message.type = 20;
                            break;
                        case "LABEL_KEYED_STRING_DICT":
                        case 21:
                            message.type = 21;
                            break;
                        case "DEPRECATED_STRING_DICT_UNARY":
                        case 17:
                            message.type = 17;
                            break;
                    }
                    if (object.elements) {
                        if (!Array.isArray(object.elements))
                            throw TypeError(".blaze_query.Attribute.SelectorList.elements: array expected");
                        message.elements = [];
                        for (var i = 0; i < object.elements.length; ++i) {
                            if (typeof object.elements[i] !== "object")
                                throw TypeError(".blaze_query.Attribute.SelectorList.elements: object expected");
                            message.elements[i] = $root.blaze_query.Attribute.Selector.fromObject(object.elements[i]);
                        }
                    }
                    return message;
                };
                /**
                 * Creates a plain object from a SelectorList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze_query.Attribute.SelectorList
                 * @static
                 * @param {blaze_query.Attribute.SelectorList} message SelectorList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SelectorList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.elements = [];
                    if (options.defaults)
                        object.type = options.enums === String ? "INTEGER" : 1;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.blaze_query.Attribute.Discriminator[message.type] : message.type;
                    if (message.elements && message.elements.length) {
                        object.elements = [];
                        for (var j = 0; j < message.elements.length; ++j)
                            object.elements[j] = $root.blaze_query.Attribute.Selector.toObject(message.elements[j], options);
                    }
                    return object;
                };
                /**
                 * Converts this SelectorList to JSON.
                 * @function toJSON
                 * @memberof blaze_query.Attribute.SelectorList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SelectorList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return SelectorList;
            })();
            return Attribute;
        })();
        blaze_query.Rule = (function () {
            /**
             * Properties of a Rule.
             * @memberof blaze_query
             * @interface IRule
             * @property {string} name Rule name
             * @property {string} ruleClass Rule ruleClass
             * @property {string|null} [location] Rule location
             * @property {Array.<blaze_query.IAttribute>|null} [attribute] Rule attribute
             * @property {Array.<string>|null} [ruleInput] Rule ruleInput
             * @property {Array.<string>|null} [ruleOutput] Rule ruleOutput
             * @property {Array.<string>|null} [defaultSetting] Rule defaultSetting
             * @property {blaze_query.ILocation|null} [DEPRECATEDParseableLocation] Rule DEPRECATEDParseableLocation
             * @property {boolean|null} [publicByDefault] Rule publicByDefault
             * @property {boolean|null} [isSkylark] Rule isSkylark
             * @property {Array.<blaze_query.IAttributeAspect>|null} [skylarkAttributeAspects] Rule skylarkAttributeAspects
             * @property {string|null} [skylarkEnvironmentHashCode] Rule skylarkEnvironmentHashCode
             */
            /**
             * Constructs a new Rule.
             * @memberof blaze_query
             * @classdesc Represents a Rule.
             * @implements IRule
             * @constructor
             * @param {blaze_query.IRule=} [properties] Properties to set
             */
            function Rule(properties) {
                this.attribute = [];
                this.ruleInput = [];
                this.ruleOutput = [];
                this.defaultSetting = [];
                this.skylarkAttributeAspects = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Rule name.
             * @member {string} name
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.name = "";
            /**
             * Rule ruleClass.
             * @member {string} ruleClass
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.ruleClass = "";
            /**
             * Rule location.
             * @member {string} location
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.location = "";
            /**
             * Rule attribute.
             * @member {Array.<blaze_query.IAttribute>} attribute
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.attribute = $util.emptyArray;
            /**
             * Rule ruleInput.
             * @member {Array.<string>} ruleInput
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.ruleInput = $util.emptyArray;
            /**
             * Rule ruleOutput.
             * @member {Array.<string>} ruleOutput
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.ruleOutput = $util.emptyArray;
            /**
             * Rule defaultSetting.
             * @member {Array.<string>} defaultSetting
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.defaultSetting = $util.emptyArray;
            /**
             * Rule DEPRECATEDParseableLocation.
             * @member {blaze_query.ILocation|null|undefined} DEPRECATEDParseableLocation
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.DEPRECATEDParseableLocation = null;
            /**
             * Rule publicByDefault.
             * @member {boolean} publicByDefault
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.publicByDefault = false;
            /**
             * Rule isSkylark.
             * @member {boolean} isSkylark
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.isSkylark = false;
            /**
             * Rule skylarkAttributeAspects.
             * @member {Array.<blaze_query.IAttributeAspect>} skylarkAttributeAspects
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.skylarkAttributeAspects = $util.emptyArray;
            /**
             * Rule skylarkEnvironmentHashCode.
             * @member {string} skylarkEnvironmentHashCode
             * @memberof blaze_query.Rule
             * @instance
             */
            Rule.prototype.skylarkEnvironmentHashCode = "";
            /**
             * Creates a new Rule instance using the specified properties.
             * @function create
             * @memberof blaze_query.Rule
             * @static
             * @param {blaze_query.IRule=} [properties] Properties to set
             * @returns {blaze_query.Rule} Rule instance
             */
            Rule.create = function create(properties) {
                return new Rule(properties);
            };
            /**
             * Encodes the specified Rule message. Does not implicitly {@link blaze_query.Rule.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.Rule
             * @static
             * @param {blaze_query.IRule} message Rule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.ruleClass);
                if (message.location != null && message.hasOwnProperty("location"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.location);
                if (message.attribute != null && message.attribute.length)
                    for (var i = 0; i < message.attribute.length; ++i)
                        $root.blaze_query.Attribute.encode(message.attribute[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.ruleInput != null && message.ruleInput.length)
                    for (var i = 0; i < message.ruleInput.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.ruleInput[i]);
                if (message.ruleOutput != null && message.ruleOutput.length)
                    for (var i = 0; i < message.ruleOutput.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.ruleOutput[i]);
                if (message.defaultSetting != null && message.defaultSetting.length)
                    for (var i = 0; i < message.defaultSetting.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.defaultSetting[i]);
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation"))
                    $root.blaze_query.Location.encode(message.DEPRECATEDParseableLocation, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                if (message.publicByDefault != null && message.hasOwnProperty("publicByDefault"))
                    writer.uint32(/* id 9, wireType 0 =*/ 72).bool(message.publicByDefault);
                if (message.isSkylark != null && message.hasOwnProperty("isSkylark"))
                    writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.isSkylark);
                if (message.skylarkAttributeAspects != null && message.skylarkAttributeAspects.length)
                    for (var i = 0; i < message.skylarkAttributeAspects.length; ++i)
                        $root.blaze_query.AttributeAspect.encode(message.skylarkAttributeAspects[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
                if (message.skylarkEnvironmentHashCode != null && message.hasOwnProperty("skylarkEnvironmentHashCode"))
                    writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.skylarkEnvironmentHashCode);
                return writer;
            };
            /**
             * Encodes the specified Rule message, length delimited. Does not implicitly {@link blaze_query.Rule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.Rule
             * @static
             * @param {blaze_query.IRule} message Rule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Rule message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.Rule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.Rule} Rule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.Rule();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.ruleClass = reader.string();
                            break;
                        case 3:
                            message.location = reader.string();
                            break;
                        case 4:
                            if (!(message.attribute && message.attribute.length))
                                message.attribute = [];
                            message.attribute.push($root.blaze_query.Attribute.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.ruleInput && message.ruleInput.length))
                                message.ruleInput = [];
                            message.ruleInput.push(reader.string());
                            break;
                        case 6:
                            if (!(message.ruleOutput && message.ruleOutput.length))
                                message.ruleOutput = [];
                            message.ruleOutput.push(reader.string());
                            break;
                        case 7:
                            if (!(message.defaultSetting && message.defaultSetting.length))
                                message.defaultSetting = [];
                            message.defaultSetting.push(reader.string());
                            break;
                        case 8:
                            message.DEPRECATEDParseableLocation = $root.blaze_query.Location.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.publicByDefault = reader.bool();
                            break;
                        case 10:
                            message.isSkylark = reader.bool();
                            break;
                        case 11:
                            if (!(message.skylarkAttributeAspects && message.skylarkAttributeAspects.length))
                                message.skylarkAttributeAspects = [];
                            message.skylarkAttributeAspects.push($root.blaze_query.AttributeAspect.decode(reader, reader.uint32()));
                            break;
                        case 12:
                            message.skylarkEnvironmentHashCode = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("ruleClass"))
                    throw $util.ProtocolError("missing required 'ruleClass'", { instance: message });
                return message;
            };
            /**
             * Decodes a Rule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.Rule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.Rule} Rule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Rule message.
             * @function verify
             * @memberof blaze_query.Rule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Rule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isString(message.ruleClass))
                    return "ruleClass: string expected";
                if (message.location != null && message.hasOwnProperty("location"))
                    if (!$util.isString(message.location))
                        return "location: string expected";
                if (message.attribute != null && message.hasOwnProperty("attribute")) {
                    if (!Array.isArray(message.attribute))
                        return "attribute: array expected";
                    for (var i = 0; i < message.attribute.length; ++i) {
                        var error = $root.blaze_query.Attribute.verify(message.attribute[i]);
                        if (error)
                            return "attribute." + error;
                    }
                }
                if (message.ruleInput != null && message.hasOwnProperty("ruleInput")) {
                    if (!Array.isArray(message.ruleInput))
                        return "ruleInput: array expected";
                    for (var i = 0; i < message.ruleInput.length; ++i)
                        if (!$util.isString(message.ruleInput[i]))
                            return "ruleInput: string[] expected";
                }
                if (message.ruleOutput != null && message.hasOwnProperty("ruleOutput")) {
                    if (!Array.isArray(message.ruleOutput))
                        return "ruleOutput: array expected";
                    for (var i = 0; i < message.ruleOutput.length; ++i)
                        if (!$util.isString(message.ruleOutput[i]))
                            return "ruleOutput: string[] expected";
                }
                if (message.defaultSetting != null && message.hasOwnProperty("defaultSetting")) {
                    if (!Array.isArray(message.defaultSetting))
                        return "defaultSetting: array expected";
                    for (var i = 0; i < message.defaultSetting.length; ++i)
                        if (!$util.isString(message.defaultSetting[i]))
                            return "defaultSetting: string[] expected";
                }
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation")) {
                    var error = $root.blaze_query.Location.verify(message.DEPRECATEDParseableLocation);
                    if (error)
                        return "DEPRECATEDParseableLocation." + error;
                }
                if (message.publicByDefault != null && message.hasOwnProperty("publicByDefault"))
                    if (typeof message.publicByDefault !== "boolean")
                        return "publicByDefault: boolean expected";
                if (message.isSkylark != null && message.hasOwnProperty("isSkylark"))
                    if (typeof message.isSkylark !== "boolean")
                        return "isSkylark: boolean expected";
                if (message.skylarkAttributeAspects != null && message.hasOwnProperty("skylarkAttributeAspects")) {
                    if (!Array.isArray(message.skylarkAttributeAspects))
                        return "skylarkAttributeAspects: array expected";
                    for (var i = 0; i < message.skylarkAttributeAspects.length; ++i) {
                        var error = $root.blaze_query.AttributeAspect.verify(message.skylarkAttributeAspects[i]);
                        if (error)
                            return "skylarkAttributeAspects." + error;
                    }
                }
                if (message.skylarkEnvironmentHashCode != null && message.hasOwnProperty("skylarkEnvironmentHashCode"))
                    if (!$util.isString(message.skylarkEnvironmentHashCode))
                        return "skylarkEnvironmentHashCode: string expected";
                return null;
            };
            /**
             * Creates a Rule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.Rule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.Rule} Rule
             */
            Rule.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.Rule)
                    return object;
                var message = new $root.blaze_query.Rule();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.ruleClass != null)
                    message.ruleClass = String(object.ruleClass);
                if (object.location != null)
                    message.location = String(object.location);
                if (object.attribute) {
                    if (!Array.isArray(object.attribute))
                        throw TypeError(".blaze_query.Rule.attribute: array expected");
                    message.attribute = [];
                    for (var i = 0; i < object.attribute.length; ++i) {
                        if (typeof object.attribute[i] !== "object")
                            throw TypeError(".blaze_query.Rule.attribute: object expected");
                        message.attribute[i] = $root.blaze_query.Attribute.fromObject(object.attribute[i]);
                    }
                }
                if (object.ruleInput) {
                    if (!Array.isArray(object.ruleInput))
                        throw TypeError(".blaze_query.Rule.ruleInput: array expected");
                    message.ruleInput = [];
                    for (var i = 0; i < object.ruleInput.length; ++i)
                        message.ruleInput[i] = String(object.ruleInput[i]);
                }
                if (object.ruleOutput) {
                    if (!Array.isArray(object.ruleOutput))
                        throw TypeError(".blaze_query.Rule.ruleOutput: array expected");
                    message.ruleOutput = [];
                    for (var i = 0; i < object.ruleOutput.length; ++i)
                        message.ruleOutput[i] = String(object.ruleOutput[i]);
                }
                if (object.defaultSetting) {
                    if (!Array.isArray(object.defaultSetting))
                        throw TypeError(".blaze_query.Rule.defaultSetting: array expected");
                    message.defaultSetting = [];
                    for (var i = 0; i < object.defaultSetting.length; ++i)
                        message.defaultSetting[i] = String(object.defaultSetting[i]);
                }
                if (object.DEPRECATEDParseableLocation != null) {
                    if (typeof object.DEPRECATEDParseableLocation !== "object")
                        throw TypeError(".blaze_query.Rule.DEPRECATEDParseableLocation: object expected");
                    message.DEPRECATEDParseableLocation = $root.blaze_query.Location.fromObject(object.DEPRECATEDParseableLocation);
                }
                if (object.publicByDefault != null)
                    message.publicByDefault = Boolean(object.publicByDefault);
                if (object.isSkylark != null)
                    message.isSkylark = Boolean(object.isSkylark);
                if (object.skylarkAttributeAspects) {
                    if (!Array.isArray(object.skylarkAttributeAspects))
                        throw TypeError(".blaze_query.Rule.skylarkAttributeAspects: array expected");
                    message.skylarkAttributeAspects = [];
                    for (var i = 0; i < object.skylarkAttributeAspects.length; ++i) {
                        if (typeof object.skylarkAttributeAspects[i] !== "object")
                            throw TypeError(".blaze_query.Rule.skylarkAttributeAspects: object expected");
                        message.skylarkAttributeAspects[i] = $root.blaze_query.AttributeAspect.fromObject(object.skylarkAttributeAspects[i]);
                    }
                }
                if (object.skylarkEnvironmentHashCode != null)
                    message.skylarkEnvironmentHashCode = String(object.skylarkEnvironmentHashCode);
                return message;
            };
            /**
             * Creates a plain object from a Rule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.Rule
             * @static
             * @param {blaze_query.Rule} message Rule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Rule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.attribute = [];
                    object.ruleInput = [];
                    object.ruleOutput = [];
                    object.defaultSetting = [];
                    object.skylarkAttributeAspects = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.ruleClass = "";
                    object.location = "";
                    object.DEPRECATEDParseableLocation = null;
                    object.publicByDefault = false;
                    object.isSkylark = false;
                    object.skylarkEnvironmentHashCode = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.ruleClass != null && message.hasOwnProperty("ruleClass"))
                    object.ruleClass = message.ruleClass;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = message.location;
                if (message.attribute && message.attribute.length) {
                    object.attribute = [];
                    for (var j = 0; j < message.attribute.length; ++j)
                        object.attribute[j] = $root.blaze_query.Attribute.toObject(message.attribute[j], options);
                }
                if (message.ruleInput && message.ruleInput.length) {
                    object.ruleInput = [];
                    for (var j = 0; j < message.ruleInput.length; ++j)
                        object.ruleInput[j] = message.ruleInput[j];
                }
                if (message.ruleOutput && message.ruleOutput.length) {
                    object.ruleOutput = [];
                    for (var j = 0; j < message.ruleOutput.length; ++j)
                        object.ruleOutput[j] = message.ruleOutput[j];
                }
                if (message.defaultSetting && message.defaultSetting.length) {
                    object.defaultSetting = [];
                    for (var j = 0; j < message.defaultSetting.length; ++j)
                        object.defaultSetting[j] = message.defaultSetting[j];
                }
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation"))
                    object.DEPRECATEDParseableLocation = $root.blaze_query.Location.toObject(message.DEPRECATEDParseableLocation, options);
                if (message.publicByDefault != null && message.hasOwnProperty("publicByDefault"))
                    object.publicByDefault = message.publicByDefault;
                if (message.isSkylark != null && message.hasOwnProperty("isSkylark"))
                    object.isSkylark = message.isSkylark;
                if (message.skylarkAttributeAspects && message.skylarkAttributeAspects.length) {
                    object.skylarkAttributeAspects = [];
                    for (var j = 0; j < message.skylarkAttributeAspects.length; ++j)
                        object.skylarkAttributeAspects[j] = $root.blaze_query.AttributeAspect.toObject(message.skylarkAttributeAspects[j], options);
                }
                if (message.skylarkEnvironmentHashCode != null && message.hasOwnProperty("skylarkEnvironmentHashCode"))
                    object.skylarkEnvironmentHashCode = message.skylarkEnvironmentHashCode;
                return object;
            };
            /**
             * Converts this Rule to JSON.
             * @function toJSON
             * @memberof blaze_query.Rule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Rule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Rule;
        })();
        blaze_query.AttributeAspect = (function () {
            /**
             * Properties of an AttributeAspect.
             * @memberof blaze_query
             * @interface IAttributeAspect
             * @property {string} attributeName AttributeAspect attributeName
             * @property {blaze_query.ISkylarkAspect} aspect AttributeAspect aspect
             */
            /**
             * Constructs a new AttributeAspect.
             * @memberof blaze_query
             * @classdesc Represents an AttributeAspect.
             * @implements IAttributeAspect
             * @constructor
             * @param {blaze_query.IAttributeAspect=} [properties] Properties to set
             */
            function AttributeAspect(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * AttributeAspect attributeName.
             * @member {string} attributeName
             * @memberof blaze_query.AttributeAspect
             * @instance
             */
            AttributeAspect.prototype.attributeName = "";
            /**
             * AttributeAspect aspect.
             * @member {blaze_query.ISkylarkAspect} aspect
             * @memberof blaze_query.AttributeAspect
             * @instance
             */
            AttributeAspect.prototype.aspect = null;
            /**
             * Creates a new AttributeAspect instance using the specified properties.
             * @function create
             * @memberof blaze_query.AttributeAspect
             * @static
             * @param {blaze_query.IAttributeAspect=} [properties] Properties to set
             * @returns {blaze_query.AttributeAspect} AttributeAspect instance
             */
            AttributeAspect.create = function create(properties) {
                return new AttributeAspect(properties);
            };
            /**
             * Encodes the specified AttributeAspect message. Does not implicitly {@link blaze_query.AttributeAspect.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.AttributeAspect
             * @static
             * @param {blaze_query.IAttributeAspect} message AttributeAspect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttributeAspect.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.attributeName);
                $root.blaze_query.SkylarkAspect.encode(message.aspect, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified AttributeAspect message, length delimited. Does not implicitly {@link blaze_query.AttributeAspect.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.AttributeAspect
             * @static
             * @param {blaze_query.IAttributeAspect} message AttributeAspect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttributeAspect.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an AttributeAspect message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.AttributeAspect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.AttributeAspect} AttributeAspect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttributeAspect.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.AttributeAspect();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.attributeName = reader.string();
                            break;
                        case 2:
                            message.aspect = $root.blaze_query.SkylarkAspect.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("attributeName"))
                    throw $util.ProtocolError("missing required 'attributeName'", { instance: message });
                if (!message.hasOwnProperty("aspect"))
                    throw $util.ProtocolError("missing required 'aspect'", { instance: message });
                return message;
            };
            /**
             * Decodes an AttributeAspect message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.AttributeAspect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.AttributeAspect} AttributeAspect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttributeAspect.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an AttributeAspect message.
             * @function verify
             * @memberof blaze_query.AttributeAspect
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AttributeAspect.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.attributeName))
                    return "attributeName: string expected";
                {
                    var error = $root.blaze_query.SkylarkAspect.verify(message.aspect);
                    if (error)
                        return "aspect." + error;
                }
                return null;
            };
            /**
             * Creates an AttributeAspect message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.AttributeAspect
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.AttributeAspect} AttributeAspect
             */
            AttributeAspect.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.AttributeAspect)
                    return object;
                var message = new $root.blaze_query.AttributeAspect();
                if (object.attributeName != null)
                    message.attributeName = String(object.attributeName);
                if (object.aspect != null) {
                    if (typeof object.aspect !== "object")
                        throw TypeError(".blaze_query.AttributeAspect.aspect: object expected");
                    message.aspect = $root.blaze_query.SkylarkAspect.fromObject(object.aspect);
                }
                return message;
            };
            /**
             * Creates a plain object from an AttributeAspect message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.AttributeAspect
             * @static
             * @param {blaze_query.AttributeAspect} message AttributeAspect
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AttributeAspect.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.attributeName = "";
                    object.aspect = null;
                }
                if (message.attributeName != null && message.hasOwnProperty("attributeName"))
                    object.attributeName = message.attributeName;
                if (message.aspect != null && message.hasOwnProperty("aspect"))
                    object.aspect = $root.blaze_query.SkylarkAspect.toObject(message.aspect, options);
                return object;
            };
            /**
             * Converts this AttributeAspect to JSON.
             * @function toJSON
             * @memberof blaze_query.AttributeAspect
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AttributeAspect.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return AttributeAspect;
        })();
        blaze_query.SkylarkAspect = (function () {
            /**
             * Properties of a SkylarkAspect.
             * @memberof blaze_query
             * @interface ISkylarkAspect
             * @property {string} extensionFileLabel SkylarkAspect extensionFileLabel
             * @property {string} exportedName SkylarkAspect exportedName
             * @property {Array.<blaze_query.IAttribute>|null} [attribute] SkylarkAspect attribute
             */
            /**
             * Constructs a new SkylarkAspect.
             * @memberof blaze_query
             * @classdesc Represents a SkylarkAspect.
             * @implements ISkylarkAspect
             * @constructor
             * @param {blaze_query.ISkylarkAspect=} [properties] Properties to set
             */
            function SkylarkAspect(properties) {
                this.attribute = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * SkylarkAspect extensionFileLabel.
             * @member {string} extensionFileLabel
             * @memberof blaze_query.SkylarkAspect
             * @instance
             */
            SkylarkAspect.prototype.extensionFileLabel = "";
            /**
             * SkylarkAspect exportedName.
             * @member {string} exportedName
             * @memberof blaze_query.SkylarkAspect
             * @instance
             */
            SkylarkAspect.prototype.exportedName = "";
            /**
             * SkylarkAspect attribute.
             * @member {Array.<blaze_query.IAttribute>} attribute
             * @memberof blaze_query.SkylarkAspect
             * @instance
             */
            SkylarkAspect.prototype.attribute = $util.emptyArray;
            /**
             * Creates a new SkylarkAspect instance using the specified properties.
             * @function create
             * @memberof blaze_query.SkylarkAspect
             * @static
             * @param {blaze_query.ISkylarkAspect=} [properties] Properties to set
             * @returns {blaze_query.SkylarkAspect} SkylarkAspect instance
             */
            SkylarkAspect.create = function create(properties) {
                return new SkylarkAspect(properties);
            };
            /**
             * Encodes the specified SkylarkAspect message. Does not implicitly {@link blaze_query.SkylarkAspect.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.SkylarkAspect
             * @static
             * @param {blaze_query.ISkylarkAspect} message SkylarkAspect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SkylarkAspect.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.extensionFileLabel);
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.exportedName);
                if (message.attribute != null && message.attribute.length)
                    for (var i = 0; i < message.attribute.length; ++i)
                        $root.blaze_query.Attribute.encode(message.attribute[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified SkylarkAspect message, length delimited. Does not implicitly {@link blaze_query.SkylarkAspect.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.SkylarkAspect
             * @static
             * @param {blaze_query.ISkylarkAspect} message SkylarkAspect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SkylarkAspect.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a SkylarkAspect message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.SkylarkAspect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.SkylarkAspect} SkylarkAspect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SkylarkAspect.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.SkylarkAspect();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.extensionFileLabel = reader.string();
                            break;
                        case 2:
                            message.exportedName = reader.string();
                            break;
                        case 3:
                            if (!(message.attribute && message.attribute.length))
                                message.attribute = [];
                            message.attribute.push($root.blaze_query.Attribute.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("extensionFileLabel"))
                    throw $util.ProtocolError("missing required 'extensionFileLabel'", { instance: message });
                if (!message.hasOwnProperty("exportedName"))
                    throw $util.ProtocolError("missing required 'exportedName'", { instance: message });
                return message;
            };
            /**
             * Decodes a SkylarkAspect message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.SkylarkAspect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.SkylarkAspect} SkylarkAspect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SkylarkAspect.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a SkylarkAspect message.
             * @function verify
             * @memberof blaze_query.SkylarkAspect
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SkylarkAspect.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.extensionFileLabel))
                    return "extensionFileLabel: string expected";
                if (!$util.isString(message.exportedName))
                    return "exportedName: string expected";
                if (message.attribute != null && message.hasOwnProperty("attribute")) {
                    if (!Array.isArray(message.attribute))
                        return "attribute: array expected";
                    for (var i = 0; i < message.attribute.length; ++i) {
                        var error = $root.blaze_query.Attribute.verify(message.attribute[i]);
                        if (error)
                            return "attribute." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a SkylarkAspect message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.SkylarkAspect
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.SkylarkAspect} SkylarkAspect
             */
            SkylarkAspect.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.SkylarkAspect)
                    return object;
                var message = new $root.blaze_query.SkylarkAspect();
                if (object.extensionFileLabel != null)
                    message.extensionFileLabel = String(object.extensionFileLabel);
                if (object.exportedName != null)
                    message.exportedName = String(object.exportedName);
                if (object.attribute) {
                    if (!Array.isArray(object.attribute))
                        throw TypeError(".blaze_query.SkylarkAspect.attribute: array expected");
                    message.attribute = [];
                    for (var i = 0; i < object.attribute.length; ++i) {
                        if (typeof object.attribute[i] !== "object")
                            throw TypeError(".blaze_query.SkylarkAspect.attribute: object expected");
                        message.attribute[i] = $root.blaze_query.Attribute.fromObject(object.attribute[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a SkylarkAspect message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.SkylarkAspect
             * @static
             * @param {blaze_query.SkylarkAspect} message SkylarkAspect
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SkylarkAspect.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.attribute = [];
                if (options.defaults) {
                    object.extensionFileLabel = "";
                    object.exportedName = "";
                }
                if (message.extensionFileLabel != null && message.hasOwnProperty("extensionFileLabel"))
                    object.extensionFileLabel = message.extensionFileLabel;
                if (message.exportedName != null && message.hasOwnProperty("exportedName"))
                    object.exportedName = message.exportedName;
                if (message.attribute && message.attribute.length) {
                    object.attribute = [];
                    for (var j = 0; j < message.attribute.length; ++j)
                        object.attribute[j] = $root.blaze_query.Attribute.toObject(message.attribute[j], options);
                }
                return object;
            };
            /**
             * Converts this SkylarkAspect to JSON.
             * @function toJSON
             * @memberof blaze_query.SkylarkAspect
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SkylarkAspect.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return SkylarkAspect;
        })();
        blaze_query.RuleSummary = (function () {
            /**
             * Properties of a RuleSummary.
             * @memberof blaze_query
             * @interface IRuleSummary
             * @property {blaze_query.IRule} rule RuleSummary rule
             * @property {Array.<blaze_query.IRule>|null} [dependency] RuleSummary dependency
             * @property {string|null} [location] RuleSummary location
             */
            /**
             * Constructs a new RuleSummary.
             * @memberof blaze_query
             * @classdesc Represents a RuleSummary.
             * @implements IRuleSummary
             * @constructor
             * @param {blaze_query.IRuleSummary=} [properties] Properties to set
             */
            function RuleSummary(properties) {
                this.dependency = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * RuleSummary rule.
             * @member {blaze_query.IRule} rule
             * @memberof blaze_query.RuleSummary
             * @instance
             */
            RuleSummary.prototype.rule = null;
            /**
             * RuleSummary dependency.
             * @member {Array.<blaze_query.IRule>} dependency
             * @memberof blaze_query.RuleSummary
             * @instance
             */
            RuleSummary.prototype.dependency = $util.emptyArray;
            /**
             * RuleSummary location.
             * @member {string} location
             * @memberof blaze_query.RuleSummary
             * @instance
             */
            RuleSummary.prototype.location = "";
            /**
             * Creates a new RuleSummary instance using the specified properties.
             * @function create
             * @memberof blaze_query.RuleSummary
             * @static
             * @param {blaze_query.IRuleSummary=} [properties] Properties to set
             * @returns {blaze_query.RuleSummary} RuleSummary instance
             */
            RuleSummary.create = function create(properties) {
                return new RuleSummary(properties);
            };
            /**
             * Encodes the specified RuleSummary message. Does not implicitly {@link blaze_query.RuleSummary.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.RuleSummary
             * @static
             * @param {blaze_query.IRuleSummary} message RuleSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RuleSummary.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.blaze_query.Rule.encode(message.rule, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                if (message.dependency != null && message.dependency.length)
                    for (var i = 0; i < message.dependency.length; ++i)
                        $root.blaze_query.Rule.encode(message.dependency[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.location != null && message.hasOwnProperty("location"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.location);
                return writer;
            };
            /**
             * Encodes the specified RuleSummary message, length delimited. Does not implicitly {@link blaze_query.RuleSummary.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.RuleSummary
             * @static
             * @param {blaze_query.IRuleSummary} message RuleSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RuleSummary.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a RuleSummary message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.RuleSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.RuleSummary} RuleSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RuleSummary.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.RuleSummary();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.rule = $root.blaze_query.Rule.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push($root.blaze_query.Rule.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.location = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("rule"))
                    throw $util.ProtocolError("missing required 'rule'", { instance: message });
                return message;
            };
            /**
             * Decodes a RuleSummary message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.RuleSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.RuleSummary} RuleSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RuleSummary.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a RuleSummary message.
             * @function verify
             * @memberof blaze_query.RuleSummary
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RuleSummary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.blaze_query.Rule.verify(message.rule);
                    if (error)
                        return "rule." + error;
                }
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (var i = 0; i < message.dependency.length; ++i) {
                        var error = $root.blaze_query.Rule.verify(message.dependency[i]);
                        if (error)
                            return "dependency." + error;
                    }
                }
                if (message.location != null && message.hasOwnProperty("location"))
                    if (!$util.isString(message.location))
                        return "location: string expected";
                return null;
            };
            /**
             * Creates a RuleSummary message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.RuleSummary
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.RuleSummary} RuleSummary
             */
            RuleSummary.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.RuleSummary)
                    return object;
                var message = new $root.blaze_query.RuleSummary();
                if (object.rule != null) {
                    if (typeof object.rule !== "object")
                        throw TypeError(".blaze_query.RuleSummary.rule: object expected");
                    message.rule = $root.blaze_query.Rule.fromObject(object.rule);
                }
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".blaze_query.RuleSummary.dependency: array expected");
                    message.dependency = [];
                    for (var i = 0; i < object.dependency.length; ++i) {
                        if (typeof object.dependency[i] !== "object")
                            throw TypeError(".blaze_query.RuleSummary.dependency: object expected");
                        message.dependency[i] = $root.blaze_query.Rule.fromObject(object.dependency[i]);
                    }
                }
                if (object.location != null)
                    message.location = String(object.location);
                return message;
            };
            /**
             * Creates a plain object from a RuleSummary message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.RuleSummary
             * @static
             * @param {blaze_query.RuleSummary} message RuleSummary
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RuleSummary.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.dependency = [];
                if (options.defaults) {
                    object.rule = null;
                    object.location = "";
                }
                if (message.rule != null && message.hasOwnProperty("rule"))
                    object.rule = $root.blaze_query.Rule.toObject(message.rule, options);
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (var j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = $root.blaze_query.Rule.toObject(message.dependency[j], options);
                }
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = message.location;
                return object;
            };
            /**
             * Converts this RuleSummary to JSON.
             * @function toJSON
             * @memberof blaze_query.RuleSummary
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RuleSummary.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return RuleSummary;
        })();
        blaze_query.PackageGroup = (function () {
            /**
             * Properties of a PackageGroup.
             * @memberof blaze_query
             * @interface IPackageGroup
             * @property {string} name PackageGroup name
             * @property {Array.<string>|null} [containedPackage] PackageGroup containedPackage
             * @property {Array.<string>|null} [includedPackageGroup] PackageGroup includedPackageGroup
             * @property {blaze_query.ILocation|null} [DEPRECATEDParseableLocation] PackageGroup DEPRECATEDParseableLocation
             */
            /**
             * Constructs a new PackageGroup.
             * @memberof blaze_query
             * @classdesc Represents a PackageGroup.
             * @implements IPackageGroup
             * @constructor
             * @param {blaze_query.IPackageGroup=} [properties] Properties to set
             */
            function PackageGroup(properties) {
                this.containedPackage = [];
                this.includedPackageGroup = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * PackageGroup name.
             * @member {string} name
             * @memberof blaze_query.PackageGroup
             * @instance
             */
            PackageGroup.prototype.name = "";
            /**
             * PackageGroup containedPackage.
             * @member {Array.<string>} containedPackage
             * @memberof blaze_query.PackageGroup
             * @instance
             */
            PackageGroup.prototype.containedPackage = $util.emptyArray;
            /**
             * PackageGroup includedPackageGroup.
             * @member {Array.<string>} includedPackageGroup
             * @memberof blaze_query.PackageGroup
             * @instance
             */
            PackageGroup.prototype.includedPackageGroup = $util.emptyArray;
            /**
             * PackageGroup DEPRECATEDParseableLocation.
             * @member {blaze_query.ILocation|null|undefined} DEPRECATEDParseableLocation
             * @memberof blaze_query.PackageGroup
             * @instance
             */
            PackageGroup.prototype.DEPRECATEDParseableLocation = null;
            /**
             * Creates a new PackageGroup instance using the specified properties.
             * @function create
             * @memberof blaze_query.PackageGroup
             * @static
             * @param {blaze_query.IPackageGroup=} [properties] Properties to set
             * @returns {blaze_query.PackageGroup} PackageGroup instance
             */
            PackageGroup.create = function create(properties) {
                return new PackageGroup(properties);
            };
            /**
             * Encodes the specified PackageGroup message. Does not implicitly {@link blaze_query.PackageGroup.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.PackageGroup
             * @static
             * @param {blaze_query.IPackageGroup} message PackageGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageGroup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                if (message.containedPackage != null && message.containedPackage.length)
                    for (var i = 0; i < message.containedPackage.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.containedPackage[i]);
                if (message.includedPackageGroup != null && message.includedPackageGroup.length)
                    for (var i = 0; i < message.includedPackageGroup.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.includedPackageGroup[i]);
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation"))
                    $root.blaze_query.Location.encode(message.DEPRECATEDParseableLocation, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified PackageGroup message, length delimited. Does not implicitly {@link blaze_query.PackageGroup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.PackageGroup
             * @static
             * @param {blaze_query.IPackageGroup} message PackageGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageGroup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PackageGroup message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.PackageGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.PackageGroup} PackageGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageGroup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.PackageGroup();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.containedPackage && message.containedPackage.length))
                                message.containedPackage = [];
                            message.containedPackage.push(reader.string());
                            break;
                        case 3:
                            if (!(message.includedPackageGroup && message.includedPackageGroup.length))
                                message.includedPackageGroup = [];
                            message.includedPackageGroup.push(reader.string());
                            break;
                        case 4:
                            message.DEPRECATEDParseableLocation = $root.blaze_query.Location.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };
            /**
             * Decodes a PackageGroup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.PackageGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.PackageGroup} PackageGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageGroup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PackageGroup message.
             * @function verify
             * @memberof blaze_query.PackageGroup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageGroup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.containedPackage != null && message.hasOwnProperty("containedPackage")) {
                    if (!Array.isArray(message.containedPackage))
                        return "containedPackage: array expected";
                    for (var i = 0; i < message.containedPackage.length; ++i)
                        if (!$util.isString(message.containedPackage[i]))
                            return "containedPackage: string[] expected";
                }
                if (message.includedPackageGroup != null && message.hasOwnProperty("includedPackageGroup")) {
                    if (!Array.isArray(message.includedPackageGroup))
                        return "includedPackageGroup: array expected";
                    for (var i = 0; i < message.includedPackageGroup.length; ++i)
                        if (!$util.isString(message.includedPackageGroup[i]))
                            return "includedPackageGroup: string[] expected";
                }
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation")) {
                    var error = $root.blaze_query.Location.verify(message.DEPRECATEDParseableLocation);
                    if (error)
                        return "DEPRECATEDParseableLocation." + error;
                }
                return null;
            };
            /**
             * Creates a PackageGroup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.PackageGroup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.PackageGroup} PackageGroup
             */
            PackageGroup.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.PackageGroup)
                    return object;
                var message = new $root.blaze_query.PackageGroup();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.containedPackage) {
                    if (!Array.isArray(object.containedPackage))
                        throw TypeError(".blaze_query.PackageGroup.containedPackage: array expected");
                    message.containedPackage = [];
                    for (var i = 0; i < object.containedPackage.length; ++i)
                        message.containedPackage[i] = String(object.containedPackage[i]);
                }
                if (object.includedPackageGroup) {
                    if (!Array.isArray(object.includedPackageGroup))
                        throw TypeError(".blaze_query.PackageGroup.includedPackageGroup: array expected");
                    message.includedPackageGroup = [];
                    for (var i = 0; i < object.includedPackageGroup.length; ++i)
                        message.includedPackageGroup[i] = String(object.includedPackageGroup[i]);
                }
                if (object.DEPRECATEDParseableLocation != null) {
                    if (typeof object.DEPRECATEDParseableLocation !== "object")
                        throw TypeError(".blaze_query.PackageGroup.DEPRECATEDParseableLocation: object expected");
                    message.DEPRECATEDParseableLocation = $root.blaze_query.Location.fromObject(object.DEPRECATEDParseableLocation);
                }
                return message;
            };
            /**
             * Creates a plain object from a PackageGroup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.PackageGroup
             * @static
             * @param {blaze_query.PackageGroup} message PackageGroup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageGroup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.containedPackage = [];
                    object.includedPackageGroup = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.DEPRECATEDParseableLocation = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.containedPackage && message.containedPackage.length) {
                    object.containedPackage = [];
                    for (var j = 0; j < message.containedPackage.length; ++j)
                        object.containedPackage[j] = message.containedPackage[j];
                }
                if (message.includedPackageGroup && message.includedPackageGroup.length) {
                    object.includedPackageGroup = [];
                    for (var j = 0; j < message.includedPackageGroup.length; ++j)
                        object.includedPackageGroup[j] = message.includedPackageGroup[j];
                }
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation"))
                    object.DEPRECATEDParseableLocation = $root.blaze_query.Location.toObject(message.DEPRECATEDParseableLocation, options);
                return object;
            };
            /**
             * Converts this PackageGroup to JSON.
             * @function toJSON
             * @memberof blaze_query.PackageGroup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageGroup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PackageGroup;
        })();
        blaze_query.EnvironmentGroup = (function () {
            /**
             * Properties of an EnvironmentGroup.
             * @memberof blaze_query
             * @interface IEnvironmentGroup
             * @property {string} name EnvironmentGroup name
             * @property {Array.<string>|null} [environment] EnvironmentGroup environment
             * @property {Array.<string>|null} ["default"] EnvironmentGroup default
             */
            /**
             * Constructs a new EnvironmentGroup.
             * @memberof blaze_query
             * @classdesc Represents an EnvironmentGroup.
             * @implements IEnvironmentGroup
             * @constructor
             * @param {blaze_query.IEnvironmentGroup=} [properties] Properties to set
             */
            function EnvironmentGroup(properties) {
                this.environment = [];
                this["default"] = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnvironmentGroup name.
             * @member {string} name
             * @memberof blaze_query.EnvironmentGroup
             * @instance
             */
            EnvironmentGroup.prototype.name = "";
            /**
             * EnvironmentGroup environment.
             * @member {Array.<string>} environment
             * @memberof blaze_query.EnvironmentGroup
             * @instance
             */
            EnvironmentGroup.prototype.environment = $util.emptyArray;
            /**
             * EnvironmentGroup default.
             * @member {Array.<string>} default
             * @memberof blaze_query.EnvironmentGroup
             * @instance
             */
            EnvironmentGroup.prototype["default"] = $util.emptyArray;
            /**
             * Creates a new EnvironmentGroup instance using the specified properties.
             * @function create
             * @memberof blaze_query.EnvironmentGroup
             * @static
             * @param {blaze_query.IEnvironmentGroup=} [properties] Properties to set
             * @returns {blaze_query.EnvironmentGroup} EnvironmentGroup instance
             */
            EnvironmentGroup.create = function create(properties) {
                return new EnvironmentGroup(properties);
            };
            /**
             * Encodes the specified EnvironmentGroup message. Does not implicitly {@link blaze_query.EnvironmentGroup.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.EnvironmentGroup
             * @static
             * @param {blaze_query.IEnvironmentGroup} message EnvironmentGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnvironmentGroup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                if (message.environment != null && message.environment.length)
                    for (var i = 0; i < message.environment.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.environment[i]);
                if (message["default"] != null && message["default"].length)
                    for (var i = 0; i < message["default"].length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message["default"][i]);
                return writer;
            };
            /**
             * Encodes the specified EnvironmentGroup message, length delimited. Does not implicitly {@link blaze_query.EnvironmentGroup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.EnvironmentGroup
             * @static
             * @param {blaze_query.IEnvironmentGroup} message EnvironmentGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnvironmentGroup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an EnvironmentGroup message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.EnvironmentGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.EnvironmentGroup} EnvironmentGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnvironmentGroup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.EnvironmentGroup();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.environment && message.environment.length))
                                message.environment = [];
                            message.environment.push(reader.string());
                            break;
                        case 3:
                            if (!(message["default"] && message["default"].length))
                                message["default"] = [];
                            message["default"].push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };
            /**
             * Decodes an EnvironmentGroup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.EnvironmentGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.EnvironmentGroup} EnvironmentGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnvironmentGroup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an EnvironmentGroup message.
             * @function verify
             * @memberof blaze_query.EnvironmentGroup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnvironmentGroup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.environment != null && message.hasOwnProperty("environment")) {
                    if (!Array.isArray(message.environment))
                        return "environment: array expected";
                    for (var i = 0; i < message.environment.length; ++i)
                        if (!$util.isString(message.environment[i]))
                            return "environment: string[] expected";
                }
                if (message["default"] != null && message.hasOwnProperty("default")) {
                    if (!Array.isArray(message["default"]))
                        return "default: array expected";
                    for (var i = 0; i < message["default"].length; ++i)
                        if (!$util.isString(message["default"][i]))
                            return "default: string[] expected";
                }
                return null;
            };
            /**
             * Creates an EnvironmentGroup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.EnvironmentGroup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.EnvironmentGroup} EnvironmentGroup
             */
            EnvironmentGroup.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.EnvironmentGroup)
                    return object;
                var message = new $root.blaze_query.EnvironmentGroup();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.environment) {
                    if (!Array.isArray(object.environment))
                        throw TypeError(".blaze_query.EnvironmentGroup.environment: array expected");
                    message.environment = [];
                    for (var i = 0; i < object.environment.length; ++i)
                        message.environment[i] = String(object.environment[i]);
                }
                if (object["default"]) {
                    if (!Array.isArray(object["default"]))
                        throw TypeError(".blaze_query.EnvironmentGroup.default: array expected");
                    message["default"] = [];
                    for (var i = 0; i < object["default"].length; ++i)
                        message["default"][i] = String(object["default"][i]);
                }
                return message;
            };
            /**
             * Creates a plain object from an EnvironmentGroup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.EnvironmentGroup
             * @static
             * @param {blaze_query.EnvironmentGroup} message EnvironmentGroup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnvironmentGroup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.environment = [];
                    object["default"] = [];
                }
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.environment && message.environment.length) {
                    object.environment = [];
                    for (var j = 0; j < message.environment.length; ++j)
                        object.environment[j] = message.environment[j];
                }
                if (message["default"] && message["default"].length) {
                    object["default"] = [];
                    for (var j = 0; j < message["default"].length; ++j)
                        object["default"][j] = message["default"][j];
                }
                return object;
            };
            /**
             * Converts this EnvironmentGroup to JSON.
             * @function toJSON
             * @memberof blaze_query.EnvironmentGroup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnvironmentGroup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return EnvironmentGroup;
        })();
        blaze_query.SourceFile = (function () {
            /**
             * Properties of a SourceFile.
             * @memberof blaze_query
             * @interface ISourceFile
             * @property {string} name SourceFile name
             * @property {string|null} [location] SourceFile location
             * @property {blaze_query.ILocation|null} [DEPRECATEDParseableLocation] SourceFile DEPRECATEDParseableLocation
             * @property {Array.<string>|null} [subinclude] SourceFile subinclude
             * @property {Array.<string>|null} [packageGroup] SourceFile packageGroup
             * @property {Array.<string>|null} [visibilityLabel] SourceFile visibilityLabel
             * @property {Array.<string>|null} [feature] SourceFile feature
             * @property {blaze_query.ILicense|null} [license] SourceFile license
             * @property {boolean|null} [packageContainsErrors] SourceFile packageContainsErrors
             */
            /**
             * Constructs a new SourceFile.
             * @memberof blaze_query
             * @classdesc Represents a SourceFile.
             * @implements ISourceFile
             * @constructor
             * @param {blaze_query.ISourceFile=} [properties] Properties to set
             */
            function SourceFile(properties) {
                this.subinclude = [];
                this.packageGroup = [];
                this.visibilityLabel = [];
                this.feature = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * SourceFile name.
             * @member {string} name
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.name = "";
            /**
             * SourceFile location.
             * @member {string} location
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.location = "";
            /**
             * SourceFile DEPRECATEDParseableLocation.
             * @member {blaze_query.ILocation|null|undefined} DEPRECATEDParseableLocation
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.DEPRECATEDParseableLocation = null;
            /**
             * SourceFile subinclude.
             * @member {Array.<string>} subinclude
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.subinclude = $util.emptyArray;
            /**
             * SourceFile packageGroup.
             * @member {Array.<string>} packageGroup
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.packageGroup = $util.emptyArray;
            /**
             * SourceFile visibilityLabel.
             * @member {Array.<string>} visibilityLabel
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.visibilityLabel = $util.emptyArray;
            /**
             * SourceFile feature.
             * @member {Array.<string>} feature
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.feature = $util.emptyArray;
            /**
             * SourceFile license.
             * @member {blaze_query.ILicense|null|undefined} license
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.license = null;
            /**
             * SourceFile packageContainsErrors.
             * @member {boolean} packageContainsErrors
             * @memberof blaze_query.SourceFile
             * @instance
             */
            SourceFile.prototype.packageContainsErrors = false;
            /**
             * Creates a new SourceFile instance using the specified properties.
             * @function create
             * @memberof blaze_query.SourceFile
             * @static
             * @param {blaze_query.ISourceFile=} [properties] Properties to set
             * @returns {blaze_query.SourceFile} SourceFile instance
             */
            SourceFile.create = function create(properties) {
                return new SourceFile(properties);
            };
            /**
             * Encodes the specified SourceFile message. Does not implicitly {@link blaze_query.SourceFile.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.SourceFile
             * @static
             * @param {blaze_query.ISourceFile} message SourceFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceFile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                if (message.location != null && message.hasOwnProperty("location"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.location);
                if (message.subinclude != null && message.subinclude.length)
                    for (var i = 0; i < message.subinclude.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.subinclude[i]);
                if (message.packageGroup != null && message.packageGroup.length)
                    for (var i = 0; i < message.packageGroup.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.packageGroup[i]);
                if (message.visibilityLabel != null && message.visibilityLabel.length)
                    for (var i = 0; i < message.visibilityLabel.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.visibilityLabel[i]);
                if (message.feature != null && message.feature.length)
                    for (var i = 0; i < message.feature.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.feature[i]);
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation"))
                    $root.blaze_query.Location.encode(message.DEPRECATEDParseableLocation, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
                if (message.license != null && message.hasOwnProperty("license"))
                    $root.blaze_query.License.encode(message.license, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                if (message.packageContainsErrors != null && message.hasOwnProperty("packageContainsErrors"))
                    writer.uint32(/* id 9, wireType 0 =*/ 72).bool(message.packageContainsErrors);
                return writer;
            };
            /**
             * Encodes the specified SourceFile message, length delimited. Does not implicitly {@link blaze_query.SourceFile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.SourceFile
             * @static
             * @param {blaze_query.ISourceFile} message SourceFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceFile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a SourceFile message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.SourceFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.SourceFile} SourceFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceFile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.SourceFile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.location = reader.string();
                            break;
                        case 7:
                            message.DEPRECATEDParseableLocation = $root.blaze_query.Location.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.subinclude && message.subinclude.length))
                                message.subinclude = [];
                            message.subinclude.push(reader.string());
                            break;
                        case 4:
                            if (!(message.packageGroup && message.packageGroup.length))
                                message.packageGroup = [];
                            message.packageGroup.push(reader.string());
                            break;
                        case 5:
                            if (!(message.visibilityLabel && message.visibilityLabel.length))
                                message.visibilityLabel = [];
                            message.visibilityLabel.push(reader.string());
                            break;
                        case 6:
                            if (!(message.feature && message.feature.length))
                                message.feature = [];
                            message.feature.push(reader.string());
                            break;
                        case 8:
                            message.license = $root.blaze_query.License.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.packageContainsErrors = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };
            /**
             * Decodes a SourceFile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.SourceFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.SourceFile} SourceFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceFile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a SourceFile message.
             * @function verify
             * @memberof blaze_query.SourceFile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceFile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.location != null && message.hasOwnProperty("location"))
                    if (!$util.isString(message.location))
                        return "location: string expected";
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation")) {
                    var error = $root.blaze_query.Location.verify(message.DEPRECATEDParseableLocation);
                    if (error)
                        return "DEPRECATEDParseableLocation." + error;
                }
                if (message.subinclude != null && message.hasOwnProperty("subinclude")) {
                    if (!Array.isArray(message.subinclude))
                        return "subinclude: array expected";
                    for (var i = 0; i < message.subinclude.length; ++i)
                        if (!$util.isString(message.subinclude[i]))
                            return "subinclude: string[] expected";
                }
                if (message.packageGroup != null && message.hasOwnProperty("packageGroup")) {
                    if (!Array.isArray(message.packageGroup))
                        return "packageGroup: array expected";
                    for (var i = 0; i < message.packageGroup.length; ++i)
                        if (!$util.isString(message.packageGroup[i]))
                            return "packageGroup: string[] expected";
                }
                if (message.visibilityLabel != null && message.hasOwnProperty("visibilityLabel")) {
                    if (!Array.isArray(message.visibilityLabel))
                        return "visibilityLabel: array expected";
                    for (var i = 0; i < message.visibilityLabel.length; ++i)
                        if (!$util.isString(message.visibilityLabel[i]))
                            return "visibilityLabel: string[] expected";
                }
                if (message.feature != null && message.hasOwnProperty("feature")) {
                    if (!Array.isArray(message.feature))
                        return "feature: array expected";
                    for (var i = 0; i < message.feature.length; ++i)
                        if (!$util.isString(message.feature[i]))
                            return "feature: string[] expected";
                }
                if (message.license != null && message.hasOwnProperty("license")) {
                    var error = $root.blaze_query.License.verify(message.license);
                    if (error)
                        return "license." + error;
                }
                if (message.packageContainsErrors != null && message.hasOwnProperty("packageContainsErrors"))
                    if (typeof message.packageContainsErrors !== "boolean")
                        return "packageContainsErrors: boolean expected";
                return null;
            };
            /**
             * Creates a SourceFile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.SourceFile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.SourceFile} SourceFile
             */
            SourceFile.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.SourceFile)
                    return object;
                var message = new $root.blaze_query.SourceFile();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.location != null)
                    message.location = String(object.location);
                if (object.DEPRECATEDParseableLocation != null) {
                    if (typeof object.DEPRECATEDParseableLocation !== "object")
                        throw TypeError(".blaze_query.SourceFile.DEPRECATEDParseableLocation: object expected");
                    message.DEPRECATEDParseableLocation = $root.blaze_query.Location.fromObject(object.DEPRECATEDParseableLocation);
                }
                if (object.subinclude) {
                    if (!Array.isArray(object.subinclude))
                        throw TypeError(".blaze_query.SourceFile.subinclude: array expected");
                    message.subinclude = [];
                    for (var i = 0; i < object.subinclude.length; ++i)
                        message.subinclude[i] = String(object.subinclude[i]);
                }
                if (object.packageGroup) {
                    if (!Array.isArray(object.packageGroup))
                        throw TypeError(".blaze_query.SourceFile.packageGroup: array expected");
                    message.packageGroup = [];
                    for (var i = 0; i < object.packageGroup.length; ++i)
                        message.packageGroup[i] = String(object.packageGroup[i]);
                }
                if (object.visibilityLabel) {
                    if (!Array.isArray(object.visibilityLabel))
                        throw TypeError(".blaze_query.SourceFile.visibilityLabel: array expected");
                    message.visibilityLabel = [];
                    for (var i = 0; i < object.visibilityLabel.length; ++i)
                        message.visibilityLabel[i] = String(object.visibilityLabel[i]);
                }
                if (object.feature) {
                    if (!Array.isArray(object.feature))
                        throw TypeError(".blaze_query.SourceFile.feature: array expected");
                    message.feature = [];
                    for (var i = 0; i < object.feature.length; ++i)
                        message.feature[i] = String(object.feature[i]);
                }
                if (object.license != null) {
                    if (typeof object.license !== "object")
                        throw TypeError(".blaze_query.SourceFile.license: object expected");
                    message.license = $root.blaze_query.License.fromObject(object.license);
                }
                if (object.packageContainsErrors != null)
                    message.packageContainsErrors = Boolean(object.packageContainsErrors);
                return message;
            };
            /**
             * Creates a plain object from a SourceFile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.SourceFile
             * @static
             * @param {blaze_query.SourceFile} message SourceFile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceFile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.subinclude = [];
                    object.packageGroup = [];
                    object.visibilityLabel = [];
                    object.feature = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.location = "";
                    object.DEPRECATEDParseableLocation = null;
                    object.license = null;
                    object.packageContainsErrors = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = message.location;
                if (message.subinclude && message.subinclude.length) {
                    object.subinclude = [];
                    for (var j = 0; j < message.subinclude.length; ++j)
                        object.subinclude[j] = message.subinclude[j];
                }
                if (message.packageGroup && message.packageGroup.length) {
                    object.packageGroup = [];
                    for (var j = 0; j < message.packageGroup.length; ++j)
                        object.packageGroup[j] = message.packageGroup[j];
                }
                if (message.visibilityLabel && message.visibilityLabel.length) {
                    object.visibilityLabel = [];
                    for (var j = 0; j < message.visibilityLabel.length; ++j)
                        object.visibilityLabel[j] = message.visibilityLabel[j];
                }
                if (message.feature && message.feature.length) {
                    object.feature = [];
                    for (var j = 0; j < message.feature.length; ++j)
                        object.feature[j] = message.feature[j];
                }
                if (message.DEPRECATEDParseableLocation != null && message.hasOwnProperty("DEPRECATEDParseableLocation"))
                    object.DEPRECATEDParseableLocation = $root.blaze_query.Location.toObject(message.DEPRECATEDParseableLocation, options);
                if (message.license != null && message.hasOwnProperty("license"))
                    object.license = $root.blaze_query.License.toObject(message.license, options);
                if (message.packageContainsErrors != null && message.hasOwnProperty("packageContainsErrors"))
                    object.packageContainsErrors = message.packageContainsErrors;
                return object;
            };
            /**
             * Converts this SourceFile to JSON.
             * @function toJSON
             * @memberof blaze_query.SourceFile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceFile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return SourceFile;
        })();
        blaze_query.GeneratedFile = (function () {
            /**
             * Properties of a GeneratedFile.
             * @memberof blaze_query
             * @interface IGeneratedFile
             * @property {string} name GeneratedFile name
             * @property {string} generatingRule GeneratedFile generatingRule
             * @property {string|null} [location] GeneratedFile location
             */
            /**
             * Constructs a new GeneratedFile.
             * @memberof blaze_query
             * @classdesc Represents a GeneratedFile.
             * @implements IGeneratedFile
             * @constructor
             * @param {blaze_query.IGeneratedFile=} [properties] Properties to set
             */
            function GeneratedFile(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * GeneratedFile name.
             * @member {string} name
             * @memberof blaze_query.GeneratedFile
             * @instance
             */
            GeneratedFile.prototype.name = "";
            /**
             * GeneratedFile generatingRule.
             * @member {string} generatingRule
             * @memberof blaze_query.GeneratedFile
             * @instance
             */
            GeneratedFile.prototype.generatingRule = "";
            /**
             * GeneratedFile location.
             * @member {string} location
             * @memberof blaze_query.GeneratedFile
             * @instance
             */
            GeneratedFile.prototype.location = "";
            /**
             * Creates a new GeneratedFile instance using the specified properties.
             * @function create
             * @memberof blaze_query.GeneratedFile
             * @static
             * @param {blaze_query.IGeneratedFile=} [properties] Properties to set
             * @returns {blaze_query.GeneratedFile} GeneratedFile instance
             */
            GeneratedFile.create = function create(properties) {
                return new GeneratedFile(properties);
            };
            /**
             * Encodes the specified GeneratedFile message. Does not implicitly {@link blaze_query.GeneratedFile.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.GeneratedFile
             * @static
             * @param {blaze_query.IGeneratedFile} message GeneratedFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedFile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.generatingRule);
                if (message.location != null && message.hasOwnProperty("location"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.location);
                return writer;
            };
            /**
             * Encodes the specified GeneratedFile message, length delimited. Does not implicitly {@link blaze_query.GeneratedFile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.GeneratedFile
             * @static
             * @param {blaze_query.IGeneratedFile} message GeneratedFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedFile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GeneratedFile message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.GeneratedFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.GeneratedFile} GeneratedFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedFile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.GeneratedFile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.generatingRule = reader.string();
                            break;
                        case 3:
                            message.location = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("generatingRule"))
                    throw $util.ProtocolError("missing required 'generatingRule'", { instance: message });
                return message;
            };
            /**
             * Decodes a GeneratedFile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.GeneratedFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.GeneratedFile} GeneratedFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedFile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GeneratedFile message.
             * @function verify
             * @memberof blaze_query.GeneratedFile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedFile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isString(message.generatingRule))
                    return "generatingRule: string expected";
                if (message.location != null && message.hasOwnProperty("location"))
                    if (!$util.isString(message.location))
                        return "location: string expected";
                return null;
            };
            /**
             * Creates a GeneratedFile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.GeneratedFile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.GeneratedFile} GeneratedFile
             */
            GeneratedFile.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.GeneratedFile)
                    return object;
                var message = new $root.blaze_query.GeneratedFile();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.generatingRule != null)
                    message.generatingRule = String(object.generatingRule);
                if (object.location != null)
                    message.location = String(object.location);
                return message;
            };
            /**
             * Creates a plain object from a GeneratedFile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.GeneratedFile
             * @static
             * @param {blaze_query.GeneratedFile} message GeneratedFile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedFile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.generatingRule = "";
                    object.location = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.generatingRule != null && message.hasOwnProperty("generatingRule"))
                    object.generatingRule = message.generatingRule;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = message.location;
                return object;
            };
            /**
             * Converts this GeneratedFile to JSON.
             * @function toJSON
             * @memberof blaze_query.GeneratedFile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedFile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return GeneratedFile;
        })();
        blaze_query.Target = (function () {
            /**
             * Properties of a Target.
             * @memberof blaze_query
             * @interface ITarget
             * @property {blaze_query.Target.Discriminator} type Target type
             * @property {blaze_query.IRule|null} [rule] Target rule
             * @property {blaze_query.ISourceFile|null} [sourceFile] Target sourceFile
             * @property {blaze_query.IGeneratedFile|null} [generatedFile] Target generatedFile
             * @property {blaze_query.IPackageGroup|null} [packageGroup] Target packageGroup
             * @property {blaze_query.IEnvironmentGroup|null} [environmentGroup] Target environmentGroup
             */
            /**
             * Constructs a new Target.
             * @memberof blaze_query
             * @classdesc Represents a Target.
             * @implements ITarget
             * @constructor
             * @param {blaze_query.ITarget=} [properties] Properties to set
             */
            function Target(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Target type.
             * @member {blaze_query.Target.Discriminator} type
             * @memberof blaze_query.Target
             * @instance
             */
            Target.prototype.type = 1;
            /**
             * Target rule.
             * @member {blaze_query.IRule|null|undefined} rule
             * @memberof blaze_query.Target
             * @instance
             */
            Target.prototype.rule = null;
            /**
             * Target sourceFile.
             * @member {blaze_query.ISourceFile|null|undefined} sourceFile
             * @memberof blaze_query.Target
             * @instance
             */
            Target.prototype.sourceFile = null;
            /**
             * Target generatedFile.
             * @member {blaze_query.IGeneratedFile|null|undefined} generatedFile
             * @memberof blaze_query.Target
             * @instance
             */
            Target.prototype.generatedFile = null;
            /**
             * Target packageGroup.
             * @member {blaze_query.IPackageGroup|null|undefined} packageGroup
             * @memberof blaze_query.Target
             * @instance
             */
            Target.prototype.packageGroup = null;
            /**
             * Target environmentGroup.
             * @member {blaze_query.IEnvironmentGroup|null|undefined} environmentGroup
             * @memberof blaze_query.Target
             * @instance
             */
            Target.prototype.environmentGroup = null;
            /**
             * Creates a new Target instance using the specified properties.
             * @function create
             * @memberof blaze_query.Target
             * @static
             * @param {blaze_query.ITarget=} [properties] Properties to set
             * @returns {blaze_query.Target} Target instance
             */
            Target.create = function create(properties) {
                return new Target(properties);
            };
            /**
             * Encodes the specified Target message. Does not implicitly {@link blaze_query.Target.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.Target
             * @static
             * @param {blaze_query.ITarget} message Target message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Target.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
                if (message.rule != null && message.hasOwnProperty("rule"))
                    $root.blaze_query.Rule.encode(message.rule, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                    $root.blaze_query.SourceFile.encode(message.sourceFile, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                if (message.generatedFile != null && message.hasOwnProperty("generatedFile"))
                    $root.blaze_query.GeneratedFile.encode(message.generatedFile, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.packageGroup != null && message.hasOwnProperty("packageGroup"))
                    $root.blaze_query.PackageGroup.encode(message.packageGroup, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                if (message.environmentGroup != null && message.hasOwnProperty("environmentGroup"))
                    $root.blaze_query.EnvironmentGroup.encode(message.environmentGroup, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified Target message, length delimited. Does not implicitly {@link blaze_query.Target.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.Target
             * @static
             * @param {blaze_query.ITarget} message Target message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Target.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Target message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.Target
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.Target} Target
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Target.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.Target();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.rule = $root.blaze_query.Rule.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.sourceFile = $root.blaze_query.SourceFile.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.generatedFile = $root.blaze_query.GeneratedFile.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.packageGroup = $root.blaze_query.PackageGroup.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.environmentGroup = $root.blaze_query.EnvironmentGroup.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };
            /**
             * Decodes a Target message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.Target
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.Target} Target
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Target.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Target message.
             * @function verify
             * @memberof blaze_query.Target
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Target.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                }
                if (message.rule != null && message.hasOwnProperty("rule")) {
                    var error = $root.blaze_query.Rule.verify(message.rule);
                    if (error)
                        return "rule." + error;
                }
                if (message.sourceFile != null && message.hasOwnProperty("sourceFile")) {
                    var error = $root.blaze_query.SourceFile.verify(message.sourceFile);
                    if (error)
                        return "sourceFile." + error;
                }
                if (message.generatedFile != null && message.hasOwnProperty("generatedFile")) {
                    var error = $root.blaze_query.GeneratedFile.verify(message.generatedFile);
                    if (error)
                        return "generatedFile." + error;
                }
                if (message.packageGroup != null && message.hasOwnProperty("packageGroup")) {
                    var error = $root.blaze_query.PackageGroup.verify(message.packageGroup);
                    if (error)
                        return "packageGroup." + error;
                }
                if (message.environmentGroup != null && message.hasOwnProperty("environmentGroup")) {
                    var error = $root.blaze_query.EnvironmentGroup.verify(message.environmentGroup);
                    if (error)
                        return "environmentGroup." + error;
                }
                return null;
            };
            /**
             * Creates a Target message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.Target
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.Target} Target
             */
            Target.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.Target)
                    return object;
                var message = new $root.blaze_query.Target();
                switch (object.type) {
                    case "RULE":
                    case 1:
                        message.type = 1;
                        break;
                    case "SOURCE_FILE":
                    case 2:
                        message.type = 2;
                        break;
                    case "GENERATED_FILE":
                    case 3:
                        message.type = 3;
                        break;
                    case "PACKAGE_GROUP":
                    case 4:
                        message.type = 4;
                        break;
                    case "ENVIRONMENT_GROUP":
                    case 5:
                        message.type = 5;
                        break;
                }
                if (object.rule != null) {
                    if (typeof object.rule !== "object")
                        throw TypeError(".blaze_query.Target.rule: object expected");
                    message.rule = $root.blaze_query.Rule.fromObject(object.rule);
                }
                if (object.sourceFile != null) {
                    if (typeof object.sourceFile !== "object")
                        throw TypeError(".blaze_query.Target.sourceFile: object expected");
                    message.sourceFile = $root.blaze_query.SourceFile.fromObject(object.sourceFile);
                }
                if (object.generatedFile != null) {
                    if (typeof object.generatedFile !== "object")
                        throw TypeError(".blaze_query.Target.generatedFile: object expected");
                    message.generatedFile = $root.blaze_query.GeneratedFile.fromObject(object.generatedFile);
                }
                if (object.packageGroup != null) {
                    if (typeof object.packageGroup !== "object")
                        throw TypeError(".blaze_query.Target.packageGroup: object expected");
                    message.packageGroup = $root.blaze_query.PackageGroup.fromObject(object.packageGroup);
                }
                if (object.environmentGroup != null) {
                    if (typeof object.environmentGroup !== "object")
                        throw TypeError(".blaze_query.Target.environmentGroup: object expected");
                    message.environmentGroup = $root.blaze_query.EnvironmentGroup.fromObject(object.environmentGroup);
                }
                return message;
            };
            /**
             * Creates a plain object from a Target message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.Target
             * @static
             * @param {blaze_query.Target} message Target
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Target.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "RULE" : 1;
                    object.rule = null;
                    object.sourceFile = null;
                    object.generatedFile = null;
                    object.packageGroup = null;
                    object.environmentGroup = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.blaze_query.Target.Discriminator[message.type] : message.type;
                if (message.rule != null && message.hasOwnProperty("rule"))
                    object.rule = $root.blaze_query.Rule.toObject(message.rule, options);
                if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                    object.sourceFile = $root.blaze_query.SourceFile.toObject(message.sourceFile, options);
                if (message.generatedFile != null && message.hasOwnProperty("generatedFile"))
                    object.generatedFile = $root.blaze_query.GeneratedFile.toObject(message.generatedFile, options);
                if (message.packageGroup != null && message.hasOwnProperty("packageGroup"))
                    object.packageGroup = $root.blaze_query.PackageGroup.toObject(message.packageGroup, options);
                if (message.environmentGroup != null && message.hasOwnProperty("environmentGroup"))
                    object.environmentGroup = $root.blaze_query.EnvironmentGroup.toObject(message.environmentGroup, options);
                return object;
            };
            /**
             * Converts this Target to JSON.
             * @function toJSON
             * @memberof blaze_query.Target
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Target.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Discriminator enum.
             * @name blaze_query.Target.Discriminator
             * @enum {string}
             * @property {number} RULE=1 RULE value
             * @property {number} SOURCE_FILE=2 SOURCE_FILE value
             * @property {number} GENERATED_FILE=3 GENERATED_FILE value
             * @property {number} PACKAGE_GROUP=4 PACKAGE_GROUP value
             * @property {number} ENVIRONMENT_GROUP=5 ENVIRONMENT_GROUP value
             */
            Target.Discriminator = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "RULE"] = 1;
                values[valuesById[2] = "SOURCE_FILE"] = 2;
                values[valuesById[3] = "GENERATED_FILE"] = 3;
                values[valuesById[4] = "PACKAGE_GROUP"] = 4;
                values[valuesById[5] = "ENVIRONMENT_GROUP"] = 5;
                return values;
            })();
            return Target;
        })();
        blaze_query.QueryResult = (function () {
            /**
             * Properties of a QueryResult.
             * @memberof blaze_query
             * @interface IQueryResult
             * @property {Array.<blaze_query.ITarget>|null} [target] QueryResult target
             */
            /**
             * Constructs a new QueryResult.
             * @memberof blaze_query
             * @classdesc Represents a QueryResult.
             * @implements IQueryResult
             * @constructor
             * @param {blaze_query.IQueryResult=} [properties] Properties to set
             */
            function QueryResult(properties) {
                this.target = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * QueryResult target.
             * @member {Array.<blaze_query.ITarget>} target
             * @memberof blaze_query.QueryResult
             * @instance
             */
            QueryResult.prototype.target = $util.emptyArray;
            /**
             * Creates a new QueryResult instance using the specified properties.
             * @function create
             * @memberof blaze_query.QueryResult
             * @static
             * @param {blaze_query.IQueryResult=} [properties] Properties to set
             * @returns {blaze_query.QueryResult} QueryResult instance
             */
            QueryResult.create = function create(properties) {
                return new QueryResult(properties);
            };
            /**
             * Encodes the specified QueryResult message. Does not implicitly {@link blaze_query.QueryResult.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.QueryResult
             * @static
             * @param {blaze_query.IQueryResult} message QueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && message.target.length)
                    for (var i = 0; i < message.target.length; ++i)
                        $root.blaze_query.Target.encode(message.target[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified QueryResult message, length delimited. Does not implicitly {@link blaze_query.QueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.QueryResult
             * @static
             * @param {blaze_query.IQueryResult} message QueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a QueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.QueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.QueryResult} QueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.QueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.target && message.target.length))
                                message.target = [];
                            message.target.push($root.blaze_query.Target.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a QueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.QueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.QueryResult} QueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a QueryResult message.
             * @function verify
             * @memberof blaze_query.QueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target")) {
                    if (!Array.isArray(message.target))
                        return "target: array expected";
                    for (var i = 0; i < message.target.length; ++i) {
                        var error = $root.blaze_query.Target.verify(message.target[i]);
                        if (error)
                            return "target." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a QueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.QueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.QueryResult} QueryResult
             */
            QueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.QueryResult)
                    return object;
                var message = new $root.blaze_query.QueryResult();
                if (object.target) {
                    if (!Array.isArray(object.target))
                        throw TypeError(".blaze_query.QueryResult.target: array expected");
                    message.target = [];
                    for (var i = 0; i < object.target.length; ++i) {
                        if (typeof object.target[i] !== "object")
                            throw TypeError(".blaze_query.QueryResult.target: object expected");
                        message.target[i] = $root.blaze_query.Target.fromObject(object.target[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a QueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.QueryResult
             * @static
             * @param {blaze_query.QueryResult} message QueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.target = [];
                if (message.target && message.target.length) {
                    object.target = [];
                    for (var j = 0; j < message.target.length; ++j)
                        object.target[j] = $root.blaze_query.Target.toObject(message.target[j], options);
                }
                return object;
            };
            /**
             * Converts this QueryResult to JSON.
             * @function toJSON
             * @memberof blaze_query.QueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return QueryResult;
        })();
        blaze_query.AllowedRuleClassInfo = (function () {
            /**
             * Properties of an AllowedRuleClassInfo.
             * @memberof blaze_query
             * @interface IAllowedRuleClassInfo
             * @property {blaze_query.AllowedRuleClassInfo.AllowedRuleClasses} policy AllowedRuleClassInfo policy
             * @property {Array.<string>|null} [allowedRuleClass] AllowedRuleClassInfo allowedRuleClass
             */
            /**
             * Constructs a new AllowedRuleClassInfo.
             * @memberof blaze_query
             * @classdesc Represents an AllowedRuleClassInfo.
             * @implements IAllowedRuleClassInfo
             * @constructor
             * @param {blaze_query.IAllowedRuleClassInfo=} [properties] Properties to set
             */
            function AllowedRuleClassInfo(properties) {
                this.allowedRuleClass = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * AllowedRuleClassInfo policy.
             * @member {blaze_query.AllowedRuleClassInfo.AllowedRuleClasses} policy
             * @memberof blaze_query.AllowedRuleClassInfo
             * @instance
             */
            AllowedRuleClassInfo.prototype.policy = 1;
            /**
             * AllowedRuleClassInfo allowedRuleClass.
             * @member {Array.<string>} allowedRuleClass
             * @memberof blaze_query.AllowedRuleClassInfo
             * @instance
             */
            AllowedRuleClassInfo.prototype.allowedRuleClass = $util.emptyArray;
            /**
             * Creates a new AllowedRuleClassInfo instance using the specified properties.
             * @function create
             * @memberof blaze_query.AllowedRuleClassInfo
             * @static
             * @param {blaze_query.IAllowedRuleClassInfo=} [properties] Properties to set
             * @returns {blaze_query.AllowedRuleClassInfo} AllowedRuleClassInfo instance
             */
            AllowedRuleClassInfo.create = function create(properties) {
                return new AllowedRuleClassInfo(properties);
            };
            /**
             * Encodes the specified AllowedRuleClassInfo message. Does not implicitly {@link blaze_query.AllowedRuleClassInfo.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.AllowedRuleClassInfo
             * @static
             * @param {blaze_query.IAllowedRuleClassInfo} message AllowedRuleClassInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AllowedRuleClassInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.policy);
                if (message.allowedRuleClass != null && message.allowedRuleClass.length)
                    for (var i = 0; i < message.allowedRuleClass.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.allowedRuleClass[i]);
                return writer;
            };
            /**
             * Encodes the specified AllowedRuleClassInfo message, length delimited. Does not implicitly {@link blaze_query.AllowedRuleClassInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.AllowedRuleClassInfo
             * @static
             * @param {blaze_query.IAllowedRuleClassInfo} message AllowedRuleClassInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AllowedRuleClassInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an AllowedRuleClassInfo message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.AllowedRuleClassInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.AllowedRuleClassInfo} AllowedRuleClassInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AllowedRuleClassInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.AllowedRuleClassInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.policy = reader.int32();
                            break;
                        case 2:
                            if (!(message.allowedRuleClass && message.allowedRuleClass.length))
                                message.allowedRuleClass = [];
                            message.allowedRuleClass.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("policy"))
                    throw $util.ProtocolError("missing required 'policy'", { instance: message });
                return message;
            };
            /**
             * Decodes an AllowedRuleClassInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.AllowedRuleClassInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.AllowedRuleClassInfo} AllowedRuleClassInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AllowedRuleClassInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an AllowedRuleClassInfo message.
             * @function verify
             * @memberof blaze_query.AllowedRuleClassInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AllowedRuleClassInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.policy) {
                    default:
                        return "policy: enum value expected";
                    case 1:
                    case 2:
                        break;
                }
                if (message.allowedRuleClass != null && message.hasOwnProperty("allowedRuleClass")) {
                    if (!Array.isArray(message.allowedRuleClass))
                        return "allowedRuleClass: array expected";
                    for (var i = 0; i < message.allowedRuleClass.length; ++i)
                        if (!$util.isString(message.allowedRuleClass[i]))
                            return "allowedRuleClass: string[] expected";
                }
                return null;
            };
            /**
             * Creates an AllowedRuleClassInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.AllowedRuleClassInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.AllowedRuleClassInfo} AllowedRuleClassInfo
             */
            AllowedRuleClassInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.AllowedRuleClassInfo)
                    return object;
                var message = new $root.blaze_query.AllowedRuleClassInfo();
                switch (object.policy) {
                    case "ANY":
                    case 1:
                        message.policy = 1;
                        break;
                    case "SPECIFIED":
                    case 2:
                        message.policy = 2;
                        break;
                }
                if (object.allowedRuleClass) {
                    if (!Array.isArray(object.allowedRuleClass))
                        throw TypeError(".blaze_query.AllowedRuleClassInfo.allowedRuleClass: array expected");
                    message.allowedRuleClass = [];
                    for (var i = 0; i < object.allowedRuleClass.length; ++i)
                        message.allowedRuleClass[i] = String(object.allowedRuleClass[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from an AllowedRuleClassInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.AllowedRuleClassInfo
             * @static
             * @param {blaze_query.AllowedRuleClassInfo} message AllowedRuleClassInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AllowedRuleClassInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.allowedRuleClass = [];
                if (options.defaults)
                    object.policy = options.enums === String ? "ANY" : 1;
                if (message.policy != null && message.hasOwnProperty("policy"))
                    object.policy = options.enums === String ? $root.blaze_query.AllowedRuleClassInfo.AllowedRuleClasses[message.policy] : message.policy;
                if (message.allowedRuleClass && message.allowedRuleClass.length) {
                    object.allowedRuleClass = [];
                    for (var j = 0; j < message.allowedRuleClass.length; ++j)
                        object.allowedRuleClass[j] = message.allowedRuleClass[j];
                }
                return object;
            };
            /**
             * Converts this AllowedRuleClassInfo to JSON.
             * @function toJSON
             * @memberof blaze_query.AllowedRuleClassInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AllowedRuleClassInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * AllowedRuleClasses enum.
             * @name blaze_query.AllowedRuleClassInfo.AllowedRuleClasses
             * @enum {string}
             * @property {number} ANY=1 ANY value
             * @property {number} SPECIFIED=2 SPECIFIED value
             */
            AllowedRuleClassInfo.AllowedRuleClasses = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "ANY"] = 1;
                values[valuesById[2] = "SPECIFIED"] = 2;
                return values;
            })();
            return AllowedRuleClassInfo;
        })();
        blaze_query.AttributeDefinition = (function () {
            /**
             * Properties of an AttributeDefinition.
             * @memberof blaze_query
             * @interface IAttributeDefinition
             * @property {string} name AttributeDefinition name
             * @property {blaze_query.Attribute.Discriminator} type AttributeDefinition type
             * @property {boolean} mandatory AttributeDefinition mandatory
             * @property {blaze_query.IAllowedRuleClassInfo|null} [allowedRuleClasses] AttributeDefinition allowedRuleClasses
             * @property {string|null} [documentation] AttributeDefinition documentation
             */
            /**
             * Constructs a new AttributeDefinition.
             * @memberof blaze_query
             * @classdesc Represents an AttributeDefinition.
             * @implements IAttributeDefinition
             * @constructor
             * @param {blaze_query.IAttributeDefinition=} [properties] Properties to set
             */
            function AttributeDefinition(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * AttributeDefinition name.
             * @member {string} name
             * @memberof blaze_query.AttributeDefinition
             * @instance
             */
            AttributeDefinition.prototype.name = "";
            /**
             * AttributeDefinition type.
             * @member {blaze_query.Attribute.Discriminator} type
             * @memberof blaze_query.AttributeDefinition
             * @instance
             */
            AttributeDefinition.prototype.type = 1;
            /**
             * AttributeDefinition mandatory.
             * @member {boolean} mandatory
             * @memberof blaze_query.AttributeDefinition
             * @instance
             */
            AttributeDefinition.prototype.mandatory = false;
            /**
             * AttributeDefinition allowedRuleClasses.
             * @member {blaze_query.IAllowedRuleClassInfo|null|undefined} allowedRuleClasses
             * @memberof blaze_query.AttributeDefinition
             * @instance
             */
            AttributeDefinition.prototype.allowedRuleClasses = null;
            /**
             * AttributeDefinition documentation.
             * @member {string} documentation
             * @memberof blaze_query.AttributeDefinition
             * @instance
             */
            AttributeDefinition.prototype.documentation = "";
            /**
             * Creates a new AttributeDefinition instance using the specified properties.
             * @function create
             * @memberof blaze_query.AttributeDefinition
             * @static
             * @param {blaze_query.IAttributeDefinition=} [properties] Properties to set
             * @returns {blaze_query.AttributeDefinition} AttributeDefinition instance
             */
            AttributeDefinition.create = function create(properties) {
                return new AttributeDefinition(properties);
            };
            /**
             * Encodes the specified AttributeDefinition message. Does not implicitly {@link blaze_query.AttributeDefinition.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.AttributeDefinition
             * @static
             * @param {blaze_query.IAttributeDefinition} message AttributeDefinition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttributeDefinition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.type);
                writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.mandatory);
                if (message.allowedRuleClasses != null && message.hasOwnProperty("allowedRuleClasses"))
                    $root.blaze_query.AllowedRuleClassInfo.encode(message.allowedRuleClasses, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                if (message.documentation != null && message.hasOwnProperty("documentation"))
                    writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.documentation);
                return writer;
            };
            /**
             * Encodes the specified AttributeDefinition message, length delimited. Does not implicitly {@link blaze_query.AttributeDefinition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.AttributeDefinition
             * @static
             * @param {blaze_query.IAttributeDefinition} message AttributeDefinition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttributeDefinition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an AttributeDefinition message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.AttributeDefinition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.AttributeDefinition} AttributeDefinition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttributeDefinition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.AttributeDefinition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        case 3:
                            message.mandatory = reader.bool();
                            break;
                        case 4:
                            message.allowedRuleClasses = $root.blaze_query.AllowedRuleClassInfo.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.documentation = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("mandatory"))
                    throw $util.ProtocolError("missing required 'mandatory'", { instance: message });
                return message;
            };
            /**
             * Decodes an AttributeDefinition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.AttributeDefinition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.AttributeDefinition} AttributeDefinition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttributeDefinition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an AttributeDefinition message.
             * @function verify
             * @memberof blaze_query.AttributeDefinition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AttributeDefinition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 17:
                        break;
                }
                if (typeof message.mandatory !== "boolean")
                    return "mandatory: boolean expected";
                if (message.allowedRuleClasses != null && message.hasOwnProperty("allowedRuleClasses")) {
                    var error = $root.blaze_query.AllowedRuleClassInfo.verify(message.allowedRuleClasses);
                    if (error)
                        return "allowedRuleClasses." + error;
                }
                if (message.documentation != null && message.hasOwnProperty("documentation"))
                    if (!$util.isString(message.documentation))
                        return "documentation: string expected";
                return null;
            };
            /**
             * Creates an AttributeDefinition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.AttributeDefinition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.AttributeDefinition} AttributeDefinition
             */
            AttributeDefinition.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.AttributeDefinition)
                    return object;
                var message = new $root.blaze_query.AttributeDefinition();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                    case "INTEGER":
                    case 1:
                        message.type = 1;
                        break;
                    case "STRING":
                    case 2:
                        message.type = 2;
                        break;
                    case "LABEL":
                    case 3:
                        message.type = 3;
                        break;
                    case "OUTPUT":
                    case 4:
                        message.type = 4;
                        break;
                    case "STRING_LIST":
                    case 5:
                        message.type = 5;
                        break;
                    case "LABEL_LIST":
                    case 6:
                        message.type = 6;
                        break;
                    case "OUTPUT_LIST":
                    case 7:
                        message.type = 7;
                        break;
                    case "DISTRIBUTION_SET":
                    case 8:
                        message.type = 8;
                        break;
                    case "LICENSE":
                    case 9:
                        message.type = 9;
                        break;
                    case "STRING_DICT":
                    case 10:
                        message.type = 10;
                        break;
                    case "FILESET_ENTRY_LIST":
                    case 11:
                        message.type = 11;
                        break;
                    case "LABEL_LIST_DICT":
                    case 12:
                        message.type = 12;
                        break;
                    case "STRING_LIST_DICT":
                    case 13:
                        message.type = 13;
                        break;
                    case "BOOLEAN":
                    case 14:
                        message.type = 14;
                        break;
                    case "TRISTATE":
                    case 15:
                        message.type = 15;
                        break;
                    case "INTEGER_LIST":
                    case 16:
                        message.type = 16;
                        break;
                    case "UNKNOWN":
                    case 18:
                        message.type = 18;
                        break;
                    case "LABEL_DICT_UNARY":
                    case 19:
                        message.type = 19;
                        break;
                    case "SELECTOR_LIST":
                    case 20:
                        message.type = 20;
                        break;
                    case "LABEL_KEYED_STRING_DICT":
                    case 21:
                        message.type = 21;
                        break;
                    case "DEPRECATED_STRING_DICT_UNARY":
                    case 17:
                        message.type = 17;
                        break;
                }
                if (object.mandatory != null)
                    message.mandatory = Boolean(object.mandatory);
                if (object.allowedRuleClasses != null) {
                    if (typeof object.allowedRuleClasses !== "object")
                        throw TypeError(".blaze_query.AttributeDefinition.allowedRuleClasses: object expected");
                    message.allowedRuleClasses = $root.blaze_query.AllowedRuleClassInfo.fromObject(object.allowedRuleClasses);
                }
                if (object.documentation != null)
                    message.documentation = String(object.documentation);
                return message;
            };
            /**
             * Creates a plain object from an AttributeDefinition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.AttributeDefinition
             * @static
             * @param {blaze_query.AttributeDefinition} message AttributeDefinition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AttributeDefinition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "INTEGER" : 1;
                    object.mandatory = false;
                    object.allowedRuleClasses = null;
                    object.documentation = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.blaze_query.Attribute.Discriminator[message.type] : message.type;
                if (message.mandatory != null && message.hasOwnProperty("mandatory"))
                    object.mandatory = message.mandatory;
                if (message.allowedRuleClasses != null && message.hasOwnProperty("allowedRuleClasses"))
                    object.allowedRuleClasses = $root.blaze_query.AllowedRuleClassInfo.toObject(message.allowedRuleClasses, options);
                if (message.documentation != null && message.hasOwnProperty("documentation"))
                    object.documentation = message.documentation;
                return object;
            };
            /**
             * Converts this AttributeDefinition to JSON.
             * @function toJSON
             * @memberof blaze_query.AttributeDefinition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AttributeDefinition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return AttributeDefinition;
        })();
        blaze_query.RuleDefinition = (function () {
            /**
             * Properties of a RuleDefinition.
             * @memberof blaze_query
             * @interface IRuleDefinition
             * @property {string} name RuleDefinition name
             * @property {Array.<blaze_query.IAttributeDefinition>|null} [attribute] RuleDefinition attribute
             * @property {string|null} [documentation] RuleDefinition documentation
             * @property {string|null} [label] RuleDefinition label
             */
            /**
             * Constructs a new RuleDefinition.
             * @memberof blaze_query
             * @classdesc Represents a RuleDefinition.
             * @implements IRuleDefinition
             * @constructor
             * @param {blaze_query.IRuleDefinition=} [properties] Properties to set
             */
            function RuleDefinition(properties) {
                this.attribute = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * RuleDefinition name.
             * @member {string} name
             * @memberof blaze_query.RuleDefinition
             * @instance
             */
            RuleDefinition.prototype.name = "";
            /**
             * RuleDefinition attribute.
             * @member {Array.<blaze_query.IAttributeDefinition>} attribute
             * @memberof blaze_query.RuleDefinition
             * @instance
             */
            RuleDefinition.prototype.attribute = $util.emptyArray;
            /**
             * RuleDefinition documentation.
             * @member {string} documentation
             * @memberof blaze_query.RuleDefinition
             * @instance
             */
            RuleDefinition.prototype.documentation = "";
            /**
             * RuleDefinition label.
             * @member {string} label
             * @memberof blaze_query.RuleDefinition
             * @instance
             */
            RuleDefinition.prototype.label = "";
            /**
             * Creates a new RuleDefinition instance using the specified properties.
             * @function create
             * @memberof blaze_query.RuleDefinition
             * @static
             * @param {blaze_query.IRuleDefinition=} [properties] Properties to set
             * @returns {blaze_query.RuleDefinition} RuleDefinition instance
             */
            RuleDefinition.create = function create(properties) {
                return new RuleDefinition(properties);
            };
            /**
             * Encodes the specified RuleDefinition message. Does not implicitly {@link blaze_query.RuleDefinition.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.RuleDefinition
             * @static
             * @param {blaze_query.IRuleDefinition} message RuleDefinition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RuleDefinition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                if (message.attribute != null && message.attribute.length)
                    for (var i = 0; i < message.attribute.length; ++i)
                        $root.blaze_query.AttributeDefinition.encode(message.attribute[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.documentation != null && message.hasOwnProperty("documentation"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.documentation);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.label);
                return writer;
            };
            /**
             * Encodes the specified RuleDefinition message, length delimited. Does not implicitly {@link blaze_query.RuleDefinition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.RuleDefinition
             * @static
             * @param {blaze_query.IRuleDefinition} message RuleDefinition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RuleDefinition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a RuleDefinition message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.RuleDefinition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.RuleDefinition} RuleDefinition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RuleDefinition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.RuleDefinition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.attribute && message.attribute.length))
                                message.attribute = [];
                            message.attribute.push($root.blaze_query.AttributeDefinition.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.documentation = reader.string();
                            break;
                        case 4:
                            message.label = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };
            /**
             * Decodes a RuleDefinition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.RuleDefinition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.RuleDefinition} RuleDefinition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RuleDefinition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a RuleDefinition message.
             * @function verify
             * @memberof blaze_query.RuleDefinition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RuleDefinition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.attribute != null && message.hasOwnProperty("attribute")) {
                    if (!Array.isArray(message.attribute))
                        return "attribute: array expected";
                    for (var i = 0; i < message.attribute.length; ++i) {
                        var error = $root.blaze_query.AttributeDefinition.verify(message.attribute[i]);
                        if (error)
                            return "attribute." + error;
                    }
                }
                if (message.documentation != null && message.hasOwnProperty("documentation"))
                    if (!$util.isString(message.documentation))
                        return "documentation: string expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                return null;
            };
            /**
             * Creates a RuleDefinition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.RuleDefinition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.RuleDefinition} RuleDefinition
             */
            RuleDefinition.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.RuleDefinition)
                    return object;
                var message = new $root.blaze_query.RuleDefinition();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.attribute) {
                    if (!Array.isArray(object.attribute))
                        throw TypeError(".blaze_query.RuleDefinition.attribute: array expected");
                    message.attribute = [];
                    for (var i = 0; i < object.attribute.length; ++i) {
                        if (typeof object.attribute[i] !== "object")
                            throw TypeError(".blaze_query.RuleDefinition.attribute: object expected");
                        message.attribute[i] = $root.blaze_query.AttributeDefinition.fromObject(object.attribute[i]);
                    }
                }
                if (object.documentation != null)
                    message.documentation = String(object.documentation);
                if (object.label != null)
                    message.label = String(object.label);
                return message;
            };
            /**
             * Creates a plain object from a RuleDefinition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.RuleDefinition
             * @static
             * @param {blaze_query.RuleDefinition} message RuleDefinition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RuleDefinition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.attribute = [];
                if (options.defaults) {
                    object.name = "";
                    object.documentation = "";
                    object.label = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.attribute && message.attribute.length) {
                    object.attribute = [];
                    for (var j = 0; j < message.attribute.length; ++j)
                        object.attribute[j] = $root.blaze_query.AttributeDefinition.toObject(message.attribute[j], options);
                }
                if (message.documentation != null && message.hasOwnProperty("documentation"))
                    object.documentation = message.documentation;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                return object;
            };
            /**
             * Converts this RuleDefinition to JSON.
             * @function toJSON
             * @memberof blaze_query.RuleDefinition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RuleDefinition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return RuleDefinition;
        })();
        blaze_query.BuildLanguage = (function () {
            /**
             * Properties of a BuildLanguage.
             * @memberof blaze_query
             * @interface IBuildLanguage
             * @property {Array.<blaze_query.IRuleDefinition>|null} [rule] BuildLanguage rule
             */
            /**
             * Constructs a new BuildLanguage.
             * @memberof blaze_query
             * @classdesc Represents a BuildLanguage.
             * @implements IBuildLanguage
             * @constructor
             * @param {blaze_query.IBuildLanguage=} [properties] Properties to set
             */
            function BuildLanguage(properties) {
                this.rule = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * BuildLanguage rule.
             * @member {Array.<blaze_query.IRuleDefinition>} rule
             * @memberof blaze_query.BuildLanguage
             * @instance
             */
            BuildLanguage.prototype.rule = $util.emptyArray;
            /**
             * Creates a new BuildLanguage instance using the specified properties.
             * @function create
             * @memberof blaze_query.BuildLanguage
             * @static
             * @param {blaze_query.IBuildLanguage=} [properties] Properties to set
             * @returns {blaze_query.BuildLanguage} BuildLanguage instance
             */
            BuildLanguage.create = function create(properties) {
                return new BuildLanguage(properties);
            };
            /**
             * Encodes the specified BuildLanguage message. Does not implicitly {@link blaze_query.BuildLanguage.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.BuildLanguage
             * @static
             * @param {blaze_query.IBuildLanguage} message BuildLanguage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildLanguage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rule != null && message.rule.length)
                    for (var i = 0; i < message.rule.length; ++i)
                        $root.blaze_query.RuleDefinition.encode(message.rule[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified BuildLanguage message, length delimited. Does not implicitly {@link blaze_query.BuildLanguage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.BuildLanguage
             * @static
             * @param {blaze_query.IBuildLanguage} message BuildLanguage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuildLanguage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a BuildLanguage message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.BuildLanguage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.BuildLanguage} BuildLanguage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildLanguage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.BuildLanguage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.rule && message.rule.length))
                                message.rule = [];
                            message.rule.push($root.blaze_query.RuleDefinition.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a BuildLanguage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.BuildLanguage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.BuildLanguage} BuildLanguage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuildLanguage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a BuildLanguage message.
             * @function verify
             * @memberof blaze_query.BuildLanguage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BuildLanguage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rule != null && message.hasOwnProperty("rule")) {
                    if (!Array.isArray(message.rule))
                        return "rule: array expected";
                    for (var i = 0; i < message.rule.length; ++i) {
                        var error = $root.blaze_query.RuleDefinition.verify(message.rule[i]);
                        if (error)
                            return "rule." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a BuildLanguage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.BuildLanguage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.BuildLanguage} BuildLanguage
             */
            BuildLanguage.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.BuildLanguage)
                    return object;
                var message = new $root.blaze_query.BuildLanguage();
                if (object.rule) {
                    if (!Array.isArray(object.rule))
                        throw TypeError(".blaze_query.BuildLanguage.rule: array expected");
                    message.rule = [];
                    for (var i = 0; i < object.rule.length; ++i) {
                        if (typeof object.rule[i] !== "object")
                            throw TypeError(".blaze_query.BuildLanguage.rule: object expected");
                        message.rule[i] = $root.blaze_query.RuleDefinition.fromObject(object.rule[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a BuildLanguage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.BuildLanguage
             * @static
             * @param {blaze_query.BuildLanguage} message BuildLanguage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BuildLanguage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rule = [];
                if (message.rule && message.rule.length) {
                    object.rule = [];
                    for (var j = 0; j < message.rule.length; ++j)
                        object.rule[j] = $root.blaze_query.RuleDefinition.toObject(message.rule[j], options);
                }
                return object;
            };
            /**
             * Converts this BuildLanguage to JSON.
             * @function toJSON
             * @memberof blaze_query.BuildLanguage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BuildLanguage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return BuildLanguage;
        })();
        blaze_query.Location = (function () {
            /**
             * Properties of a Location.
             * @memberof blaze_query
             * @interface ILocation
             * @property {number|null} [startOffset] Location startOffset
             * @property {number|null} [startLine] Location startLine
             * @property {number|null} [startColumn] Location startColumn
             * @property {number|null} [endOffset] Location endOffset
             * @property {number|null} [endLine] Location endLine
             * @property {number|null} [endColumn] Location endColumn
             */
            /**
             * Constructs a new Location.
             * @memberof blaze_query
             * @classdesc Represents a Location.
             * @implements ILocation
             * @constructor
             * @param {blaze_query.ILocation=} [properties] Properties to set
             */
            function Location(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Location startOffset.
             * @member {number} startOffset
             * @memberof blaze_query.Location
             * @instance
             */
            Location.prototype.startOffset = 0;
            /**
             * Location startLine.
             * @member {number} startLine
             * @memberof blaze_query.Location
             * @instance
             */
            Location.prototype.startLine = 0;
            /**
             * Location startColumn.
             * @member {number} startColumn
             * @memberof blaze_query.Location
             * @instance
             */
            Location.prototype.startColumn = 0;
            /**
             * Location endOffset.
             * @member {number} endOffset
             * @memberof blaze_query.Location
             * @instance
             */
            Location.prototype.endOffset = 0;
            /**
             * Location endLine.
             * @member {number} endLine
             * @memberof blaze_query.Location
             * @instance
             */
            Location.prototype.endLine = 0;
            /**
             * Location endColumn.
             * @member {number} endColumn
             * @memberof blaze_query.Location
             * @instance
             */
            Location.prototype.endColumn = 0;
            /**
             * Creates a new Location instance using the specified properties.
             * @function create
             * @memberof blaze_query.Location
             * @static
             * @param {blaze_query.ILocation=} [properties] Properties to set
             * @returns {blaze_query.Location} Location instance
             */
            Location.create = function create(properties) {
                return new Location(properties);
            };
            /**
             * Encodes the specified Location message. Does not implicitly {@link blaze_query.Location.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.Location
             * @static
             * @param {blaze_query.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startOffset != null && message.hasOwnProperty("startOffset"))
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.startOffset);
                if (message.startLine != null && message.hasOwnProperty("startLine"))
                    writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.startLine);
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.startColumn);
                if (message.endOffset != null && message.hasOwnProperty("endOffset"))
                    writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.endOffset);
                if (message.endLine != null && message.hasOwnProperty("endLine"))
                    writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.endLine);
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.endColumn);
                return writer;
            };
            /**
             * Encodes the specified Location message, length delimited. Does not implicitly {@link blaze_query.Location.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.Location
             * @static
             * @param {blaze_query.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Location message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.Location();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.startOffset = reader.int32();
                            break;
                        case 2:
                            message.startLine = reader.int32();
                            break;
                        case 3:
                            message.startColumn = reader.int32();
                            break;
                        case 4:
                            message.endOffset = reader.int32();
                            break;
                        case 5:
                            message.endLine = reader.int32();
                            break;
                        case 6:
                            message.endColumn = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Location message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Location message.
             * @function verify
             * @memberof blaze_query.Location
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Location.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startOffset != null && message.hasOwnProperty("startOffset"))
                    if (!$util.isInteger(message.startOffset))
                        return "startOffset: integer expected";
                if (message.startLine != null && message.hasOwnProperty("startLine"))
                    if (!$util.isInteger(message.startLine))
                        return "startLine: integer expected";
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    if (!$util.isInteger(message.startColumn))
                        return "startColumn: integer expected";
                if (message.endOffset != null && message.hasOwnProperty("endOffset"))
                    if (!$util.isInteger(message.endOffset))
                        return "endOffset: integer expected";
                if (message.endLine != null && message.hasOwnProperty("endLine"))
                    if (!$util.isInteger(message.endLine))
                        return "endLine: integer expected";
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    if (!$util.isInteger(message.endColumn))
                        return "endColumn: integer expected";
                return null;
            };
            /**
             * Creates a Location message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.Location
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.Location} Location
             */
            Location.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.Location)
                    return object;
                var message = new $root.blaze_query.Location();
                if (object.startOffset != null)
                    message.startOffset = object.startOffset | 0;
                if (object.startLine != null)
                    message.startLine = object.startLine | 0;
                if (object.startColumn != null)
                    message.startColumn = object.startColumn | 0;
                if (object.endOffset != null)
                    message.endOffset = object.endOffset | 0;
                if (object.endLine != null)
                    message.endLine = object.endLine | 0;
                if (object.endColumn != null)
                    message.endColumn = object.endColumn | 0;
                return message;
            };
            /**
             * Creates a plain object from a Location message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.Location
             * @static
             * @param {blaze_query.Location} message Location
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Location.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.startOffset = 0;
                    object.startLine = 0;
                    object.startColumn = 0;
                    object.endOffset = 0;
                    object.endLine = 0;
                    object.endColumn = 0;
                }
                if (message.startOffset != null && message.hasOwnProperty("startOffset"))
                    object.startOffset = message.startOffset;
                if (message.startLine != null && message.hasOwnProperty("startLine"))
                    object.startLine = message.startLine;
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    object.startColumn = message.startColumn;
                if (message.endOffset != null && message.hasOwnProperty("endOffset"))
                    object.endOffset = message.endOffset;
                if (message.endLine != null && message.hasOwnProperty("endLine"))
                    object.endLine = message.endLine;
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    object.endColumn = message.endColumn;
                return object;
            };
            /**
             * Converts this Location to JSON.
             * @function toJSON
             * @memberof blaze_query.Location
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Location.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Location;
        })();
        blaze_query.MakeVarBinding = (function () {
            /**
             * Properties of a MakeVarBinding.
             * @memberof blaze_query
             * @interface IMakeVarBinding
             * @property {string} value MakeVarBinding value
             * @property {string} platformSetRegexp MakeVarBinding platformSetRegexp
             */
            /**
             * Constructs a new MakeVarBinding.
             * @memberof blaze_query
             * @classdesc Represents a MakeVarBinding.
             * @implements IMakeVarBinding
             * @constructor
             * @param {blaze_query.IMakeVarBinding=} [properties] Properties to set
             */
            function MakeVarBinding(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * MakeVarBinding value.
             * @member {string} value
             * @memberof blaze_query.MakeVarBinding
             * @instance
             */
            MakeVarBinding.prototype.value = "";
            /**
             * MakeVarBinding platformSetRegexp.
             * @member {string} platformSetRegexp
             * @memberof blaze_query.MakeVarBinding
             * @instance
             */
            MakeVarBinding.prototype.platformSetRegexp = "";
            /**
             * Creates a new MakeVarBinding instance using the specified properties.
             * @function create
             * @memberof blaze_query.MakeVarBinding
             * @static
             * @param {blaze_query.IMakeVarBinding=} [properties] Properties to set
             * @returns {blaze_query.MakeVarBinding} MakeVarBinding instance
             */
            MakeVarBinding.create = function create(properties) {
                return new MakeVarBinding(properties);
            };
            /**
             * Encodes the specified MakeVarBinding message. Does not implicitly {@link blaze_query.MakeVarBinding.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.MakeVarBinding
             * @static
             * @param {blaze_query.IMakeVarBinding} message MakeVarBinding message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeVarBinding.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.value);
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.platformSetRegexp);
                return writer;
            };
            /**
             * Encodes the specified MakeVarBinding message, length delimited. Does not implicitly {@link blaze_query.MakeVarBinding.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.MakeVarBinding
             * @static
             * @param {blaze_query.IMakeVarBinding} message MakeVarBinding message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeVarBinding.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a MakeVarBinding message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.MakeVarBinding
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.MakeVarBinding} MakeVarBinding
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeVarBinding.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.MakeVarBinding();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.value = reader.string();
                            break;
                        case 2:
                            message.platformSetRegexp = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                if (!message.hasOwnProperty("platformSetRegexp"))
                    throw $util.ProtocolError("missing required 'platformSetRegexp'", { instance: message });
                return message;
            };
            /**
             * Decodes a MakeVarBinding message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.MakeVarBinding
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.MakeVarBinding} MakeVarBinding
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeVarBinding.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a MakeVarBinding message.
             * @function verify
             * @memberof blaze_query.MakeVarBinding
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MakeVarBinding.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.value))
                    return "value: string expected";
                if (!$util.isString(message.platformSetRegexp))
                    return "platformSetRegexp: string expected";
                return null;
            };
            /**
             * Creates a MakeVarBinding message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.MakeVarBinding
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.MakeVarBinding} MakeVarBinding
             */
            MakeVarBinding.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.MakeVarBinding)
                    return object;
                var message = new $root.blaze_query.MakeVarBinding();
                if (object.value != null)
                    message.value = String(object.value);
                if (object.platformSetRegexp != null)
                    message.platformSetRegexp = String(object.platformSetRegexp);
                return message;
            };
            /**
             * Creates a plain object from a MakeVarBinding message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.MakeVarBinding
             * @static
             * @param {blaze_query.MakeVarBinding} message MakeVarBinding
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MakeVarBinding.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.value = "";
                    object.platformSetRegexp = "";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.platformSetRegexp != null && message.hasOwnProperty("platformSetRegexp"))
                    object.platformSetRegexp = message.platformSetRegexp;
                return object;
            };
            /**
             * Converts this MakeVarBinding to JSON.
             * @function toJSON
             * @memberof blaze_query.MakeVarBinding
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MakeVarBinding.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return MakeVarBinding;
        })();
        blaze_query.MakeVar = (function () {
            /**
             * Properties of a MakeVar.
             * @memberof blaze_query
             * @interface IMakeVar
             * @property {string} name MakeVar name
             * @property {Array.<blaze_query.IMakeVarBinding>|null} [binding] MakeVar binding
             */
            /**
             * Constructs a new MakeVar.
             * @memberof blaze_query
             * @classdesc Represents a MakeVar.
             * @implements IMakeVar
             * @constructor
             * @param {blaze_query.IMakeVar=} [properties] Properties to set
             */
            function MakeVar(properties) {
                this.binding = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * MakeVar name.
             * @member {string} name
             * @memberof blaze_query.MakeVar
             * @instance
             */
            MakeVar.prototype.name = "";
            /**
             * MakeVar binding.
             * @member {Array.<blaze_query.IMakeVarBinding>} binding
             * @memberof blaze_query.MakeVar
             * @instance
             */
            MakeVar.prototype.binding = $util.emptyArray;
            /**
             * Creates a new MakeVar instance using the specified properties.
             * @function create
             * @memberof blaze_query.MakeVar
             * @static
             * @param {blaze_query.IMakeVar=} [properties] Properties to set
             * @returns {blaze_query.MakeVar} MakeVar instance
             */
            MakeVar.create = function create(properties) {
                return new MakeVar(properties);
            };
            /**
             * Encodes the specified MakeVar message. Does not implicitly {@link blaze_query.MakeVar.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.MakeVar
             * @static
             * @param {blaze_query.IMakeVar} message MakeVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                if (message.binding != null && message.binding.length)
                    for (var i = 0; i < message.binding.length; ++i)
                        $root.blaze_query.MakeVarBinding.encode(message.binding[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified MakeVar message, length delimited. Does not implicitly {@link blaze_query.MakeVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.MakeVar
             * @static
             * @param {blaze_query.IMakeVar} message MakeVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a MakeVar message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.MakeVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.MakeVar} MakeVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.MakeVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.binding && message.binding.length))
                                message.binding = [];
                            message.binding.push($root.blaze_query.MakeVarBinding.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };
            /**
             * Decodes a MakeVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.MakeVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.MakeVar} MakeVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a MakeVar message.
             * @function verify
             * @memberof blaze_query.MakeVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MakeVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.binding != null && message.hasOwnProperty("binding")) {
                    if (!Array.isArray(message.binding))
                        return "binding: array expected";
                    for (var i = 0; i < message.binding.length; ++i) {
                        var error = $root.blaze_query.MakeVarBinding.verify(message.binding[i]);
                        if (error)
                            return "binding." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a MakeVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.MakeVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.MakeVar} MakeVar
             */
            MakeVar.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.MakeVar)
                    return object;
                var message = new $root.blaze_query.MakeVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.binding) {
                    if (!Array.isArray(object.binding))
                        throw TypeError(".blaze_query.MakeVar.binding: array expected");
                    message.binding = [];
                    for (var i = 0; i < object.binding.length; ++i) {
                        if (typeof object.binding[i] !== "object")
                            throw TypeError(".blaze_query.MakeVar.binding: object expected");
                        message.binding[i] = $root.blaze_query.MakeVarBinding.fromObject(object.binding[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a MakeVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.MakeVar
             * @static
             * @param {blaze_query.MakeVar} message MakeVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MakeVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.binding = [];
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.binding && message.binding.length) {
                    object.binding = [];
                    for (var j = 0; j < message.binding.length; ++j)
                        object.binding[j] = $root.blaze_query.MakeVarBinding.toObject(message.binding[j], options);
                }
                return object;
            };
            /**
             * Converts this MakeVar to JSON.
             * @function toJSON
             * @memberof blaze_query.MakeVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MakeVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return MakeVar;
        })();
        blaze_query.DEPRECATED_GlobCriteria = (function () {
            /**
             * Properties of a DEPRECATED_GlobCriteria.
             * @memberof blaze_query
             * @interface IDEPRECATED_GlobCriteria
             * @property {Array.<string>|null} [include] DEPRECATED_GlobCriteria include
             * @property {Array.<string>|null} [exclude] DEPRECATED_GlobCriteria exclude
             * @property {boolean|null} [glob] DEPRECATED_GlobCriteria glob
             */
            /**
             * Constructs a new DEPRECATED_GlobCriteria.
             * @memberof blaze_query
             * @classdesc Represents a DEPRECATED_GlobCriteria.
             * @implements IDEPRECATED_GlobCriteria
             * @constructor
             * @param {blaze_query.IDEPRECATED_GlobCriteria=} [properties] Properties to set
             */
            function DEPRECATED_GlobCriteria(properties) {
                this.include = [];
                this.exclude = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * DEPRECATED_GlobCriteria include.
             * @member {Array.<string>} include
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @instance
             */
            DEPRECATED_GlobCriteria.prototype.include = $util.emptyArray;
            /**
             * DEPRECATED_GlobCriteria exclude.
             * @member {Array.<string>} exclude
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @instance
             */
            DEPRECATED_GlobCriteria.prototype.exclude = $util.emptyArray;
            /**
             * DEPRECATED_GlobCriteria glob.
             * @member {boolean} glob
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @instance
             */
            DEPRECATED_GlobCriteria.prototype.glob = false;
            /**
             * Creates a new DEPRECATED_GlobCriteria instance using the specified properties.
             * @function create
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @static
             * @param {blaze_query.IDEPRECATED_GlobCriteria=} [properties] Properties to set
             * @returns {blaze_query.DEPRECATED_GlobCriteria} DEPRECATED_GlobCriteria instance
             */
            DEPRECATED_GlobCriteria.create = function create(properties) {
                return new DEPRECATED_GlobCriteria(properties);
            };
            /**
             * Encodes the specified DEPRECATED_GlobCriteria message. Does not implicitly {@link blaze_query.DEPRECATED_GlobCriteria.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @static
             * @param {blaze_query.IDEPRECATED_GlobCriteria} message DEPRECATED_GlobCriteria message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DEPRECATED_GlobCriteria.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.include != null && message.include.length)
                    for (var i = 0; i < message.include.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.include[i]);
                if (message.exclude != null && message.exclude.length)
                    for (var i = 0; i < message.exclude.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.exclude[i]);
                if (message.glob != null && message.hasOwnProperty("glob"))
                    writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.glob);
                return writer;
            };
            /**
             * Encodes the specified DEPRECATED_GlobCriteria message, length delimited. Does not implicitly {@link blaze_query.DEPRECATED_GlobCriteria.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @static
             * @param {blaze_query.IDEPRECATED_GlobCriteria} message DEPRECATED_GlobCriteria message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DEPRECATED_GlobCriteria.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a DEPRECATED_GlobCriteria message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.DEPRECATED_GlobCriteria} DEPRECATED_GlobCriteria
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DEPRECATED_GlobCriteria.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.DEPRECATED_GlobCriteria();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.include && message.include.length))
                                message.include = [];
                            message.include.push(reader.string());
                            break;
                        case 2:
                            if (!(message.exclude && message.exclude.length))
                                message.exclude = [];
                            message.exclude.push(reader.string());
                            break;
                        case 3:
                            message.glob = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a DEPRECATED_GlobCriteria message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.DEPRECATED_GlobCriteria} DEPRECATED_GlobCriteria
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DEPRECATED_GlobCriteria.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a DEPRECATED_GlobCriteria message.
             * @function verify
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DEPRECATED_GlobCriteria.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.include != null && message.hasOwnProperty("include")) {
                    if (!Array.isArray(message.include))
                        return "include: array expected";
                    for (var i = 0; i < message.include.length; ++i)
                        if (!$util.isString(message.include[i]))
                            return "include: string[] expected";
                }
                if (message.exclude != null && message.hasOwnProperty("exclude")) {
                    if (!Array.isArray(message.exclude))
                        return "exclude: array expected";
                    for (var i = 0; i < message.exclude.length; ++i)
                        if (!$util.isString(message.exclude[i]))
                            return "exclude: string[] expected";
                }
                if (message.glob != null && message.hasOwnProperty("glob"))
                    if (typeof message.glob !== "boolean")
                        return "glob: boolean expected";
                return null;
            };
            /**
             * Creates a DEPRECATED_GlobCriteria message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.DEPRECATED_GlobCriteria} DEPRECATED_GlobCriteria
             */
            DEPRECATED_GlobCriteria.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.DEPRECATED_GlobCriteria)
                    return object;
                var message = new $root.blaze_query.DEPRECATED_GlobCriteria();
                if (object.include) {
                    if (!Array.isArray(object.include))
                        throw TypeError(".blaze_query.DEPRECATED_GlobCriteria.include: array expected");
                    message.include = [];
                    for (var i = 0; i < object.include.length; ++i)
                        message.include[i] = String(object.include[i]);
                }
                if (object.exclude) {
                    if (!Array.isArray(object.exclude))
                        throw TypeError(".blaze_query.DEPRECATED_GlobCriteria.exclude: array expected");
                    message.exclude = [];
                    for (var i = 0; i < object.exclude.length; ++i)
                        message.exclude[i] = String(object.exclude[i]);
                }
                if (object.glob != null)
                    message.glob = Boolean(object.glob);
                return message;
            };
            /**
             * Creates a plain object from a DEPRECATED_GlobCriteria message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @static
             * @param {blaze_query.DEPRECATED_GlobCriteria} message DEPRECATED_GlobCriteria
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DEPRECATED_GlobCriteria.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.include = [];
                    object.exclude = [];
                }
                if (options.defaults)
                    object.glob = false;
                if (message.include && message.include.length) {
                    object.include = [];
                    for (var j = 0; j < message.include.length; ++j)
                        object.include[j] = message.include[j];
                }
                if (message.exclude && message.exclude.length) {
                    object.exclude = [];
                    for (var j = 0; j < message.exclude.length; ++j)
                        object.exclude[j] = message.exclude[j];
                }
                if (message.glob != null && message.hasOwnProperty("glob"))
                    object.glob = message.glob;
                return object;
            };
            /**
             * Converts this DEPRECATED_GlobCriteria to JSON.
             * @function toJSON
             * @memberof blaze_query.DEPRECATED_GlobCriteria
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DEPRECATED_GlobCriteria.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return DEPRECATED_GlobCriteria;
        })();
        blaze_query.Event = (function () {
            /**
             * Properties of an Event.
             * @memberof blaze_query
             * @interface IEvent
             * @property {blaze_query.Event.EventKind} kind Event kind
             * @property {blaze_query.ILocation|null} [DEPRECATEDLocation] Event DEPRECATEDLocation
             * @property {string|null} [message] Event message
             */
            /**
             * Constructs a new Event.
             * @memberof blaze_query
             * @classdesc Represents an Event.
             * @implements IEvent
             * @constructor
             * @param {blaze_query.IEvent=} [properties] Properties to set
             */
            function Event(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Event kind.
             * @member {blaze_query.Event.EventKind} kind
             * @memberof blaze_query.Event
             * @instance
             */
            Event.prototype.kind = 1;
            /**
             * Event DEPRECATEDLocation.
             * @member {blaze_query.ILocation|null|undefined} DEPRECATEDLocation
             * @memberof blaze_query.Event
             * @instance
             */
            Event.prototype.DEPRECATEDLocation = null;
            /**
             * Event message.
             * @member {string} message
             * @memberof blaze_query.Event
             * @instance
             */
            Event.prototype.message = "";
            /**
             * Creates a new Event instance using the specified properties.
             * @function create
             * @memberof blaze_query.Event
             * @static
             * @param {blaze_query.IEvent=} [properties] Properties to set
             * @returns {blaze_query.Event} Event instance
             */
            Event.create = function create(properties) {
                return new Event(properties);
            };
            /**
             * Encodes the specified Event message. Does not implicitly {@link blaze_query.Event.verify|verify} messages.
             * @function encode
             * @memberof blaze_query.Event
             * @static
             * @param {blaze_query.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.kind);
                if (message.DEPRECATEDLocation != null && message.hasOwnProperty("DEPRECATEDLocation"))
                    $root.blaze_query.Location.encode(message.DEPRECATEDLocation, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.message);
                return writer;
            };
            /**
             * Encodes the specified Event message, length delimited. Does not implicitly {@link blaze_query.Event.verify|verify} messages.
             * @function encodeDelimited
             * @memberof blaze_query.Event
             * @static
             * @param {blaze_query.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Event message from the specified reader or buffer.
             * @function decode
             * @memberof blaze_query.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {blaze_query.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze_query.Event();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.kind = reader.int32();
                            break;
                        case 2:
                            message.DEPRECATEDLocation = $root.blaze_query.Location.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                if (!message.hasOwnProperty("kind"))
                    throw $util.ProtocolError("missing required 'kind'", { instance: message });
                return message;
            };
            /**
             * Decodes an Event message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof blaze_query.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {blaze_query.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Event message.
             * @function verify
             * @memberof blaze_query.Event
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Event.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
                if (message.DEPRECATEDLocation != null && message.hasOwnProperty("DEPRECATEDLocation")) {
                    var error = $root.blaze_query.Location.verify(message.DEPRECATEDLocation);
                    if (error)
                        return "DEPRECATEDLocation." + error;
                }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };
            /**
             * Creates an Event message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof blaze_query.Event
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {blaze_query.Event} Event
             */
            Event.fromObject = function fromObject(object) {
                if (object instanceof $root.blaze_query.Event)
                    return object;
                var message = new $root.blaze_query.Event();
                switch (object.kind) {
                    case "ERROR":
                    case 1:
                        message.kind = 1;
                        break;
                    case "WARNING":
                    case 2:
                        message.kind = 2;
                        break;
                    case "INFO":
                    case 3:
                        message.kind = 3;
                        break;
                    case "PROGRESS":
                    case 4:
                        message.kind = 4;
                        break;
                }
                if (object.DEPRECATEDLocation != null) {
                    if (typeof object.DEPRECATEDLocation !== "object")
                        throw TypeError(".blaze_query.Event.DEPRECATEDLocation: object expected");
                    message.DEPRECATEDLocation = $root.blaze_query.Location.fromObject(object.DEPRECATEDLocation);
                }
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };
            /**
             * Creates a plain object from an Event message. Also converts values to other types if specified.
             * @function toObject
             * @memberof blaze_query.Event
             * @static
             * @param {blaze_query.Event} message Event
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Event.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = options.enums === String ? "ERROR" : 1;
                    object.DEPRECATEDLocation = null;
                    object.message = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.blaze_query.Event.EventKind[message.kind] : message.kind;
                if (message.DEPRECATEDLocation != null && message.hasOwnProperty("DEPRECATEDLocation"))
                    object.DEPRECATEDLocation = $root.blaze_query.Location.toObject(message.DEPRECATEDLocation, options);
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };
            /**
             * Converts this Event to JSON.
             * @function toJSON
             * @memberof blaze_query.Event
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Event.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * EventKind enum.
             * @name blaze_query.Event.EventKind
             * @enum {string}
             * @property {number} ERROR=1 ERROR value
             * @property {number} WARNING=2 WARNING value
             * @property {number} INFO=3 INFO value
             * @property {number} PROGRESS=4 PROGRESS value
             */
            Event.EventKind = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "ERROR"] = 1;
                values[valuesById[2] = "WARNING"] = 2;
                values[valuesById[3] = "INFO"] = 3;
                values[valuesById[4] = "PROGRESS"] = 4;
                return values;
            })();
            return Event;
        })();
        return blaze_query;
    })();
    $root.command_line = (function () {
        /**
         * Namespace command_line.
         * @exports command_line
         * @namespace
         */
        var command_line = {};
        command_line.CommandLine = (function () {
            /**
             * Properties of a CommandLine.
             * @memberof command_line
             * @interface ICommandLine
             * @property {string|null} [commandLineLabel] CommandLine commandLineLabel
             * @property {Array.<command_line.ICommandLineSection>|null} [sections] CommandLine sections
             */
            /**
             * Constructs a new CommandLine.
             * @memberof command_line
             * @classdesc Represents a CommandLine.
             * @implements ICommandLine
             * @constructor
             * @param {command_line.ICommandLine=} [properties] Properties to set
             */
            function CommandLine(properties) {
                this.sections = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * CommandLine commandLineLabel.
             * @member {string} commandLineLabel
             * @memberof command_line.CommandLine
             * @instance
             */
            CommandLine.prototype.commandLineLabel = "";
            /**
             * CommandLine sections.
             * @member {Array.<command_line.ICommandLineSection>} sections
             * @memberof command_line.CommandLine
             * @instance
             */
            CommandLine.prototype.sections = $util.emptyArray;
            /**
             * Creates a new CommandLine instance using the specified properties.
             * @function create
             * @memberof command_line.CommandLine
             * @static
             * @param {command_line.ICommandLine=} [properties] Properties to set
             * @returns {command_line.CommandLine} CommandLine instance
             */
            CommandLine.create = function create(properties) {
                return new CommandLine(properties);
            };
            /**
             * Encodes the specified CommandLine message. Does not implicitly {@link command_line.CommandLine.verify|verify} messages.
             * @function encode
             * @memberof command_line.CommandLine
             * @static
             * @param {command_line.ICommandLine} message CommandLine message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommandLine.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.commandLineLabel != null && message.hasOwnProperty("commandLineLabel"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.commandLineLabel);
                if (message.sections != null && message.sections.length)
                    for (var i = 0; i < message.sections.length; ++i)
                        $root.command_line.CommandLineSection.encode(message.sections[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified CommandLine message, length delimited. Does not implicitly {@link command_line.CommandLine.verify|verify} messages.
             * @function encodeDelimited
             * @memberof command_line.CommandLine
             * @static
             * @param {command_line.ICommandLine} message CommandLine message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommandLine.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a CommandLine message from the specified reader or buffer.
             * @function decode
             * @memberof command_line.CommandLine
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {command_line.CommandLine} CommandLine
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommandLine.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_line.CommandLine();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.commandLineLabel = reader.string();
                            break;
                        case 2:
                            if (!(message.sections && message.sections.length))
                                message.sections = [];
                            message.sections.push($root.command_line.CommandLineSection.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a CommandLine message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof command_line.CommandLine
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {command_line.CommandLine} CommandLine
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommandLine.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a CommandLine message.
             * @function verify
             * @memberof command_line.CommandLine
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommandLine.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.commandLineLabel != null && message.hasOwnProperty("commandLineLabel"))
                    if (!$util.isString(message.commandLineLabel))
                        return "commandLineLabel: string expected";
                if (message.sections != null && message.hasOwnProperty("sections")) {
                    if (!Array.isArray(message.sections))
                        return "sections: array expected";
                    for (var i = 0; i < message.sections.length; ++i) {
                        var error = $root.command_line.CommandLineSection.verify(message.sections[i]);
                        if (error)
                            return "sections." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a CommandLine message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof command_line.CommandLine
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {command_line.CommandLine} CommandLine
             */
            CommandLine.fromObject = function fromObject(object) {
                if (object instanceof $root.command_line.CommandLine)
                    return object;
                var message = new $root.command_line.CommandLine();
                if (object.commandLineLabel != null)
                    message.commandLineLabel = String(object.commandLineLabel);
                if (object.sections) {
                    if (!Array.isArray(object.sections))
                        throw TypeError(".command_line.CommandLine.sections: array expected");
                    message.sections = [];
                    for (var i = 0; i < object.sections.length; ++i) {
                        if (typeof object.sections[i] !== "object")
                            throw TypeError(".command_line.CommandLine.sections: object expected");
                        message.sections[i] = $root.command_line.CommandLineSection.fromObject(object.sections[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a CommandLine message. Also converts values to other types if specified.
             * @function toObject
             * @memberof command_line.CommandLine
             * @static
             * @param {command_line.CommandLine} message CommandLine
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommandLine.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.sections = [];
                if (options.defaults)
                    object.commandLineLabel = "";
                if (message.commandLineLabel != null && message.hasOwnProperty("commandLineLabel"))
                    object.commandLineLabel = message.commandLineLabel;
                if (message.sections && message.sections.length) {
                    object.sections = [];
                    for (var j = 0; j < message.sections.length; ++j)
                        object.sections[j] = $root.command_line.CommandLineSection.toObject(message.sections[j], options);
                }
                return object;
            };
            /**
             * Converts this CommandLine to JSON.
             * @function toJSON
             * @memberof command_line.CommandLine
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommandLine.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return CommandLine;
        })();
        command_line.CommandLineSection = (function () {
            /**
             * Properties of a CommandLineSection.
             * @memberof command_line
             * @interface ICommandLineSection
             * @property {string|null} [sectionLabel] CommandLineSection sectionLabel
             * @property {command_line.IChunkList|null} [chunkList] CommandLineSection chunkList
             * @property {command_line.IOptionList|null} [optionList] CommandLineSection optionList
             */
            /**
             * Constructs a new CommandLineSection.
             * @memberof command_line
             * @classdesc Represents a CommandLineSection.
             * @implements ICommandLineSection
             * @constructor
             * @param {command_line.ICommandLineSection=} [properties] Properties to set
             */
            function CommandLineSection(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * CommandLineSection sectionLabel.
             * @member {string} sectionLabel
             * @memberof command_line.CommandLineSection
             * @instance
             */
            CommandLineSection.prototype.sectionLabel = "";
            /**
             * CommandLineSection chunkList.
             * @member {command_line.IChunkList|null|undefined} chunkList
             * @memberof command_line.CommandLineSection
             * @instance
             */
            CommandLineSection.prototype.chunkList = null;
            /**
             * CommandLineSection optionList.
             * @member {command_line.IOptionList|null|undefined} optionList
             * @memberof command_line.CommandLineSection
             * @instance
             */
            CommandLineSection.prototype.optionList = null;
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
            /**
             * CommandLineSection sectionType.
             * @member {"chunkList"|"optionList"|undefined} sectionType
             * @memberof command_line.CommandLineSection
             * @instance
             */
            Object.defineProperty(CommandLineSection.prototype, "sectionType", {
                get: $util.oneOfGetter($oneOfFields = ["chunkList", "optionList"]),
                set: $util.oneOfSetter($oneOfFields)
            });
            /**
             * Creates a new CommandLineSection instance using the specified properties.
             * @function create
             * @memberof command_line.CommandLineSection
             * @static
             * @param {command_line.ICommandLineSection=} [properties] Properties to set
             * @returns {command_line.CommandLineSection} CommandLineSection instance
             */
            CommandLineSection.create = function create(properties) {
                return new CommandLineSection(properties);
            };
            /**
             * Encodes the specified CommandLineSection message. Does not implicitly {@link command_line.CommandLineSection.verify|verify} messages.
             * @function encode
             * @memberof command_line.CommandLineSection
             * @static
             * @param {command_line.ICommandLineSection} message CommandLineSection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommandLineSection.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sectionLabel != null && message.hasOwnProperty("sectionLabel"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sectionLabel);
                if (message.chunkList != null && message.hasOwnProperty("chunkList"))
                    $root.command_line.ChunkList.encode(message.chunkList, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                if (message.optionList != null && message.hasOwnProperty("optionList"))
                    $root.command_line.OptionList.encode(message.optionList, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified CommandLineSection message, length delimited. Does not implicitly {@link command_line.CommandLineSection.verify|verify} messages.
             * @function encodeDelimited
             * @memberof command_line.CommandLineSection
             * @static
             * @param {command_line.ICommandLineSection} message CommandLineSection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommandLineSection.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a CommandLineSection message from the specified reader or buffer.
             * @function decode
             * @memberof command_line.CommandLineSection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {command_line.CommandLineSection} CommandLineSection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommandLineSection.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_line.CommandLineSection();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.sectionLabel = reader.string();
                            break;
                        case 2:
                            message.chunkList = $root.command_line.ChunkList.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.optionList = $root.command_line.OptionList.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a CommandLineSection message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof command_line.CommandLineSection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {command_line.CommandLineSection} CommandLineSection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommandLineSection.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a CommandLineSection message.
             * @function verify
             * @memberof command_line.CommandLineSection
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommandLineSection.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.sectionLabel != null && message.hasOwnProperty("sectionLabel"))
                    if (!$util.isString(message.sectionLabel))
                        return "sectionLabel: string expected";
                if (message.chunkList != null && message.hasOwnProperty("chunkList")) {
                    properties.sectionType = 1;
                    {
                        var error = $root.command_line.ChunkList.verify(message.chunkList);
                        if (error)
                            return "chunkList." + error;
                    }
                }
                if (message.optionList != null && message.hasOwnProperty("optionList")) {
                    if (properties.sectionType === 1)
                        return "sectionType: multiple values";
                    properties.sectionType = 1;
                    {
                        var error = $root.command_line.OptionList.verify(message.optionList);
                        if (error)
                            return "optionList." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a CommandLineSection message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof command_line.CommandLineSection
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {command_line.CommandLineSection} CommandLineSection
             */
            CommandLineSection.fromObject = function fromObject(object) {
                if (object instanceof $root.command_line.CommandLineSection)
                    return object;
                var message = new $root.command_line.CommandLineSection();
                if (object.sectionLabel != null)
                    message.sectionLabel = String(object.sectionLabel);
                if (object.chunkList != null) {
                    if (typeof object.chunkList !== "object")
                        throw TypeError(".command_line.CommandLineSection.chunkList: object expected");
                    message.chunkList = $root.command_line.ChunkList.fromObject(object.chunkList);
                }
                if (object.optionList != null) {
                    if (typeof object.optionList !== "object")
                        throw TypeError(".command_line.CommandLineSection.optionList: object expected");
                    message.optionList = $root.command_line.OptionList.fromObject(object.optionList);
                }
                return message;
            };
            /**
             * Creates a plain object from a CommandLineSection message. Also converts values to other types if specified.
             * @function toObject
             * @memberof command_line.CommandLineSection
             * @static
             * @param {command_line.CommandLineSection} message CommandLineSection
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommandLineSection.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.sectionLabel = "";
                if (message.sectionLabel != null && message.hasOwnProperty("sectionLabel"))
                    object.sectionLabel = message.sectionLabel;
                if (message.chunkList != null && message.hasOwnProperty("chunkList")) {
                    object.chunkList = $root.command_line.ChunkList.toObject(message.chunkList, options);
                    if (options.oneofs)
                        object.sectionType = "chunkList";
                }
                if (message.optionList != null && message.hasOwnProperty("optionList")) {
                    object.optionList = $root.command_line.OptionList.toObject(message.optionList, options);
                    if (options.oneofs)
                        object.sectionType = "optionList";
                }
                return object;
            };
            /**
             * Converts this CommandLineSection to JSON.
             * @function toJSON
             * @memberof command_line.CommandLineSection
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommandLineSection.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return CommandLineSection;
        })();
        command_line.ChunkList = (function () {
            /**
             * Properties of a ChunkList.
             * @memberof command_line
             * @interface IChunkList
             * @property {Array.<string>|null} [chunk] ChunkList chunk
             */
            /**
             * Constructs a new ChunkList.
             * @memberof command_line
             * @classdesc Represents a ChunkList.
             * @implements IChunkList
             * @constructor
             * @param {command_line.IChunkList=} [properties] Properties to set
             */
            function ChunkList(properties) {
                this.chunk = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ChunkList chunk.
             * @member {Array.<string>} chunk
             * @memberof command_line.ChunkList
             * @instance
             */
            ChunkList.prototype.chunk = $util.emptyArray;
            /**
             * Creates a new ChunkList instance using the specified properties.
             * @function create
             * @memberof command_line.ChunkList
             * @static
             * @param {command_line.IChunkList=} [properties] Properties to set
             * @returns {command_line.ChunkList} ChunkList instance
             */
            ChunkList.create = function create(properties) {
                return new ChunkList(properties);
            };
            /**
             * Encodes the specified ChunkList message. Does not implicitly {@link command_line.ChunkList.verify|verify} messages.
             * @function encode
             * @memberof command_line.ChunkList
             * @static
             * @param {command_line.IChunkList} message ChunkList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChunkList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chunk != null && message.chunk.length)
                    for (var i = 0; i < message.chunk.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.chunk[i]);
                return writer;
            };
            /**
             * Encodes the specified ChunkList message, length delimited. Does not implicitly {@link command_line.ChunkList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof command_line.ChunkList
             * @static
             * @param {command_line.IChunkList} message ChunkList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChunkList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ChunkList message from the specified reader or buffer.
             * @function decode
             * @memberof command_line.ChunkList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {command_line.ChunkList} ChunkList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChunkList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_line.ChunkList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.chunk && message.chunk.length))
                                message.chunk = [];
                            message.chunk.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a ChunkList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof command_line.ChunkList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {command_line.ChunkList} ChunkList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChunkList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ChunkList message.
             * @function verify
             * @memberof command_line.ChunkList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChunkList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chunk != null && message.hasOwnProperty("chunk")) {
                    if (!Array.isArray(message.chunk))
                        return "chunk: array expected";
                    for (var i = 0; i < message.chunk.length; ++i)
                        if (!$util.isString(message.chunk[i]))
                            return "chunk: string[] expected";
                }
                return null;
            };
            /**
             * Creates a ChunkList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof command_line.ChunkList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {command_line.ChunkList} ChunkList
             */
            ChunkList.fromObject = function fromObject(object) {
                if (object instanceof $root.command_line.ChunkList)
                    return object;
                var message = new $root.command_line.ChunkList();
                if (object.chunk) {
                    if (!Array.isArray(object.chunk))
                        throw TypeError(".command_line.ChunkList.chunk: array expected");
                    message.chunk = [];
                    for (var i = 0; i < object.chunk.length; ++i)
                        message.chunk[i] = String(object.chunk[i]);
                }
                return message;
            };
            /**
             * Creates a plain object from a ChunkList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof command_line.ChunkList
             * @static
             * @param {command_line.ChunkList} message ChunkList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChunkList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chunk = [];
                if (message.chunk && message.chunk.length) {
                    object.chunk = [];
                    for (var j = 0; j < message.chunk.length; ++j)
                        object.chunk[j] = message.chunk[j];
                }
                return object;
            };
            /**
             * Converts this ChunkList to JSON.
             * @function toJSON
             * @memberof command_line.ChunkList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChunkList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ChunkList;
        })();
        command_line.OptionList = (function () {
            /**
             * Properties of an OptionList.
             * @memberof command_line
             * @interface IOptionList
             * @property {Array.<command_line.IOption>|null} [option] OptionList option
             */
            /**
             * Constructs a new OptionList.
             * @memberof command_line
             * @classdesc Represents an OptionList.
             * @implements IOptionList
             * @constructor
             * @param {command_line.IOptionList=} [properties] Properties to set
             */
            function OptionList(properties) {
                this.option = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OptionList option.
             * @member {Array.<command_line.IOption>} option
             * @memberof command_line.OptionList
             * @instance
             */
            OptionList.prototype.option = $util.emptyArray;
            /**
             * Creates a new OptionList instance using the specified properties.
             * @function create
             * @memberof command_line.OptionList
             * @static
             * @param {command_line.IOptionList=} [properties] Properties to set
             * @returns {command_line.OptionList} OptionList instance
             */
            OptionList.create = function create(properties) {
                return new OptionList(properties);
            };
            /**
             * Encodes the specified OptionList message. Does not implicitly {@link command_line.OptionList.verify|verify} messages.
             * @function encode
             * @memberof command_line.OptionList
             * @static
             * @param {command_line.IOptionList} message OptionList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OptionList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.option != null && message.option.length)
                    for (var i = 0; i < message.option.length; ++i)
                        $root.command_line.Option.encode(message.option[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified OptionList message, length delimited. Does not implicitly {@link command_line.OptionList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof command_line.OptionList
             * @static
             * @param {command_line.IOptionList} message OptionList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OptionList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an OptionList message from the specified reader or buffer.
             * @function decode
             * @memberof command_line.OptionList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {command_line.OptionList} OptionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OptionList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_line.OptionList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.option && message.option.length))
                                message.option = [];
                            message.option.push($root.command_line.Option.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an OptionList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof command_line.OptionList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {command_line.OptionList} OptionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OptionList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an OptionList message.
             * @function verify
             * @memberof command_line.OptionList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OptionList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.option != null && message.hasOwnProperty("option")) {
                    if (!Array.isArray(message.option))
                        return "option: array expected";
                    for (var i = 0; i < message.option.length; ++i) {
                        var error = $root.command_line.Option.verify(message.option[i]);
                        if (error)
                            return "option." + error;
                    }
                }
                return null;
            };
            /**
             * Creates an OptionList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof command_line.OptionList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {command_line.OptionList} OptionList
             */
            OptionList.fromObject = function fromObject(object) {
                if (object instanceof $root.command_line.OptionList)
                    return object;
                var message = new $root.command_line.OptionList();
                if (object.option) {
                    if (!Array.isArray(object.option))
                        throw TypeError(".command_line.OptionList.option: array expected");
                    message.option = [];
                    for (var i = 0; i < object.option.length; ++i) {
                        if (typeof object.option[i] !== "object")
                            throw TypeError(".command_line.OptionList.option: object expected");
                        message.option[i] = $root.command_line.Option.fromObject(object.option[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from an OptionList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof command_line.OptionList
             * @static
             * @param {command_line.OptionList} message OptionList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OptionList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.option = [];
                if (message.option && message.option.length) {
                    object.option = [];
                    for (var j = 0; j < message.option.length; ++j)
                        object.option[j] = $root.command_line.Option.toObject(message.option[j], options);
                }
                return object;
            };
            /**
             * Converts this OptionList to JSON.
             * @function toJSON
             * @memberof command_line.OptionList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OptionList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return OptionList;
        })();
        command_line.Option = (function () {
            /**
             * Properties of an Option.
             * @memberof command_line
             * @interface IOption
             * @property {string|null} [combinedForm] Option combinedForm
             * @property {string|null} [optionName] Option optionName
             * @property {string|null} [optionValue] Option optionValue
             * @property {Array.<options.OptionEffectTag>|null} [effectTags] Option effectTags
             * @property {Array.<options.OptionMetadataTag>|null} [metadataTags] Option metadataTags
             */
            /**
             * Constructs a new Option.
             * @memberof command_line
             * @classdesc Represents an Option.
             * @implements IOption
             * @constructor
             * @param {command_line.IOption=} [properties] Properties to set
             */
            function Option(properties) {
                this.effectTags = [];
                this.metadataTags = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Option combinedForm.
             * @member {string} combinedForm
             * @memberof command_line.Option
             * @instance
             */
            Option.prototype.combinedForm = "";
            /**
             * Option optionName.
             * @member {string} optionName
             * @memberof command_line.Option
             * @instance
             */
            Option.prototype.optionName = "";
            /**
             * Option optionValue.
             * @member {string} optionValue
             * @memberof command_line.Option
             * @instance
             */
            Option.prototype.optionValue = "";
            /**
             * Option effectTags.
             * @member {Array.<options.OptionEffectTag>} effectTags
             * @memberof command_line.Option
             * @instance
             */
            Option.prototype.effectTags = $util.emptyArray;
            /**
             * Option metadataTags.
             * @member {Array.<options.OptionMetadataTag>} metadataTags
             * @memberof command_line.Option
             * @instance
             */
            Option.prototype.metadataTags = $util.emptyArray;
            /**
             * Creates a new Option instance using the specified properties.
             * @function create
             * @memberof command_line.Option
             * @static
             * @param {command_line.IOption=} [properties] Properties to set
             * @returns {command_line.Option} Option instance
             */
            Option.create = function create(properties) {
                return new Option(properties);
            };
            /**
             * Encodes the specified Option message. Does not implicitly {@link command_line.Option.verify|verify} messages.
             * @function encode
             * @memberof command_line.Option
             * @static
             * @param {command_line.IOption} message Option message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Option.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.combinedForm != null && message.hasOwnProperty("combinedForm"))
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.combinedForm);
                if (message.optionName != null && message.hasOwnProperty("optionName"))
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.optionName);
                if (message.optionValue != null && message.hasOwnProperty("optionValue"))
                    writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.optionValue);
                if (message.effectTags != null && message.effectTags.length) {
                    writer.uint32(/* id 4, wireType 2 =*/ 34).fork();
                    for (var i = 0; i < message.effectTags.length; ++i)
                        writer.int32(message.effectTags[i]);
                    writer.ldelim();
                }
                if (message.metadataTags != null && message.metadataTags.length) {
                    writer.uint32(/* id 5, wireType 2 =*/ 42).fork();
                    for (var i = 0; i < message.metadataTags.length; ++i)
                        writer.int32(message.metadataTags[i]);
                    writer.ldelim();
                }
                return writer;
            };
            /**
             * Encodes the specified Option message, length delimited. Does not implicitly {@link command_line.Option.verify|verify} messages.
             * @function encodeDelimited
             * @memberof command_line.Option
             * @static
             * @param {command_line.IOption} message Option message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Option.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Option message from the specified reader or buffer.
             * @function decode
             * @memberof command_line.Option
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {command_line.Option} Option
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Option.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_line.Option();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.combinedForm = reader.string();
                            break;
                        case 2:
                            message.optionName = reader.string();
                            break;
                        case 3:
                            message.optionValue = reader.string();
                            break;
                        case 4:
                            if (!(message.effectTags && message.effectTags.length))
                                message.effectTags = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.effectTags.push(reader.int32());
                            }
                            else
                                message.effectTags.push(reader.int32());
                            break;
                        case 5:
                            if (!(message.metadataTags && message.metadataTags.length))
                                message.metadataTags = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.metadataTags.push(reader.int32());
                            }
                            else
                                message.metadataTags.push(reader.int32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Option message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof command_line.Option
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {command_line.Option} Option
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Option.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Option message.
             * @function verify
             * @memberof command_line.Option
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Option.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.combinedForm != null && message.hasOwnProperty("combinedForm"))
                    if (!$util.isString(message.combinedForm))
                        return "combinedForm: string expected";
                if (message.optionName != null && message.hasOwnProperty("optionName"))
                    if (!$util.isString(message.optionName))
                        return "optionName: string expected";
                if (message.optionValue != null && message.hasOwnProperty("optionValue"))
                    if (!$util.isString(message.optionValue))
                        return "optionValue: string expected";
                if (message.effectTags != null && message.hasOwnProperty("effectTags")) {
                    if (!Array.isArray(message.effectTags))
                        return "effectTags: array expected";
                    for (var i = 0; i < message.effectTags.length; ++i)
                        switch (message.effectTags[i]) {
                            default:
                                return "effectTags: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                                break;
                        }
                }
                if (message.metadataTags != null && message.hasOwnProperty("metadataTags")) {
                    if (!Array.isArray(message.metadataTags))
                        return "metadataTags: array expected";
                    for (var i = 0; i < message.metadataTags.length; ++i)
                        switch (message.metadataTags[i]) {
                            default:
                                return "metadataTags: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                        }
                }
                return null;
            };
            /**
             * Creates an Option message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof command_line.Option
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {command_line.Option} Option
             */
            Option.fromObject = function fromObject(object) {
                if (object instanceof $root.command_line.Option)
                    return object;
                var message = new $root.command_line.Option();
                if (object.combinedForm != null)
                    message.combinedForm = String(object.combinedForm);
                if (object.optionName != null)
                    message.optionName = String(object.optionName);
                if (object.optionValue != null)
                    message.optionValue = String(object.optionValue);
                if (object.effectTags) {
                    if (!Array.isArray(object.effectTags))
                        throw TypeError(".command_line.Option.effectTags: array expected");
                    message.effectTags = [];
                    for (var i = 0; i < object.effectTags.length; ++i)
                        switch (object.effectTags[i]) {
                            default:
                            case "UNKNOWN":
                            case 0:
                                message.effectTags[i] = 0;
                                break;
                            case "NO_OP":
                            case 1:
                                message.effectTags[i] = 1;
                                break;
                            case "LOSES_INCREMENTAL_STATE":
                            case 2:
                                message.effectTags[i] = 2;
                                break;
                            case "CHANGES_INPUTS":
                            case 3:
                                message.effectTags[i] = 3;
                                break;
                            case "AFFECTS_OUTPUTS":
                            case 4:
                                message.effectTags[i] = 4;
                                break;
                            case "BUILD_FILE_SEMANTICS":
                            case 5:
                                message.effectTags[i] = 5;
                                break;
                            case "BAZEL_INTERNAL_CONFIGURATION":
                            case 6:
                                message.effectTags[i] = 6;
                                break;
                            case "LOADING_AND_ANALYSIS":
                            case 7:
                                message.effectTags[i] = 7;
                                break;
                            case "EXECUTION":
                            case 8:
                                message.effectTags[i] = 8;
                                break;
                            case "HOST_MACHINE_RESOURCE_OPTIMIZATIONS":
                            case 9:
                                message.effectTags[i] = 9;
                                break;
                            case "EAGERNESS_TO_EXIT":
                            case 10:
                                message.effectTags[i] = 10;
                                break;
                            case "BAZEL_MONITORING":
                            case 11:
                                message.effectTags[i] = 11;
                                break;
                            case "TERMINAL_OUTPUT":
                            case 12:
                                message.effectTags[i] = 12;
                                break;
                            case "ACTION_COMMAND_LINES":
                            case 13:
                                message.effectTags[i] = 13;
                                break;
                            case "TEST_RUNNER":
                            case 14:
                                message.effectTags[i] = 14;
                                break;
                        }
                }
                if (object.metadataTags) {
                    if (!Array.isArray(object.metadataTags))
                        throw TypeError(".command_line.Option.metadataTags: array expected");
                    message.metadataTags = [];
                    for (var i = 0; i < object.metadataTags.length; ++i)
                        switch (object.metadataTags[i]) {
                            default:
                            case "EXPERIMENTAL":
                            case 0:
                                message.metadataTags[i] = 0;
                                break;
                            case "INCOMPATIBLE_CHANGE":
                            case 1:
                                message.metadataTags[i] = 1;
                                break;
                            case "DEPRECATED":
                            case 2:
                                message.metadataTags[i] = 2;
                                break;
                            case "HIDDEN":
                            case 3:
                                message.metadataTags[i] = 3;
                                break;
                            case "INTERNAL":
                            case 4:
                                message.metadataTags[i] = 4;
                                break;
                            case "TRIGGERED_BY_ALL_INCOMPATIBLE_CHANGES":
                            case 5:
                                message.metadataTags[i] = 5;
                                break;
                        }
                }
                return message;
            };
            /**
             * Creates a plain object from an Option message. Also converts values to other types if specified.
             * @function toObject
             * @memberof command_line.Option
             * @static
             * @param {command_line.Option} message Option
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Option.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.effectTags = [];
                    object.metadataTags = [];
                }
                if (options.defaults) {
                    object.combinedForm = "";
                    object.optionName = "";
                    object.optionValue = "";
                }
                if (message.combinedForm != null && message.hasOwnProperty("combinedForm"))
                    object.combinedForm = message.combinedForm;
                if (message.optionName != null && message.hasOwnProperty("optionName"))
                    object.optionName = message.optionName;
                if (message.optionValue != null && message.hasOwnProperty("optionValue"))
                    object.optionValue = message.optionValue;
                if (message.effectTags && message.effectTags.length) {
                    object.effectTags = [];
                    for (var j = 0; j < message.effectTags.length; ++j)
                        object.effectTags[j] = options.enums === String ? $root.options.OptionEffectTag[message.effectTags[j]] : message.effectTags[j];
                }
                if (message.metadataTags && message.metadataTags.length) {
                    object.metadataTags = [];
                    for (var j = 0; j < message.metadataTags.length; ++j)
                        object.metadataTags[j] = options.enums === String ? $root.options.OptionMetadataTag[message.metadataTags[j]] : message.metadataTags[j];
                }
                return object;
            };
            /**
             * Converts this Option to JSON.
             * @function toJSON
             * @memberof command_line.Option
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Option.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Option;
        })();
        return command_line;
    })();
    $root.blaze = (function () {
        /**
         * Namespace blaze.
         * @exports blaze
         * @namespace
         */
        var blaze = {};
        blaze.invocation_policy = (function () {
            /**
             * Namespace invocation_policy.
             * @memberof blaze
             * @namespace
             */
            var invocation_policy = {};
            invocation_policy.InvocationPolicy = (function () {
                /**
                 * Properties of an InvocationPolicy.
                 * @memberof blaze.invocation_policy
                 * @interface IInvocationPolicy
                 * @property {Array.<blaze.invocation_policy.IFlagPolicy>|null} [flagPolicies] InvocationPolicy flagPolicies
                 */
                /**
                 * Constructs a new InvocationPolicy.
                 * @memberof blaze.invocation_policy
                 * @classdesc Represents an InvocationPolicy.
                 * @implements IInvocationPolicy
                 * @constructor
                 * @param {blaze.invocation_policy.IInvocationPolicy=} [properties] Properties to set
                 */
                function InvocationPolicy(properties) {
                    this.flagPolicies = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * InvocationPolicy flagPolicies.
                 * @member {Array.<blaze.invocation_policy.IFlagPolicy>} flagPolicies
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @instance
                 */
                InvocationPolicy.prototype.flagPolicies = $util.emptyArray;
                /**
                 * Creates a new InvocationPolicy instance using the specified properties.
                 * @function create
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @static
                 * @param {blaze.invocation_policy.IInvocationPolicy=} [properties] Properties to set
                 * @returns {blaze.invocation_policy.InvocationPolicy} InvocationPolicy instance
                 */
                InvocationPolicy.create = function create(properties) {
                    return new InvocationPolicy(properties);
                };
                /**
                 * Encodes the specified InvocationPolicy message. Does not implicitly {@link blaze.invocation_policy.InvocationPolicy.verify|verify} messages.
                 * @function encode
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @static
                 * @param {blaze.invocation_policy.IInvocationPolicy} message InvocationPolicy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationPolicy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.flagPolicies != null && message.flagPolicies.length)
                        for (var i = 0; i < message.flagPolicies.length; ++i)
                            $root.blaze.invocation_policy.FlagPolicy.encode(message.flagPolicies[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified InvocationPolicy message, length delimited. Does not implicitly {@link blaze.invocation_policy.InvocationPolicy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @static
                 * @param {blaze.invocation_policy.IInvocationPolicy} message InvocationPolicy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvocationPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an InvocationPolicy message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze.invocation_policy.InvocationPolicy} InvocationPolicy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationPolicy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze.invocation_policy.InvocationPolicy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.flagPolicies && message.flagPolicies.length))
                                    message.flagPolicies = [];
                                message.flagPolicies.push($root.blaze.invocation_policy.FlagPolicy.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an InvocationPolicy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze.invocation_policy.InvocationPolicy} InvocationPolicy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvocationPolicy.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an InvocationPolicy message.
                 * @function verify
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InvocationPolicy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.flagPolicies != null && message.hasOwnProperty("flagPolicies")) {
                        if (!Array.isArray(message.flagPolicies))
                            return "flagPolicies: array expected";
                        for (var i = 0; i < message.flagPolicies.length; ++i) {
                            var error = $root.blaze.invocation_policy.FlagPolicy.verify(message.flagPolicies[i]);
                            if (error)
                                return "flagPolicies." + error;
                        }
                    }
                    return null;
                };
                /**
                 * Creates an InvocationPolicy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze.invocation_policy.InvocationPolicy} InvocationPolicy
                 */
                InvocationPolicy.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze.invocation_policy.InvocationPolicy)
                        return object;
                    var message = new $root.blaze.invocation_policy.InvocationPolicy();
                    if (object.flagPolicies) {
                        if (!Array.isArray(object.flagPolicies))
                            throw TypeError(".blaze.invocation_policy.InvocationPolicy.flagPolicies: array expected");
                        message.flagPolicies = [];
                        for (var i = 0; i < object.flagPolicies.length; ++i) {
                            if (typeof object.flagPolicies[i] !== "object")
                                throw TypeError(".blaze.invocation_policy.InvocationPolicy.flagPolicies: object expected");
                            message.flagPolicies[i] = $root.blaze.invocation_policy.FlagPolicy.fromObject(object.flagPolicies[i]);
                        }
                    }
                    return message;
                };
                /**
                 * Creates a plain object from an InvocationPolicy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @static
                 * @param {blaze.invocation_policy.InvocationPolicy} message InvocationPolicy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvocationPolicy.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.flagPolicies = [];
                    if (message.flagPolicies && message.flagPolicies.length) {
                        object.flagPolicies = [];
                        for (var j = 0; j < message.flagPolicies.length; ++j)
                            object.flagPolicies[j] = $root.blaze.invocation_policy.FlagPolicy.toObject(message.flagPolicies[j], options);
                    }
                    return object;
                };
                /**
                 * Converts this InvocationPolicy to JSON.
                 * @function toJSON
                 * @memberof blaze.invocation_policy.InvocationPolicy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvocationPolicy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return InvocationPolicy;
            })();
            invocation_policy.FlagPolicy = (function () {
                /**
                 * Properties of a FlagPolicy.
                 * @memberof blaze.invocation_policy
                 * @interface IFlagPolicy
                 * @property {string|null} [flagName] FlagPolicy flagName
                 * @property {Array.<string>|null} [commands] FlagPolicy commands
                 * @property {blaze.invocation_policy.ISetValue|null} [setValue] FlagPolicy setValue
                 * @property {blaze.invocation_policy.IUseDefault|null} [useDefault] FlagPolicy useDefault
                 * @property {blaze.invocation_policy.IDisallowValues|null} [disallowValues] FlagPolicy disallowValues
                 * @property {blaze.invocation_policy.IAllowValues|null} [allowValues] FlagPolicy allowValues
                 */
                /**
                 * Constructs a new FlagPolicy.
                 * @memberof blaze.invocation_policy
                 * @classdesc Represents a FlagPolicy.
                 * @implements IFlagPolicy
                 * @constructor
                 * @param {blaze.invocation_policy.IFlagPolicy=} [properties] Properties to set
                 */
                function FlagPolicy(properties) {
                    this.commands = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * FlagPolicy flagName.
                 * @member {string} flagName
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @instance
                 */
                FlagPolicy.prototype.flagName = "";
                /**
                 * FlagPolicy commands.
                 * @member {Array.<string>} commands
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @instance
                 */
                FlagPolicy.prototype.commands = $util.emptyArray;
                /**
                 * FlagPolicy setValue.
                 * @member {blaze.invocation_policy.ISetValue|null|undefined} setValue
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @instance
                 */
                FlagPolicy.prototype.setValue = null;
                /**
                 * FlagPolicy useDefault.
                 * @member {blaze.invocation_policy.IUseDefault|null|undefined} useDefault
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @instance
                 */
                FlagPolicy.prototype.useDefault = null;
                /**
                 * FlagPolicy disallowValues.
                 * @member {blaze.invocation_policy.IDisallowValues|null|undefined} disallowValues
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @instance
                 */
                FlagPolicy.prototype.disallowValues = null;
                /**
                 * FlagPolicy allowValues.
                 * @member {blaze.invocation_policy.IAllowValues|null|undefined} allowValues
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @instance
                 */
                FlagPolicy.prototype.allowValues = null;
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
                /**
                 * FlagPolicy operation.
                 * @member {"setValue"|"useDefault"|"disallowValues"|"allowValues"|undefined} operation
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @instance
                 */
                Object.defineProperty(FlagPolicy.prototype, "operation", {
                    get: $util.oneOfGetter($oneOfFields = ["setValue", "useDefault", "disallowValues", "allowValues"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
                /**
                 * Creates a new FlagPolicy instance using the specified properties.
                 * @function create
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @static
                 * @param {blaze.invocation_policy.IFlagPolicy=} [properties] Properties to set
                 * @returns {blaze.invocation_policy.FlagPolicy} FlagPolicy instance
                 */
                FlagPolicy.create = function create(properties) {
                    return new FlagPolicy(properties);
                };
                /**
                 * Encodes the specified FlagPolicy message. Does not implicitly {@link blaze.invocation_policy.FlagPolicy.verify|verify} messages.
                 * @function encode
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @static
                 * @param {blaze.invocation_policy.IFlagPolicy} message FlagPolicy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FlagPolicy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.flagName != null && message.hasOwnProperty("flagName"))
                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.flagName);
                    if (message.commands != null && message.commands.length)
                        for (var i = 0; i < message.commands.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.commands[i]);
                    if (message.setValue != null && message.hasOwnProperty("setValue"))
                        $root.blaze.invocation_policy.SetValue.encode(message.setValue, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                    if (message.useDefault != null && message.hasOwnProperty("useDefault"))
                        $root.blaze.invocation_policy.UseDefault.encode(message.useDefault, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                    if (message.disallowValues != null && message.hasOwnProperty("disallowValues"))
                        $root.blaze.invocation_policy.DisallowValues.encode(message.disallowValues, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                    if (message.allowValues != null && message.hasOwnProperty("allowValues"))
                        $root.blaze.invocation_policy.AllowValues.encode(message.allowValues, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified FlagPolicy message, length delimited. Does not implicitly {@link blaze.invocation_policy.FlagPolicy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @static
                 * @param {blaze.invocation_policy.IFlagPolicy} message FlagPolicy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FlagPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a FlagPolicy message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze.invocation_policy.FlagPolicy} FlagPolicy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FlagPolicy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze.invocation_policy.FlagPolicy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.flagName = reader.string();
                                break;
                            case 2:
                                if (!(message.commands && message.commands.length))
                                    message.commands = [];
                                message.commands.push(reader.string());
                                break;
                            case 3:
                                message.setValue = $root.blaze.invocation_policy.SetValue.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.useDefault = $root.blaze.invocation_policy.UseDefault.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.disallowValues = $root.blaze.invocation_policy.DisallowValues.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.allowValues = $root.blaze.invocation_policy.AllowValues.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a FlagPolicy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze.invocation_policy.FlagPolicy} FlagPolicy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FlagPolicy.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a FlagPolicy message.
                 * @function verify
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FlagPolicy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.flagName != null && message.hasOwnProperty("flagName"))
                        if (!$util.isString(message.flagName))
                            return "flagName: string expected";
                    if (message.commands != null && message.hasOwnProperty("commands")) {
                        if (!Array.isArray(message.commands))
                            return "commands: array expected";
                        for (var i = 0; i < message.commands.length; ++i)
                            if (!$util.isString(message.commands[i]))
                                return "commands: string[] expected";
                    }
                    if (message.setValue != null && message.hasOwnProperty("setValue")) {
                        properties.operation = 1;
                        {
                            var error = $root.blaze.invocation_policy.SetValue.verify(message.setValue);
                            if (error)
                                return "setValue." + error;
                        }
                    }
                    if (message.useDefault != null && message.hasOwnProperty("useDefault")) {
                        if (properties.operation === 1)
                            return "operation: multiple values";
                        properties.operation = 1;
                        {
                            var error = $root.blaze.invocation_policy.UseDefault.verify(message.useDefault);
                            if (error)
                                return "useDefault." + error;
                        }
                    }
                    if (message.disallowValues != null && message.hasOwnProperty("disallowValues")) {
                        if (properties.operation === 1)
                            return "operation: multiple values";
                        properties.operation = 1;
                        {
                            var error = $root.blaze.invocation_policy.DisallowValues.verify(message.disallowValues);
                            if (error)
                                return "disallowValues." + error;
                        }
                    }
                    if (message.allowValues != null && message.hasOwnProperty("allowValues")) {
                        if (properties.operation === 1)
                            return "operation: multiple values";
                        properties.operation = 1;
                        {
                            var error = $root.blaze.invocation_policy.AllowValues.verify(message.allowValues);
                            if (error)
                                return "allowValues." + error;
                        }
                    }
                    return null;
                };
                /**
                 * Creates a FlagPolicy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze.invocation_policy.FlagPolicy} FlagPolicy
                 */
                FlagPolicy.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze.invocation_policy.FlagPolicy)
                        return object;
                    var message = new $root.blaze.invocation_policy.FlagPolicy();
                    if (object.flagName != null)
                        message.flagName = String(object.flagName);
                    if (object.commands) {
                        if (!Array.isArray(object.commands))
                            throw TypeError(".blaze.invocation_policy.FlagPolicy.commands: array expected");
                        message.commands = [];
                        for (var i = 0; i < object.commands.length; ++i)
                            message.commands[i] = String(object.commands[i]);
                    }
                    if (object.setValue != null) {
                        if (typeof object.setValue !== "object")
                            throw TypeError(".blaze.invocation_policy.FlagPolicy.setValue: object expected");
                        message.setValue = $root.blaze.invocation_policy.SetValue.fromObject(object.setValue);
                    }
                    if (object.useDefault != null) {
                        if (typeof object.useDefault !== "object")
                            throw TypeError(".blaze.invocation_policy.FlagPolicy.useDefault: object expected");
                        message.useDefault = $root.blaze.invocation_policy.UseDefault.fromObject(object.useDefault);
                    }
                    if (object.disallowValues != null) {
                        if (typeof object.disallowValues !== "object")
                            throw TypeError(".blaze.invocation_policy.FlagPolicy.disallowValues: object expected");
                        message.disallowValues = $root.blaze.invocation_policy.DisallowValues.fromObject(object.disallowValues);
                    }
                    if (object.allowValues != null) {
                        if (typeof object.allowValues !== "object")
                            throw TypeError(".blaze.invocation_policy.FlagPolicy.allowValues: object expected");
                        message.allowValues = $root.blaze.invocation_policy.AllowValues.fromObject(object.allowValues);
                    }
                    return message;
                };
                /**
                 * Creates a plain object from a FlagPolicy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @static
                 * @param {blaze.invocation_policy.FlagPolicy} message FlagPolicy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FlagPolicy.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.commands = [];
                    if (options.defaults)
                        object.flagName = "";
                    if (message.flagName != null && message.hasOwnProperty("flagName"))
                        object.flagName = message.flagName;
                    if (message.commands && message.commands.length) {
                        object.commands = [];
                        for (var j = 0; j < message.commands.length; ++j)
                            object.commands[j] = message.commands[j];
                    }
                    if (message.setValue != null && message.hasOwnProperty("setValue")) {
                        object.setValue = $root.blaze.invocation_policy.SetValue.toObject(message.setValue, options);
                        if (options.oneofs)
                            object.operation = "setValue";
                    }
                    if (message.useDefault != null && message.hasOwnProperty("useDefault")) {
                        object.useDefault = $root.blaze.invocation_policy.UseDefault.toObject(message.useDefault, options);
                        if (options.oneofs)
                            object.operation = "useDefault";
                    }
                    if (message.disallowValues != null && message.hasOwnProperty("disallowValues")) {
                        object.disallowValues = $root.blaze.invocation_policy.DisallowValues.toObject(message.disallowValues, options);
                        if (options.oneofs)
                            object.operation = "disallowValues";
                    }
                    if (message.allowValues != null && message.hasOwnProperty("allowValues")) {
                        object.allowValues = $root.blaze.invocation_policy.AllowValues.toObject(message.allowValues, options);
                        if (options.oneofs)
                            object.operation = "allowValues";
                    }
                    return object;
                };
                /**
                 * Converts this FlagPolicy to JSON.
                 * @function toJSON
                 * @memberof blaze.invocation_policy.FlagPolicy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FlagPolicy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return FlagPolicy;
            })();
            invocation_policy.SetValue = (function () {
                /**
                 * Properties of a SetValue.
                 * @memberof blaze.invocation_policy
                 * @interface ISetValue
                 * @property {Array.<string>|null} [flagValue] SetValue flagValue
                 * @property {boolean|null} [overridable] SetValue overridable
                 * @property {boolean|null} [append] SetValue append
                 */
                /**
                 * Constructs a new SetValue.
                 * @memberof blaze.invocation_policy
                 * @classdesc Represents a SetValue.
                 * @implements ISetValue
                 * @constructor
                 * @param {blaze.invocation_policy.ISetValue=} [properties] Properties to set
                 */
                function SetValue(properties) {
                    this.flagValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * SetValue flagValue.
                 * @member {Array.<string>} flagValue
                 * @memberof blaze.invocation_policy.SetValue
                 * @instance
                 */
                SetValue.prototype.flagValue = $util.emptyArray;
                /**
                 * SetValue overridable.
                 * @member {boolean} overridable
                 * @memberof blaze.invocation_policy.SetValue
                 * @instance
                 */
                SetValue.prototype.overridable = false;
                /**
                 * SetValue append.
                 * @member {boolean} append
                 * @memberof blaze.invocation_policy.SetValue
                 * @instance
                 */
                SetValue.prototype.append = false;
                /**
                 * Creates a new SetValue instance using the specified properties.
                 * @function create
                 * @memberof blaze.invocation_policy.SetValue
                 * @static
                 * @param {blaze.invocation_policy.ISetValue=} [properties] Properties to set
                 * @returns {blaze.invocation_policy.SetValue} SetValue instance
                 */
                SetValue.create = function create(properties) {
                    return new SetValue(properties);
                };
                /**
                 * Encodes the specified SetValue message. Does not implicitly {@link blaze.invocation_policy.SetValue.verify|verify} messages.
                 * @function encode
                 * @memberof blaze.invocation_policy.SetValue
                 * @static
                 * @param {blaze.invocation_policy.ISetValue} message SetValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.flagValue != null && message.flagValue.length)
                        for (var i = 0; i < message.flagValue.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.flagValue[i]);
                    if (message.overridable != null && message.hasOwnProperty("overridable"))
                        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.overridable);
                    if (message.append != null && message.hasOwnProperty("append"))
                        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.append);
                    return writer;
                };
                /**
                 * Encodes the specified SetValue message, length delimited. Does not implicitly {@link blaze.invocation_policy.SetValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze.invocation_policy.SetValue
                 * @static
                 * @param {blaze.invocation_policy.ISetValue} message SetValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a SetValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze.invocation_policy.SetValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze.invocation_policy.SetValue} SetValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze.invocation_policy.SetValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.flagValue && message.flagValue.length))
                                    message.flagValue = [];
                                message.flagValue.push(reader.string());
                                break;
                            case 2:
                                message.overridable = reader.bool();
                                break;
                            case 3:
                                message.append = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a SetValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze.invocation_policy.SetValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze.invocation_policy.SetValue} SetValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a SetValue message.
                 * @function verify
                 * @memberof blaze.invocation_policy.SetValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SetValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.flagValue != null && message.hasOwnProperty("flagValue")) {
                        if (!Array.isArray(message.flagValue))
                            return "flagValue: array expected";
                        for (var i = 0; i < message.flagValue.length; ++i)
                            if (!$util.isString(message.flagValue[i]))
                                return "flagValue: string[] expected";
                    }
                    if (message.overridable != null && message.hasOwnProperty("overridable"))
                        if (typeof message.overridable !== "boolean")
                            return "overridable: boolean expected";
                    if (message.append != null && message.hasOwnProperty("append"))
                        if (typeof message.append !== "boolean")
                            return "append: boolean expected";
                    return null;
                };
                /**
                 * Creates a SetValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze.invocation_policy.SetValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze.invocation_policy.SetValue} SetValue
                 */
                SetValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze.invocation_policy.SetValue)
                        return object;
                    var message = new $root.blaze.invocation_policy.SetValue();
                    if (object.flagValue) {
                        if (!Array.isArray(object.flagValue))
                            throw TypeError(".blaze.invocation_policy.SetValue.flagValue: array expected");
                        message.flagValue = [];
                        for (var i = 0; i < object.flagValue.length; ++i)
                            message.flagValue[i] = String(object.flagValue[i]);
                    }
                    if (object.overridable != null)
                        message.overridable = Boolean(object.overridable);
                    if (object.append != null)
                        message.append = Boolean(object.append);
                    return message;
                };
                /**
                 * Creates a plain object from a SetValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze.invocation_policy.SetValue
                 * @static
                 * @param {blaze.invocation_policy.SetValue} message SetValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.flagValue = [];
                    if (options.defaults) {
                        object.overridable = false;
                        object.append = false;
                    }
                    if (message.flagValue && message.flagValue.length) {
                        object.flagValue = [];
                        for (var j = 0; j < message.flagValue.length; ++j)
                            object.flagValue[j] = message.flagValue[j];
                    }
                    if (message.overridable != null && message.hasOwnProperty("overridable"))
                        object.overridable = message.overridable;
                    if (message.append != null && message.hasOwnProperty("append"))
                        object.append = message.append;
                    return object;
                };
                /**
                 * Converts this SetValue to JSON.
                 * @function toJSON
                 * @memberof blaze.invocation_policy.SetValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SetValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return SetValue;
            })();
            invocation_policy.UseDefault = (function () {
                /**
                 * Properties of a UseDefault.
                 * @memberof blaze.invocation_policy
                 * @interface IUseDefault
                 */
                /**
                 * Constructs a new UseDefault.
                 * @memberof blaze.invocation_policy
                 * @classdesc Represents a UseDefault.
                 * @implements IUseDefault
                 * @constructor
                 * @param {blaze.invocation_policy.IUseDefault=} [properties] Properties to set
                 */
                function UseDefault(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Creates a new UseDefault instance using the specified properties.
                 * @function create
                 * @memberof blaze.invocation_policy.UseDefault
                 * @static
                 * @param {blaze.invocation_policy.IUseDefault=} [properties] Properties to set
                 * @returns {blaze.invocation_policy.UseDefault} UseDefault instance
                 */
                UseDefault.create = function create(properties) {
                    return new UseDefault(properties);
                };
                /**
                 * Encodes the specified UseDefault message. Does not implicitly {@link blaze.invocation_policy.UseDefault.verify|verify} messages.
                 * @function encode
                 * @memberof blaze.invocation_policy.UseDefault
                 * @static
                 * @param {blaze.invocation_policy.IUseDefault} message UseDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UseDefault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
                /**
                 * Encodes the specified UseDefault message, length delimited. Does not implicitly {@link blaze.invocation_policy.UseDefault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze.invocation_policy.UseDefault
                 * @static
                 * @param {blaze.invocation_policy.IUseDefault} message UseDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UseDefault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a UseDefault message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze.invocation_policy.UseDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze.invocation_policy.UseDefault} UseDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UseDefault.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze.invocation_policy.UseDefault();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a UseDefault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze.invocation_policy.UseDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze.invocation_policy.UseDefault} UseDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UseDefault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a UseDefault message.
                 * @function verify
                 * @memberof blaze.invocation_policy.UseDefault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UseDefault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
                /**
                 * Creates a UseDefault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze.invocation_policy.UseDefault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze.invocation_policy.UseDefault} UseDefault
                 */
                UseDefault.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze.invocation_policy.UseDefault)
                        return object;
                    return new $root.blaze.invocation_policy.UseDefault();
                };
                /**
                 * Creates a plain object from a UseDefault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze.invocation_policy.UseDefault
                 * @static
                 * @param {blaze.invocation_policy.UseDefault} message UseDefault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UseDefault.toObject = function toObject() {
                    return {};
                };
                /**
                 * Converts this UseDefault to JSON.
                 * @function toJSON
                 * @memberof blaze.invocation_policy.UseDefault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UseDefault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return UseDefault;
            })();
            invocation_policy.DisallowValues = (function () {
                /**
                 * Properties of a DisallowValues.
                 * @memberof blaze.invocation_policy
                 * @interface IDisallowValues
                 * @property {Array.<string>|null} [disallowedValues] DisallowValues disallowedValues
                 * @property {string|null} [newValue] DisallowValues newValue
                 * @property {blaze.invocation_policy.IUseDefault|null} [useDefault] DisallowValues useDefault
                 */
                /**
                 * Constructs a new DisallowValues.
                 * @memberof blaze.invocation_policy
                 * @classdesc Represents a DisallowValues.
                 * @implements IDisallowValues
                 * @constructor
                 * @param {blaze.invocation_policy.IDisallowValues=} [properties] Properties to set
                 */
                function DisallowValues(properties) {
                    this.disallowedValues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * DisallowValues disallowedValues.
                 * @member {Array.<string>} disallowedValues
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @instance
                 */
                DisallowValues.prototype.disallowedValues = $util.emptyArray;
                /**
                 * DisallowValues newValue.
                 * @member {string} newValue
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @instance
                 */
                DisallowValues.prototype.newValue = "";
                /**
                 * DisallowValues useDefault.
                 * @member {blaze.invocation_policy.IUseDefault|null|undefined} useDefault
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @instance
                 */
                DisallowValues.prototype.useDefault = null;
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
                /**
                 * DisallowValues replacementValue.
                 * @member {"newValue"|"useDefault"|undefined} replacementValue
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @instance
                 */
                Object.defineProperty(DisallowValues.prototype, "replacementValue", {
                    get: $util.oneOfGetter($oneOfFields = ["newValue", "useDefault"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
                /**
                 * Creates a new DisallowValues instance using the specified properties.
                 * @function create
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @static
                 * @param {blaze.invocation_policy.IDisallowValues=} [properties] Properties to set
                 * @returns {blaze.invocation_policy.DisallowValues} DisallowValues instance
                 */
                DisallowValues.create = function create(properties) {
                    return new DisallowValues(properties);
                };
                /**
                 * Encodes the specified DisallowValues message. Does not implicitly {@link blaze.invocation_policy.DisallowValues.verify|verify} messages.
                 * @function encode
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @static
                 * @param {blaze.invocation_policy.IDisallowValues} message DisallowValues message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DisallowValues.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.disallowedValues != null && message.disallowedValues.length)
                        for (var i = 0; i < message.disallowedValues.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.disallowedValues[i]);
                    if (message.newValue != null && message.hasOwnProperty("newValue"))
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.newValue);
                    if (message.useDefault != null && message.hasOwnProperty("useDefault"))
                        $root.blaze.invocation_policy.UseDefault.encode(message.useDefault, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified DisallowValues message, length delimited. Does not implicitly {@link blaze.invocation_policy.DisallowValues.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @static
                 * @param {blaze.invocation_policy.IDisallowValues} message DisallowValues message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DisallowValues.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes a DisallowValues message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze.invocation_policy.DisallowValues} DisallowValues
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DisallowValues.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze.invocation_policy.DisallowValues();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.disallowedValues && message.disallowedValues.length))
                                    message.disallowedValues = [];
                                message.disallowedValues.push(reader.string());
                                break;
                            case 3:
                                message.newValue = reader.string();
                                break;
                            case 4:
                                message.useDefault = $root.blaze.invocation_policy.UseDefault.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes a DisallowValues message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze.invocation_policy.DisallowValues} DisallowValues
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DisallowValues.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies a DisallowValues message.
                 * @function verify
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DisallowValues.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.disallowedValues != null && message.hasOwnProperty("disallowedValues")) {
                        if (!Array.isArray(message.disallowedValues))
                            return "disallowedValues: array expected";
                        for (var i = 0; i < message.disallowedValues.length; ++i)
                            if (!$util.isString(message.disallowedValues[i]))
                                return "disallowedValues: string[] expected";
                    }
                    if (message.newValue != null && message.hasOwnProperty("newValue")) {
                        properties.replacementValue = 1;
                        if (!$util.isString(message.newValue))
                            return "newValue: string expected";
                    }
                    if (message.useDefault != null && message.hasOwnProperty("useDefault")) {
                        if (properties.replacementValue === 1)
                            return "replacementValue: multiple values";
                        properties.replacementValue = 1;
                        {
                            var error = $root.blaze.invocation_policy.UseDefault.verify(message.useDefault);
                            if (error)
                                return "useDefault." + error;
                        }
                    }
                    return null;
                };
                /**
                 * Creates a DisallowValues message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze.invocation_policy.DisallowValues} DisallowValues
                 */
                DisallowValues.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze.invocation_policy.DisallowValues)
                        return object;
                    var message = new $root.blaze.invocation_policy.DisallowValues();
                    if (object.disallowedValues) {
                        if (!Array.isArray(object.disallowedValues))
                            throw TypeError(".blaze.invocation_policy.DisallowValues.disallowedValues: array expected");
                        message.disallowedValues = [];
                        for (var i = 0; i < object.disallowedValues.length; ++i)
                            message.disallowedValues[i] = String(object.disallowedValues[i]);
                    }
                    if (object.newValue != null)
                        message.newValue = String(object.newValue);
                    if (object.useDefault != null) {
                        if (typeof object.useDefault !== "object")
                            throw TypeError(".blaze.invocation_policy.DisallowValues.useDefault: object expected");
                        message.useDefault = $root.blaze.invocation_policy.UseDefault.fromObject(object.useDefault);
                    }
                    return message;
                };
                /**
                 * Creates a plain object from a DisallowValues message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @static
                 * @param {blaze.invocation_policy.DisallowValues} message DisallowValues
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DisallowValues.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.disallowedValues = [];
                    if (message.disallowedValues && message.disallowedValues.length) {
                        object.disallowedValues = [];
                        for (var j = 0; j < message.disallowedValues.length; ++j)
                            object.disallowedValues[j] = message.disallowedValues[j];
                    }
                    if (message.newValue != null && message.hasOwnProperty("newValue")) {
                        object.newValue = message.newValue;
                        if (options.oneofs)
                            object.replacementValue = "newValue";
                    }
                    if (message.useDefault != null && message.hasOwnProperty("useDefault")) {
                        object.useDefault = $root.blaze.invocation_policy.UseDefault.toObject(message.useDefault, options);
                        if (options.oneofs)
                            object.replacementValue = "useDefault";
                    }
                    return object;
                };
                /**
                 * Converts this DisallowValues to JSON.
                 * @function toJSON
                 * @memberof blaze.invocation_policy.DisallowValues
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DisallowValues.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return DisallowValues;
            })();
            invocation_policy.AllowValues = (function () {
                /**
                 * Properties of an AllowValues.
                 * @memberof blaze.invocation_policy
                 * @interface IAllowValues
                 * @property {Array.<string>|null} [allowedValues] AllowValues allowedValues
                 * @property {string|null} [newValue] AllowValues newValue
                 * @property {blaze.invocation_policy.IUseDefault|null} [useDefault] AllowValues useDefault
                 */
                /**
                 * Constructs a new AllowValues.
                 * @memberof blaze.invocation_policy
                 * @classdesc Represents an AllowValues.
                 * @implements IAllowValues
                 * @constructor
                 * @param {blaze.invocation_policy.IAllowValues=} [properties] Properties to set
                 */
                function AllowValues(properties) {
                    this.allowedValues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * AllowValues allowedValues.
                 * @member {Array.<string>} allowedValues
                 * @memberof blaze.invocation_policy.AllowValues
                 * @instance
                 */
                AllowValues.prototype.allowedValues = $util.emptyArray;
                /**
                 * AllowValues newValue.
                 * @member {string} newValue
                 * @memberof blaze.invocation_policy.AllowValues
                 * @instance
                 */
                AllowValues.prototype.newValue = "";
                /**
                 * AllowValues useDefault.
                 * @member {blaze.invocation_policy.IUseDefault|null|undefined} useDefault
                 * @memberof blaze.invocation_policy.AllowValues
                 * @instance
                 */
                AllowValues.prototype.useDefault = null;
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
                /**
                 * AllowValues replacementValue.
                 * @member {"newValue"|"useDefault"|undefined} replacementValue
                 * @memberof blaze.invocation_policy.AllowValues
                 * @instance
                 */
                Object.defineProperty(AllowValues.prototype, "replacementValue", {
                    get: $util.oneOfGetter($oneOfFields = ["newValue", "useDefault"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
                /**
                 * Creates a new AllowValues instance using the specified properties.
                 * @function create
                 * @memberof blaze.invocation_policy.AllowValues
                 * @static
                 * @param {blaze.invocation_policy.IAllowValues=} [properties] Properties to set
                 * @returns {blaze.invocation_policy.AllowValues} AllowValues instance
                 */
                AllowValues.create = function create(properties) {
                    return new AllowValues(properties);
                };
                /**
                 * Encodes the specified AllowValues message. Does not implicitly {@link blaze.invocation_policy.AllowValues.verify|verify} messages.
                 * @function encode
                 * @memberof blaze.invocation_policy.AllowValues
                 * @static
                 * @param {blaze.invocation_policy.IAllowValues} message AllowValues message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AllowValues.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allowedValues != null && message.allowedValues.length)
                        for (var i = 0; i < message.allowedValues.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.allowedValues[i]);
                    if (message.newValue != null && message.hasOwnProperty("newValue"))
                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.newValue);
                    if (message.useDefault != null && message.hasOwnProperty("useDefault"))
                        $root.blaze.invocation_policy.UseDefault.encode(message.useDefault, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                    return writer;
                };
                /**
                 * Encodes the specified AllowValues message, length delimited. Does not implicitly {@link blaze.invocation_policy.AllowValues.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof blaze.invocation_policy.AllowValues
                 * @static
                 * @param {blaze.invocation_policy.IAllowValues} message AllowValues message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AllowValues.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                /**
                 * Decodes an AllowValues message from the specified reader or buffer.
                 * @function decode
                 * @memberof blaze.invocation_policy.AllowValues
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {blaze.invocation_policy.AllowValues} AllowValues
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AllowValues.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.blaze.invocation_policy.AllowValues();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.allowedValues && message.allowedValues.length))
                                    message.allowedValues = [];
                                message.allowedValues.push(reader.string());
                                break;
                            case 3:
                                message.newValue = reader.string();
                                break;
                            case 4:
                                message.useDefault = $root.blaze.invocation_policy.UseDefault.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                /**
                 * Decodes an AllowValues message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof blaze.invocation_policy.AllowValues
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {blaze.invocation_policy.AllowValues} AllowValues
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AllowValues.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                /**
                 * Verifies an AllowValues message.
                 * @function verify
                 * @memberof blaze.invocation_policy.AllowValues
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AllowValues.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.allowedValues != null && message.hasOwnProperty("allowedValues")) {
                        if (!Array.isArray(message.allowedValues))
                            return "allowedValues: array expected";
                        for (var i = 0; i < message.allowedValues.length; ++i)
                            if (!$util.isString(message.allowedValues[i]))
                                return "allowedValues: string[] expected";
                    }
                    if (message.newValue != null && message.hasOwnProperty("newValue")) {
                        properties.replacementValue = 1;
                        if (!$util.isString(message.newValue))
                            return "newValue: string expected";
                    }
                    if (message.useDefault != null && message.hasOwnProperty("useDefault")) {
                        if (properties.replacementValue === 1)
                            return "replacementValue: multiple values";
                        properties.replacementValue = 1;
                        {
                            var error = $root.blaze.invocation_policy.UseDefault.verify(message.useDefault);
                            if (error)
                                return "useDefault." + error;
                        }
                    }
                    return null;
                };
                /**
                 * Creates an AllowValues message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof blaze.invocation_policy.AllowValues
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {blaze.invocation_policy.AllowValues} AllowValues
                 */
                AllowValues.fromObject = function fromObject(object) {
                    if (object instanceof $root.blaze.invocation_policy.AllowValues)
                        return object;
                    var message = new $root.blaze.invocation_policy.AllowValues();
                    if (object.allowedValues) {
                        if (!Array.isArray(object.allowedValues))
                            throw TypeError(".blaze.invocation_policy.AllowValues.allowedValues: array expected");
                        message.allowedValues = [];
                        for (var i = 0; i < object.allowedValues.length; ++i)
                            message.allowedValues[i] = String(object.allowedValues[i]);
                    }
                    if (object.newValue != null)
                        message.newValue = String(object.newValue);
                    if (object.useDefault != null) {
                        if (typeof object.useDefault !== "object")
                            throw TypeError(".blaze.invocation_policy.AllowValues.useDefault: object expected");
                        message.useDefault = $root.blaze.invocation_policy.UseDefault.fromObject(object.useDefault);
                    }
                    return message;
                };
                /**
                 * Creates a plain object from an AllowValues message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof blaze.invocation_policy.AllowValues
                 * @static
                 * @param {blaze.invocation_policy.AllowValues} message AllowValues
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AllowValues.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.allowedValues = [];
                    if (message.allowedValues && message.allowedValues.length) {
                        object.allowedValues = [];
                        for (var j = 0; j < message.allowedValues.length; ++j)
                            object.allowedValues[j] = message.allowedValues[j];
                    }
                    if (message.newValue != null && message.hasOwnProperty("newValue")) {
                        object.newValue = message.newValue;
                        if (options.oneofs)
                            object.replacementValue = "newValue";
                    }
                    if (message.useDefault != null && message.hasOwnProperty("useDefault")) {
                        object.useDefault = $root.blaze.invocation_policy.UseDefault.toObject(message.useDefault, options);
                        if (options.oneofs)
                            object.replacementValue = "useDefault";
                    }
                    return object;
                };
                /**
                 * Converts this AllowValues to JSON.
                 * @function toJSON
                 * @memberof blaze.invocation_policy.AllowValues
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AllowValues.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return AllowValues;
            })();
            return invocation_policy;
        })();
        return blaze;
    })();
    $root.options = (function () {
        /**
         * Namespace options.
         * @exports options
         * @namespace
         */
        var options = {};
        /**
         * OptionEffectTag enum.
         * @name options.OptionEffectTag
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} NO_OP=1 NO_OP value
         * @property {number} LOSES_INCREMENTAL_STATE=2 LOSES_INCREMENTAL_STATE value
         * @property {number} CHANGES_INPUTS=3 CHANGES_INPUTS value
         * @property {number} AFFECTS_OUTPUTS=4 AFFECTS_OUTPUTS value
         * @property {number} BUILD_FILE_SEMANTICS=5 BUILD_FILE_SEMANTICS value
         * @property {number} BAZEL_INTERNAL_CONFIGURATION=6 BAZEL_INTERNAL_CONFIGURATION value
         * @property {number} LOADING_AND_ANALYSIS=7 LOADING_AND_ANALYSIS value
         * @property {number} EXECUTION=8 EXECUTION value
         * @property {number} HOST_MACHINE_RESOURCE_OPTIMIZATIONS=9 HOST_MACHINE_RESOURCE_OPTIMIZATIONS value
         * @property {number} EAGERNESS_TO_EXIT=10 EAGERNESS_TO_EXIT value
         * @property {number} BAZEL_MONITORING=11 BAZEL_MONITORING value
         * @property {number} TERMINAL_OUTPUT=12 TERMINAL_OUTPUT value
         * @property {number} ACTION_COMMAND_LINES=13 ACTION_COMMAND_LINES value
         * @property {number} TEST_RUNNER=14 TEST_RUNNER value
         */
        options.OptionEffectTag = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "NO_OP"] = 1;
            values[valuesById[2] = "LOSES_INCREMENTAL_STATE"] = 2;
            values[valuesById[3] = "CHANGES_INPUTS"] = 3;
            values[valuesById[4] = "AFFECTS_OUTPUTS"] = 4;
            values[valuesById[5] = "BUILD_FILE_SEMANTICS"] = 5;
            values[valuesById[6] = "BAZEL_INTERNAL_CONFIGURATION"] = 6;
            values[valuesById[7] = "LOADING_AND_ANALYSIS"] = 7;
            values[valuesById[8] = "EXECUTION"] = 8;
            values[valuesById[9] = "HOST_MACHINE_RESOURCE_OPTIMIZATIONS"] = 9;
            values[valuesById[10] = "EAGERNESS_TO_EXIT"] = 10;
            values[valuesById[11] = "BAZEL_MONITORING"] = 11;
            values[valuesById[12] = "TERMINAL_OUTPUT"] = 12;
            values[valuesById[13] = "ACTION_COMMAND_LINES"] = 13;
            values[valuesById[14] = "TEST_RUNNER"] = 14;
            return values;
        })();
        /**
         * OptionMetadataTag enum.
         * @name options.OptionMetadataTag
         * @enum {string}
         * @property {number} EXPERIMENTAL=0 EXPERIMENTAL value
         * @property {number} INCOMPATIBLE_CHANGE=1 INCOMPATIBLE_CHANGE value
         * @property {number} DEPRECATED=2 DEPRECATED value
         * @property {number} HIDDEN=3 HIDDEN value
         * @property {number} INTERNAL=4 INTERNAL value
         * @property {number} TRIGGERED_BY_ALL_INCOMPATIBLE_CHANGES=5 TRIGGERED_BY_ALL_INCOMPATIBLE_CHANGES value
         */
        options.OptionMetadataTag = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EXPERIMENTAL"] = 0;
            values[valuesById[1] = "INCOMPATIBLE_CHANGE"] = 1;
            values[valuesById[2] = "DEPRECATED"] = 2;
            values[valuesById[3] = "HIDDEN"] = 3;
            values[valuesById[4] = "INTERNAL"] = 4;
            values[valuesById[5] = "TRIGGERED_BY_ALL_INCOMPATIBLE_CHANGES"] = 5;
            return values;
        })();
        return options;
    })();
    return $root;
});
//# sourceMappingURL=protos.js.map