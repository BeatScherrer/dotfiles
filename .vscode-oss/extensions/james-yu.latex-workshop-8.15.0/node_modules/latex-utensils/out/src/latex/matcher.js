"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pattern = void 0;
const find_all_1 = require("./find_all");
class Pattern {
    constructor(typeguard, parentPattern) {
        this.typeguard = typeguard;
        this.parentPattern = parentPattern || this.parentPattern;
    }
    child(typeguard) {
        const childMatcher = new Pattern(typeguard, this);
        return childMatcher;
    }
    match(nodes, opt = { traverseAll: false }) {
        if (!this.parentPattern) {
            if (opt.traverseAll) {
                const result = find_all_1.find(nodes, this.typeguard);
                if (result) {
                    return { node: result.node, parent: undefined };
                }
            }
            else {
                for (const node of nodes) {
                    if (this.typeguard(node)) {
                        return { node, parent: undefined };
                    }
                }
            }
        }
        else {
            const parentMatchResults = this.parentPattern.matchAll(nodes, opt);
            for (const parentMatchResult of parentMatchResults) {
                const parentNode = parentMatchResult.node;
                const childNodes = find_all_1.getChildNodes(parentNode);
                for (const node of childNodes) {
                    if (this.typeguard(node)) {
                        return { node, parent: parentMatchResult };
                    }
                }
            }
        }
        return undefined;
    }
    matchAll(nodes, opt = { traverseAll: false }) {
        const ret = [];
        if (!this.parentPattern) {
            if (opt.traverseAll) {
                const results = find_all_1.findAll(nodes, this.typeguard);
                for (const result of results) {
                    ret.push({ node: result.node, parent: undefined });
                }
            }
            else {
                for (const node of nodes) {
                    if (this.typeguard(node)) {
                        ret.push({ node, parent: undefined });
                    }
                }
            }
        }
        else {
            const parentMatchResults = this.parentPattern.matchAll(nodes, opt);
            for (const parentMatchResult of parentMatchResults) {
                const parentNode = parentMatchResult.node;
                const childNodes = find_all_1.getChildNodes(parentNode);
                for (const node of childNodes) {
                    if (this.typeguard(node)) {
                        ret.push({ node, parent: parentMatchResult });
                    }
                }
            }
        }
        return ret;
    }
}
function pattern(typeguard) {
    return new Pattern(typeguard);
}
exports.pattern = pattern;
//# sourceMappingURL=matcher.js.map